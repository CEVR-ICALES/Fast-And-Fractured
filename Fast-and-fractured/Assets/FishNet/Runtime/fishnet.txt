using FishNet.Component.ColliderRollback;
using FishNet.Managing;
using FishNet.Managing.Client;
using FishNet.Managing.Predicting;
using FishNet.Managing.Scened;
using FishNet.Managing.Server;
using FishNet.Managing.Statistic;
using FishNet.Managing.Timing;
using FishNet.Managing.Transporting;
using FishNet.Utility;
using GameKit.Dependencies.Utilities;
using System;
using System.Linq;
using UnityEngine;

namespace FishNet
{
    /// <summary>
    /// Used to globally get information from the first found instance of NetworkManager.
    /// </summary>
    public static class InstanceFinder
    {
        #region Public.

        /// <summary>
        /// Returns the first found NetworkManager instance.
        /// </summary>
        public static NetworkManager NetworkManager
        {
            get
            {
                if (_networkManager == null)
                {
                    int managersCount = NetworkManager.Instances.Count;
                    //At least one manager.
                    if (managersCount > 0)
                    {
                        _networkManager = NetworkManager.Instances.First();
                        if (managersCount > 1)
                            _networkManager.LogWarning($"Multiple NetworkManagers found, the first result will be returned. If you only wish to have one NetworkManager then uncheck 'Allow Multiple' within your NetworkManagers.");
                    }
                    //No managers.
                    else
                    {
                        //If application is quitting return null without logging.
                        if (ApplicationState.IsQuitting())
                            return null;

                        //Do not log using NetworkManager extensions, it will try to use InstanceFinder, resulting in this causing a stack overflow.
                        Debug.Log($"NetworkManager not found in any open scenes.");
                    }
                }

                return _networkManager;
            }
        }

        /// <summary>
        /// Returns the first instance of ServerManager.
        /// </summary>
        public static ServerManager ServerManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.ServerManager;
            }
        }

        /// <summary>
        /// Returns the first instance of ClientManager.
        /// </summary>
        public static ClientManager ClientManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.ClientManager;
            }
        }

        /// <summary>
        /// Returns the first instance of TransportManager.
        /// </summary>
        public static TransportManager TransportManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.TransportManager;
            }
        }

        /// <summary>
        /// Returns the first instance of TimeManager.
        /// </summary>
        public static TimeManager TimeManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.TimeManager;
            }
        }

        /// <summary>
        /// Returns the first instance of SceneManager.
        /// </summary>
        public static SceneManager SceneManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.SceneManager;
            }
        }

        /// <summary>
        /// Returns the first instance of RollbackManager.
        /// </summary>
        public static RollbackManager RollbackManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.RollbackManager;
            }
        }

        /// <summary>
        /// Returns the first instance of PredictionManager.
        /// </summary>
        public static PredictionManager PredictionManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.PredictionManager;
            }
        }

        /// <summary>
        /// Returns the first instance of StatisticsManager.
        /// </summary>
        public static StatisticsManager StatisticsManager
        {
            get
            {
                NetworkManager nm = NetworkManager;
                return (nm == null) ? null : nm.StatisticsManager;
            }
        }

        #region Obsoletes

        [Obsolete("Use IsClientOnlyStarted. Note the difference between IsClientOnlyInitialized and IsClientOnlyStarted.")]
        public static bool IsClientOnly => IsClientOnlyStarted;

        [Obsolete("Use IsServerOnlyStarted. Note the difference between IsServerOnlyInitialized and IsServerOnlyStarted.")]
        public static bool IsServerOnly => IsServerOnlyStarted;

        [Obsolete("Use IsHostStarted. Note the difference between IsHostInitialized and IsHostStarted.")]
        public static bool IsHost => IsHostStarted;

        [Obsolete("Use IsClientStarted. Note the difference between IsClientInitialized and IsClientStarted.")]
        public static bool IsClient => IsClientStarted;

        [Obsolete("Use IsServerStarted. Note the difference between IsServerInitialized and IsServerStarted.")]
        public static bool IsServer => IsServerStarted;

        #endregion

        /// <summary>
        /// True if the server is active.
        /// </summary>
        public static bool IsServerStarted => (NetworkManager == null) ? false : NetworkManager.IsServerStarted;

        /// <summary>
        /// True if only the server is started.
        /// </summary>
        public static bool IsServerOnlyStarted => (NetworkManager == null) ? false : NetworkManager.IsServerOnlyStarted;

        /// <summary>
        /// True if the client is started and authenticated.
        /// </summary>
        public static bool IsClientStarted => (NetworkManager == null) ? false : NetworkManager.IsClientStarted;

        /// <summary>
        /// True if only the client is started and authenticated.
        /// </summary>
        public static bool IsClientOnlyStarted => (NetworkManager == null) ? false : NetworkManager.IsClientOnlyStarted;

        /// <summary>
        /// True if client and server are started.
        /// </summary>
        public static bool IsHostStarted => (NetworkManager == null) ? false : NetworkManager.IsHostStarted;

        /// <summary>
        /// True if client nor server are started.
        /// </summary>
        public static bool IsOffline
        {
            get
            {
                return (NetworkManager == null) ? true : NetworkManager.IsOffline;
            }
        }
        #endregion

        #region Private.

        /// <summary>
        /// NetworkManager instance.
        /// </summary>
        private static NetworkManager _networkManager;

        #endregion

        #region Registered components

        /// <summary>
        /// Registers to invoke an action when a specified component becomes registered. Action will invoke immediately if already registered.
        /// </summary>
        /// <typeparam name="T">Component type.</typeparam>
        /// <param name="handler">Action to invoke.</param>
        public static void RegisterInvokeOnInstance<T>(Action<UnityEngine.Component> handler) where T : UnityEngine.Component
        {
            if (NetworkManager != null)
                NetworkManager.RegisterInvokeOnInstance<T>(handler);
        }

        /// <summary>
        /// Unrgisters to invoke an action when a specified component becomes registered. Action will invoke immediately if already registered.
        /// </summary>
        /// <typeparam name="T">Component type.</typeparam>
        /// <param name="handler">Action to invoke.</param>
        public static void UnregisterInvokeOnInstance<T>(Action<UnityEngine.Component> handler) where T : UnityEngine.Component
        {
            if (NetworkManager != null)
                NetworkManager.UnregisterInvokeOnInstance<T>(handler);
        }

        /// <summary>
        /// Returns class of type if found within CodegenBase classes.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public static T GetInstance<T>() where T : UnityEngine.Component
        {
            return (NetworkManager == null) ? default : NetworkManager.GetInstance<T>();
        }

        /// <summary>
        /// Returns if class of type is registered with the NetworkManager.
        /// </summary>
        /// <typeparam name="T">Type to check for.</typeparam>
        /// <returns></returns>
        public static bool HasInstance<T>() where T : UnityEngine.Component
        {
            return (NetworkManager == null) ? false : NetworkManager.HasInstance<T>();
        }

        /// <summary>
        /// Registers a new component to this NetworkManager.
        /// </summary>
        /// <typeparam name="T">Type to register.</typeparam>
        /// <param name="component">Reference of the component being registered.</param>
        /// <param name="replace">True to replace existing references.</param>
        public static void RegisterInstance<T>(T component, bool replace = true) where T : UnityEngine.Component
        {
            if (NetworkManager != null)
                NetworkManager.RegisterInstance(component, replace);
        }

        /// <summary>
        /// Tries to registers a new component to this NetworkManager.
        /// This will not register the instance if another already exists.
        /// </summary>
        /// <typeparam name="T">Type to register.</typeparam>
        /// <param name="component">Reference of the component being registered.</param>
        /// <returns>True if was able to register, false if an instance is already registered.</returns>
        public static bool TryRegisterInstance<T>(T component) where T : UnityEngine.Component
        {
            return (NetworkManager == null) ? false : NetworkManager.TryRegisterInstance(component);
        }

        /// <summary>
        /// Returns class of type from registered instances.
        /// </summary>
        /// <param name="component">Outputted component.</param>
        /// <typeparam name="T">Type to get.</typeparam>
        /// <returns>True if was able to get instance.</returns>
        public static bool TryGetInstance<T>(out T component) where T : UnityEngine.Component
        {
            if (NetworkManager == null)
            {
                component = default;
                return false;
            }
            else
            {
                return NetworkManager.TryGetInstance(out component);
            }
        }

        /// <summary>
        /// Unregisters a component from this NetworkManager.
        /// </summary>
        /// <typeparam name="T">Type to unregister.</typeparam>
        public static void UnregisterInstance<T>() where T : UnityEngine.Component
        {
            if (NetworkManager != null)
                NetworkManager.UnregisterInstance<T>();
        }
        #endregion
    }
}﻿using FishNet.Connection;
using FishNet.Managing;
using System;
using UnityEngine;

namespace FishNet.Authenticating
{
    /// <summary>
    /// When inherited from this can be used to create a custom authentication process before clients may communicate with the server.
    /// </summary>
    public abstract class Authenticator : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// True if this authenticator has been intiialzied.
        /// </summary>
        public bool Initialized { get; private set; }
        #endregion

        #region Protected.
        /// <summary>
        /// NetworkManager for this Authenticator.
        /// </summary>
        protected NetworkManager NetworkManager { get; private set; }
        #endregion
         
        /// <summary>
        /// Called when authenticator has concluded a result for a connection. Boolean is true if authentication passed, false if failed.
        /// Server listens for this event automatically.
        /// </summary>
        public abstract event Action<NetworkConnection, bool> OnAuthenticationResult;

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="networkManager"></param>
        public virtual void InitializeOnce(NetworkManager networkManager)
        {
            NetworkManager = networkManager;
            Initialized = true;
        }

        /// <summary>
        /// Called on the server immediately after a client connects. Can be used to send data to the client for authentication.
        /// </summary>
        /// <param name="connection">Connection which is not yet authenticated.</param>
        public virtual void OnRemoteConnection(NetworkConnection connection) { }
    }


}﻿
namespace FishNet.Broadcast
{
    /// <summary>
    /// Include this interface on types intended to be used with Broadcast.
    /// </summary>
    public interface IBroadcast { }
}﻿//using FishNet.Connection; //remove on v5
//using FishNet.Serializing;
//using FishNet.Transporting;
//using GameKit.Dependencies.Utilities;
//using System;
//using System.Collections.Generic;
//using System.Diagnostics;

//namespace FishNet.Broadcast.Helping
//{
//    internal static class BroadcastHelper
//    {
//        /// <summary>
//        /// Gets the key for a broadcast type.
//        /// </summary>
//        /// <typeparam name="T"></typeparam>
//        /// <param name="broadcastType"></param>
//        /// <returns></returns>
//        internal static ushort GetKey<T>()
//        {
//            return typeof(T).FullName.GetStableHashU16();
//        }
//    }

//    /// <summary>
//    /// Implemented by server and client broadcast handlers.
//    /// </summary>
//    public abstract class BroadcastHandlerBase
//    {
//        /// <summary>
//        /// Current index when iterating invokes.
//        /// This value will be -1 when not iterating.
//        /// </summary>
//        protected int IteratingIndex;

//        public abstract void RegisterHandler(object obj);
//        public abstract void UnregisterHandler(object obj);
//        public virtual void InvokeHandlers(PooledReader reader, Channel channel) { }
//        public virtual void InvokeHandlers(NetworkConnection conn, PooledReader reader, Channel channel) { }
//        public virtual bool RequireAuthentication => false;
//    }

//    /// <summary>
//    /// Handles broadcasts received on server, from clients.
//    /// </summary>
//    internal class ClientBroadcastHandler<T> : BroadcastHandlerBase
//    {
//        /// <summary>
//        /// Action handlers for the broadcast.
//        /// </summary>
//        private List<Action<NetworkConnection, T, Channel>> _handlers = new List<Action<NetworkConnection, T, Channel>>();
//        /// <summary>
//        /// True to require authentication for the broadcast type.
//        /// </summary>
//        private bool _requireAuthentication;

//        public ClientBroadcastHandler(bool requireAuthentication)
//        {
//            _requireAuthentication = requireAuthentication;
//        }

//        /// <summary>
//        /// Invokes handlers after reading broadcast.
//        /// </summary>
//        /// <returns>True if a rebuild was required.</returns>
//        public override void InvokeHandlers(NetworkConnection conn, PooledReader reader, Channel channel)
//        {
//            T result = reader.Read<T>();
//            for (base.IteratingIndex = 0; base.IteratingIndex < _handlers.Count; base.IteratingIndex++)
//            {
//                Action<NetworkConnection, T, Channel> item = _handlers[base.IteratingIndex];
//                if (item != null)
//                {
//                    item.Invoke(conn, result, channel);
//                }
//                else
//                {
//                    _handlers.RemoveAt(base.IteratingIndex);
//                    base.IteratingIndex--;
//                }
//            }

//            base.IteratingIndex = -1;
//        }

//        /// <summary>
//        /// Adds a handler for this type.
//        /// </summary>
//        public override void RegisterHandler(object obj)
//        {
//            Action<NetworkConnection, T, Channel> handler = (Action<NetworkConnection, T, Channel>)obj;
//            _handlers.AddUnique(handler);
//        }

//        /// <summary>
//        /// Removes a handler from this type.
//        /// </summary>
//        /// <param name="handler"></param>
//        public override void UnregisterHandler(object obj)
//        {
//            Action<NetworkConnection, T, Channel> handler = (Action<NetworkConnection, T, Channel>)obj;
//            int indexOf = _handlers.IndexOf(handler);
//            //Not registered.
//            if (indexOf == -1)
//                return;

//            /* Has already been iterated over, need to subtract
//            * 1 from iteratingIndex to accomodate
//            * for the entry about to be removed. */
//            if (base.IteratingIndex >= 0 && (indexOf <= base.IteratingIndex))
//                base.IteratingIndex--;

//            //Remove entry.
//            _handlers.RemoveAt(indexOf);
//        }

//        /// <summary>
//        /// True to require authentication for the broadcast type.
//        /// </summary>
//        public override bool RequireAuthentication => _requireAuthentication;
//    }



//    /// <summary>
//    /// Handles broadcasts received on client, from server.
//    /// </summary>
//    internal class ServerBroadcastHandler<T> : BroadcastHandlerBase
//    {
//        /// <summary>
//        /// Action handlers for the broadcast.
//        /// Even though List lookups are slower this allows easy adding and removing of entries during iteration.
//        /// </summary>
//        private List<Action<T, Channel>> _handlers = new List<Action<T, Channel>>();

//        /// <summary>
//        /// Invokes handlers after reading broadcast.
//        /// </summary>
//        /// <returns>True if a rebuild was required.</returns>
//        public override void InvokeHandlers(PooledReader reader, Channel channel)
//        {
//            T result = reader.Read<T>();
//            for (base.IteratingIndex = 0; base.IteratingIndex < _handlers.Count; base.IteratingIndex++)
//            {
//                Action<T, Channel> item = _handlers[base.IteratingIndex];
//                if (item != null)
//                {
//                    item.Invoke(result, channel);
//                }
//                else
//                {
//                    _handlers.RemoveAt(base.IteratingIndex);
//                    base.IteratingIndex--;
//                }
//            }

//            base.IteratingIndex = -1;
//        }

//        /// <summary>
//        /// Adds a handler for this type.
//        /// </summary>
//        public override void RegisterHandler(object obj)
//        {
//            Action<T, Channel> handler = (Action<T, Channel>)obj;
//            _handlers.AddUnique(handler);
//        }

//        /// <summary>
//        /// Removes a handler from this type.
//        /// </summary>
//        /// <param name="handler"></param>
//        public override void UnregisterHandler(object obj)
//        {
//            Action<T, Channel> handler = (Action<T, Channel>)obj;
//            int indexOf = _handlers.IndexOf(handler);
//            //Not registered.
//            if (indexOf == -1)
//                return;

//            /* Has already been iterated over, need to subtract
//            * 1 from iteratingIndex to accomodate
//            * for the entry about to be removed. */
//            if (base.IteratingIndex >= 0 && (indexOf <= base.IteratingIndex))
//                base.IteratingIndex--;

//            //Remove entry.
//            _handlers.RemoveAt(indexOf);
//        }

//        /// <summary>
//        /// True to require authentication for the broadcast type.
//        /// </summary>
//        public override bool RequireAuthentication => false;
//    }



//}﻿using FishNet.Utility;
using System;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]
namespace FishNet.CodeGenerating
{
    /// <summary>
    /// Allows a SyncType to be mutable.
    /// </summary>
    public class AllowMutableSyncTypeAttribute : Attribute { }
    /// <summary>
    /// Type will be included in auto serializer creation.
    /// </summary>
    [AttributeUsage((AttributeTargets.Class | AttributeTargets.Struct), Inherited = true, AllowMultiple = false)]
    public class IncludeSerializationAttribute : Attribute { }
    /// <summary>
    /// Type will be excluded from auto serializer creation.
    /// </summary>
    public class ExcludeSerializationAttribute : Attribute { }
    /// <summary>
    /// Method will not be considered a writer or reader.
    /// </summary>
    public class NotSerializerAttribute : Attribute { }
    /// <summary>
    /// Method or type will be made public by codegen.
    /// </summary>
    internal class MakePublicAttribute : Attribute { }
    /// <summary>
    /// Method is a comparer for a value type.
    /// </summary>
    public class CustomComparerAttribute : Attribute { }
    /// <summary>
    /// Used on a type when you want a custom serializer to be global across all assemblies.
    /// </summary>
    [AttributeUsage((AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface), Inherited = true, AllowMultiple = false)]
    public class UseGlobalCustomSerializerAttribute : Attribute { }
    /// <summary>
    /// Uses built-in caches to retrieve read classes rather than initializing a new instance.
    /// This attribute is primarily for internal use and may change at anytime without notice.
    /// </summary>
    [AttributeUsage((AttributeTargets.Class), Inherited = true, AllowMultiple = false)]
    public class ReadUnallocatedAttribute : Attribute { }
    /// <summary>
    /// Indicates a method is the default writer for a type. The first non-extension parameter indicates the type this writer is for.
    /// This attribute is primarily for internal use and may change at anytime without notice.
    /// </summary>
    public class DefaultWriterAttribute : Attribute { }
    /// <summary>
    /// Indicates a method is the default reader for a type. The return type indicates what type the reader is for.
    /// This attribute is primarily for internal use and may change at anytime without notice.
    /// </summary>
    public class DefaultReaderAttribute : Attribute { }
    /// <summary>
    /// Indicates a method is a delta writer. The first non-extension parameter indicates the type this writer is for.
    /// This attribute is primarily for internal use and may change at anytime without notice.
    /// </summary>
    public class DefaultDeltaWriterAttribute : Attribute { }
    /// <summary>
    /// Indicates a method is a delta reader. The return type indicates what type the reader is for.
    /// This attribute is primarily for internal use and may change at anytime without notice.
    /// </summary>
    public class DefaultDeltaReaderAttribute : Attribute { }
}﻿using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Transporting;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Utility.Performance;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Connection
{
    /// <summary>
    /// A byte buffer that automatically resizes.
    /// </summary>
    internal class ByteBuffer
    {
        /// <summary>
        /// How many more bytes may fit into the buffer.
        /// </summary>
        internal int Remaining => (Size - Length);
        /// <summary>
        /// Buffer data.
        /// </summary>
        internal byte[] Data { get; private set; }
        /// <summary>
        /// How many bytes currently into Data. This will include the reserve.
        /// </summary>
        internal int Length { get; private set; }
        /// <summary>
        /// Size of the buffer. Data.Length may exceed this value as it uses a pooled array.
        /// </summary>
        internal int Size { get; private set; }
        /// <summary>
        /// True if data has been written.
        /// </summary>
        internal bool HasData { get; private set; }
        /// <summary>
        /// Bytes to reserve when resetting.
        /// </summary>
        private int _reserve;

        internal ByteBuffer(int size, int reserve = 0)
        {
            Data = ByteArrayPool.Retrieve(size);
            Size = size;
            _reserve = reserve;
            Reset();
        }

        public void Dispose()
        {
            if (Data != null)
                ByteArrayPool.Store(Data);
            Data = null;
        }

        /// <summary>
        /// Resets instance without clearing Data.
        /// </summary>
        internal void Reset()
        {
            Length = _reserve;
            HasData = false;
        }

        /// <summary>
        /// Copies segments without error checking, including tick for the first time data is added.
        /// </summary>
        /// <param name="segment"></param>
        internal void CopySegment(uint tick, ArraySegment<byte> segment)
        {
            /* If data has not been written to buffer yet
            * then write tick to the start. */
            if (!HasData)
            {
                int pos = 0;
                Writer.WriteUInt32Unpacked(Data, tick, ref pos);
            }

            Buffer.BlockCopy(segment.Array, segment.Offset, Data, Length, segment.Count);
            Length += segment.Count;
            HasData = true;
        }
        /// <summary>
        /// Copies segments without error checking.
        /// </summary>
        /// <param name="segment"></param>
        internal void CopySegment(ArraySegment<byte> segment)
        {
            Buffer.BlockCopy(segment.Array, segment.Offset, Data, Length, segment.Count);
            Length += segment.Count;
            HasData = true;
        }

    }

    internal class PacketBundle
    {
        /// <summary>
        /// True if data has been written.
        /// </summary>
        internal bool HasData => (_buffers[0].HasData || (!_isSendLastBundle && _sendLastBundle.HasData));
        /// <summary>
        /// All buffers written. Collection is not cleared when reset but rather the index in which to write is.
        /// </summary>
        private List<ByteBuffer> _buffers = new();
        /// <summary>
        /// Buffer which is being written to.
        /// </summary>
        private int _bufferIndex;
        /// <summary>
        /// Maximum size packet the transport can handle.
        /// </summary>
        private int _maximumTransportUnit;
        /// <summary>
        /// Number of buffers written to. Will return 0 if nothing has been written.
        /// </summary>
        public int WrittenBuffers => (!HasData) ? 0 : (_bufferIndex + 1);
        /// <summary>
        /// Number of bytes to reserve at the beginning of each buffer.
        /// </summary>
        private int _reserve;
        /// <summary>
        /// NetworkManager this is for.
        /// </summary>
        private NetworkManager _networkManager;
        /// <summary>
        /// Packet bundle to use for last enqueued data.
        /// </summary>
        private PacketBundle _sendLastBundle;
        /// <summary>
        /// True if being used as an sendLast bundle.
        /// </summary>
        private bool _isSendLastBundle;

        internal PacketBundle(NetworkManager manager, int mtu, int reserve = 0, DataOrderType orderType = DataOrderType.Default)
        {
            _isSendLastBundle = (orderType == DataOrderType.Last);
            //If this is not the send last packetbundle then make a new one.
            if (!_isSendLastBundle)
                _sendLastBundle = new(manager, mtu, reserve, DataOrderType.Last);

            _networkManager = manager;
            _maximumTransportUnit = mtu;
            /* Allow bytes for the tick.
             * Modify reserve after making sendLast bundle
             * so that the wrong reserve is not passed into
             * the sendLast bundle. */
            reserve += TransportManager.UNPACKED_TICK_LENGTH;
            _reserve = reserve;
            //Add buffer requires the right reserve so call after setting.
            AddBuffer();

            Reset(false);
        }

        public void Dispose()
        {
            for (int i = 0; i < _buffers.Count; i++)
                _buffers[i].Dispose();

            _sendLastBundle?.Dispose();
        }

        /// <summary>
        /// Adds a buffer using current settings.
        /// </summary>
        private ByteBuffer AddBuffer()
        {
            ByteBuffer ba = new(_maximumTransportUnit, _reserve);
            _buffers.Add(ba);
            return ba;
        }

        /// <summary>
        /// Resets using current settings.
        /// </summary>
        internal void Reset(bool resetSendLast)
        {
            _bufferIndex = 0;

            for (int i = 0; i < _buffers.Count; i++)
                _buffers[i].Reset();

            if (resetSendLast)
                _sendLastBundle.Reset(false);
        }

        /// <summary>
        /// Writes a segment to this packet bundle using the current WriteIndex.
        /// </summary>
        /// <param name="forceNewBuffer">True to force data into a new buffer.</param>
        internal void Write(ArraySegment<byte> segment, bool forceNewBuffer = false, DataOrderType orderType = DataOrderType.Default)
        {
            /* If not the send last bundle and to send data last
             * then send using the send last bundle. */
            if (!_isSendLastBundle && orderType == DataOrderType.Last)
            {
                _sendLastBundle.Write(segment, forceNewBuffer, orderType);
                return;
            }

            //Nothing to be written.
            if (segment.Count == 0)
                return;

            /* If the segment count is larger than the mtu then
             * something went wrong. Nothing should call this method
             * directly except the TransportManager, which will automatically
             * split packets that exceed MTU into reliable ordered. */
            if (segment.Count > _maximumTransportUnit)
            {
                _networkManager.LogError($"Segment is length of {segment.Count} while MTU is {_maximumTransportUnit}. Packet was not split properly and will not be sent.");
                return;
            }


            ByteBuffer ba = _buffers[_bufferIndex];
            /* Make a new buffer if...
             * forcing a new buffer and data has already been written to the current.
             * or---
             * segment.Count is more than what is remaining in the buffer. */
            bool useNewBuffer = (forceNewBuffer && ba.Length > _reserve) ||
                (segment.Count > ba.Remaining);
            if (useNewBuffer)
            {
                _bufferIndex++;
                //If need to make a new buffer then do so.
                if (_buffers.Count <= _bufferIndex)
                {
                    ba = AddBuffer();
                }
                else
                {
                    ba = _buffers[_bufferIndex];
                    ba.Reset();
                }
            }

            uint tick = _networkManager.TimeManager.LocalTick;
            ba.CopySegment(tick, segment);
        }

        /// <summary>
        /// Returns the packetBundle for send last.
        /// </summary>
        /// <returns></returns>
        internal PacketBundle GetSendLastBundle() => _sendLastBundle;

        /// <summary>
        /// Gets a buffer for the specified index. Returns true and outputs the buffer if it was successfully found.
        /// </summary>
        /// <param name="index">Index of the buffer to retrieve.</param>
        /// <param name="bb">Buffer retrieved from the list. Null if the specified buffer was not found.</param>
        internal bool GetBuffer(int index, out ByteBuffer bb)
        {
            bb = null;

            if (index >= _buffers.Count || index < 0)
            {
                _networkManager.LogError($"Index of {index} is out of bounds. There are {_buffers.Count} available.");
                return false;
            }
            if (index > _bufferIndex)
            {
                _networkManager.LogError($"Index of {index} exceeds the number of written buffers. There are {WrittenBuffers} written buffers.");
                return false;
            }

            bb = _buffers[index];
            return bb.HasData;
        }

        /// <summary>
        /// Returns a PacketBundle for a channel. ResetPackets must be called afterwards.
        /// </summary>
        /// <param name="channel"></param>
        /// <returns>True if PacketBundle is valid on the index and contains data.</returns>
        internal static bool GetPacketBundle(int channel, List<PacketBundle> bundles, out PacketBundle mtuBuffer)
        {
            //Out of bounds.
            if (channel >= bundles.Count)
            {
                mtuBuffer = null;
                return false;
            }

            mtuBuffer = bundles[channel];
            return mtuBuffer.HasData;
        }
    }



}﻿using System.Runtime.CompilerServices;

namespace FishNet.Managing.Timing
{
    public class EstimatedTick
    {
        #region Types.
        /// <summary>
        /// How to handle old ticks, specifically related to EstimatedTick.
        /// </summary>
        public enum OldTickOption : byte
        {
            /// <summary>
            /// Completely ignore old ticks.
            /// </summary>
            Discard = 0,
            /// <summary>
            /// Set LastRemoteTick but do not update RemoteTick.
            /// </summary>
            SetLastRemoteTick = 1,
            /// <summary>
            /// Set LastRemoteTick and RemoteTick.
            /// </summary>
            SetRemoteTick = 2,
        }
        #endregion

        /// <summary>
        /// Local tick when this was last updated.
        /// </summary>
        public uint LocalTick { get; private set; } = TimeManager.UNSET_TICK;
        /// <summary>
        /// Last remote tick this was updated with that was not out of order or a duplicate.
        /// </summary>
        public uint RemoteTick { get; private set; } = TimeManager.UNSET_TICK;
        /// <summary>
        /// Last remote tick received regardless if it was out of order or a duplicate.
        /// </summary>
        public uint LastRemoteTick { get; private set; } = TimeManager.UNSET_TICK;
        /// <summary>
        /// True if LastRemoteTick is equal to RemoteTick.
        /// This would indicate that the LastRemoteTick did not arrive out of order.
        /// </summary>
        public bool IsLastRemoteTickOrdered => (LastRemoteTick == RemoteTick);
        /// <summary>
        /// True if value is unset.
        /// </summary>
        //Only need to check one value for unset as they all would be if not set.
        public bool IsUnset => (LocalTick == TimeManager.UNSET_TICK);
        /// <summary>
        /// Last TimeManager specified during an Update call.
        /// </summary>
        private TimeManager _updateTimeManager;
        /// <summary>
        /// LocalTick when Value was last reset.
        /// </summary>
        private uint _valueLocalTick = TimeManager.UNSET_TICK;


        /// <summary>
        /// Number of ticks LocalTick is being current LocalTick.
        /// </summary>
        public uint LocalTickDifference(TimeManager tm = null)
        {
            if (!TryAssignTimeManager(ref tm))
                return TimeManager.UNSET_TICK;

            long value = (tm.LocalTick - LocalTick);
            //Shouldn't be possible to be less than 0.
            if (value < 0)
                return TimeManager.UNSET_TICK;
            else if (value > uint.MaxValue)
                value = uint.MaxValue;

            return (uint)value;
        }

        /// <summary>
        /// True if values were updated this tick.
        /// </summary>
        public bool IsCurrent(TimeManager tm = null)
        {
            if (!TryAssignTimeManager(ref tm))
                return false;

            return (!IsUnset && LocalTick == tm.LocalTick);
        }

        /// <summary>
        /// Current estimated value.
        /// </summary>
        /// <param name="nm">NetworkManager to use. When null default value will be returned.</param>
        public uint Value(TimeManager tm = null)
        {
            if (!TryAssignTimeManager(ref tm))
                return TimeManager.UNSET_TICK;

            return Value(out _, tm);
        }

        /// <summary>
        /// Current estimated value. Outputs if value is current.
        /// </summary>
        /// <param name="nm">NetworkManager to use. When null default value will be returned.</param>
        /// <param name="isCurrent">True if the value was updated this local tick.</param>
        public uint Value(out bool isCurrent, TimeManager tm = null)
        {
            //Default value.
            isCurrent = false;

            if (!TryAssignTimeManager(ref tm))
                return TimeManager.UNSET_TICK;
            if (IsUnset)
                return TimeManager.UNSET_TICK;

            isCurrent = IsCurrent(tm);

            uint diff = (tm.LocalTick - _valueLocalTick);
            return (diff + RemoteTick);
        }

        /// <summary>
        /// Initializes this EstimatedTick with values.
        /// </summary>
        public void Initialize(TimeManager tm, uint remoteTick = 0, uint lastRemoteTick = 0, uint localTick = 0)
        {
            _updateTimeManager = tm;
            RemoteTick = remoteTick;
            LastRemoteTick = lastRemoteTick;
            LocalTick = localTick;
        }

        /// <summary>
        /// Updates values.
        /// </summary>
        /// <param name="tm">TimeManager to use.</param>
        /// <param name="remoteTick">Remote tick being updated.</param>
        /// <param name="oldTickOption">How to handle remoteTick if it is old.</param>
        /// /// <param name="resetValue">True to reset Value based on this information. False will allow Value to continue to to estimate tick based on the last reset.</param>
        /// <returns>True if was able to update values.</returns>
        public bool Update(TimeManager tm, uint remoteTick, OldTickOption oldTickOption = OldTickOption.Discard, bool resetValue = true)
        {
            _updateTimeManager = tm;
            //Always set LastRemoteTick even if out of order.
            LastRemoteTick = remoteTick;
            //If cannot update with old values return.
            if (oldTickOption != OldTickOption.SetRemoteTick && remoteTick <= RemoteTick)
                return false;

            //nm is assumed set here.
            LocalTick = tm.LocalTick;
            if (resetValue)
                _valueLocalTick = LocalTick;
            RemoteTick = remoteTick;

            return true;
        }

        /// <summary>
        /// Updates values.
        /// </summary>
        /// <param name="remoteTick">Remote tick being updated.</param>
        /// <param name="oldTickOption">How to handle remoteTick if it is old.</param>
        /// <param name="resetValue">True to reset Value based on this information. False will allow Value to continue to to estimate tick based on the last reset.</param>
        /// <returns>True if was able to update values.</returns>
        public bool Update(uint remoteTick, OldTickOption oldTickOption = OldTickOption.Discard, bool resetValue = true)
        {
            TimeManager tm = null;
            if (!TryAssignTimeManager(ref tm))
                return false;

            return Update(tm, remoteTick, oldTickOption);
        }

        /// <summary>
        /// Updates Value based on current ticks.
        /// This is typically used when you want to control when Value is reset through the Update methods.
        /// </summary>
        public void UpdateValue()
        {
            _valueLocalTick = LocalTick;
        }

        /// <summary>
        /// Assigns a TimeManager reference to UpdateTimeManager if was null.
        /// </summary>
        /// <returns>True if the reference has value or was assigned value. False if the reference remains null.</returns>
        private bool TryAssignTimeManager(ref TimeManager tm)
        {
            if (tm == null)
                tm = _updateTimeManager;

            return (tm != null);
        }

        /// <summary>
        /// Resets values to unset and clears the NetworkManager.
        /// </summary>
        public void Reset()
        {
            ResetTicks();
            _updateTimeManager = null;
        }


        /// <summary>
        /// Resets only tick values, leaving type references.
        /// </summary>
        public void ResetTicks()
        {
            LocalTick = TimeManager.UNSET_TICK;
            RemoteTick = TimeManager.UNSET_TICK;
            LastRemoteTick = TimeManager.UNSET_TICK;
            _valueLocalTick = TimeManager.UNSET_TICK;
        }
    }
}﻿using FishNet.Broadcast;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Transporting;
using FishNet.Object;
using FishNet.Transporting;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Connection
{
    public partial class NetworkConnection
    {
        #region Private.

        /// <summary>
        /// PacketBundles to send to this connection. An entry will be made for each channel.
        /// </summary>
        private List<PacketBundle> _toClientBundles = new();
        /// <summary>
        /// True if this object has been dirtied.
        /// </summary>
        private bool _serverDirtied;

        #endregion

        /// <summary>
        /// Initializes this script.
        /// </summary>
        private void InitializeBuffer()
        {
            for (byte i = 0; i < TransportManager.CHANNEL_COUNT; i++)
            {
                int mtu = NetworkManager.TransportManager.GetLowestMTU(i);
                _toClientBundles.Add(new(NetworkManager, mtu));
            }
        }


        /// <summary>
        /// Sends a broadcast to this connection.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the client must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void Broadcast<T>(T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!IsActive)
                NetworkManager.LogError($"Connection is not valid, cannot send broadcast.");
            else
                NetworkManager.ServerManager.Broadcast(this, message, requireAuthenticated, channel);
        }

        /// <summary>
        /// Sends data from the server to a client.
        /// </summary>
        /// <param name="forceNewBuffer">True to force data into a new buffer.</param>
        internal void SendToClient(byte channel, ArraySegment<byte> segment, bool forceNewBuffer = false, DataOrderType orderType = DataOrderType.Default)
        {
            //Cannot send data when disconnecting.
            if (Disconnecting)
                return;

            if (!IsActive)
            {
                NetworkManager.LogWarning($"Data cannot be sent to connection {ClientId} because it is not active.");
                return;
            }

            //If channel is out of bounds then default to the first channel.
            if (channel >= _toClientBundles.Count)
                channel = 0;

            _toClientBundles[channel].Write(segment, forceNewBuffer, orderType);
            ServerDirty();
        }

        /// <summary>
        /// Returns a PacketBundle for a channel. ResetPackets must be called afterwards.
        /// </summary>
        /// <param name="channel"></param>
        /// <returns>True if PacketBundle is valid on the index and contains data.</returns>
        internal bool GetPacketBundle(int channel, out PacketBundle packetBundle)
        {
            return PacketBundle.GetPacketBundle(channel, _toClientBundles, out packetBundle);
        }

        /// <summary>
        /// Indicates the server has data to send to this connection.
        /// </summary>
        private void ServerDirty()
        {
            bool wasDirty = _serverDirtied;
            _serverDirtied = true;

            //If not yet dirty then tell transport manager this is dirty.
            if (!wasDirty)
                NetworkManager.TransportManager.ServerDirty(this);
        }

        /// <summary>
        /// Resets that there is data to send.
        /// </summary>
        internal void ResetServerDirty()
        {
            _serverDirtied = false;
        }
    }
}﻿using FishNet.Component.Observing;
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Managing.Timing;
using FishNet.Object;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using UnityEngine.SceneManagement;
using static FishNet.Managing.Timing.EstimatedTick;

namespace FishNet.Connection
{

    public static class NetworkConnectionExtensions
    {

        /// <summary>
        /// True if this connection is valid. An invalid connection indicates no client is set for this reference.
        /// Null references can be used with this method.
        /// </summary>
        public static bool IsValid(this NetworkConnection c)
        {
            if (c == null)
                return false;
            else
                return c.IsValid;
        }
    }
    /// <summary>
    /// A container for a connected client used to perform actions on and gather information for the declared client.
    /// </summary>
    public partial class NetworkConnection : IResettable, IEquatable<NetworkConnection>
    {

        #region Internal.
        /// <summary>
        /// Tick when Disconnecting was set.
        /// </summary>
        internal uint DisconnectingTick { get; private set; }
        /// <summary>
        /// ObjectIds to use for predicted spawning.
        /// </summary>
        internal Queue<int> PredictedObjectIds = new();
        /// <summary>
        /// True if the client has sent the same version that the server is on.
        /// </summary>
        internal bool HasSentVersion;
        /// <summary>
        /// LocalTick of the server when this connection was established. This value is not set for clients.
        /// </summary>
        internal uint ServerConnectionTick;
        #endregion

        #region Public.
        /// <summary>
        /// Called after this connection has loaded start scenes. Boolean will be true if asServer. Available to this connection and server.
        /// </summary>
        public event Action<NetworkConnection, bool> OnLoadedStartScenes;
        /// <summary>
        /// Called after connection gains ownership of an object, and after the object has been added to Objects. Available to this connection and server.
        /// </summary>
        public event Action<NetworkObject> OnObjectAdded;
        /// <summary>
        /// Called after connection loses ownership of an object, and after the object has been removed from Objects. Available to this connection and server.
        /// </summary>
        public event Action<NetworkObject> OnObjectRemoved;
        /// <summary>
        /// NetworkManager managing this class.
        /// </summary>
        public NetworkManager NetworkManager { get; private set; }
        /// <summary>
        /// True if connection has loaded start scenes. Available to this connection and server.
        /// </summary>
        public bool LoadedStartScenes() => (_loadedStartScenesAsServer || _loadedStartScenesAsClient);
        /// <summary>
        /// 
        /// </summary>
        public bool LoadedStartScenes(bool asServer)
        {
            if (asServer)
                return _loadedStartScenesAsServer;
            else
                return _loadedStartScenesAsClient;
        }
        /// <summary>
        /// TransportIndex this connection is on.
        /// For security reasons this value will be unset on clients if this is not their connection.
        /// This is not yet used.
        /// </summary>
        public int TransportIndex { get; private set; } = -1;
        /// <summary>
        /// True if this connection is authenticated. Only available to server.
        /// </summary>
        public bool IsAuthenticated { get; private set; }
        [Obsolete("Use IsAuthenticated.")] //Remove in V5
        public bool Authenticated
        {
            get => IsAuthenticated;
            set => IsAuthenticated = value;
        }
        /// <summary>
        /// True if this connection IsValid and not Disconnecting.
        /// </summary>
        public bool IsActive => (ClientId >= 0 && !Disconnecting);
        /// <summary>
        /// True if this connection is valid. An invalid connection indicates no client is set for this reference.
        /// </summary>
        public bool IsValid => (ClientId >= 0);
        /// <summary>
        /// Unique Id for this connection.
        /// </summary>
        public int ClientId = -1;
        /// <summary>
        /// Objects owned by this connection. Available to this connection and server.
        /// </summary>
        public HashSet<NetworkObject> Objects = new();
        /// <summary>
        /// The first object within Objects.
        /// </summary>
        public NetworkObject FirstObject { get; private set; }
        /// <summary>
        /// Sets a custom FirstObject. This connection must be owner of the specified object.
        /// </summary>
        /// <param name="nob"></param>
        public void SetFirstObject(NetworkObject nob)
        {
            //Invalid object.
            if (!Objects.Contains(nob))
            {
                string errMessage = $"FirstObject for {ClientId} cannot be set to {nob.name} as it's not within Objects for this connection.";
                NetworkManager.LogError(errMessage);
                return;
            }

            FirstObject = nob;
        }
        /// <summary>
        /// Scenes this connection is in. Available to this connection and server.
        /// </summary>
        public HashSet<Scene> Scenes { get; private set; } = new();
        /// <summary>
        /// True if this connection is being disconnected. Only available to server.
        /// </summary>
        public bool Disconnecting { get; private set; }
        /// <summary>
        /// Custom data associated with this connection which may be modified by the user.
        /// The value of this field are not synchronized over the network.
        /// </summary>
        public object CustomData = null;
        /// <summary>
        /// Tick of the last packet received from this connection which was not out of order.
        /// This value is only available on the server.
        /// </summary>
        public EstimatedTick PacketTick { get; private set; } = new();
        /// <summary>
        /// Approximate local tick as it is on this connection.
        /// This also contains the last set value for local and remote.
        /// </summary>
        public EstimatedTick LocalTick { get; private set; } = new();
        #endregion

        #region Private.
        /// <summary>
        /// True if loaded start scenes as server.
        /// </summary>
        private bool _loadedStartScenesAsServer;
        /// <summary>
        /// True if loaded start scenes as client.
        /// </summary>
        private bool _loadedStartScenesAsClient;
        #endregion

        #region Const.
        /// <summary>
        /// Value used when ClientId has not been set.
        /// </summary>
        public const int UNSET_CLIENTID_VALUE = -1;
        /// <summary>
        /// Maximum value a ClientId can be.
        /// </summary>
        public const int MAXIMUM_CLIENTID_VALUE = int.MaxValue;
        /// <summary>
        /// Maximum value a ClientId can be excluding simulated value.
        /// </summary>
        public const int MAXIMUM_CLIENTID_WITHOUT_SIMULATED_VALUE = (int.MaxValue - 1);
        /// <summary>
        /// Value to use as a ClientId when simulating a local client without actually using a socket.
        /// </summary>
        public const int SIMULATED_CLIENTID_VALUE = int.MaxValue;
        /// <summary>
        /// Number of bytes to reserve for a connectionId if writing the value uncompressed.
        /// </summary>
        public const int CLIENTID_UNCOMPRESSED_RESERVE_LENGTH = 4;
        #endregion

        #region Comparers.
        public override bool Equals(object obj)
        {
            if (obj is NetworkConnection nc)
                return (nc.ClientId == this.ClientId);
            else
                return false;
        }
        public bool Equals(NetworkConnection nc)
        {
            if (nc is null)
                return false;
            //If either is -1 Id.
            if (this.ClientId == NetworkConnection.UNSET_CLIENTID_VALUE || nc.ClientId == NetworkConnection.UNSET_CLIENTID_VALUE)
                return false;
            //Same object.
            if (System.Object.ReferenceEquals(this, nc))
                return true;

            return (this.ClientId == nc.ClientId);
        }
        public override int GetHashCode()
        {
            return ClientId;
        }
        public static bool operator ==(NetworkConnection a, NetworkConnection b)
        {
            if (a is null && b is null)
                return true;
            if (a is null && !(b is null))
                return false;

            return (b == null) ? a.Equals(b) : b.Equals(a);
        }
        public static bool operator !=(NetworkConnection a, NetworkConnection b)
        {
            return !(a == b);
        }
        #endregion

        [APIExclude]
        public NetworkConnection() { }
        [APIExclude]
        public NetworkConnection(NetworkManager manager, int clientId, int transportIndex, bool asServer)
        {
            Initialize(manager, clientId, transportIndex, asServer);
        }

        /// <summary>
        /// Outputs data about this connection as a string.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            int clientId = ClientId;
            string ip = (NetworkManager != null) ? NetworkManager.TransportManager.Transport.GetConnectionAddress(clientId) : "Unset";
            return $"Id [{ClientId}] Address [{ip}]";
        }

        /// <summary>
        /// Initializes this for use.
        /// </summary>
        
        private void Initialize(NetworkManager nm, int clientId, int transportIndex, bool asServer)
        {
            NetworkManager = nm;
            LocalTick.Initialize(nm.TimeManager);
            PacketTick.Initialize(nm.TimeManager);
            if (asServer)
                ServerConnectionTick = nm.TimeManager.LocalTick;
            TransportIndex = transportIndex;
            ClientId = clientId;
            /* Set PacketTick to current values so
            * that timeouts and other things around
           * first packet do not occur due to an unset value. */
            PacketTick.Update(nm.TimeManager, 0, OldTickOption.SetLastRemoteTick);
            Observers_Initialize(nm);
            Prediction_Initialize(nm, asServer);
            //Only the server uses the ping and buffer.
            if (asServer)
            {
                InitializeBuffer();
                InitializePing();
            }
        }

        /// <summary>
        /// Sets Disconnecting boolean for this connection.
        /// </summary>
        internal void SetDisconnecting(bool value)
        {
            Disconnecting = value;
            if (Disconnecting)
                DisconnectingTick = NetworkManager.TimeManager.LocalTick;
        }

        /// <summary>
        /// Disconnects this connection.
        /// </summary>
        /// <param name="immediately">True to disconnect immediately. False to send any pending data first.</param>
        public void Disconnect(bool immediately)
        {
            if (!IsValid)
            {
                NetworkManager.LogWarning($"Disconnect called on an invalid connection.");
                return;
            }
            if (Disconnecting)
            {
                NetworkManager.LogWarning($"ClientId {ClientId} is already disconnecting.");
                return;
            }

            SetDisconnecting(true);
            //If immediately then force disconnect through transport.
            if (immediately)
                NetworkManager.TransportManager.Transport.StopConnection(ClientId, true);
            //Otherwise mark dirty so server will push out any pending information, and then disconnect.
            else
                ServerDirty();
        }

        /// <summary>
        /// Returns if just loaded start scenes and sets them as loaded if not.
        /// </summary>
        /// <returns></returns>
        internal bool SetLoadedStartScenes(bool asServer)
        {
            bool loadedToCheck = (asServer) ? _loadedStartScenesAsServer : _loadedStartScenesAsClient;
            //Result becomes true if not yet loaded start scenes.
            bool result = !loadedToCheck;
            if (asServer)
                _loadedStartScenesAsServer = true;
            else
                _loadedStartScenesAsClient = true;

            OnLoadedStartScenes?.Invoke(this, asServer);

            return result;
        }

        /// <summary>
        /// Sets connection as authenticated.
        /// </summary>
        internal void ConnectionAuthenticated()
        {
            IsAuthenticated = true;
        }

        /// <summary>
        /// Adds to Objects owned by this connection.
        /// </summary>
        /// <param name="nob"></param>
        
        internal void AddObject(NetworkObject nob)
        {
            if (!IsValid)
                return;

            Objects.Add(nob);
            //If adding the first object then set new FirstObject.
            if (Objects.Count == 1)
                SetFirstObject();

            OnObjectAdded?.Invoke(nob);
        }

        /// <summary>
        /// Removes from Objects owned by this connection.
        /// </summary>
        /// <param name="nob"></param>
        
        internal void RemoveObject(NetworkObject nob)
        {
            if (!IsValid)
            {
                ClearObjects();
                return;
            }

            Objects.Remove(nob);
            //If removing the first object then set a new one.
            if (nob == FirstObject)
                SetFirstObject();

            OnObjectRemoved?.Invoke(nob);
        }

        /// <summary>
        /// Clears all Objects.
        /// </summary>
        private void ClearObjects()
        {
            Objects.Clear();
            FirstObject = null;
        }

        /// <summary>
        /// Sets FirstObject using the first element in Objects.
        /// </summary>
        private void SetFirstObject()
        {
            if (Objects.Count == 0)
            {
                FirstObject = null;
            }
            else
            {
                foreach (NetworkObject nob in Objects)
                {
                    FirstObject = nob;
                    Observers_FirstObjectChanged();
                    break;
                }
            }
        }

        /// <summary>
        /// Adds a scene to this connections Scenes.
        /// </summary>
        /// <param name="scene"></param>
        /// <returns></returns>
        internal bool AddToScene(Scene scene)
        {
            return Scenes.Add(scene);
        }

        /// <summary>
        /// Removes a scene to this connections Scenes.
        /// </summary>
        /// <param name="scene"></param>
        /// <returns></returns>
        internal bool RemoveFromScene(Scene scene)
        {
            return Scenes.Remove(scene);
        }

        /// <summary>
        /// Resets all states for re-use.
        /// </summary>
        
        public void ResetState()
        {
            MatchCondition.RemoveFromMatchesWithoutRebuild(this, NetworkManager);

            foreach (PacketBundle p in _toClientBundles)
                p.Dispose();
            _toClientBundles.Clear();

            ServerConnectionTick = 0;
            PacketTick.Reset();
            LocalTick.Reset();
            TransportIndex = -1;
            ClientId = -1;
            ClearObjects();
            IsAuthenticated = false;
            HasSentVersion = false;
            NetworkManager = null;
            _loadedStartScenesAsClient = false;
            _loadedStartScenesAsServer = false;
            SetDisconnecting(false);
            Scenes.Clear();
            PredictedObjectIds.Clear();
            ResetPingPong();
            Observers_Reset();
            Prediction_Reset();
        }

        public void InitializeState() { }
    
    }


}﻿using FishNet.Component.Observing;
using FishNet.Managing;
using UnityEngine;

namespace FishNet.Connection
{

    /// <summary>
    /// A container for a connected client used to perform actions on and gather information for the declared client.
    /// </summary>
    public partial class NetworkConnection
    {
        #region Internal.
        /// <summary>
        /// Current GridEntry this connection is in.
        /// </summary>
        internal GridEntry HashGridEntry = HashGrid.EmptyGridEntry;
        #endregion

        #region Private.
        /// <summary>
        /// HashGrid for the NetworkManager on this connection.
        /// </summary>
        private HashGrid _hashGrid;
        /// <summary>
        /// Last unscaled time the HashGrid position was updated with this connections Objects.
        /// </summary>
        private float _nextHashGridUpdateTime;
        /// <summary>
        /// Current GridPosition this connection is in.
        /// </summary>
        private Vector2Int _hashGridPosition = HashGrid.UnsetGridPosition;
        #endregion

        /// <summary>
        /// Called when the FirstObject changes for this connection.
        /// </summary>
        private void Observers_FirstObjectChanged()
        {
            UpdateHashGridPositions(true);
        }

        /// <summary>
        /// Initializes this for use.
        /// </summary>
        private void Observers_Initialize(NetworkManager nm)
        {
            nm.TryGetInstance(out _hashGrid);
        }

        /// <summary>
        /// Updates the HashGridPosition value for FirstObject.
        /// </summary>
        internal void UpdateHashGridPositions(bool force)
        {
            if (_hashGrid == null)
                return;

            float unscaledTime = Time.unscaledTime;
            //Not enough time has passed to update.
            if (!force && unscaledTime < _nextHashGridUpdateTime)
                return;

            const float updateInterval = 1f;
            _nextHashGridUpdateTime = unscaledTime + updateInterval;

            if (FirstObject == null)
            {
                HashGridEntry = HashGrid.EmptyGridEntry;
                _hashGridPosition = HashGrid.UnsetGridPosition;
            }
            else
            {
                Vector2Int newPosition = _hashGrid.GetHashGridPosition(FirstObject);
                if (newPosition != _hashGridPosition)
                {
                    _hashGridPosition = newPosition;
                    HashGridEntry = _hashGrid.GetGridEntry(newPosition);
                }
            }            
        }

        /// <summary>
        /// Resets values.
        /// </summary>
        private void Observers_Reset()
        {
            _hashGrid = null;
            _hashGridPosition = HashGrid.UnsetGridPosition;
            _nextHashGridUpdateTime = 0f;
        }



    }


}﻿using FishNet.Managing;
using FishNet.Managing.Timing;
using System;
using UnityEngine;

namespace FishNet.Connection
{

    /// <summary>
    /// A container for a connected client used to perform actions on and gather information for the declared client.
    /// </summary>
    public partial class NetworkConnection
    {
#pragma warning disable CS0414
        #region Private.
        /// <summary>
        /// Last tick this connection sent a ping.
        /// </summary>
        private uint _lastPingTick;
        ///// <summary>
        ///// Number of times client has excessively sent a ping.
        ///// </summary>
        //private float _excessivePingCount;
        /// <summary>
        /// Ticks expected between each ping.
        /// </summary>
        private uint _requiredPingTicks;
        #endregion

        #region Const.
        /// <summary>
        /// Number of times a ping may occur excessively before server will punish connection.
        /// </summary>
        private const byte EXCESSIVE_PING_LIMIT = 10;
        #endregion

#pragma warning restore CS0414
        /// <summary>
        /// Initializes for ping.
        /// </summary>
        private void InitializePing()
        {
            //Give the client some room for error.
            float requiredInterval = (NetworkManager.TimeManager.PingInterval * 0.85f);
            //Round down so required ticks is lower.
            _requiredPingTicks = NetworkManager.TimeManager.TimeToTicks(requiredInterval, TickRounding.RoundDown);
        }


        /// <summary>
        /// Resets PingPong values.
        /// </summary>
        private void ResetPingPong()
        {
            //_excessivePingCount = 0;
            _lastPingTick = 0;
        }

        /// <summary>
        /// Called when a ping is received from this connection. Returns if can respond to ping.
        /// </summary>
        /// <returns>True to respond to ping, false to kick connection.</returns>
        internal bool CanPingPong()
        {
            /* Only check ping conditions in build. Editors are prone to pausing which can
             * improperly kick clients. */
            TimeManager tm = (NetworkManager == null) ? InstanceFinder.TimeManager : NetworkManager.TimeManager;
            /* Server FPS is running low, timing isn't reliable enough to kick clients.
             * Respond with clients ping and remove infractions just in case the
             * client received some from other server instabilities. */
            if (tm.LowFrameRate)
            {
                //_excessivePingCount = 0f;
                return false;
            }

            uint currentTick = tm.Tick;
            uint difference = (currentTick - _lastPingTick);
            _lastPingTick = currentTick;

            //Ping sent too quickly.
            if (difference < _requiredPingTicks)
            {
                //_excessivePingCount += 1f;
                ////Ping limit hit.
                //if (_excessivePingCount >= EXCESSIVE_PING_LIMIT)
                //{
                //    NetworkManager.LogWarning($"Kicked connectionId {ClientId} for excessive pings.");
                //    Disconnect(true);
                //}

                //Return to not send pong back.
                return false;
            }
            //Ping isnt too fast.
            else
            {
                //_excessivePingCount = UnityEngine.Mathf.Max(0f, _excessivePingCount - 0.5f);
                return true;
            }
        }
    }


}﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.Managing;
using FishNet.Managing.Predicting;
using FishNet.Managing.Timing;
using FishNet.Managing.Transporting;
using FishNet.Serializing;
using FishNet.Transporting;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace FishNet.Connection
{

    /// <summary>
    /// A container for a connected client used to perform actions on and gather information for the declared client.
    /// </summary>
    public partial class NetworkConnection
    {
        /// <summary>
        /// Approximate replicate tick on the server for this connection.
        /// This also contains the last set value for local and remote.
        /// </summary>
        public EstimatedTick ReplicateTick { get; private set; } = new();
        /// <summary>
        /// Writers for states.
        /// </summary>
        internal List<PooledWriter> PredictionStateWriters = new();

        internal void Prediction_Initialize(NetworkManager manager, bool asServer) { }


        /// <summary>
        /// Writes a prediction state.
        /// </summary>
        /// <param name="data"></param>
        internal void WriteState(PooledWriter data)
        {
#if !DEVELOPMENT
            //Do not send states to clientHost.
            if (IsLocalClient)
                return;
#endif

            TimeManager timeManager = NetworkManager.TimeManager;
            TransportManager transportManager = NetworkManager.TransportManager;
            uint ticksBehind = (IsLocalClient) ? 0 : PacketTick.LocalTickDifference(timeManager);
            /* If it's been a really long while the client could just be setting up
             * or dropping. Only send if they've communicated within 5 seconds. */
            if (ticksBehind > (timeManager.TickRate * 5))
                return;

            int mtu = transportManager.GetLowestMTU((byte)Channel.Unreliable);
            PooledWriter stateWriter;
            int writerCount = PredictionStateWriters.Count;
            /* Conditions to create a new writer are:
             * - writer does not exist yet.
             * - data length + currentWriter length > mtu */
            Channel channel = Channel.Unreliable;
            if (writerCount > 0)
                transportManager.CheckSetReliableChannel((data.Length + PredictionStateWriters[writerCount - 1].Length), ref channel);
            /* If no writers or if channel would be forced reliable.
             * 
             * By checking if channel would be reliable this is
             * essentially asking if (current written + new data) would
             * exceed mtu. When it would get a new writer to try
             * and favor unreliable. Emphasis on try, because if some
             * really unlikely chance the data was really large it would
             * still send on reliable down the line. */
            if (writerCount == 0 || channel == Channel.Reliable)
            {
                stateWriter = WriterPool.Retrieve(mtu);
                PredictionStateWriters.Add(stateWriter);
                stateWriter.Skip(PredictionManager.STATE_HEADER_RESERVE_LENGTH);
                /// 2 PacketId.
                /// 4 Last replicate tick run for connection.
                /// 4 Length unpacked.
            }
            else
            {
                stateWriter = PredictionStateWriters[writerCount - 1];
            }

            stateWriter.WriteArraySegment(data.GetArraySegment());
        }

        /// <summary>
        /// Stores prediction writers to be re-used later.
        /// </summary>
        internal void StorePredictionStateWriters()
        {
            for (int i = 0; i < PredictionStateWriters.Count; i++)
                WriterPool.Store(PredictionStateWriters[i]);

            PredictionStateWriters.Clear();
        }


        /// <summary>
        /// Sets the last tick a NetworkBehaviour replicated with.
        /// </summary>
        /// <param name="setUnordered">True to set unordered value, false to set ordered.</param>
        internal void SetReplicateTick(uint value, EstimatedTick.OldTickOption oldTickOption = EstimatedTick.OldTickOption.Discard)
        {
            ReplicateTick.Update(value, oldTickOption);
        }


        /// <summary>
        /// Resets NetworkConnection.
        /// </summary>
        
        private void Prediction_Reset()
        {
            StorePredictionStateWriters();
            ReplicateTick.Reset();
        }
    }


}
﻿using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Server;
using FishNet.Serializing;
using System;
using UnityEngine;

namespace FishNet.Connection
{
    /// <summary>
    /// A container for a connected client used to perform actions on and gather information for the declared client.
    /// </summary>
    public partial class NetworkConnection
    {
        #region Public.
        /// <summary>
        /// Returns true if this connection is a clientHost.
        /// </summary>
        public bool IsHost => (NetworkManager == null) ? false : (NetworkManager.IsServerStarted && (this == NetworkManager.ClientManager.Connection));
        /// <summary>
        /// Returns if this connection is for the local client.
        /// </summary>
        public bool IsLocalClient => (NetworkManager == null) ? false : (NetworkManager.ClientManager.Connection == this);
        #endregion

        /// <summary>
        /// Returns the address of this connection.
        /// </summary>
        /// <returns></returns>
        public string GetAddress()
        {
            if (!IsValid)
                return string.Empty;
            if (NetworkManager == null)
                return string.Empty;

            return NetworkManager.TransportManager.Transport.GetConnectionAddress(ClientId);
        }

        /// <summary>
        /// Kicks a connection immediately while invoking OnClientKick.
        /// </summary>
        /// <param name="kickReason">Reason client is being kicked.</param>
        /// <param name="loggingType">How to print logging as.</param>
        /// <param name="log">Optional message to be debug logged.</param>
        public void Kick(KickReason kickReason, LoggingType loggingType = LoggingType.Common, string log = "")
        {
            if (CanKick())
                NetworkManager.ServerManager.Kick(this, kickReason, loggingType, log);
        }

        /// <summary>
        /// Kicks a connection immediately while invoking OnClientKick.
        /// </summary>
        /// <param name="reader">Reader to clear before kicking.</param>
        /// <param name="kickReason">Reason client is being kicked.</param>
        /// <param name="loggingType">How to print logging as.</param>
        /// <param name="log">Optional message to be debug logged.</param>
        public void Kick(Reader reader, KickReason kickReason, LoggingType loggingType = LoggingType.Common, string log = "")
        {
            if (CanKick())
                NetworkManager.ServerManager.Kick(this, reader, kickReason, loggingType, log);
        }

        private bool CanKick()
        {
            //Connection isn't valid, calling kick on an empty connection.
            if (!IsValid)
                return false;

            //Should never happen.
            if (NetworkManager == null)
            {
                NetworkManager = InstanceFinder.NetworkManager;
                NetworkManager.LogError($"NetworkManager was not set for connection {this.ToString()}. InstanceFinder has been used.");
            }

            return true;
        }
    }
}﻿using System.Runtime.CompilerServices;

namespace FishNet.Managing.Timing
{


}﻿
using System;

namespace FishNet.Documenting
{
    public class APIExcludeAttribute : Attribute { }

}
#if UNITY_EDITOR

using System.IO;
using UnityEditor;
using UnityEditor.Callbacks;

namespace FishNet.Editing
{
    /* When creating dedicated server builds this will place an empty file within
     * the build folder.
     *
     * The file contains absolutely no information, and is used by our partners to identify how many of their customers are using
     * Fish-Networking.
     *
     * The created file is not required -- you may delete the file and/or this code, but please
     * consider retaining the file as it helps keep FishNet free. */

    public class BuildIdentifier
    {
        [PostProcessBuild(1)]
        public static void OnPostprocessBuild(BuildTarget target, string pathToBuiltProject)
        {
            //Not a server build.
#if !SERVER_BUILD && !UNITY_SERVER
            return;
#endif

            string buildPath = Path.GetDirectoryName(pathToBuiltProject);
            if (buildPath == null)
                return;

            //Validate that we are in the right folder.
            string crashHandler = Path.Combine(buildPath, "UnityCrashHandler64.exe");
            if (File.Exists(crashHandler))
            {
                //Try to create the empty file.
                try
                {
                    string filePath = Path.Combine(buildPath, "BuildIdentifier.json");
                    File.WriteAllText(filePath, string.Empty);
                }
                finally { }
            }
        }
    }
}

#endif﻿#if UNITY_EDITOR

using FishNet.Configuring;
using System.IO;
using UnityEngine;
using System.Xml.Serialization;

using FishNet.Editing.PrefabCollectionGenerator;
using UnityEditor.Compilation;
using UnityEditor.Build.Reporting;
using UnityEditor;
using UnityEditor.Build;

namespace FishNet.Configuring
{


    public class CodeStripping
    
    {

        /// <summary>
        /// True if making a release build for client.
        /// </summary>
        public static bool ReleasingForClient => (Configuration.Configurations.CodeStripping.IsBuilding && !Configuration.Configurations.CodeStripping.IsHeadless && !Configuration.Configurations.CodeStripping.IsDevelopment);
        /// <summary>
        /// True if making a release build for server.
        /// </summary>
        public static bool ReleasingForServer => (Configuration.Configurations.CodeStripping.IsBuilding && Configuration.Configurations.CodeStripping.IsHeadless && !Configuration.Configurations.CodeStripping.IsDevelopment);
        /// <summary>
        /// Returns if to remove server logic.
        /// </summary>
        /// <returns></returns>
        public static bool RemoveServerLogic
        {
            get
            {
                

                /* This is to protect non pro users from enabling this
                 * without the extra logic code.  */
#pragma warning disable CS0162 // Unreachable code detected
                return false;
#pragma warning restore CS0162 // Unreachable code detected
            }
        }
        /// <summary>
        /// True if building and stripping is enabled.
        /// </summary>
        public static bool StripBuild
        {
            get
            {
                

                /* This is to protect non pro users from enabling this
                 * without the extra logic code.  */
#pragma warning disable CS0162 // Unreachable code detected
                return false;
#pragma warning restore CS0162 // Unreachable code detected
            }
        }
        /// <summary>
        /// Technique to strip methods.
        /// </summary>
        public static StrippingTypes StrippingType => (StrippingTypes)Configuration.Configurations.CodeStripping.StrippingType;

        private static object _compilationContext;
        public int callbackOrder => 0;

        public void OnPreprocessBuild(BuildReport report)
        {
            Generator.IgnorePostProcess = true;
            Generator.GenerateFull();
            CompilationPipeline.compilationStarted += CompilationPipelineOnCompilationStarted;
            CompilationPipeline.compilationFinished += CompilationPipelineOnCompilationFinished;

            
        }
        /* Solution for builds ending with errors and not triggering OnPostprocessBuild.
        * Link: https://gamedev.stackexchange.com/questions/181611/custom-build-failure-callback
        */
        private void CompilationPipelineOnCompilationStarted(object compilationContext)
        {
            _compilationContext = compilationContext;
        }

        private void CompilationPipelineOnCompilationFinished(object compilationContext)
        {
            if (compilationContext != _compilationContext)
                return;

            _compilationContext = null;

            CompilationPipeline.compilationStarted -= CompilationPipelineOnCompilationStarted;
            CompilationPipeline.compilationFinished -= CompilationPipelineOnCompilationFinished;

           // BuildingEnded();
        }

        private void BuildingEnded()
        {
            

            Generator.IgnorePostProcess = false;
        }

        public void OnPostprocessBuild(BuildReport report)
        {
            
                BuildingEnded();
        }
    }

}
#endif
﻿using FishNet.Documenting;

namespace FishNet.Editing
{
    [APIExclude]
    public static class EditingConstants
    {
        public const string PRO_ASSETS_LOCKED_TEXT = "Fields marked with * are only active with Fish-Networking Pro.";
        public const string PRO_ASSETS_UNLOCKED_TEXT = "Thank you for supporting Fish-Networking! Pro asset features are unlocked.";

    }

}//Remove in V5﻿#if UNITY_EDITOR
using FishNet.Utility;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Editing
{
    public static class Finding
    {
        #region Private.
        /// <summary>
        /// Path where the FishNet.Runtime assembly is.
        /// </summary>
        [System.NonSerialized]
        private static string _fishNetRuntimePath = string.Empty;
        /// <summary>
        /// Path where the FishNet.Generated assembly is.
        /// </summary>
        private static string _fishNetGeneratedPath = string.Empty;
        #endregion

        /// <summary>
        /// Sets FishNet assembly paths.
        /// </summary>
        /// <param name="error"></param>
        private static void UpdateFishNetPaths()
        {
            if (_fishNetGeneratedPath != string.Empty && _fishNetRuntimePath != string.Empty)
                return;

            string[] guids = AssetDatabase.FindAssets("t:asmdef", new string[] { "Assets" });
            string[] objectPaths = new string[guids.Length];
            for (int i = 0; i < guids.Length; i++)
                objectPaths[i] = AssetDatabase.GUIDToAssetPath(guids[i]);

            string runtimeName = (UtilityConstants.RUNTIME_ASSEMBLY_NAME + ".asmdef").ToLower();
            string generatedName = (UtilityConstants.GENERATED_ASSEMBLY_NAME + ".asmdef").ToLower();
            /* Find all network managers which use Single prefab linking
             * as well all network object prefabs. */
            foreach (string item in objectPaths)
            {
                //Found directory to create object in.
                if (item.ToLower().Contains(runtimeName))
                    _fishNetRuntimePath = System.IO.Path.GetDirectoryName(item);
                else if (item.ToLower().Contains(generatedName))
                    _fishNetGeneratedPath = System.IO.Path.GetDirectoryName(item);

                if (_fishNetGeneratedPath != string.Empty && _fishNetRuntimePath != string.Empty)
                    return;
            }
        }

        /// <summary>
        /// Gets all GameObjects in Assets and optionally scenes.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public static List<GameObject> GetGameObjects(bool userAssemblies, bool fishNetAssembly, bool includeScenes, string[] ignoredPaths = null)
        {
            List<GameObject> results = new();

            string[] guids;
            string[] objectPaths;

            UpdateFishNetPaths();

            guids = AssetDatabase.FindAssets("t:GameObject", null);
            objectPaths = new string[guids.Length];
            for (int i = 0; i < guids.Length; i++)
                objectPaths[i] = AssetDatabase.GUIDToAssetPath(guids[i]);

            foreach (string item in objectPaths)
            {
                bool inFishNet = item.Contains(_fishNetRuntimePath);
                if (inFishNet && !fishNetAssembly)
                    continue;
                if (!inFishNet && !userAssemblies)
                    continue;
                if (ignoredPaths != null)
                {
                    bool ignore = false;
                    foreach (string path in ignoredPaths)
                    {
                        if (item.Contains(path))
                        {
                            ignore = true;
                            break;
                        }
                    }
                    if (ignore)
                        continue;
                }

                GameObject go = (GameObject)AssetDatabase.LoadAssetAtPath(item, typeof(GameObject));
                results.Add(go);
            }

            if (includeScenes)
                results.AddRange(GetSceneGameObjects());

            return results;
        }

        /// <summary>
        /// Gets all GameObjects in all open scenes.
        /// </summary>
        /// <returns></returns>
        private static List<GameObject> GetSceneGameObjects()
        {
            List<GameObject> results = new();

            for (int i = 0; i < SceneManager.sceneCount; i++)
                results.AddRange(GetSceneGameObjects(SceneManager.GetSceneAt(i)));

            return results;
        }
        /// <summary>
        /// Gets all GameObjects in a scene.
        /// </summary>
        private static List<GameObject> GetSceneGameObjects(Scene s)
        {
            List<GameObject> results = new();
            List<Transform> buffer = new();
            //Iterate all root objects for the scene.
            GameObject[] gos = s.GetRootGameObjects();
            for (int i = 0; i < gos.Length; i++)
            {
                /* Get GameObjects within children of each
                 * root object then add them to the cache. */
                gos[i].GetComponentsInChildren(true, buffer);
                foreach (Transform t in buffer)
                    results.Add(t.gameObject);
            }

            return results;
        }


        /// <summary>
        /// Gets created ScriptableObjects of T.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public static List<UnityEngine.Object> GetScriptableObjects<T>(bool fishNetAssembly, bool breakOnFirst = false)
        {
            System.Type tType = typeof(T);
            List<UnityEngine.Object> results = new();

            string[] guids = AssetDatabase.FindAssets("t:ScriptableObject", new string[] { "Assets" });
            string[] objectPaths = new string[guids.Length];
            for (int i = 0; i < guids.Length; i++)
                objectPaths[i] = AssetDatabase.GUIDToAssetPath(guids[i]);


            /* This might be faster than using directory comparers.
             * Don't really care since this occurs only at edit. */
            List<string> fishNetPaths = new();
            fishNetPaths.Add(_fishNetGeneratedPath.Replace(@"/", @"\"));
            fishNetPaths.Add(_fishNetGeneratedPath.Replace(@"\", @"/"));
            fishNetPaths.Add(_fishNetRuntimePath.Replace(@"/", @"\"));
            fishNetPaths.Add(_fishNetRuntimePath.Replace(@"\", @"/"));
            /* Find all network managers which use Single prefab linking
             * as well all network object prefabs. */
            foreach (string item in objectPaths)
            {
                //This will skip hidden unity types.
                if (!item.EndsWith(".asset"))
                    continue;
                if (fishNetAssembly)
                {
                    bool found = false;
                    foreach (string path in fishNetPaths)
                    {
                        if (item.Contains(path))
                        {
                            found = true;
                            break;
                        }
                    }
                    if (!found)
                        continue;
                }
                UnityEngine.Object obj = AssetDatabase.LoadAssetAtPath(item, tType);
                if (obj != null && tType != null && obj.GetType() == tType)
                {
                    results.Add(obj);
                    if (breakOnFirst)
                        return results;
                }
            }

            return results;
        }

    }
}
#endif#if UNITY_EDITOR
using System;
using System.IO;
using UnityEditor;
using UnityEngine;

namespace FishNet.Editing
{
    /* When you import playeveryware's EOS asset, it force installs NGO, which creates
     * a lot of issues for anyone not using NGO. This script will block the force installation. */
    public class ForceInstallPreventor : AssetPostprocessor
    {
        private static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
        {
            // No need to continue if nothing was imported.
            if (importedAssets == null || importedAssets.Length == 0)
                return;

            EditorApplication.LockReloadAssemblies();

            foreach (string path in importedAssets)
                CheckTargetPath(path);

            /* We don't have a way to know if the user intentionally
             * had domain locked so we just have to unlock it and hope
             * we aren't messing up users settings.
             *
             * Worse case scenario this will only happen when the forceware
             * is removed.
             *
             * There is a 'didDomainReload' boolean override for this
             * method, but it does not seem to reflect the information
             * we need.
             * */
            EditorApplication.UnlockReloadAssemblies();
        }

        private void OnPreprocessAsset()
        {
            CheckTargetPath(assetImporter.assetPath);
        }

        private static void CheckTargetPath(string path)
        {
            if (!path.Contains("PackageInstallHelper_Netcode", StringComparison.CurrentCultureIgnoreCase))
                return;

            try
            {
                File.Delete(path);
                Debug.Log($"Fish-Networking prevented PlayEveryWare from forcefully installing Netcode for GameObjects.");
            }
            finally { }
        }
    }
}
#endif﻿#if UNITY_EDITOR
using System;
using UnityEditor;
using UnityEngine;

namespace FishNet.Editing
{

    [InitializeOnLoad]
    public class PlayModeTracker
    {
        static PlayModeTracker()
        {
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;
        }

        ~PlayModeTracker()
        {
            EditorApplication.playModeStateChanged -= OnPlayModeStateChanged;
        }

        /// <summary>
        /// DateTime when the editor last exited playmode.
        /// </summary>
        private static DateTime _quitTime = DateTime.MaxValue;

        /// <summary>
        /// True if the editor has exited playmode within past.
        /// </summary>
        /// <param name="past"></param>
        /// <returns></returns>
        internal static bool QuitRecently(float past)
        {
            past *= 1000;
            return ((DateTime.Now - _quitTime).TotalMilliseconds < past);
        }

        private static void OnPlayModeStateChanged(PlayModeStateChange stateChange)
        {
            switch (stateChange)
            {
                case (PlayModeStateChange.ExitingPlayMode):
                    _quitTime = DateTime.Now;
                    break;
            }
        }

    }
}

#endif﻿#if UNITY_EDITOR
using FishNet.Managing;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.Build;
using UnityEngine;

namespace FishNet
{
    internal static class ScriptingDefines
    {
        [InitializeOnLoadMethod]
        public static void AddDefineSymbols()
        {
            // Get data about current target group
            bool standaloneAndServer = false;
            BuildTarget buildTarget = EditorUserBuildSettings.activeBuildTarget;
            BuildTargetGroup buildTargetGroup = BuildPipeline.GetBuildTargetGroup(buildTarget);
            if (buildTargetGroup == BuildTargetGroup.Standalone)
            {
                StandaloneBuildSubtarget standaloneSubTarget = EditorUserBuildSettings.standaloneBuildSubtarget;
                if (standaloneSubTarget == StandaloneBuildSubtarget.Server)
                    standaloneAndServer = true;
            }

            // Prepare named target, depending on above stuff
            NamedBuildTarget namedBuildTarget;
            if (standaloneAndServer)
                namedBuildTarget = NamedBuildTarget.Server;
            else
                namedBuildTarget = NamedBuildTarget.FromBuildTargetGroup(buildTargetGroup);

            string currentDefines = PlayerSettings.GetScriptingDefineSymbols(namedBuildTarget);
            /* Convert current defines into a hashset. This is so we can
             * determine if any of our defines were added. Only save playersettings
             * when a define is added. */
            HashSet<string> definesHs = new();
            string[] currentArr = currentDefines.Split(';');
            //Add current defines into hs.
            foreach (string item in currentArr)
                definesHs.Add(item);

            string proDefine = "FISHNET_PRO";
            string versionPrefix = "FISHNET_V";
            string[] currentVersionSplit = NetworkManager.FISHNET_VERSION.Split(".");
            string thisVersion = $"{versionPrefix}{currentVersionSplit[0]}";

            string[] fishNetDefines = new string[]
            {
                "FISHNET",
                thisVersion,
                
            };
            bool modified = false;
            //Now add FN defines.
            foreach (string item in fishNetDefines)
                modified |= definesHs.Add(item);

            //Remove old prediction defines.
            modified |= definesHs.Remove("PREDICTION_V2");
            /* Remove pro define if not on pro. This might look a little
             * funny because the code below varies depending on if pro or not. */
            
#pragma warning disable CS0162 // Unreachable code detected
                modified |= definesHs.Remove(proDefine);
#pragma warning restore CS0162 // Unreachable code detected

            List<string> definesToRemove = new();
            int versionPrefixLength = versionPrefix.Length;
            //Remove old versions.
            foreach (string item in definesHs)
            {
                //Do not remove this version.
                if (item == thisVersion)
                    continue;

                //If length is possible to be a version prefix and is so then remove it.
                if (item.Length >= versionPrefixLength && item.Substring(0, versionPrefixLength) == versionPrefix)
                    definesToRemove.Add(item);
            }

            modified |= (definesToRemove.Count > 0);
            foreach (string item in definesToRemove)
            {
                definesHs.Remove(item);
                Debug.Log($"Removed unused Fish-Networking define {item}.");
            }

            if (modified)
            {
                Debug.Log("Added or removed Fish-Networking defines within player settings.");
                string changedDefines = string.Join(";", definesHs);
                PlayerSettings.SetScriptingDefineSymbols(namedBuildTarget, changedDefines);
            }
        }
    }
}
#endif﻿#if UNITY_EDITOR
using FishNet.Editing.PrefabCollectionGenerator;
using FishNet.Object;
using FishNet.Utility.Extension;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Editing.Beta
{
    public class BetaModeMenu : MonoBehaviour
    {
        #region const.
        private const string STABLE_SYNCTYPES_DEFINE = "FISHNET_STABLE_SYNCTYPES";
        private const string STABLE_REPLICATESTATES_DEFINE = "FISHNET_STABLE_REPLICATESTATES";
        private const string STABLE_RECURSIVE_DESPAWNS_DEFINE = "FISHNET_STABLE_RECURSIVE_DESPAWNS";
        #endregion

        #region Beta SyncTypes
#if FISHNET_STABLE_SYNCTYPES
        [MenuItem("Tools/Fish-Networking/Beta/Enable for SyncTypes", false, -1101)]
        private static void EnableBetaSyncTypes() => SetBetaSyncTypes(useStable: false);
#else
        [MenuItem("Tools/Fish-Networking/Beta/Disable for SyncTypes", false, -1101)]
        private static void DisableBetaSyncTypes() => SetBetaSyncTypes(useStable: true);
#endif
        private static void SetBetaSyncTypes(bool useStable)
        {
            bool result = DeveloperMenu.RemoveOrAddDefine(STABLE_SYNCTYPES_DEFINE, removeDefine: !useStable);
            if (result)
                Debug.LogWarning($"Beta SyncTypes are now {GetBetaEnabledText(useStable)}.");
        }
        #endregion
        
        #region Beta Recursive Despawns
#if FISHNET_STABLE_RECURSIVE_DESPAWNS
        [MenuItem("Tools/Fish-Networking/Beta/Enable for Recursive Despawns", false, -1101)]
        private static void EnableBetaRecursiveDespawns() => SetBetaRecursiveDespawns(useStable: false);
#else
        [MenuItem("Tools/Fish-Networking/Beta/Disable for Recursive Despawns", false, -1101)]
        private static void DisableBetaRecursiveDespawns() => SetBetaRecursiveDespawns(useStable: true);
#endif
        private static void SetBetaRecursiveDespawns(bool useStable)
        {
            bool result = DeveloperMenu.RemoveOrAddDefine(STABLE_RECURSIVE_DESPAWNS_DEFINE,  removeDefine: !useStable);
            if (result)
                Debug.LogWarning($"Beta Recursive Despawns are now {GetBetaEnabledText(useStable)}.");
        }
        #endregion
        
        #region Beta ReplicateStates
#if FISHNET_STABLE_REPLICATESTATES
        [MenuItem("Tools/Fish-Networking/Beta/Enable for ReplicateStates", false, -1101)]
        private static void EnableBetaReplicateStates() => SetBetaReplicateStates(useStable: false);
#else
        [MenuItem("Tools/Fish-Networking/Beta/Disable for ReplicateStates", false, -1101)]
        private static void DisableBetaReplicateStates() => SetBetaReplicateStates(useStable: true);
#endif
        private static void SetBetaReplicateStates(bool useStable)
        {
            bool result = DeveloperMenu.RemoveOrAddDefine(STABLE_REPLICATESTATES_DEFINE,  removeDefine: !useStable);
            if (result)
                Debug.LogWarning($"Beta ReplicateStates are now {GetBetaEnabledText(useStable)}.");
        }
        #endregion

        private static string GetBetaEnabledText(bool useStable) 
        {
            return (useStable) ? "disabled" : "enabled";
        }
    }
}

#endif﻿#if UNITY_EDITOR
using FishNet.Editing.PrefabCollectionGenerator;
using System;
using System.Collections.Generic;
using System.IO;
using System.Xml.Serialization;
using UnityEditor;
using UnityEngine;


namespace FishNet.Configuring
{

    public enum StrippingTypes : int
    {
        Redirect = 0,
        Empty_Experimental = 1,
    }
    public enum SearchScopeType : int
    {
        EntireProject = 0,
        SpecificFolders = 1,
    }

    public class CreateNewNetworkBehaviourConfigurations
    {
        public string templateDirectoryPath = "Assets";

    }

    public class PrefabGeneratorConfigurations
    {
        public bool Enabled = true;
        public bool LogToConsole = true;
        public bool FullRebuild = false;
        public bool SpawnableOnly = true;
        public bool SaveChanges = true;
        public string DefaultPrefabObjectsPath = Path.Combine("Assets", "DefaultPrefabObjects.asset");
        internal string DefaultPrefabObjectsPath_Platform => Generator.GetPlatformPath(DefaultPrefabObjectsPath);
        public int SearchScope = (int)SearchScopeType.EntireProject;
        public List<string> ExcludedFolders = new();
        public List<string> IncludedFolders = new();
    }

    public class CodeStrippingConfigurations
    {
        public bool IsBuilding = false;
        public bool IsDevelopment = false;
        public bool IsHeadless = false;
        public bool StripReleaseBuilds = false;
        public int StrippingType = (int)StrippingTypes.Redirect;
    }


    public class ConfigurationData
    {
        //Non serialized doesn't really do anything, its just for me.
        [System.NonSerialized]
        public bool Loaded;

        public PrefabGeneratorConfigurations PrefabGenerator = new();
        public CodeStrippingConfigurations CodeStripping = new();
        public CreateNewNetworkBehaviourConfigurations CreateNewNetworkBehaviour = new();
    }

    public static class ConfigurationDataExtension
    {
        /// <summary>
        /// Returns if a differs from b.
        /// </summary>
        public static bool HasChanged(this ConfigurationData a, ConfigurationData b)
        {
            return (a.CodeStripping.StripReleaseBuilds != b.CodeStripping.StripReleaseBuilds);
        }
        /// <summary>
        /// Copies all values from source to target.
        /// </summary>
        public static void CopyTo(this ConfigurationData source, ConfigurationData target)
        {
            target.CodeStripping.StripReleaseBuilds = source.CodeStripping.StripReleaseBuilds;
        }


        /// <summary>
        /// Writes a configuration data.
        /// </summary>
        public static void Write(this ConfigurationData cd, bool refreshAssetDatabase)
        {
            /* Why is this a thing you ask? Because Unity makes it VERY difficult to read values from
             * memory during builds since on some Unity versions the building application is on a different
             * processor. In result instead of using memory to read configurationdata the values
             * must be written to disk then load the disk values as needed.
             * 
             * Fortunatelly the file is extremely small and this does not occur often at all. The disk read
             * will occur once per script save, and once per assembly when building. */
            try
            {
                string path = Configuration.GetAssetsPath(Configuration.CONFIG_FILE_NAME);
                XmlSerializer serializer = new(typeof(ConfigurationData));
                TextWriter writer = new StreamWriter(path);
                serializer.Serialize(writer, cd);
                writer.Close();
#if UNITY_EDITOR
                if (refreshAssetDatabase)
                {
                    AssetDatabase.SaveAssets();
                    AssetDatabase.Refresh();
                }
#endif
            }
            catch (Exception ex)
            {
                throw new($"An error occurred while writing ConfigurationData. Message: {ex.Message}");
            }

        }


        /// <summary>
        /// Writes a configuration data.
        /// </summary>
        public static void Write(this ConfigurationData cd, string path, bool refreshAssetDatabase)
        {
            /* Why is this a thing you ask? Because Unity makes it VERY difficult to read values from
             * memory during builds since on some Unity versions the building application is on a different
             * processor. In result instead of using memory to read configurationdata the values
             * must be written to disk then load the disk values as needed.
             * 
             * Fortunatelly the file is extremely small and this does not occur often at all. The disk read
             * will occur once per script save, and once per assembly when building. */
            try
            {
                XmlSerializer serializer = new(typeof(ConfigurationData));
                TextWriter writer = new StreamWriter(path);
                serializer.Serialize(writer, cd);
                writer.Close();
#if UNITY_EDITOR
                if (refreshAssetDatabase)
                {
                    AssetDatabase.SaveAssets();
                    AssetDatabase.Refresh();
                }
#endif
            }
            catch (Exception ex)
            {
                throw new($"An error occurred while writing ConfigurationData. Message: {ex.Message}");
            }

        }

    }


}
#endif﻿#if UNITY_EDITOR
using FishNet.Editing.PrefabCollectionGenerator;
using FishNet.Object;
using FishNet.Utility.Extension;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Editing
{
    public class ConfigurationEditor : EditorWindow
    {
        [MenuItem("Tools/Fish-Networking/Configuration", false, 0)]
        public static void ShowConfiguration()
        {
            SettingsService.OpenProjectSettings("Project/Fish-Networking/Configuration");
        }
    }

    public class DeveloperMenu : MonoBehaviour
    {
        #region const.
        private const string QOL_ATTRIBUTES_DEFINE = "DISABLE_QOL_ATTRIBUTES";
        private const string DEVELOPER_ONLY_WARNING = "If you are not a developer or were not instructed to do this by a developer things are likely to break. You have been warned.";
        #endregion

        #region QOL Attributes
#if DISABLE_QOL_ATTRIBUTES
        [MenuItem("Tools/Fish-Networking/Utility/Quality of Life Attributes/Enable", false, -999)]
        private static void EnableQOLAttributes()
        {
            bool result = RemoveOrAddDefine(QOL_ATTRIBUTES_DEFINE, removeDefine: true);
            if (result)
                Debug.LogWarning($"Quality of Life Attributes have been enabled.");
        }
#else
        [MenuItem("Tools/Fish-Networking/Utility/Quality of Life Attributes/Disable", false, 0)]
        private static void DisableQOLAttributes()
        {
            bool result = RemoveOrAddDefine(QOL_ATTRIBUTES_DEFINE, removeDefine: false);
            if (result)
                Debug.LogWarning($"Quality of Life Attributes have been disabled. {DEVELOPER_ONLY_WARNING}");
        }
#endif
        #endregion

        internal static bool RemoveOrAddDefine(string define, bool removeDefine)
        {
            string currentDefines = PlayerSettings.GetScriptingDefineSymbolsForGroup(EditorUserBuildSettings.selectedBuildTargetGroup);
            HashSet<string> definesHs = new();
            string[] currentArr = currentDefines.Split(';');

            //Add any define which doesn't contain MIRROR.
            foreach (string item in currentArr)
                definesHs.Add(item);

            int startingCount = definesHs.Count;

            if (removeDefine)
                definesHs.Remove(define);
            else
                definesHs.Add(define);

            bool modified = (definesHs.Count != startingCount);
            if (modified)
            {
                string changedDefines = string.Join(";", definesHs);
                PlayerSettings.SetScriptingDefineSymbolsForGroup(EditorUserBuildSettings.selectedBuildTargetGroup, changedDefines);
            }

            return modified;
        }
    }

    public class RefreshDefaultPrefabsMenu : MonoBehaviour
    {
        /// <summary>
        /// Rebuilds the DefaultPrefabsCollection file.
        /// </summary>
        [MenuItem("Tools/Fish-Networking/Utility/Refresh Default Prefabs", false, 300)]
        public static void RebuildDefaultPrefabs()
        {
#if PARRELSYNC
            if (ParrelSync.ClonesManager.IsClone() && ParrelSync.Preferences.AssetModPref.Value)
            {
                Debug.Log("Cannot perform this operation on a ParrelSync clone");
                return;
            }
#endif
            Debug.Log("Refreshing default prefabs.");
            Generator.GenerateFull(null, true);
        }
    }

}

#endif﻿#if UNITY_EDITOR
using System.IO;
using System.Xml.Serialization;
using UnityEngine;
using UnityEditor.Compilation;
using UnityEditor.Build.Reporting;
using UnityEditor;
using UnityEditor.Build;

namespace FishNet.Configuring
{
    public class Configuration
    {
        /// <summary>
        /// 
        /// </summary>
        private static ConfigurationData _configurations;
        /// <summary>
        /// ConfigurationData to use.
        /// </summary>
        public static ConfigurationData Configurations
        {
            get
            {
                if (_configurations == null)
                    _configurations = LoadConfigurationData();
                if (_configurations == null)
                    throw new("Fish-Networking Configurations could not be loaded. Certain features such as code-stripping may not function.");
                return _configurations;
            }
            private set { _configurations = value; }
        }

        /// <summary>
        /// File name for configuration disk data.
        /// </summary>
        public const string CONFIG_FILE_NAME = "FishNet.Config.XML";

        /// <summary>
        /// Returns true if this editor is a multiplayer clone.
        /// </summary>
        /// <returns></returns>
        public static bool IsMultiplayerClone()
        {
#if UNITY_EDITOR
            if (Application.dataPath.ToLower().Contains("library/vp/"))
                return true;

#if PARRELSYNC
            return ParrelSync.ClonesManager.IsClone();
#endif
#endif
            return false;
        }

        /// <summary>
        /// Returns the path for the configuration file.
        /// </summary>
        /// <returns></returns>
        internal static string GetAssetsPath(string additional = "")
        {
            string a = Path.Combine(System.IO.Directory.GetCurrentDirectory(), "Assets");
            if (additional != "")
                a = Path.Combine(a, additional);
            return a;
        }

        /// <summary>
        /// Returns FishNetworking ConfigurationData.
        /// </summary>
        /// <returns></returns>
        internal static ConfigurationData LoadConfigurationData()
        {
            //return new ConfigurationData();
            if (_configurations == null || !_configurations.Loaded)
            {
                string configPath = GetAssetsPath(CONFIG_FILE_NAME);
                //string configPath = string.Empty;
                //File is on disk.
                if (File.Exists(configPath))
                {
                    FileStream fs = null;
                    try
                    {
                        XmlSerializer serializer = new(typeof(ConfigurationData));
                        fs = new(configPath, FileMode.Open, FileAccess.Read, FileShare.Read);
                        _configurations = (ConfigurationData)serializer.Deserialize(fs);
                    }
                    finally
                    {
                        fs?.Close();
                    }
                    _configurations.Loaded = true;
                }
                else
                {
                    //If null then make a new instance.
                    if (_configurations == null)
                        _configurations = new();
                    //Don't unset loaded, if its true then it should have proper info.
                    //_configurationData.Loaded = false;
                }
            }

            return _configurations;
        }
    }
}

#endif﻿#if UNITY_EDITOR
using System;
using FishNet.Configuring;
using FishNet.Managing;
using UnityEditor;
using UnityEngine;

namespace FishNet.Editing
{
    /// <summary>
    /// Contributed by YarnCat! Thank you!
    /// </summary>
    [InitializeOnLoad]
    public class DelayedEditorTasks : EditorWindow
    {
        private static double _startTime = double.MinValue;

        static DelayedEditorTasks()
        {
            if (Configuration.IsMultiplayerClone())
                return;

            const string startupCheckString = "FishNetDelayedEditorTasks";
            if (SessionState.GetBool(startupCheckString, false))
                return;

            _startTime = EditorApplication.timeSinceStartup;
            EditorApplication.update += CheckRunTasks;

            SessionState.SetBool(startupCheckString, true);
        }

        private static void CheckRunTasks()
        {
            if (EditorApplication.timeSinceStartup - _startTime < 1f)
                return;

            EditorApplication.update -= CheckRunTasks;

            LogFeedbackLink();

            //First time use, no other actions should be done.
            if (FishNetGettingStartedEditor.ShowGettingStarted())
                return;

            ReviewReminderEditor.CheckRemindToReview();
        }

        private static void LogFeedbackLink()
        {
            //Only log the link when editor opens.
            if (Time.realtimeSinceStartup < 10f)
            {
                string msg = $"Thank you for using Fish-Networking! If you have any feedback -- be suggestions, documentation, or performance related, let us know through our anonymous Google feedback form!{Environment.NewLine}" + @"<color=#67d419>https://forms.gle/1g13VY4KKMnEqpkp6</color>";
                Debug.Log(msg);
            }
        }
    }
}
#endif﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Editing
{
    /// <summary>
    /// Contributed by YarnCat! Thank you!
    /// </summary>
    public class FishNetGettingStartedEditor : EditorWindow
    {
        private Texture2D _fishnetLogo, _reviewButtonBg, _reviewButtonBgHover;
        private GUIStyle _labelStyle, _reviewButtonStyle;

        private const string SHOWED_GETTING_STARTED = "ShowedFishNetGettingStarted";

        [MenuItem("Tools/Fish-Networking/Getting Started",isValidateFunction: false, 9999)]
        public static void GettingStartedMenu()
        {
            FishNetGettingStartedEditor window = (FishNetGettingStartedEditor)EditorWindow.GetWindow(typeof(FishNetGettingStartedEditor));
            window.position = new(0, 0, 320, 355);
            Rect mainPos;
            mainPos = EditorGUIUtility.GetMainWindowPosition();
            var pos = window.position;
            float w = (mainPos.width - pos.width) * 0.5f;
            float h = (mainPos.height - pos.height) * 0.5f;
            pos.x = mainPos.x + w;
            pos.y = mainPos.y + h;
            window.position = pos;

            window._fishnetLogo = (Texture2D)AssetDatabase.LoadAssetAtPath("Assets/FishNet/Runtime/Editor/Textures/UI/Logo_With_Text.png", typeof(Texture));
            window._labelStyle = new("label");
            window._labelStyle.fontSize = 24;
            window._labelStyle.wordWrap = true;
            //window.labelStyle.alignment = TextAnchor.MiddleCenter;
            window._labelStyle.normal.textColor = new Color32(74, 195, 255, 255);

            window._reviewButtonBg = MakeBackgroundTexture(1, 1, new Color32(52, 111, 255, 255));
            window._reviewButtonBgHover = MakeBackgroundTexture(1, 1, new Color32(99, 153, 255, 255));
            window._reviewButtonStyle = new("button");
            window._reviewButtonStyle.fontSize = 18;
            window._reviewButtonStyle.fontStyle = FontStyle.Bold;
            window._reviewButtonStyle.normal.background = window._reviewButtonBg;
            window._reviewButtonStyle.active.background = window._reviewButtonBgHover;
            window._reviewButtonStyle.focused.background = window._reviewButtonBgHover;
            window._reviewButtonStyle.onFocused.background = window._reviewButtonBgHover;
            window._reviewButtonStyle.hover.background = window._reviewButtonBgHover;
            window._reviewButtonStyle.onHover.background = window._reviewButtonBgHover;
            window._reviewButtonStyle.alignment = TextAnchor.MiddleCenter;
            window._reviewButtonStyle.normal.textColor = new(1, 1, 1, 1);
        }

        internal static bool ShowGettingStarted()
        {
            bool shown = EditorPrefs.GetBool(SHOWED_GETTING_STARTED, false);
            if (!shown)
            {
                EditorPrefs.SetBool(SHOWED_GETTING_STARTED, true);
                ReviewReminderEditor.ResetDateTimeReminded();
                GettingStartedMenu();

                return true;
            }

            return false;
        }

        private void OnGUI()
        {
            GUILayout.Box(_fishnetLogo, GUILayout.Width(this.position.width), GUILayout.Height(128));
            GUILayout.Space(20);

            GUILayout.Label("Have you considered leaving us a review?", _labelStyle, GUILayout.Width(280));

            GUILayout.Space(10);

            if (GUILayout.Button("Leave us a review!", _reviewButtonStyle))
            {
                Application.OpenURL("https://assetstore.unity.com/packages/tools/network/fish-net-networking-evolved-207815");
            }

            GUILayout.Space(20);

            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Documentation", GUILayout.Width(this.position.width * 0.485f)))
            {
                Application.OpenURL("https://fish-networking.gitbook.io/docs/");
            }

            if (GUILayout.Button("Discord", GUILayout.Width(this.position.width * 0.485f)))
            {
                Application.OpenURL("https://discord.gg/Ta9HgDh4Hj");
            }
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("FishNet Pro", GUILayout.Width(this.position.width * 0.485f)))
            {
                Application.OpenURL("https://fish-networking.gitbook.io/docs/master/pro");
            }

            if (GUILayout.Button("Github", GUILayout.Width(this.position.width * 0.485f)))
            {
                Application.OpenURL("https://github.com/FirstGearGames/FishNet");
            }
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Pro Downloads", GUILayout.Width(this.position.width * 0.485f)))
            {
                Application.OpenURL("https://www.firstgeargames.com/");
            }

            //if (GUILayout.Button("Examples", GUILayout.Width(this.position.width * 0.485f)))
            //{
            //    Application.OpenURL("https://fish-networking.gitbook.io/docs/manual/tutorials/example-projects");
            //}
            EditorGUILayout.EndHorizontal();

            //GUILayout.Space(20);
            //_showOnStartupSelected = EditorGUILayout.Popup("Show on Startup", _showOnStartupSelected, showOnStartupOptions);
        }
        //private string[] showOnStartupOptions = new string[] { "Always", "On new version", "Never", };
        //private int _showOnStartupSelected = 1;

        private static Texture2D MakeBackgroundTexture(int width, int height, Color color)
        {
            Color[] pixels = new Color[width * height];
            for (int i = 0; i < pixels.Length; i++)
                pixels[i] = color;
            Texture2D backgroundTexture = new(width, height);
            backgroundTexture.SetPixels(pixels);
            backgroundTexture.Apply();
            return backgroundTexture;
        }
        
    }
}
#endif﻿#if UNITY_EDITOR
using System.Collections.Generic;
using System.Linq;
using FishNet.Editing.PrefabCollectionGenerator;
using FishNet.Object;
using FishNet.Utility.Extension;
using GameKit.Dependencies.Utilities;
using UnityEditor;
using UnityEditor.SceneManagement;
using UnityEngine;
using UnityScene = UnityEngine.SceneManagement.Scene;
using UnitySceneManagement = UnityEngine.SceneManagement;

namespace FishNet.Editing
{
    /// <summary>
    /// Contributed by YarnCat! Thank you!
    /// </summary>
    public class ReserializeNetworkObjectsEditor : EditorWindow
    {
        /// <summary>
        /// True if currently iterating.
        /// </summary>
        [System.NonSerialized]
        internal static bool IsRunning;

        private enum ReserializeSceneType : int
        {
            AllScenes = 0,
            OpenScenes = 1,
            SelectedScenes = 2,
            BuildScenes = 3,
        }

        private struct OpenScene
        {
            public UnityScene Scene;
            public string Path;

            public OpenScene(UnityScene scene)
            {
                Scene = scene;
                Path = scene.path;
            }
        }

        private Texture2D _fishnetLogo;
        private Texture2D _buttonBg;
        private Texture2D _buttonBgHover;
        private GUIStyle _upgradeRequiredStyle;
        private GUIStyle _instructionsStyle;
        private GUIStyle _buttonStyle;

        private bool _loaded;

        private bool _iteratePrefabs;
        private bool _iterateScenes;
        private ReserializeSceneType _sceneReserializeType = ReserializeSceneType.OpenScenes;
        private bool _enabledOnlyBuildScenes = true;

        private const string UPGRADE_PART_COLOR = "cd61ff";
        private const string UPGRADE_COMPLETE_COLOR = "32e66e";
        private const string PREFS_PREFIX = "FishNetReserialize";

        private static ReserializeNetworkObjectsEditor _window;

        [MenuItem("Tools/Fish-Networking/Utility/Reserialize NetworkObjects", false, 400)]
        internal static void ReserializeNetworkObjects()
        {
            if (ApplicationState.IsPlaying())
            {
                Debug.LogError($"NetworkObjects cannot be reserialized while in play mode.");
                return;
            }

            InitializeWindow();
        }

        private static void InitializeWindow()
        {
            if (_window != null)
                return;

            _window = (ReserializeNetworkObjectsEditor)EditorWindow.GetWindow(typeof(ReserializeNetworkObjectsEditor));
            _window.position = new(0f, 0f, 550f, 300f);
            Rect mainPos;
            mainPos = EditorGUIUtility.GetMainWindowPosition();
            Rect pos = _window.position;
            float w = (mainPos.width - pos.width) * 0.5f;
            float h = (mainPos.height - pos.height) * 0.5f;
            pos.x = mainPos.x + w;
            pos.y = mainPos.y + h;
            _window.position = pos;
        }

        private static void StyleWindow()
        {
            if (_window == null)
                return;

            _window._fishnetLogo = (Texture2D)AssetDatabase.LoadAssetAtPath("Assets/FishNet/Runtime/Editor/Textures/UI/Logo_With_Text.png", typeof(Texture));
            _window._upgradeRequiredStyle = new("label");
            _window._upgradeRequiredStyle.fontSize = 20;
            _window._upgradeRequiredStyle.wordWrap = true;
            _window._upgradeRequiredStyle.alignment = TextAnchor.MiddleCenter;
            _window._upgradeRequiredStyle.normal.textColor = new Color32(255, 102, 102, 255);

            _window._instructionsStyle = new("label");
            _window._instructionsStyle.fontSize = 14;
            _window._instructionsStyle.wordWrap = true;
            _window._instructionsStyle.alignment = TextAnchor.MiddleCenter;
            _window._instructionsStyle.normal.textColor = new Color32(255, 255, 255, 255);
            _window._instructionsStyle.hover.textColor = new Color32(255, 255, 255, 255);

            _window._buttonBg = MakeBackgroundTexture(1, 1, new Color32(52, 111, 255, 255));
            _window._buttonBgHover = MakeBackgroundTexture(1, 1, new Color32(99, 153, 255, 255));
            _window._buttonStyle = new("button");
            _window._buttonStyle.fontSize = 18;
            _window._buttonStyle.fontStyle = FontStyle.Bold;
            _window._buttonStyle.normal.background = _window._buttonBg;
            _window._buttonStyle.active.background = _window._buttonBgHover;
            _window._buttonStyle.focused.background = _window._buttonBgHover;
            _window._buttonStyle.onFocused.background = _window._buttonBgHover;
            _window._buttonStyle.hover.background = _window._buttonBgHover;
            _window._buttonStyle.onHover.background = _window._buttonBgHover;
            _window._buttonStyle.alignment = TextAnchor.MiddleCenter;
            _window._buttonStyle.normal.textColor = new(1, 1, 1, 1);
        }

        private void OnGUI()
        {
            //If not yet loaded then set last used values.
            if (!_loaded)
            {
                LoadLastValues();
                _loaded = true;
            }

            float thisWidth = this.position.width;
            StyleWindow();
            //Starting values.
            Vector2 requiredSize = new Vector2(this.position.width, 160f);

            GUILayout.Box(_fishnetLogo, GUILayout.Width(requiredSize.x), GUILayout.Height(requiredSize.y));

            GUILayout.Space(8f);
            EditorGUILayout.BeginHorizontal();
            GUILayout.Space(5f);
            CreateInformationLabel("Use this window to refresh serialized values on all NetworkObject prefabs and scene NetworkObjects.");
            EditorGUILayout.EndHorizontal();
            GUILayout.Space(8f);

            EditorGUILayout.BeginHorizontal();
            GUILayout.Space(30f);
            _iteratePrefabs = EditorGUILayout.Toggle("Reserialize Prefabs", _iteratePrefabs);
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            //Some dumb reason Unity moves the checkbox further when using nested settings.
            float rebuildScenesSpacing = (_iterateScenes) ? 27f : 30f;
            GUILayout.Space(rebuildScenesSpacing);
            EditorGUILayout.BeginVertical();

            _iterateScenes = EditorGUILayout.Toggle("Reserialize Scenes", _iterateScenes);

            if (_iterateScenes)
            {
                EditorGUILayout.BeginHorizontal();
                GUILayout.Space(15f);
                _sceneReserializeType = (ReserializeSceneType)EditorGUILayout.EnumPopup("Targeted Scenes", _sceneReserializeType);
                EditorGUILayout.EndHorizontal();

                requiredSize.y += 20f;

                if (_sceneReserializeType == ReserializeSceneType.BuildScenes)
                {
                    EditorGUILayout.BeginHorizontal();
                    GUILayout.Space(30f);
                    _enabledOnlyBuildScenes = EditorGUILayout.Toggle("Enabled Only", _enabledOnlyBuildScenes);
                    EditorGUILayout.EndHorizontal();
                    requiredSize.y += 18f;
                }

                if (_sceneReserializeType != ReserializeSceneType.OpenScenes)
                {
                    EditorGUILayout.BeginHorizontal();
                    GUILayout.Space(30f);
                    EditorGUILayout.HelpBox("This operation will open and close targeted scene one at a time. Your current open scenes will be closed and re-opened without saving.", MessageType.Warning);
                    EditorGUILayout.EndHorizontal();
                    requiredSize.y += 40f;
                }
            }

            EditorGUILayout.EndVertical();
            EditorGUILayout.EndHorizontal();

            requiredSize.y += 80f;

            GUILayout.Space(8f);

            EditorGUILayout.BeginHorizontal();

            if (!_iteratePrefabs && !_iterateScenes)
                GUI.enabled = false;

            if (GUILayout.Button("Run Task"))
            {
                IsRunning = true;

                SaveLastValues();

                ReserializeProjectPrefabs();
                ReserializeScenes();

                LogColoredText($"Task complete.", UPGRADE_COMPLETE_COLOR);

                _iteratePrefabs = false;
                _iterateScenes = false;

                IsRunning = false;
            }

            GUI.enabled = true;
            EditorGUILayout.EndHorizontal();

            this.minSize = requiredSize;
            this.maxSize = this.minSize;

            void CreateInformationLabel(string text, FontStyle? style = null)
            {
                EditorGUILayout.BeginHorizontal();

                FontStyle firstStyle = _instructionsStyle.fontStyle;
                if (style != null)
                    _instructionsStyle.fontStyle = style.Value;

                GUILayout.Label(text, _instructionsStyle, GUILayout.Width(thisWidth * 0.95f));

                _instructionsStyle.fontStyle = firstStyle;
                EditorGUILayout.EndHorizontal();

                requiredSize.y += 55f;
            }
        }

        private void LoadLastValues()
        {
            _iteratePrefabs = EditorPrefs.GetBool($"{PREFS_PREFIX}{nameof(_iteratePrefabs)}", defaultValue: false);
            _iterateScenes = EditorPrefs.GetBool($"{PREFS_PREFIX}{nameof(_iterateScenes)}", defaultValue: false);
            _sceneReserializeType = (ReserializeSceneType)EditorPrefs.GetInt($"{PREFS_PREFIX}{nameof(_sceneReserializeType)}", defaultValue: (int)ReserializeSceneType.OpenScenes);
            _enabledOnlyBuildScenes = EditorPrefs.GetBool($"{PREFS_PREFIX}{nameof(_enabledOnlyBuildScenes)}", defaultValue: true);
        }

        private void SaveLastValues()
        {
            EditorPrefs.SetBool($"{PREFS_PREFIX}{nameof(_iteratePrefabs)}", _iteratePrefabs);
            EditorPrefs.SetBool($"{PREFS_PREFIX}{nameof(_iterateScenes)}", _iterateScenes);
            EditorPrefs.SetInt($"{PREFS_PREFIX}{nameof(_sceneReserializeType)}", (int)_sceneReserializeType);
            EditorPrefs.SetBool($"{PREFS_PREFIX}{nameof(_enabledOnlyBuildScenes)}", _enabledOnlyBuildScenes);
        }

        private void ReserializeProjectPrefabs()
        {
            if (!_iteratePrefabs)
                return;

            int checkedObjects = 0;
            int duplicateNetworkObjectsRemoved = 0;

            bool modified = false;

            List<NetworkObject> networkObjects = Generator.GetNetworkObjects(settings: null);
            foreach (NetworkObject nob in networkObjects)
            {
                checkedObjects++;
                duplicateNetworkObjectsRemoved += nob.RemoveDuplicateNetworkObjects();

                nob.ReserializeEditorSetValues(setWasActiveDuringEdit: true, setSceneId: false);
                EditorUtility.SetDirty(nob);

                modified = true;
            }

            if (modified)
                AssetDatabase.SaveAssets();

            Debug.Log($"Reserialized {checkedObjects} NetworkObject prefabs. Removed {duplicateNetworkObjectsRemoved} duplicate NetworkObject components.");
        }

        private void ReserializeScenes()
        {
            if (!_iterateScenes)
                return;

            int duplicateNetworkObjectsRemoved = 0;
            int checkedObjects = 0;
            int checkedScenes = 0;
            int changedObjects = 0;

            List<OpenScene> openScenes = GetOpenScenes();

            //If running for open scenes only.
            if (_sceneReserializeType == ReserializeSceneType.OpenScenes)
            {
                ReserializeScenes(openScenes, ref checkedScenes, ref checkedObjects, ref changedObjects, ref duplicateNetworkObjectsRemoved);
            }
            //Running on multiple scenes.
            else
            {
                //When working on multiple scenes make sure open scenes are not dirty to prevent data loss.
                foreach (OpenScene os in openScenes)
                {
                    if (os.Scene.isDirty)
                    {
                        Debug.LogError($"One or more open scenes are dirty. To prevent data loss scene reserialization will not complete. Ensure all open scenes are saved before continuing.");
                        return;
                    }
                }
                List<SceneAsset> targetedScenes;
                if (_sceneReserializeType == ReserializeSceneType.SelectedScenes)
                {
                    targetedScenes = Selection.GetFiltered<SceneAsset>(SelectionMode.Assets).ToList();
                }
                else if (_sceneReserializeType == ReserializeSceneType.AllScenes)
                {
                    targetedScenes = new();

                    string[] scenePaths = Generator.GetProjectFiles("Assets", "unity", new(), recursive: true);
                    foreach (string path in scenePaths)
                    {
                        SceneAsset sceneAsset = AssetDatabase.LoadAssetAtPath<SceneAsset>(path);
                        if (sceneAsset != null)
                            targetedScenes.Add(sceneAsset);
                    }
                }
                else if (_sceneReserializeType == ReserializeSceneType.BuildScenes)
                {
                    targetedScenes = new();

                    EditorBuildSettingsScene[] buildScenes = EditorBuildSettings.scenes;
                    foreach (EditorBuildSettingsScene bs in buildScenes)
                    {
                        if (_enabledOnlyBuildScenes && !bs.enabled)
                            continue;

                        SceneAsset sceneAsset = AssetDatabase.LoadAssetAtPath<SceneAsset>(bs.path);
                        if (sceneAsset != null)
                            targetedScenes.Add(sceneAsset);
                    }
                }
                else
                {
                    Debug.LogError($"Unsupported {nameof(ReserializeSceneType)} type {_sceneReserializeType}.");
                    return;
                }

                ReserializeScenes(targetedScenes, ref checkedScenes, ref checkedObjects, ref changedObjects, ref duplicateNetworkObjectsRemoved);

                //Reopen original scenes.
                for (int i = 0; i < openScenes.Count; i++)
                {
                    string path = openScenes[i].Path;

                    /* Make sure asset exists before trying to reopen scene.
                     * Its possible the dev had a scene open that wasn't saved, which
                     * would otherwise result in an error here. */
                    SceneAsset sceneAsset = AssetDatabase.LoadAssetAtPath<SceneAsset>(path);
                    if (sceneAsset != null)
                    {
                        OpenSceneMode mode = (i == 0) ? OpenSceneMode.Single : OpenSceneMode.Additive;
                        EditorSceneManager.OpenScene(path, mode);
                    }
                }
            }

            if (changedObjects > 0)
                AssetDatabase.SaveAssets();

            string saveText = ((_sceneReserializeType == ReserializeSceneType.OpenScenes) && (changedObjects > 0)) ? " Please save your open scenes." : string.Empty;
            Debug.Log($"Checked {checkedObjects} NetworkObjects over {checkedScenes} scenes. {changedObjects} sceneIds were generated. {duplicateNetworkObjectsRemoved} duplicate NetworkObject components were removed. {saveText}");

            LogColoredText($"Scene NetworkObjects refreshed.", UPGRADE_PART_COLOR);

            List<OpenScene> GetOpenScenes()
            {
                List<OpenScene> result = new();
                int sceneCount = UnitySceneManagement.SceneManager.sceneCount;
                for (int i = 0; i < sceneCount; i++)
                {
                    UnityScene scene = UnitySceneManagement.SceneManager.GetSceneAt(i);
                    if (scene.isLoaded)
                        result.Add(new(scene));
                }

                return result;
            }
        }

        /// <summary>
        /// Refreshes NetworkObjects for specified scenes.
        /// </summary>
        private static void ReserializeScenes(List<SceneAsset> sceneAssets, ref int checkedScenes, ref int checkedObjects, ref int changedObjects, ref int duplicateNetworkObjectsRemoved)
        {
            foreach (SceneAsset sa in sceneAssets)
            {
                string path = AssetDatabase.GetAssetPath(sa);
                UnityScene scene = EditorSceneManager.OpenScene(path, OpenSceneMode.Single);
                List<NetworkObject> foundNobs = NetworkObject.CreateSceneId(scene, force: true, out int changed);

                foreach (NetworkObject n in foundNobs)
                {
                    duplicateNetworkObjectsRemoved += n.RemoveDuplicateNetworkObjects();
                    n.ReserializeEditorSetValues(setWasActiveDuringEdit: true, setSceneId: false);
                }

                EditorSceneManager.SaveScene(scene);

                checkedScenes++;
                checkedObjects += foundNobs.Count;
                changedObjects += changed;
            }
        }

        /// <summary>
        /// Refreshes NetworkObjects in OpenScenes.
        /// </summary>
        private static void ReserializeScenes(List<OpenScene> openScenes, ref int checkedScenes, ref int checkedObjects, ref int changedObjects, ref int duplicateNetworkObjectsRemoved)
        {
            foreach (OpenScene os in openScenes)
            {
                List<NetworkObject> foundNobs = NetworkObject.CreateSceneId(os.Scene, force: true, out int changed);

                foreach (NetworkObject n in foundNobs)
                {
                    duplicateNetworkObjectsRemoved += n.RemoveDuplicateNetworkObjects();
                    n.ReserializeEditorSetValues(setWasActiveDuringEdit: true, setSceneId: false);
                }

                checkedScenes++;
                checkedObjects += foundNobs.Count;
                changedObjects += changed;
            }
        }

        private static void LogColoredText(string txt, string hexColor)
        {
            Debug.Log($"<color=#{hexColor}>{txt}</color>");
        }

        private static Texture2D MakeBackgroundTexture(int width, int height, Color color)
        {
            Color[] pixels = new Color[width * height];
            for (int i = 0; i < pixels.Length; i++)
                pixels[i] = color;
            Texture2D backgroundTexture = new(width, height);
            backgroundTexture.SetPixels(pixels);
            backgroundTexture.Apply();
            return backgroundTexture;
        }
    }
}
#endif﻿#if UNITY_EDITOR
using System;
using FishNet.Configuring;
using UnityEditor;
using UnityEngine;

namespace FishNet.Editing
{

    /// <summary>
    /// Contributed by YarnCat! Thank you!
    /// </summary>
    public class ReviewReminderEditor : EditorWindow
    {
        private Texture2D _fishnetLogo, _reviewButtonBg, _reviewButtonBgHover;
        private GUIStyle _labelStyle, _reviewButtonStyle;

        private const string DATETIME_REMINDED = "ReviewDateTimeReminded";
        private const string CHECK_REMIND_COUNT = "CheckRemindCount";
        private const string IS_ENABLED = "ReminderEnabled";

        private static ReviewReminderEditor _window;

        internal static void CheckRemindToReview()
        {
            bool reminderEnabled = EditorPrefs.GetBool(IS_ENABLED, true);
            if (!reminderEnabled)
                return;

            /* Require at least two opens and 10 days
             * to be passed before reminding. */
            int checkRemindCount = (EditorPrefs.GetInt(CHECK_REMIND_COUNT, 0) + 1);
            EditorPrefs.SetInt(CHECK_REMIND_COUNT, checkRemindCount);
            
            //Not enough checks.
            if (checkRemindCount < 2)
                return;
            
            string dtStr = EditorPrefs.GetString(DATETIME_REMINDED, string.Empty);
            //Somehow got cleared. Reset.
            if (string.IsNullOrWhiteSpace(dtStr))
            {
                ResetDateTimeReminded();
                return;
            }
            long binary;
            //Failed to parse.
            if (!long.TryParse(dtStr, out binary))
            {
                ResetDateTimeReminded();
                return;
            }
            //Not enough time passed.
            DateTime dt = DateTime.FromBinary(binary);
            
            if ((DateTime.Now - dt).TotalDays < 10)
                return;

            //If here then the reminder can be shown.
            EditorPrefs.SetInt(CHECK_REMIND_COUNT, 0);
            ResetDateTimeReminded();
            
            ShowReminder();
        }

        internal static void ResetDateTimeReminded()
        {
            EditorPrefs.SetString(DATETIME_REMINDED, DateTime.Now.ToBinary().ToString());
        }

        private static void ShowReminder()
        {
            InitializeWindow();
        }
      
        private static void InitializeWindow()
        {
            if (_window != null)
                return;
            _window = (ReviewReminderEditor)EditorWindow.GetWindow(typeof(ReviewReminderEditor));
            _window.position = new(0f, 0f, 320f, 300f);
            Rect mainPos;
            mainPos = EditorGUIUtility.GetMainWindowPosition();
            Rect pos = _window.position;
            float w = (mainPos.width - pos.width) * 0.5f;
            float h = (mainPos.height - pos.height) * 0.5f;
            pos.x = mainPos.x + w;
            pos.y = mainPos.y + h;
            _window.position = pos;
        }

        static void StyleWindow()
        {
            InitializeWindow();
            _window._fishnetLogo = (Texture2D)AssetDatabase.LoadAssetAtPath("Assets/FishNet/Runtime/Editor/Textures/UI/Logo_With_Text.png", typeof(Texture));
            _window._labelStyle = new("label");
            _window._labelStyle.fontSize = 24;
            _window._labelStyle.wordWrap = true;
            //window.labelStyle.alignment = TextAnchor.MiddleCenter;
            _window._labelStyle.normal.textColor = new Color32(74, 195, 255, 255);

            _window._reviewButtonBg = MakeBackgroundTexture(1, 1, new Color32(52, 111, 255, 255));
            _window._reviewButtonBgHover = MakeBackgroundTexture(1, 1, new Color32(99, 153, 255, 255));
            _window._reviewButtonStyle = new("button");
            _window._reviewButtonStyle.fontSize = 18;
            _window._reviewButtonStyle.fontStyle = FontStyle.Bold;
            _window._reviewButtonStyle.normal.background = _window._reviewButtonBg;
            _window._reviewButtonStyle.active.background = _window._reviewButtonBgHover;
            _window._reviewButtonStyle.focused.background = _window._reviewButtonBgHover;
            _window._reviewButtonStyle.onFocused.background = _window._reviewButtonBgHover;
            _window._reviewButtonStyle.hover.background = _window._reviewButtonBgHover;
            _window._reviewButtonStyle.onHover.background = _window._reviewButtonBgHover;
            _window._reviewButtonStyle.alignment = TextAnchor.MiddleCenter;
            _window._reviewButtonStyle.normal.textColor = new(1, 1, 1, 1);

        }

        void OnGUI()
        {
            float thisWidth = this.position.width;
            StyleWindow();
            GUILayout.Box(_fishnetLogo, GUILayout.Width(this.position.width), GUILayout.Height(160f));
            EditorGUILayout.BeginHorizontal();
            GUILayout.Space(8f);
            GUILayout.Label("Have you considered leaving us a review?", _labelStyle, GUILayout.Width(thisWidth * 0.95f));
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Don't Ask Again", GUILayout.Width(this.position.width)))
            {
                this.Close();
                EditorPrefs.SetBool(IS_ENABLED, false);
            }
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Ask Later", GUILayout.Width(this.position.width)))
            {
                this.Close();
                //Application.OpenURL("https://discord.gg/Ta9HgDh4Hj");
            }
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("Leave A Review", GUILayout.Width(this.position.width)))
            {
                this.Close();
                EditorPrefs.SetBool(IS_ENABLED, false);
                Application.OpenURL("https://assetstore.unity.com/packages/tools/network/fish-net-networking-evolved-207815");
            }
            EditorGUILayout.EndHorizontal();

            //GUILayout.Space(20);
            //_showOnStartupSelected = EditorGUILayout.Popup("Show on Startup", _showOnStartupSelected, showOnStartupOptions);
        }

        private static Texture2D MakeBackgroundTexture(int width, int height, Color color)
        {
            Color[] pixels = new Color[width * height];
            for (int i = 0; i < pixels.Length; i++)
                pixels[i] = color;
            Texture2D backgroundTexture = new(width, height);
            backgroundTexture.SetPixels(pixels);
            backgroundTexture.Apply();
            return backgroundTexture;
        }
    }

}
#endif﻿#if UNITY_EDITOR

using UnityEngine;
using UnityEditor;
using FishNet.Configuring;

using UnitySettingsProviderAttribute = UnityEditor.SettingsProviderAttribute;
using UnitySettingsProvider = UnityEditor.SettingsProvider;
using System.Collections.Generic;

namespace FishNet.Configuring.Editing
{
    internal static class SettingsProvider
    {
        private static Vector2 _scrollView;

        [UnitySettingsProvider]
        private static UnitySettingsProvider Create()
        {
            return new("Project/Fish-Networking/Configuration", SettingsScope.Project)
            {
                label = "Configuration",

                guiHandler = OnGUI,

                keywords = new string[]
                {
                    "Fish",
                    "Networking",
                    "Configuration",
                },
            };
        }

        private static void OnGUI(string searchContext)
        {
            ConfigurationData configuration = Configuration.LoadConfigurationData();

            if (configuration == null)
            {
                EditorGUILayout.HelpBox("Unable to load configuration data.", MessageType.Error);

                return;
            }

            EditorGUI.BeginChangeCheck();

            GUIStyle scrollViewStyle = new()
            {
                padding = new(10, 10, 10, 10),
            };

            _scrollView = GUILayout.BeginScrollView(_scrollView, scrollViewStyle);

            EditorGUILayout.BeginHorizontal();

            GUIStyle toggleStyle = new(EditorStyles.toggle)
            {
                richText = true,
            };

            configuration.CodeStripping.StripReleaseBuilds = GUILayout.Toggle(configuration.CodeStripping.StripReleaseBuilds, $"{ObjectNames.NicifyVariableName(nameof(configuration.CodeStripping.StripReleaseBuilds))} <color=yellow>(Pro Only)</color>", toggleStyle);

            EditorGUILayout.EndHorizontal();

            if (configuration.CodeStripping.StripReleaseBuilds)
            {
                EditorGUI.indentLevel++;
                //Stripping Method.
                List<string> enumStrings = new();
                foreach (string item in System.Enum.GetNames(typeof(StrippingTypes)))
                    enumStrings.Add(item);
                configuration.CodeStripping.StrippingType = EditorGUILayout.Popup($"{ObjectNames.NicifyVariableName(nameof(configuration.CodeStripping.StrippingType))}", (int)configuration.CodeStripping.StrippingType, enumStrings.ToArray());

                EditorGUILayout.HelpBox("Development builds will not have code stripped. Additionally, if you plan to run as host disable code stripping.", MessageType.Warning);
                EditorGUI.indentLevel--;
            }

            GUILayout.EndScrollView();

            if (EditorGUI.EndChangeCheck()) Configuration.Configurations.Write(true);
        }
    }
}

#endif
#if UNITY_EDITOR
using FishNet.Configuring;
using System;
using System.IO;
using System.Text;
using UnityEditor;
using UnityEngine;
using File = System.IO.File;

namespace FishNet.Editing.NewNetworkBehaviourScript
{
    internal sealed class CreateNewNetworkBehaviour : MonoBehaviour
    {
        private const string TEMPLATE_CLASS_NAME = "NewNetworkBehaviourTemplate";
        public static string TemplatePath => Path.Combine(Configuration.Configurations.CreateNewNetworkBehaviour.templateDirectoryPath, $"{TEMPLATE_CLASS_NAME}.txt");

        [MenuItem("Assets/Create/FishNet/NetworkBehaviour Script", false, -220)]
        private static void CreateNewAsset()
        {
            try
            {
                EnsureTemplateExists();
                ProjectWindowUtil.CreateScriptAssetFromTemplateFile(TemplatePath, $"{TEMPLATE_CLASS_NAME}.cs");
            }
            catch (Exception e)
            {
                Debug.LogError($"An exception occurred while trying to copy the NetworkBehaviour template. {e.Message}");
            }
        }

        public static void EnsureTemplateExists()
        {
            try
            {
                if (!File.Exists(TemplatePath))
                {
                    string fileContent = GetNewTemplateText();
                    File.WriteAllText(TemplatePath, fileContent);
                }
            }
            catch (Exception e)
            {
                Debug.LogError($"An exception occurred while trying to create the NetworkBehaviour template. {e.Message}");
            }
        }

        private static string GetNewTemplateText()
        {
            StringBuilder sb = new();
            sb.AppendLine("using UnityEngine;");
            sb.AppendLine("using FishNet.Object;");
            sb.AppendLine();
            sb.AppendLine("public class NewNetworkBehaviourTemplate : NetworkBehaviour");
            sb.AppendLine("{");
            sb.AppendLine("     private void Awake() { }");
            sb.AppendLine();
            sb.AppendLine("     private void Update() { }");
            sb.AppendLine("}");

            return sb.ToString();
        }
    }
    
}
#endif#if UNITY_EDITOR

using UnityEditor;
using UnityEngine;
using UnitySettingsProviderAttribute = UnityEditor.SettingsProviderAttribute;
using UnitySettingsProvider = UnityEditor.SettingsProvider;
using FishNet.Configuring;
using System.IO;
using System;
using System.Text.RegularExpressions;

namespace FishNet.Editing.NewNetworkBehaviourScript
{
    internal static class SettingsProvider
    {
        private static CreateNewNetworkBehaviourConfigurations _settings;
        private static GUIContent _folderIcon;
        private static readonly Regex SlashRegex = new(@"[\\//]");

        [UnitySettingsProvider]
        private static UnitySettingsProvider Create()
        {
            return new("Project/Fish-Networking/New NetworkBehaviour Template", SettingsScope.Project)
            {
                label = "New NetworkBehaviour Template",

                guiHandler = OnGUI,

                keywords = new string[]
                {
                    "Fish",
                    "Networking",
                    "CreateNewNetworkBehaviour",
                    "Template"
                },
            };
        }

        private static void OnGUI(string searchContext)
        {
            if (_settings == null)
                _settings = Configuration.Configurations.CreateNewNetworkBehaviour;

            if (_folderIcon == null)
                _folderIcon = EditorGUIUtility.IconContent("d_FolderOpened Icon");

            EditorGUI.BeginChangeCheck();

            GUILayoutOption iconWidthConstraint = GUILayout.MaxWidth(32.0f);
            GUILayoutOption iconHeightConstraint = GUILayout.MaxHeight(EditorGUIUtility.singleLineHeight);

            if (GUILayout.Button("Edit template"))
            {
                CreateNewNetworkBehaviour.EnsureTemplateExists();
                
                try
                {
                    System.Diagnostics.Process.Start(CreateNewNetworkBehaviour.TemplatePath);
                }
                catch (Exception e)
                {
                    Debug.LogError($"An issue occurred while trying to launch the NetworkBehaviour template. {e.Message}");
                }
            }
            GUILayout.Space(20);
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label("Template directory: ", GUILayout.MaxWidth(150));
            string newDirectoryPath;

            newDirectoryPath = EditorGUILayout.DelayedTextField(_settings.templateDirectoryPath, GUILayout.MaxWidth(600));
            if (newDirectoryPath.StartsWith("Assets") && Directory.Exists(newDirectoryPath))
            {
                _settings.templateDirectoryPath = newDirectoryPath;
            }
            else
            {
                EditorWindow.focusedWindow.ShowNotification(new($"Directory must be inside the Assets folder."), 2);
            }


            if (GUILayout.Button(_folderIcon, iconHeightConstraint, iconWidthConstraint))
            {
                newDirectoryPath = EditorUtility.OpenFolderPanel("Select template directory", _settings.templateDirectoryPath, "");
            }
            if (newDirectoryPath.StartsWith(Application.dataPath, StringComparison.OrdinalIgnoreCase))
            {
                newDirectoryPath = SlashRegex.Replace(newDirectoryPath.Remove(0, Path.GetDirectoryName(Application.dataPath).Length + 1), Path.DirectorySeparatorChar.ToString());
                _settings.templateDirectoryPath = newDirectoryPath;
            }
            else if (!newDirectoryPath.StartsWith(Application.dataPath, StringComparison.OrdinalIgnoreCase) && !newDirectoryPath.StartsWith("Assets"))
            {
                EditorWindow.focusedWindow.ShowNotification(new($"Directory must be inside the Assets folder."), 2);
            }

            EditorGUILayout.EndHorizontal();

//            EditorGUILayout.HelpBox("By default MonoBehaviour script template will be copied", MessageType.Info);
            if (EditorGUI.EndChangeCheck())
                Configuration.Configurations.Write(true);
        }
    }
}
#endif﻿#if UNITY_EDITOR
using FishNet.Configuring;
using FishNet.Managing;
using FishNet.Managing.Object;
using FishNet.Object;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using UnityEditor;
using UnityEngine;
using UnityDebug = UnityEngine.Debug;

namespace FishNet.Editing.PrefabCollectionGenerator
{
    internal sealed class Generator : AssetPostprocessor
    {
        public Generator()
        {
            if (!_subscribed)
            {
                _subscribed = true;
                EditorApplication.update += OnEditorUpdate;
            }
        }

        ~Generator()
        {
            if (_subscribed)
            {
                _subscribed = false;
                EditorApplication.update -= OnEditorUpdate;
            }
        }

        #region Types.
        internal readonly struct SpecifiedFolder
        {
            public readonly string Path;
            public readonly bool Recursive;

            public SpecifiedFolder(string path, bool recursive)
            {
                Path = path;
                Recursive = recursive;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// True to ignore post process changes.
        /// </summary>
        public static bool IgnorePostProcess = false;
        #endregion

        #region Private.
        /// <summary>
        /// Last asset to import when there was only one imported asset and no other changes.
        /// </summary>
        private static string _lastSingleImportedAsset = string.Empty;
        /// <summary>
        /// Cached DefaultPrefabObjects reference.
        /// </summary>
        private static DefaultPrefabObjects _cachedDefaultPrefabs;
        /// <summary>
        /// True to refresh prefabs next update.
        /// </summary>
        private static bool _retryRefreshDefaultPrefabs;
        /// <summary>
        /// True if already subscribed to EditorApplication.Update.
        /// </summary>
        private static bool _subscribed;
        /// <summary>
        /// True if ran once since editor started.
        /// </summary>
        [System.NonSerialized]
        private static bool _ranOnce;
        /// <summary>
        /// Last paths of updated nobs during a changed update.
        /// </summary>
        [System.NonSerialized]
        private static List<string> _lastUpdatedNamePaths = new();
        /// <summary>
        /// Last frame changed was updated.
        /// </summary>
        [System.NonSerialized]
        private static int _lastUpdatedFrame = -1;
        /// <summary>
        /// Length of assets strings during the last update.
        /// </summary>
        [System.NonSerialized]
        private static int _lastUpdatedLengths = -1;
        #endregion

        internal static string[] GetProjectFiles(string startingPath, string fileExtension, List<string> excludedPaths, bool recursive)
        {
            //Opportunity to exit early if there are no excluded paths.
            if (excludedPaths.Count == 0)
            {
                string[] strResults = Directory.GetFiles(startingPath, $"*{fileExtension}", SearchOption.AllDirectories);
                return strResults;
            }
            //starting path is excluded.
            if (excludedPaths.Contains(startingPath))
                return new string[0];

            //Folders remaining to be iterated.
            List<string> enumeratedCollection = new() { startingPath };
            //Only check other directories if recursive.
            if (recursive)
            {
                //Find all folders which aren't excluded.
                for (int i = 0; i < enumeratedCollection.Count; i++)
                {
                    string[] allFolders = Directory.GetDirectories(enumeratedCollection[i], "*", SearchOption.TopDirectoryOnly);
                    for (int z = 0; z < allFolders.Length; z++)
                    {
                        string current = allFolders[z];
                        //Not excluded.
                        if (!excludedPaths.Contains(current))
                            enumeratedCollection.Add(current);
                    }
                }
            }

            //Valid prefab files.
            List<string> results = new();
            //Build files from folders.
            int count = enumeratedCollection.Count;
            for (int i = 0; i < count; i++)
            {
                string[] r = Directory.GetFiles(enumeratedCollection[i], "*.prefab", SearchOption.TopDirectoryOnly);
                results.AddRange(r);
            }

            return results.ToArray();
        }

        /// <summary>
        /// Returns a message to attach to logs if objects were dirtied.
        /// </summary>
        private static string GetDirtiedMessage(PrefabGeneratorConfigurations settings, bool dirtied)
        {
            if (!settings.SaveChanges && dirtied)
                return " One or more NetworkObjects were dirtied. Please save your project.";
            else
                return string.Empty;
        }

        /// <summary>
        /// Updates prefabs by using only changed information.
        /// </summary>
        public static void GenerateChanged(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths, PrefabGeneratorConfigurations settings = null)
        {
#if PARRELSYNC
            if (ParrelSync.ClonesManager.IsClone() && ParrelSync.Preferences.AssetModPref.Value)
            {
                UnityDebug.Log("Skipping prefab generation in ParrelSync clone");
                return;
            }
#endif

            //Do not run if the reserializer is currently running.
            if (ReserializeNetworkObjectsEditor.IsRunning)
                return;

            if (settings == null)
                settings = Configuration.Configurations.PrefabGenerator;
            if (!settings.Enabled)
                return;

            bool log = settings.LogToConsole;
            Stopwatch sw = (log) ? Stopwatch.StartNew() : null;

            DefaultPrefabObjects prefabCollection = GetDefaultPrefabObjects(settings);
            //No need to error if nto found, GetDefaultPrefabObjects will.
            if (prefabCollection == null)
                return;

            int assetsLength = (importedAssets.Length + deletedAssets.Length + movedAssets.Length + movedFromAssetPaths.Length);
            List<string> changedNobPaths = new();

            System.Type goType = typeof(UnityEngine.GameObject);
            IterateAssetCollection(importedAssets);
            IterateAssetCollection(movedAssets);

            //True if dirtied by changes.
            bool dirtied;
            //First remove null entries.
            int startCount = prefabCollection.GetObjectCount();
            prefabCollection.RemoveNull();
            dirtied = (prefabCollection.GetObjectCount() != startCount);
            //First index which new objects will be added to.
            int firstAddIndex = (prefabCollection.GetObjectCount() - 1);

            //Iterates strings adding prefabs to collection.
            void IterateAssetCollection(string[] c)
            {
                foreach (string item in c)
                {
                    System.Type assetType = AssetDatabase.GetMainAssetTypeAtPath(item);
                    if (assetType != goType)
                        continue;

                    NetworkObject nob = AssetDatabase.LoadAssetAtPath<NetworkObject>(item);
                    if (CanAddNetworkObject(nob, settings))
                    {
                        changedNobPaths.Add(item);
                        prefabCollection.AddObject(nob, true);
                        dirtied = true;
                    }
                }
            }

            //To prevent out of range.
            if (firstAddIndex < 0 || firstAddIndex >= prefabCollection.GetObjectCount())
                firstAddIndex = 0;
            dirtied |= prefabCollection.SetAssetPathHashes(firstAddIndex);

            if (log && dirtied)
                UnityDebug.Log($"Default prefab generator updated prefabs in {sw.ElapsedMilliseconds}ms.{GetDirtiedMessage(settings, dirtied)}");

            //Check for redundancy.
            int frameCount = Time.frameCount;
            int changedCount = changedNobPaths.Count;
            if (frameCount == _lastUpdatedFrame && assetsLength == _lastUpdatedLengths && (changedCount == _lastUpdatedNamePaths.Count) && changedCount > 0)
            {
                bool allMatch = true;
                for (int i = 0; i < changedCount; i++)
                {
                    if (changedNobPaths[i] != _lastUpdatedNamePaths[i])
                    {
                        allMatch = false;
                        break;
                    }
                }

                /* If the import results are the same as the last attempt, on the same frame
                 * then there is likely an issue saving the assets. */
                if (allMatch)
                {
                    //Unset dirtied to prevent a save.
                    dirtied = false;
                    //Log this no matter what, it's critical.
                    UnityDebug.LogError($"Default prefab generator had a problem saving one or more assets. " + $"This usually occurs when the assets cannot be saved due to missing scripts or serialization errors. " + $"Please see above any prefabs which could not save any make corrections.");
                }
            }
            //Set last values.
            _lastUpdatedFrame = Time.frameCount;
            _lastUpdatedNamePaths = changedNobPaths;
            _lastUpdatedLengths = assetsLength;

            EditorUtility.SetDirty(prefabCollection);
            if (dirtied && settings.SaveChanges)
                AssetDatabase.SaveAssets();
        }

        /// <summary>
        /// Gets NetworkObjects from folders using settings.
        /// </summary>
        internal static List<NetworkObject> GetNetworkObjects(PrefabGeneratorConfigurations settings = null)
        {
            List<SpecifiedFolder> folders = GetSpecifiedFolders(settings);
            if (folders == null)
                return new();
            
            return GetNetworkObjects(folders, settings);
        }

        /// <summary>
        /// Gets specified folders to check for prefab generation. This may include excluded paths. Null is returned on error.
        /// </summary>
        internal static List<SpecifiedFolder> GetSpecifiedFolders(PrefabGeneratorConfigurations settings = null)
        {
            settings = GetSettingsIfNull(settings);

            List<string> folderStrs;

            if (settings.SearchScope == (int)SearchScopeType.EntireProject)
            {
                folderStrs = new List<string>();
                folderStrs.Add("Assets*");
            }
            else if (settings.SearchScope == (int)SearchScopeType.SpecificFolders)
            {
                folderStrs = settings.IncludedFolders.ToList();
            }
            else
            {
                UnityDebug.LogError($"{settings.SearchScope} is not handled; folder paths cannot be found.");
                return null;
            }

            return GetSpecifiedFolders(folderStrs);
        }
        
        
        /// <summary>
        /// Gets all NetworkObjects in specified folders while ignoring any excluded paths.
        /// </summary>
        internal static List<NetworkObject> GetNetworkObjects(SpecifiedFolder specifiedFolder, PrefabGeneratorConfigurations settings = null)
        {
            List<string> excludedPaths = GetSettingsIfNull(settings).ExcludedFolders;
            
            List<NetworkObject> foundNobs = new();
            
            foreach (string path in GetProjectFiles(specifiedFolder.Path, "prefab", excludedPaths, specifiedFolder.Recursive))
            {
                NetworkObject nob = AssetDatabase.LoadAssetAtPath<NetworkObject>(path);
                if (CanAddNetworkObject(nob, settings))
                    foundNobs.Add(nob);
            }

            return foundNobs;
        }
        
        /// <summary>
        /// Gets all NetworkObjects in specified folders while ignoring any excluded paths.
        /// </summary>
        internal static List<NetworkObject> GetNetworkObjects(List<SpecifiedFolder> specifiedFolders, PrefabGeneratorConfigurations settings = null)
        {
            List<NetworkObject> foundNobs = new();

            foreach (SpecifiedFolder sf in specifiedFolders)
                foundNobs.AddRange(GetNetworkObjects(sf, settings));

            return foundNobs;
        }


        /// <summary>
        /// Generates prefabs by iterating all files within settings parameters.
        /// </summary>
        public static void GenerateFull(PrefabGeneratorConfigurations settings = null, bool forced = false, bool initializeAdded = true)
        {
#if PARRELSYNC
            if (ParrelSync.ClonesManager.IsClone() && ParrelSync.Preferences.AssetModPref.Value)
            {
                UnityDebug.Log("Skipping prefab generation in ParrelSync clone");
                return;
            }
#endif
            //Do not run if the reserializer is currently running.
            if (ReserializeNetworkObjectsEditor.IsRunning)
            {
                UnityDebug.LogError($"Cannot generate default prefabs when ReserializeNetworkObjectsEditor is running");
                return;
            }

            settings = GetSettingsIfNull(settings);
     
            if (!forced && !settings.Enabled)
                return;
            
            bool log = settings.LogToConsole;

            Stopwatch sw = (log) ? Stopwatch.StartNew() : null;
            
            DefaultPrefabObjects prefabCollection = GetDefaultPrefabObjects(settings);
            //No need to error if not found, GetDefaultPrefabObjects will throw.
            if (prefabCollection == null)
                return;
            
            List<NetworkObject> foundNobs = GetNetworkObjects(settings);
            
            //Clear and add built list.
            prefabCollection.Clear();
            prefabCollection.AddObjects(foundNobs, checkForDuplicates: false, initializeAdded);
            bool dirtied = prefabCollection.SetAssetPathHashes(0);

            int newCount = prefabCollection.GetObjectCount();
            if (log)
            {
                string dirtiedMessage = (newCount > 0) ? GetDirtiedMessage(settings, dirtied) : string.Empty;
                UnityDebug.Log($"Default prefab generator found {newCount} prefabs in {sw.ElapsedMilliseconds}ms.{dirtiedMessage}");
            }
            //Only set dirty if and save if prefabs were found.
            if (newCount > 0)
            {
                EditorUtility.SetDirty(prefabCollection);
                if (settings.SaveChanges)
                    AssetDatabase.SaveAssets();
            }
        }

        /// <summary>
        /// Returns settings parameter if not null, otherwise returns settings from configuration.
        /// </summary>
        internal static PrefabGeneratorConfigurations GetSettingsIfNull(PrefabGeneratorConfigurations settings) => (settings == null) ? Configuration.Configurations.PrefabGenerator : settings;

        /// <summary>
        /// Iterates folders building them into SpecifiedFolders.
        /// </summary>
        internal static List<SpecifiedFolder> GetSpecifiedFolders(List<string> strFolders)
        {
            List<SpecifiedFolder> results = new();
            //Remove astericks.
            foreach (string path in strFolders)
            {
                int pLength = path.Length;
                if (pLength == 0)
                    continue;

                bool recursive;
                string p;
                //If the last character indicates resursive.
                if (path.Substring(pLength - 1, 1) == "*")
                {
                    p = path.Substring(0, pLength - 1);
                    recursive = true;
                }
                else
                {
                    p = path;
                    recursive = false;
                }

                p = GetPlatformPath(p);

                //Path does not exist.
                if (!Directory.Exists(p))
                    continue;

                results.Add(new(p, recursive));
            }


            RemoveOverlappingFolders(results);

            return results;

            //Removes paths which may overlap each other, such as sub directories.
            static void RemoveOverlappingFolders(List<SpecifiedFolder> specifiedFolders)
            {
                for (int z = 0; z < specifiedFolders.Count; z++)
                {
                    for (int i = 0; i < specifiedFolders.Count; i++)
                    {
                        //Do not check against self.
                        if (i == z)
                            continue;

                        //Duplicate.
                        if (specifiedFolders[z].Path.Equals(specifiedFolders[i].Path, System.StringComparison.OrdinalIgnoreCase))
                        {
                            UnityDebug.LogError($"The same path is specified multiple times in the DefaultPrefabGenerator settings. Remove the duplicate to clear this error.");
                            specifiedFolders.RemoveAt(i);
                            break;
                        }

                        /* We are checking if i can be within
                         * z. This is only possible if i is longer
                         * than z. */
                        if (specifiedFolders[i].Path.Length < specifiedFolders[z].Path.Length)
                            continue;
                        /* Do not need to check if not recursive.
                         * Only recursive needs to be checked because
                         * a shorter recursive path could contain
                         * a longer path. */
                        if (!specifiedFolders[z].Recursive)
                            continue;

                        //Compare paths.
                        string zPath = GetPathWithSeparator(specifiedFolders[z].Path);
                        string iPath = zPath.Substring(0, zPath.Length);
                        //If paths match.
                        if (iPath.Equals(zPath, System.StringComparison.OrdinalIgnoreCase))
                        {
                            UnityDebug.LogError($"Path {specifiedFolders[i].Path} is included within recursive path {specifiedFolders[z].Path}. Remove path {specifiedFolders[i].Path} to clear this error.");
                            specifiedFolders.RemoveAt(i);
                            break;
                        }
                    }
                }

                string GetPathWithSeparator(string txt)
                {
                    return txt.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar) + Path.DirectorySeparatorChar;
                }
            }
        }

        internal static string GetPlatformPath(string path)
        {
            if (string.IsNullOrEmpty(path))
                return path;

            path = path.Replace(@"\"[0], Path.DirectorySeparatorChar);
            path = path.Replace(@"/"[0], Path.DirectorySeparatorChar);
            return path;
        }

        /// <summary>
        /// Returns the DefaultPrefabObjects file.
        /// </summary>
        internal static DefaultPrefabObjects GetDefaultPrefabObjects(PrefabGeneratorConfigurations settings = null)
        {
            if (settings == null)
                settings = Configuration.Configurations.PrefabGenerator;

            //If not using default prefabs then exit early.
            if (!settings.Enabled)
                return null;

            //Load the prefab collection 
            string defaultPrefabsPath = settings.DefaultPrefabObjectsPath_Platform;
            string fullDefaultPrefabsPath = (defaultPrefabsPath.Length > 0) ? Path.GetFullPath(defaultPrefabsPath) : string.Empty;

            //If cached prefabs is not the same path as assetPath.
            if (_cachedDefaultPrefabs != null)
            {
                string unityAssetPath = AssetDatabase.GetAssetPath(_cachedDefaultPrefabs);
                string fullCachedPath = (unityAssetPath.Length > 0) ? Path.GetFullPath(unityAssetPath) : string.Empty;
                if (fullCachedPath != fullDefaultPrefabsPath)
                    _cachedDefaultPrefabs = null;
            }

            //If cached is null try to get it.
            if (_cachedDefaultPrefabs == null)
            {
                //Only try to load it if file exist.
                if (File.Exists(fullDefaultPrefabsPath))
                {
                    _cachedDefaultPrefabs = AssetDatabase.LoadAssetAtPath<DefaultPrefabObjects>(defaultPrefabsPath);
                    if (_cachedDefaultPrefabs == null)
                    {
                        //If already retried then throw an error.
                        if (_retryRefreshDefaultPrefabs)
                        {
                            UnityDebug.LogError("DefaultPrefabObjects file exists but it could not be loaded by Unity. Use the Fish-Networking menu -> Utility -> Refresh Default Prefabs to refresh prefabs.");
                        }
                        else
                        {
                            UnityDebug.Log("DefaultPrefabObjects file exists but it could not be loaded by Unity. Trying to reload the file next frame.");
                            _retryRefreshDefaultPrefabs = true;
                        }
                        return null;
                    }
                }
            }

#if PARRELSYNC
            if (!ParrelSync.ClonesManager.IsClone() && ParrelSync.Preferences.AssetModPref.Value)
            {
#endif
            if (_cachedDefaultPrefabs == null)
            {
                string fullPath = Path.GetFullPath(defaultPrefabsPath);
                UnityDebug.Log($"Creating a new DefaultPrefabsObject at {fullPath}.");
                string directory = Path.GetDirectoryName(fullPath);

                if (!Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                    AssetDatabase.Refresh();
                }

                _cachedDefaultPrefabs = ScriptableObject.CreateInstance<DefaultPrefabObjects>();
                AssetDatabase.CreateAsset(_cachedDefaultPrefabs, defaultPrefabsPath);
                AssetDatabase.SaveAssets();
            }
#if PARRELSYNC
            }
#endif

            if (_cachedDefaultPrefabs != null && _retryRefreshDefaultPrefabs)
                UnityDebug.Log("DefaultPrefabObjects found on the second iteration.");
            return _cachedDefaultPrefabs;
        }

        /// <summary>
        /// Called every frame the editor updates.
        /// </summary>
        private static void OnEditorUpdate()
        {
            if (!_retryRefreshDefaultPrefabs)
                return;

            GenerateFull();
            _retryRefreshDefaultPrefabs = false;
        }

        /// <summary>
        /// Called by Unity when assets are modified.
        /// </summary>
        private static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
        {
            if (Application.isPlaying)
                return;
            //If retrying next frame don't bother updating, next frame will do a full refresh.
            if (_retryRefreshDefaultPrefabs)
                return;
            //Post process is being ignored. Could be temporary or user has disabled this feature.
            if (IgnorePostProcess)
                return;
            /* Don't iterate if updating or compiling as that could cause an infinite loop
             * due to the prefabs being generated during an update, which causes the update
             * to start over, which causes the generator to run again, which... you get the idea. */
            if (EditorApplication.isCompiling)
                return;

            DefaultPrefabObjects prefabCollection = GetDefaultPrefabObjects();
            if (prefabCollection == null)
                return;
            PrefabGeneratorConfigurations settings = Configuration.Configurations.PrefabGenerator;

            if (prefabCollection.GetObjectCount() == 0)
            {
                //If there are no prefabs then do a full rebuild. Odds of there being none are pretty much nill.
                GenerateFull(settings);
            }
            else
            {
                int totalChanges = importedAssets.Length + deletedAssets.Length + movedAssets.Length + movedFromAssetPaths.Length;
                //Nothing has changed. This shouldn't occur but unity is funny so we're going to check anyway.
                if (totalChanges == 0)
                    return;

                //Normalizes path.
                string dpoPath = Path.GetFullPath(settings.DefaultPrefabObjectsPath_Platform);
                //If total changes is 1 and the only changed file is the default prefab collection then do nothing.
                if (totalChanges == 1)
                {
                    //Do not need to check movedFromAssetPaths because that's not possible for this check.
                    if ((importedAssets.Length == 1 && Path.GetFullPath(importedAssets[0]) == dpoPath) || (deletedAssets.Length == 1 && Path.GetFullPath(deletedAssets[0]) == dpoPath) || (movedAssets.Length == 1 && Path.GetFullPath(movedAssets[0]) == dpoPath))
                        return;

                    /* If the only change is an import then check if the imported file
                     * is the same as the last, and if so check into returning early.
                     * For some reason occasionally when files are saved unity runs postprocess
                     * multiple times on the same file. */
                    string imported = (importedAssets.Length == 1) ? importedAssets[0] : null;
                    if (imported != null && imported == _lastSingleImportedAsset)
                    {
                        //If here then the file is the same. Make sure it's already in the collection before returning.
                        System.Type assetType = AssetDatabase.GetMainAssetTypeAtPath(imported);
                        //Not a gameObject, no reason to continue.
                        if (assetType != typeof(GameObject))
                            return;

                        NetworkObject nob = AssetDatabase.LoadAssetAtPath<NetworkObject>(imported);
                        //If is a networked object.
                        if (CanAddNetworkObject(nob, settings))
                        {
                            //Already added!
                            if (prefabCollection.Prefabs.Contains(nob))
                                return;
                        }
                    }
                    else if (imported != null)
                    {
                        _lastSingleImportedAsset = imported;
                    }
                }


                bool fullRebuild = settings.FullRebuild;
                /* If updating FN. This needs to be done a better way.
                 * Parsing the actual version file would be better.
                 * I'll get to it next release. */
                if (!_ranOnce)
                {
                    _ranOnce = true;
                    fullRebuild = true;
                }
                //Other conditions which a full rebuild may be required.
                else if (!fullRebuild)
                {
                    const string fishnetVersionSave = "fishnet_version";
                    string savedVersion = EditorPrefs.GetString(fishnetVersionSave, string.Empty);
                    if (savedVersion != NetworkManager.FISHNET_VERSION)
                    {
                        fullRebuild = true;
                        EditorPrefs.SetString(fishnetVersionSave, NetworkManager.FISHNET_VERSION);
                    }
                }

                if (fullRebuild)
                    GenerateFull(settings);
                else
                    GenerateChanged(importedAssets, deletedAssets, movedAssets, movedFromAssetPaths, settings);
            }
        }

        /// <summary>
        /// Returns true if a NetworkObject can be added to DefaultPrefabs.
        /// </summary>
        private static bool CanAddNetworkObject(NetworkObject networkObject, PrefabGeneratorConfigurations settings)
        {
            settings = GetSettingsIfNull(settings);
            return networkObject != null && (networkObject.GetIsSpawnable() || !settings.SpawnableOnly);
        }
    }
}

#endif﻿#if UNITY_EDITOR

using System;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEngine;

using UnitySettingsProviderAttribute = UnityEditor.SettingsProviderAttribute;
using UnitySettingsProvider = UnityEditor.SettingsProvider;
using FishNet.Configuring;
using System.Linq;

namespace FishNet.Editing.PrefabCollectionGenerator
{
    internal static class SettingsProvider
    {
        private static readonly Regex SlashRegex = new(@"[\\//]");

        private static PrefabGeneratorConfigurations _settings;

        private static GUIContent _folderIcon;
        private static GUIContent _deleteIcon;

        private static Vector2 _scrollVector;

        private static bool _showFolders;

        [UnitySettingsProvider]
        private static UnitySettingsProvider Create()
        {
            return new("Project/Fish-Networking/Prefab Objects Generator", SettingsScope.Project)
            {
                label = "Prefab Objects Generator",

                guiHandler = OnGUI,

                keywords = new string[]
                {
                    "Fish",
                    "Networking",
                    "Prefab",
                    "Objects",
                    "Generator",
                },
            };
        }

        private static void OnGUI(string searchContext)
        {
            if (_settings == null)
                _settings = Configuration.Configurations.PrefabGenerator;
            if (_folderIcon == null)
                _folderIcon = EditorGUIUtility.IconContent("d_FolderOpened Icon");
            if (_deleteIcon == null)
                _deleteIcon = EditorGUIUtility.IconContent("P4_DeletedLocal");

            EditorGUI.BeginChangeCheck();
            GUIStyle scrollViewStyle = new()
            {
                padding = new(10, 10, 10, 10),
            };

            _scrollVector = EditorGUILayout.BeginScrollView(_scrollVector, scrollViewStyle);

            _settings.Enabled = EditorGUILayout.Toggle(ObjectNames.NicifyVariableName(nameof(_settings.Enabled)), _settings.Enabled);
            _settings.LogToConsole = EditorGUILayout.Toggle(ObjectNames.NicifyVariableName(nameof(_settings.LogToConsole)), _settings.LogToConsole);
            _settings.FullRebuild = EditorGUILayout.Toggle(ObjectNames.NicifyVariableName(nameof(_settings.FullRebuild)), _settings.FullRebuild);
            _settings.SpawnableOnly = EditorGUILayout.Toggle(ObjectNames.NicifyVariableName(nameof(_settings.SpawnableOnly)), _settings.SpawnableOnly);
            _settings.SaveChanges = EditorGUILayout.Toggle(ObjectNames.NicifyVariableName(nameof(_settings.SaveChanges)), _settings.SaveChanges);

            GUILayoutOption iconWidthConstraint = GUILayout.MaxWidth(32.0f);
            GUILayoutOption iconHeightConstraint = GUILayout.MaxHeight(EditorGUIUtility.singleLineHeight);

            EditorGUILayout.BeginHorizontal();

            string oldAssetPath = _settings.DefaultPrefabObjectsPath;
            string newAssetPath = EditorGUILayout.DelayedTextField(ObjectNames.NicifyVariableName(nameof(_settings.DefaultPrefabObjectsPath)), oldAssetPath);

            if (GUILayout.Button(_folderIcon, iconWidthConstraint, iconHeightConstraint))
            {
                if (TrySaveFilePathInsideAssetsFolder(null, Application.dataPath, "DefaultPrefabObjects", "asset", out string result))
                    newAssetPath = result;
                else
                    EditorWindow.focusedWindow.ShowNotification(new($"{ObjectNames.NicifyVariableName(nameof(_settings.DefaultPrefabObjectsPath))} must be inside the Assets folder."));
            }

            if (!newAssetPath.Equals(oldAssetPath, StringComparison.OrdinalIgnoreCase))
            {
                if (newAssetPath.StartsWith($"Assets{Path.DirectorySeparatorChar}", StringComparison.OrdinalIgnoreCase))
                {
                    if (File.Exists(newAssetPath))
                    {
                        EditorWindow.focusedWindow.ShowNotification(new("Another asset already exists at the new path."));
                    }
                    else
                    {
                        Generator.IgnorePostProcess = true;

                        if (File.Exists(oldAssetPath))
                            AssetDatabase.MoveAsset(oldAssetPath, newAssetPath);
                        _settings.DefaultPrefabObjectsPath = newAssetPath;

                        Generator.IgnorePostProcess = false;
                    }
                }
                else
                {
                    EditorWindow.focusedWindow.ShowNotification(new($"{ObjectNames.NicifyVariableName(nameof(_settings.DefaultPrefabObjectsPath))} must be inside the Assets folder."));
                }
            }

            EditorGUILayout.EndHorizontal();

            int currentSearchScope = _settings.SearchScope;
            SearchScopeType searchScopeType = (SearchScopeType)EditorGUILayout.EnumPopup(ValueToSearchScope(_settings.SearchScope));
            _settings.SearchScope = (int)searchScopeType;
            SearchScopeType ValueToSearchScope(int value) => (SearchScopeType)value;
            if (_settings.SearchScope == (int)SearchScopeType.EntireProject)
            {
                EditorGUILayout.HelpBox("Searching the entire project for prefabs can become very slow. Consider switching the search scope to specific folders instead.", MessageType.Warning);

                if (GUILayout.Button("Switch"))
                    _settings.SearchScope = (int)SearchScopeType.SpecificFolders;
            }
            //If search scope changed then update prefabs.
            if (currentSearchScope != _settings.SearchScope && (SearchScopeType)_settings.SearchScope == SearchScopeType.EntireProject)
                Generator.GenerateFull();

            List<string> folders = null;
            string foldersName = null;

            if (_settings.SearchScope == (int)SearchScopeType.EntireProject)
            {
                folders = _settings.ExcludedFolders;
                foldersName = ObjectNames.NicifyVariableName(nameof(_settings.ExcludedFolders));
            }
            else if (_settings.SearchScope == (int)SearchScopeType.SpecificFolders)
            {
                folders = _settings.IncludedFolders;
                foldersName = ObjectNames.NicifyVariableName(nameof(_settings.IncludedFolders));
            }

            string folderName = foldersName.Substring(0, foldersName.Length - 1);

            if ((_showFolders = EditorGUILayout.Foldout(_showFolders, $"{foldersName} ({folders.Count})")) && folders != null)
            {
                EditorGUI.indentLevel++;

                for (int i = 0; i < folders.Count; i++)
                {
                    EditorGUILayout.BeginHorizontal();

                    string oldFolder = folders[i];
                    string newFolder = SlashRegex.Replace(EditorGUILayout.DelayedTextField(oldFolder), Path.DirectorySeparatorChar.ToString());
                    if (!newFolder.Equals(oldFolder, StringComparison.OrdinalIgnoreCase))
                    {
                        if (newFolder.StartsWith($"Assets{Path.DirectorySeparatorChar}", StringComparison.OrdinalIgnoreCase))
                            folders[i] = newFolder;
                        else
                            EditorWindow.focusedWindow.ShowNotification(new($"{folderName} must be inside the Assets folder."));
                    }

                    if (GUILayout.Button(_folderIcon, iconWidthConstraint, iconHeightConstraint))
                    {
                        if (TryOpenFolderPathInsideAssetsFolder(null, Application.dataPath, null, out string result))
                            folders[i] = result;
                        else
                            EditorWindow.focusedWindow.ShowNotification(new($"{folderName} must be inside the Assets folder."));
                    }

                    if (GUILayout.Button(_deleteIcon, iconWidthConstraint, iconHeightConstraint)) folders.RemoveAt(i);

                    EditorGUILayout.EndHorizontal();
                }

                EditorGUI.indentLevel--;

                if (_settings.SearchScope == (int)SearchScopeType.SpecificFolders) EditorGUILayout.HelpBox("You can include subfolders by appending an asterisk (*) to a path.", MessageType.None);

                if (GUILayout.Button("Browse"))
                {
                    if (TryOpenFolderPathInsideAssetsFolder(null, Application.dataPath, null, out string result))
                    {
                        folders.Add(result);
                    }
                    else
                    {
                        EditorWindow.focusedWindow.ShowNotification(new($"{folderName} must be inside the Assets folder."));
                    }
                }
            }

            if (EditorGUI.EndChangeCheck())
                Configuration.Configurations.Write(true);
            if (GUILayout.Button("Generate"))
                Generator.GenerateFull();

            EditorGUILayout.HelpBox("Consider pressing 'Generate' after changing the settings.", MessageType.Info);

            EditorGUILayout.EndScrollView();
        }

        private static bool TrySaveFilePathInsideAssetsFolder(string title, string directory, string name, string extension, out string result)
        {
            result = null;

            string selectedPath = EditorUtility.SaveFilePanel(title, directory, name, extension);

            if (selectedPath.StartsWith(Application.dataPath, StringComparison.OrdinalIgnoreCase))
            {
                result = SlashRegex.Replace(selectedPath.Remove(0, Path.GetDirectoryName(Application.dataPath).Length + 1), Path.DirectorySeparatorChar.ToString());

                return true;
            }

            return false;
        }

        private static bool TryOpenFolderPathInsideAssetsFolder(string title, string folder, string name, out string result)
        {
            result = null;

            string selectedPath = EditorUtility.OpenFolderPanel(title, folder, name);

            if (selectedPath.StartsWith(Application.dataPath, StringComparison.OrdinalIgnoreCase))
            {
                result = SlashRegex.Replace(selectedPath.Remove(0, Path.GetDirectoryName(Application.dataPath).Length + 1), Path.DirectorySeparatorChar.ToString());

                return true;
            }

            return false;
        }
    }
}

#endif﻿//Remove V5#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.Component.Transforming;
using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing.Logging;
using FishNet.Managing.Server;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Utility;
using FishNet.Utility.Performance;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using FishNet.Managing;
using UnityEngine;
using TimeManagerCls = FishNet.Managing.Timing.TimeManager;

namespace FishNet.Component.Animating
{
    [AddComponentMenu("FishNet/Component/NetworkAnimator")]
    public sealed class NetworkAnimator : NetworkBehaviour
    {
        #region Types.
        /// <summary>
        /// Data received from the server.
        /// </summary>
        private struct ReceivedServerData
        {
            /// <summary>
            /// Gets an Arraysegment of received data.
            /// </summary>
            public ArraySegment<byte> GetArraySegment() => new(_data, 0, _length);
            /// <summary>
            /// How much data written.
            /// </summary>
            private int _length;
            /// <summary>
            /// Buffer which contains data.
            /// </summary>
            private byte[] _data;

            public ReceivedServerData(ArraySegment<byte> segment)
            {
                _length = segment.Count;
                _data = ByteArrayPool.Retrieve(_length);
                Buffer.BlockCopy(segment.Array, segment.Offset, _data, 0, _length);
            }

            public void Dispose()
            {
                if (_data != null)
                    ByteArrayPool.Store(_data);
            }
        }
        private struct StateChange
        {
            /// <summary>
            /// Frame which the state was changed.
            /// </summary>
            public int FrameCount;
            /// <summary>
            /// True if a crossfade.
            /// </summary>
            public bool IsCrossfade;
            /// <summary>
            /// Hash to crossfade into.
            /// </summary>  
            public int Hash;
            /// <summary>
            /// True if using FixedTime.
            /// </summary>
            public bool FixedTime;
            /// <summary>
            /// Duration of crossfade.
            /// </summary>
            public float DurationTime;
            /// <summary>
            /// Offset time of crossfade.
            /// </summary>
            public float OffsetTime;
            /// <summary>
            /// Normalized transition time of crossfade.
            /// </summary>
            public float NormalizedTransitionTime;

            public StateChange(int frame)
            {
                FrameCount = frame;
                IsCrossfade = default;
                Hash = default;
                FixedTime = default;
                DurationTime = default;
                OffsetTime = default;
                NormalizedTransitionTime = default;
            }

            public StateChange(int frame, int hash, bool fixedTime, float duration, float offset, float normalizedTransition)
            {
                FrameCount = frame;
                IsCrossfade = true;
                Hash = hash;
                FixedTime = fixedTime;
                DurationTime = duration;
                OffsetTime = offset;
                NormalizedTransitionTime = normalizedTransition;
            }
        }
        /// <summary>
        /// Animator updates received from clients when using Client Authoritative.
        /// </summary>
        private class ClientAuthoritativeUpdate
        {
            /// <summary>
            /// 
            /// </summary>
            public ClientAuthoritativeUpdate()
            {
                //Start buffers off at 8 bytes nad grow them as needed.
                for (int i = 0; i < MAXIMUM_BUFFER_COUNT; i++)
                    _buffers.Add(new byte[MAXIMUM_DATA_SIZE]);

                _bufferLengths = new int[MAXIMUM_BUFFER_COUNT];
            }

            #region Public.
            /// <summary>
            /// True to force all animator data and ignore buffers.
            /// </summary>
            public bool ForceAll { get; private set; }
            /// <summary>
            /// Number of entries in Buffers.
            /// </summary>
            public int BufferCount = 0;
            #endregion

            #region Private.
            /// <summary>
            /// Length of buffers.
            /// </summary>
            private int[] _bufferLengths;
            /// <summary>
            /// Buffers.
            /// </summary>
            private List<byte[]> _buffers = new();
            #endregion

            #region Const.
            /// <summary>
            /// Maximum size data may be.
            /// </summary>
            private const int MAXIMUM_DATA_SIZE = 1000;
            /// <summary>
            /// Maximum number of allowed buffers.
            /// </summary>
            public const int MAXIMUM_BUFFER_COUNT = 2;
            #endregion

            public void AddToBuffer(ref ArraySegment<byte> data)
            {
                int dataCount = data.Count;
                /* Data will never get this large, it's quite impossible.
                 * Just ignore the data if it does, client is likely performing
                 * an attack. */
                if (dataCount > MAXIMUM_DATA_SIZE)
                    return;

                //If index exceeds buffer count.
                if (BufferCount >= MAXIMUM_BUFFER_COUNT)
                {
                    ForceAll = true;
                    return;
                }

                /* If here, can write to buffer. */
                byte[] buffer = _buffers[BufferCount];
                Buffer.BlockCopy(data.Array, data.Offset, buffer, 0, dataCount);
                _bufferLengths[BufferCount] = dataCount;
                BufferCount++;
            }

            /// <summary>
            /// Sets referenced data to buffer and it's length for index.
            /// </summary>
            /// <param name="index"></param>
            /// <param name="buffer"></param>
            /// <param name="length"></param>
            public void GetBuffer(int index, ref byte[] buffer, ref int length)
            {
                if (index > _buffers.Count)
                {
                    NetworkManagerExtensions.LogWarning("Index exceeds Buffers count.");
                    return;
                }
                if (index > _bufferLengths.Length)
                {
                    NetworkManagerExtensions.LogWarning("Index exceeds BufferLengths count.");
                    return;
                }

                buffer = _buffers[index];
                length = _bufferLengths[index];
            }
            /// <summary>
            /// Resets buffers.
            /// </summary>
            public void Reset()
            {
                BufferCount = 0;
                ForceAll = false;
            }

        }
        /// <summary>
        /// Information on how to smooth to a float value.
        /// </summary>
        private struct SmoothedFloat
        {
            public SmoothedFloat(float rate, float target)
            {
                Rate = rate;
                Target = target;
            }

            public readonly float Rate;
            public readonly float Target;
        }

        /// <summary>
        /// Details about a trigger update.
        /// </summary>
        private struct TriggerUpdate
        {
            public byte ParameterIndex;
            public bool Setting;

            public TriggerUpdate(byte parameterIndex, bool setting)
            {
                ParameterIndex = parameterIndex;
                Setting = setting;
            }
        }
        /// <summary>
        /// Details about an animator parameter.
        /// </summary>
        private class ParameterDetail
        {
            /// <summary>
            /// Parameter information.
            /// </summary>
            public readonly AnimatorControllerParameter ControllerParameter = null;
            /// <summary>
            /// Index within the types collection for this parameters value. The exception is with triggers; if the parameter type is a trigger then a value of 1 is set, 0 is unset.
            /// </summary>
            public readonly byte TypeIndex = 0;
            /// <summary>
            /// Hash for the animator string.
            /// </summary>
            public readonly int Hash;

            public ParameterDetail(AnimatorControllerParameter controllerParameter, byte typeIndex)
            {
                ControllerParameter = controllerParameter;
                TypeIndex = typeIndex;
                Hash = controllerParameter.nameHash;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Parameters which will not be synchronized.
        /// </summary>
        [SerializeField, HideInInspector]
        internal List<string> IgnoredParameters = new();
        #endregion

        #region Serialized.
        /// <summary>
        /// The animator component to synchronize.
        /// </summary>
        [Tooltip("The animator component to synchronize.")]
        [SerializeField]
        private Animator _animator;
        /// <summary>
        /// The animator component to synchronize.
        /// </summary>
        public Animator Animator { get { return _animator; } }
        /// <summary>
        /// True to synchronize changes even when the animator component is disabled.
        /// </summary>
        [Tooltip("True to synchronize changes even when the animator component is disabled.")]
        [SerializeField]
        private bool _synchronizeWhenDisabled;
        /// <summary>
        /// True to smooth float value changes for spectators.
        /// </summary>
        [Tooltip("True to smooth float value changes for spectators.")]
        [SerializeField]
        private bool _smoothFloats = true;
        /// <summary>
        /// How many ticks to interpolate.
        /// </summary>
        [Tooltip("How many ticks to interpolate.")]
        [Range(1, NetworkTransform.MAX_INTERPOLATION)]
        [SerializeField]
        private ushort _interpolation = 2;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True if using client authoritative animations.")]
        [SerializeField]
        private bool _clientAuthoritative = true;
        /// <summary>
        /// True if using client authoritative animations.
        /// </summary>
        public bool ClientAuthoritative { get { return _clientAuthoritative; } }
        /// <summary>
        /// True to synchronize server results back to owner. Typically used when you are changing animations on the server and are relying on the server response to update the clients animations.
        /// </summary>
        [Tooltip("True to synchronize server results back to owner. Typically used when you are changing animations on the server and are relying on the server response to update the clients animations.")]
        [SerializeField]
        private bool _sendToOwner;
        #endregion

        #region Private.
        /// <summary>
        /// All parameter values, excluding triggers.
        /// </summary>
        private readonly List<ParameterDetail> _parameterDetails = new();
        /// <summary>
        /// Last int values.
        /// </summary>
        private readonly List<int> _ints = new();
        /// <summary>
        /// Last float values.
        /// </summary>
        private readonly List<float> _floats = new();
        /// <summary>
        /// Last bool values.
        /// </summary>
        private readonly List<bool> _bools = new();
        /// <summary>
        /// Last layer weights.
        /// </summary>
        private float[] _layerWeights;
        /// <summary>
        /// Last speed.
        /// </summary>
        private float _speed;
        /// <summary>
        /// Trigger values set by using SetTrigger and ResetTrigger.
        /// </summary>
        private readonly List<TriggerUpdate> _triggerUpdates = new();
        // /// <summary>
        // /// Updates going to clients.
        // /// </summary>
        // private List<byte[]> _toClientsBuffer = new();
        /// <summary>
        /// Returns if the animator is exist and can be synchronized.
        /// </summary>
        private bool _canSynchronizeAnimator
        {
            get
            {
                if (!_isAnimatorSet)
                    return false;

                if (_animator.enabled || _synchronizeWhenDisabled)
                    return true;

                return false;
            }
        }
        /// <summary>
        /// True if the animator is valid but not enabled.
        /// </summary>
        private bool _isAnimatorSet
        {
            get
            {
                bool failedChecks = (_animator == null || _animator.runtimeAnimatorController == null);
                return !failedChecks;
            }
        }
        /// <summary>
        /// Float valeus to smooth towards.
        /// </summary>
        private Dictionary<int, SmoothedFloat> _smoothedFloats = new();
        /// <summary>
        /// Returns if floats can be smoothed for this client.
        /// </summary>
        private bool _canSmoothFloats
        {
            get
            {
                //Don't smooth on server only.
                if (!base.IsClientStarted)
                    return false;
                //Smoothing is disabled.
                if (!_smoothFloats)
                    return false;
                //No reason to smooth for self.
                if (base.IsOwner && ClientAuthoritative)
                    return false;

                //Fall through.
                return true;
            }
        }
        /// <summary>
        /// Layers which need to have their state synchronized. Key is the layer, Value is the state change information.
        /// </summary>
        private Dictionary<int, StateChange> _unsynchronizedLayerStates = new();
        /// <summary>
        /// Last animator set.
        /// </summary>
        private Animator _lastAnimator;
        /// <summary>
        /// Last Controller set.
        /// </summary>
        private RuntimeAnimatorController _lastController;
        /// <summary>
        /// PooledWriter for this animator.
        /// </summary>
        private PooledWriter _writer = new();
        /// <summary>
        /// Holds client authoritative updates received to send to other clients.
        /// </summary>
        private ClientAuthoritativeUpdate _clientAuthoritativeUpdates;
        /// <summary>
        /// True to forceAll next timed send.
        /// </summary>
        private bool _forceAllOnTimed;
        /// <summary>
        /// Animations received which should be applied.
        /// </summary>
        private Queue<ReceivedServerData> _fromServerBuffer = new();
        /// <summary>
        /// Tick when the buffer may begin to run.
        /// </summary>
        private uint _startTick = TimeManagerCls.UNSET_TICK;
        /// <summary>
        /// True if subscribed to TimeManager for ticks.
        /// </summary>
        private bool _subscribedToTicks;
        #endregion

        #region Const.
        ///// <summary>
        ///// How much time to fall behind when using smoothing. Only increase value if the smoothing is sometimes jittery. Recommended values are between 0 and 0.04.
        ///// </summary>
        //private const float INTERPOLATION = 0.02f;
        /// <summary>
        /// ParameterDetails index which indicates a layer weight change.
        /// </summary>
        private const byte LAYER_WEIGHT = 240;
        /// <summary>
        /// ParameterDetails index which indicates an animator speed change.
        /// </summary>
        private const byte SPEED = 241;
        /// <summary>
        /// ParameterDetails index which indicates a layer state change.
        /// </summary>
        private const byte STATE = 242;
        /// <summary>
        /// ParameterDetails index which indicates a crossfade change.
        /// </summary>
        private const byte CROSSFADE = 243;
        #endregion

        private void Awake()
        {
            InitializeOnce();
        }

        private void OnDestroy()
        {
            ChangeTickSubscription(false);
        }

        [APIExclude]
        public override void OnSpawnServer(NetworkConnection connection)
        {
            if (!_canSynchronizeAnimator)
                return;
            if (AnimatorUpdated(out ArraySegment<byte> updatedBytes, true))
                TargetAnimatorUpdated(connection, updatedBytes);
        }

        public override void OnStartNetwork()
        {
            ChangeTickSubscription(true);
        }

        [APIExclude]
        public override void OnStartServer()
        {
            //If using client authoritative then initialize clientAuthoritativeUpdates.
            if (_clientAuthoritative)
            {
                _clientAuthoritativeUpdates = new();
                // //Expand to clients buffer count to however many buffers can be held.
                // for (int i = 0; i < ClientAuthoritativeUpdate.MAXIMUM_BUFFER_COUNT; i++)
                //     _toClientsBuffer.Add(new byte[0]);
            }
            // else
            // {
            //     _toClientsBuffer.Add(new byte[0]);
            // }
        }
        
        public override void OnStartClient()
        {
            base.TimeManager.OnUpdate += TimeManager_OnUpdate;
        }

        public override void OnStopClient()
        {
            if (base.TimeManager != null)
                base.TimeManager.OnUpdate -= TimeManager_OnUpdate;
        }

        public override void OnStopNetwork()
        {
            _unsynchronizedLayerStates.Clear();
            ChangeTickSubscription(false);
        }

        /// <summary>
        /// Tries to subscribe to TimeManager ticks.
        /// </summary>
        private void ChangeTickSubscription(bool subscribe)
        {
            if (subscribe == _subscribedToTicks || base.NetworkManager == null)
                return;

            _subscribedToTicks = subscribe;
            if (subscribe)
            {
                base.NetworkManager.TimeManager.OnPreTick += TimeManager_OnPreTick;
                base.NetworkManager.TimeManager.OnPostTick += TimeManager_OnPostTick;
            }
            else
            {
                base.NetworkManager.TimeManager.OnPreTick -= TimeManager_OnPreTick;
                base.NetworkManager.TimeManager.OnPostTick -= TimeManager_OnPostTick;
            }
        }



        /// <summary>
        /// Called right before a tick occurs, as well before data is read.
        /// </summary>
        private void TimeManager_OnPreTick()
        {
            if (!_canSynchronizeAnimator)
            {
                _fromServerBuffer.Clear();
                return;
            }
            //Disabled/cannot start.
            if (_startTick == 0)
                return;
            //Nothing in queue.
            if (_fromServerBuffer.Count == 0)
            {
                _startTick = 0;
                return;
            }
            //Not enough time has passed to start queue.
            if (base.TimeManager.LocalTick < _startTick)
                return;

            ReceivedServerData rd = _fromServerBuffer.Dequeue();
            ArraySegment<byte> segment = rd.GetArraySegment();
            ApplyParametersUpdated(ref segment);
            rd.Dispose();
        }


        /* Use post tick values are checked after
         * client has an opportunity to use OnTick. */
        /// <summary>
        /// Called after a tick occurs; physics would have simulated if using PhysicsMode.TimeManager.
        /// </summary>
        
        private void TimeManager_OnPostTick()
        {
            //One check rather than per each method.
            if (!_canSynchronizeAnimator)
                return;

            CheckSendToServer();
            CheckSendToClients();
        }

        private void TimeManager_OnUpdate()
        {
            if (!_canSynchronizeAnimator)
                return;

            if (base.IsClientStarted)
                SmoothFloats();
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        private void InitializeOnce()
        {
            if (_animator == null)
                _animator = GetComponent<Animator>();

            //Don't run the rest if not in play mode.
            if (!ApplicationState.IsPlaying())
                return;

            if (!_canSynchronizeAnimator)
            {
                //Debug.LogWarning("Animator is null or not enabled; unable to initialize for animator. Use SetAnimator if animator was changed or enable the animator.");
                return;
            }

            //Speed.
            _speed = _animator.speed;

            //Build layer weights.
            _layerWeights = new float[_animator.layerCount];
            for (int i = 0; i < _layerWeights.Length; i++)
                _layerWeights[i] = _animator.GetLayerWeight(i);

            _parameterDetails.Clear();
            _bools.Clear();
            _floats.Clear();
            _ints.Clear();
            //Create a parameter detail for each parameter that can be synchronized.
            foreach (AnimatorControllerParameter item in _animator.parameters)
            {
                bool process = !_animator.IsParameterControlledByCurve(item.name);
                
                if (process)
                {
                    //Over 250 parameters; who would do this!?
                    if (_parameterDetails.Count == 240)
                    {
                        base.NetworkManager.LogError($"Parameter {item.name} exceeds the allowed 240 parameter count and is being ignored.");
                        continue;
                    }

                    int typeIndex = 0;
                    //Bools.
                    if (item.type == AnimatorControllerParameterType.Bool)
                    {
                        typeIndex = _bools.Count;
                        _bools.Add(_animator.GetBool(item.nameHash));
                    }
                    //Floats.
                    else if (item.type == AnimatorControllerParameterType.Float)
                    {
                        typeIndex = _floats.Count;
                        _floats.Add(_animator.GetFloat(item.name));
                    }
                    //Ints.
                    else if (item.type == AnimatorControllerParameterType.Int)
                    {
                        typeIndex = _ints.Count;
                        _ints.Add(_animator.GetInteger(item.nameHash));
                    }
                    //Triggers.
                    else if (item.type == AnimatorControllerParameterType.Trigger)
                    {
                        /* Triggers aren't persistent so they don't use stored values
                         * but I do need to make a parameter detail to track the hash. */
                        typeIndex = -1;
                    }

                    _parameterDetails.Add(new(item, (byte)typeIndex));
                }
            }
        }

        /// <summary>
        /// Sets which animator to use. You must call this with the appropriate animator on all clients and server. This change is not automatically synchronized.
        /// </summary>
        /// <param name="animator"></param>
        public void SetAnimator(Animator animator)
        {
            //No update required.
            if (animator == _lastAnimator)
                return;

            _animator = animator;
            InitializeOnce();
            _lastAnimator = animator;
        }

        /// <summary>
        /// Sets which controller to use. You must call this with the appropriate controller on all clients and server. This change is not automatically synchronized.
        /// </summary>
        /// <param name="controller"></param>        
        public void SetController(RuntimeAnimatorController controller)
        {
            //No update required.
            if (controller == _lastController)
                return;

            _animator.runtimeAnimatorController = controller;
            InitializeOnce();
            _lastController = controller;
        }

        /// <summary>
        /// Checks to send animator data from server to clients.
        /// </summary>
        private void CheckSendToServer()
        {
            //Cannot send to server if is server or not client.
            if (base.IsServerStarted || !base.IsClientInitialized)
                return;
            //Cannot send to server if not client authoritative or don't have authority.
            if (!ClientAuthoritative || !base.IsOwner)
                return;

            /* If there are updated parameters to send.
             * Don't really need to worry about mtu here
             * because there's no way the sent bytes are
             * ever going to come close to the mtu
             * when sending a single update. */
            if (AnimatorUpdated(out ArraySegment<byte> updatedBytes, _forceAllOnTimed))
                ServerAnimatorUpdated(updatedBytes);

            _forceAllOnTimed = false;
        }

        /// <summary>
        /// Checks to send animator data from server to clients.
        /// </summary>
        private void CheckSendToClients()
        {
            //Cannot send to clients if not server initialized.
            if (!base.IsServerInitialized)
                return;

            bool sendFromServer;
            //If client authoritative.
            if (ClientAuthoritative)
            {
                //If has no owner then use latest values on server.
                if (!base.Owner.IsValid)
                {
                    sendFromServer = true;
                }
                //If has a owner.
                else
                {
                    //If is owner then send latest values on server.
                    if (base.IsOwner)
                    {
                        sendFromServer = true;
                    }
                    //Not owner.
                    else
                    {
                        //Haven't received any data from clients, cannot send yet.
                        if (_clientAuthoritativeUpdates.BufferCount == 0)
                        {
                            return;
                        }
                        //Data was received from client; check eligibility to send it.
                        else
                        {
                            /* If forceAll is true then the latest values on
                             * server must be used, rather than what was received
                             * from client. This can occur if the client is possibly
                             * trying to use an attack or if the client is
                             * excessively sending updates. To prevent relaying that
                             * same data to others the server will send it's current
                             * animator settings in this scenario. */
                            if (_clientAuthoritativeUpdates.ForceAll)
                            {
                                sendFromServer = true;
                                _clientAuthoritativeUpdates.Reset();
                            }
                            else
                            {
                                sendFromServer = false;
                            }
                        }
                    }
                }
            }
            //Not client authoritative, always send from server.
            else
            {
                sendFromServer = true;
            }

            /* If client authoritative then use what was received from clients
             * if data exist. */
            if (!sendFromServer)
            {
                byte[] buffer = null;
                int bufferLength = 0;
                for (int i = 0; i < _clientAuthoritativeUpdates.BufferCount; i++)
                {
                    _clientAuthoritativeUpdates.GetBuffer(i, ref buffer, ref bufferLength);

                    //If null was returned then something went wrong.
                    if (buffer == null || bufferLength == 0)
                        continue;

                    SendSegment(new(buffer, 0, bufferLength));
                }
                //Reset client auth buffer.
                _clientAuthoritativeUpdates.Reset();
            }
            //Sending from server, send what's changed.
            else
            {
                if (AnimatorUpdated(out ArraySegment<byte> updatedBytes, _forceAllOnTimed))
                    SendSegment(updatedBytes);

                _forceAllOnTimed = false;
            }

            //Sends segment to clients
            void SendSegment(ArraySegment<byte> data)
            {
                foreach (NetworkConnection nc in base.Observers)
                {
                    //If to not send to owner.
                    if (!_sendToOwner && nc == base.Owner)
                        continue;
                    TargetAnimatorUpdated(nc, data);
                }
            }
        }


        /// <summary>
        /// Smooths floats on clients.
        /// </summary>
        private void SmoothFloats()
        {
            //Don't need to smooth on authoritative client.
            if (!_canSmoothFloats)
                return;
            //Nothing to smooth.
            if (_smoothedFloats.Count == 0)
                return;

            float deltaTime = Time.deltaTime;

            List<int> finishedEntries = new();

            /* Cycle through each target float and move towards it.
                * Once at a target float mark it to be removed from floatTargets. */
            foreach (KeyValuePair<int, SmoothedFloat> item in _smoothedFloats)
            {
                float current = _animator.GetFloat(item.Key);
                float next = Mathf.MoveTowards(current, item.Value.Target, item.Value.Rate * deltaTime);
                _animator.SetFloat(item.Key, next);

                if (next == item.Value.Target)
                    finishedEntries.Add(item.Key);
            }

            //Remove finished entries from dictionary.
            for (int i = 0; i < finishedEntries.Count; i++)
                _smoothedFloats.Remove(finishedEntries[i]);
        }

        /// <summary>
        /// Returns if animator is updated and bytes of updated values.
        /// </summary>
        /// <returns></returns>
        private bool AnimatorUpdated(out ArraySegment<byte> updatedBytes, bool forceAll = false)
        {
            updatedBytes = default;
            //Something isn't setup right.
            if (_layerWeights == null)
                return false;
            //Reset the writer.
            _writer.Clear();

            /* Every time a parameter is updated a byte is added
             * for it's index, this is why requiredBytes increases
             * by 1 when a value updates. ChangedParameter contains
             * the index updated and the new value. The requiresBytes
             * is increased also by however many bytes are required
             * for the type which has changed. Some types use special parameter
             * detail indexes, such as layer weights; these can be found under const. */
            for (byte parameterIndex = 0; parameterIndex < _parameterDetails.Count; parameterIndex++)
            {
                ParameterDetail pd = _parameterDetails[parameterIndex];
                /* Bool. */
                if (pd.ControllerParameter.type == AnimatorControllerParameterType.Bool)
                {
                    bool next = _animator.GetBool(pd.Hash);
                    //If changed.
                    if (forceAll || _bools[pd.TypeIndex] != next)
                    {
                        _writer.WriteUInt8Unpacked(parameterIndex);
                        _writer.WriteBoolean(next);
                        _bools[pd.TypeIndex] = next;
                    }
                }
                /* Float. */
                else if (pd.ControllerParameter.type == AnimatorControllerParameterType.Float)
                {
                    float next = _animator.GetFloat(pd.Hash);
                    //If changed.
                    if (forceAll || _floats[pd.TypeIndex] != next)
                    {
                        _writer.WriteUInt8Unpacked(parameterIndex);
                        _writer.WriteSingle(next);
                        _floats[pd.TypeIndex] = next;
                    }
                }
                /* Int. */
                else if (pd.ControllerParameter.type == AnimatorControllerParameterType.Int)
                {
                    int next = _animator.GetInteger(pd.Hash);
                    //If changed.
                    if (forceAll || _ints[pd.TypeIndex] != next)
                    {
                        _writer.WriteUInt8Unpacked(parameterIndex);
                        _writer.WriteInt32(next);
                        _ints[pd.TypeIndex] = next;
                    }
                }
            }

            /* Don't need to force trigger sends since
             * they're one-shots. */
            for (int i = 0; i < _triggerUpdates.Count; i++)
            {
                _writer.WriteUInt8Unpacked(_triggerUpdates[i].ParameterIndex);
                _writer.WriteBoolean(_triggerUpdates[i].Setting);
            }
            _triggerUpdates.Clear();

            /* States. */
            if (forceAll)
            {
                //Add all layers to layer states.
                for (int i = 0; i < _animator.layerCount; i++)
                    _unsynchronizedLayerStates[i] = new(Time.frameCount);
            }

            /* Only iterate if the collection has values. This is to avoid some
             * unnecessary caching when collection is empty. */
            if (_unsynchronizedLayerStates.Count > 0)
            {
                int frameCount = Time.frameCount;
                List<int> sentLayers = CollectionCaches<int>.RetrieveList();
                //Go through each layer which needs to be synchronized.
                foreach (KeyValuePair<int, StateChange> item in _unsynchronizedLayerStates)
                {
                    /* If a frame has not passed since the state was created
                     * then do not send it until next tick. State changes take 1 frame
                     * to be processed by Unity, this check ensures that. */
                    if (frameCount == item.Value.FrameCount)
                        continue;

                    //Add to layers being sent. This is so they can be removed from the collection later.
                    sentLayers.Add(item.Key);
                    int layerIndex = item.Key;
                    StateChange sc = item.Value;
                    //If a regular state change.
                    if (!sc.IsCrossfade)
                    {
                        if (ReturnCurrentLayerState(out int stateHash, out float normalizedTime, layerIndex))
                        {
                            _writer.WriteUInt8Unpacked(STATE);
                            _writer.WriteUInt8Unpacked((byte)layerIndex);
                            //Current hash will always be too large to compress.
                            _writer.WriteInt32Unpacked(stateHash);
                            _writer.WriteSingle(normalizedTime);
                        }
                    }
                    //When it's a crossfade then send crossfade data.
                    else
                    {
                        _writer.WriteUInt8Unpacked(CROSSFADE);
                        _writer.WriteUInt8Unpacked((byte)layerIndex);
                        //Current hash will always be too large to compress.
                        _writer.WriteInt32(sc.Hash);
                        _writer.WriteBoolean(sc.FixedTime);
                        //Times usually can be compressed.
                        _writer.WriteSingle(sc.DurationTime);
                        _writer.WriteSingle(sc.OffsetTime);
                        _writer.WriteSingle(sc.NormalizedTransitionTime);
                    }
                }

                if (sentLayers.Count > 0)
                {
                    for (int i = 0; i < sentLayers.Count; i++)
                        _unsynchronizedLayerStates.Remove(sentLayers[i]);
                    //Store cache.
                    CollectionCaches<int>.Store(sentLayers);
                }
            }

            /* Layer weights. */
            for (int layerIndex = 0; layerIndex < _layerWeights.Length; layerIndex++)
            {
                float next = _animator.GetLayerWeight(layerIndex);
                if (forceAll || _layerWeights[layerIndex] != next)
                {
                    _writer.WriteUInt8Unpacked(LAYER_WEIGHT);
                    _writer.WriteUInt8Unpacked((byte)layerIndex);
                    _writer.WriteSingle(next);
                    _layerWeights[layerIndex] = next;
                }
            }

            /* Speed is similar to layer weights but we don't need the index,
             * only the indicator and value. */
            float speedNext = _animator.speed;
            if (forceAll || _speed != speedNext)
            {
                _writer.WriteUInt8Unpacked(SPEED);
                _writer.WriteSingle(speedNext);
                _speed = speedNext;
            }

            //Nothing to update.
            if (_writer.Position == 0)
            {
                return false;
            }
            else
            {
                updatedBytes = _writer.GetArraySegment();
                return true;
            }
        }

        /// <summary>
        /// Applies changed parameters to the animator.
        /// </summary>
        /// <param name="changedParameters"></param>
        private void ApplyParametersUpdated(ref ArraySegment<byte> updatedParameters)
        {
            if (!_canSynchronizeAnimator)
                return;
            if (_layerWeights == null)
                return;
            if (updatedParameters.Count == 0)
                return;

            PooledReader reader = ReaderPool.Retrieve(updatedParameters, base.NetworkManager);

            try
            {
                while (reader.Remaining > 0)
                {
                    byte parameterIndex = reader.ReadUInt8Unpacked();
                    //Layer weight
                    if (parameterIndex == LAYER_WEIGHT)
                    {
                        byte layerIndex = reader.ReadUInt8Unpacked();
                        float value = reader.ReadSingle();
                        _animator.SetLayerWeight((int)layerIndex, value);
                    }
                    //Speed.
                    else if (parameterIndex == SPEED)
                    {
                        float value = reader.ReadSingle();
                        _animator.speed = value;
                    }
                    //State.
                    else if (parameterIndex == STATE)
                    {
                        byte layerIndex = reader.ReadUInt8Unpacked();
                        //Hashes will always be too large to compress.
                        int hash = reader.ReadInt32Unpacked();
                        float normalizedTime = reader.ReadSingle();
                        //Play results.
                        _animator.Play(hash, layerIndex, normalizedTime);
                    }
                    //Crossfade.
                    else if (parameterIndex == CROSSFADE)
                    {
                        byte layerIndex = reader.ReadUInt8Unpacked();
                        //Hashes will always be too large to compress.
                        int hash = reader.ReadInt32();
                        bool useFixedTime = reader.ReadBoolean();
                        //Get time values.
                        float durationTime = reader.ReadSingle();
                        float offsetTime = reader.ReadSingle();
                        float normalizedTransitionTime = reader.ReadSingle();
                        //If using fixed.
                        if (useFixedTime)
                            _animator.CrossFadeInFixedTime(hash, durationTime, layerIndex, offsetTime, normalizedTransitionTime);
                        else
                            _animator.CrossFade(hash, durationTime, layerIndex, offsetTime, normalizedTransitionTime);
                    }
                    //Not a predetermined index, is an actual parameter.
                    else
                    {
                        AnimatorControllerParameterType acpt = _parameterDetails[parameterIndex].ControllerParameter.type;
                        if (acpt == AnimatorControllerParameterType.Bool)
                        {
                            bool value = reader.ReadBoolean();
                            _animator.SetBool(_parameterDetails[parameterIndex].Hash, value);
                        }
                        //Float.
                        else if (acpt == AnimatorControllerParameterType.Float)
                        {
                            float value = reader.ReadSingle();
                            //If able to smooth floats.
                            if (_canSmoothFloats)
                            {
                                float currentValue = _animator.GetFloat(_parameterDetails[parameterIndex].Hash);
                                float past = (float)base.TimeManager.TickDelta;
                                //float past = _synchronizeInterval + INTERPOLATION;
                                float rate = Mathf.Abs(currentValue - value) / past;
                                _smoothedFloats[_parameterDetails[parameterIndex].Hash] = new(rate, value);
                            }
                            else
                            {
                                _animator.SetFloat(_parameterDetails[parameterIndex].Hash, value);
                            }
                        }
                        //Integer.
                        else if (acpt == AnimatorControllerParameterType.Int)
                        {
                            int value = reader.ReadInt32();
                            _animator.SetInteger(_parameterDetails[parameterIndex].Hash, value);
                        }
                        //Trigger.
                        else if (acpt == AnimatorControllerParameterType.Trigger)
                        {
                            bool value = reader.ReadBoolean();
                            if (value)
                                _animator.SetTrigger(_parameterDetails[parameterIndex].Hash);
                            else
                                _animator.ResetTrigger(_parameterDetails[parameterIndex].Hash);
                        }
                        //Unhandled.
                        else
                        {
                            base.NetworkManager.LogWarning($"Unhandled parameter type of {acpt}.");
                        }
                    }
                }

            }
            catch
            {
                base.NetworkManager.LogWarning("An error occurred while applying updates. This may occur when malformed data is sent or when you change the animator or controller but not on all connections.");
            }
            finally
            {
                reader?.Store();
            }
        }

        /// <summary>
        /// Outputs the current state and time for a layer. Returns true if stateHash is not 0.
        /// </summary>
        /// <param name="stateHash"></param>
        /// <param name="normalizedTime"></param>
        /// <param name="results"></param>
        /// <param name="layerIndex"></param>
        /// <returns></returns>
        private bool ReturnCurrentLayerState(out int stateHash, out float normalizedTime, int layerIndex)
        {
            stateHash = 0;
            normalizedTime = 0f;

            if (!_canSynchronizeAnimator)
                return false;

            AnimatorStateInfo st = _animator.GetCurrentAnimatorStateInfo(layerIndex);
            stateHash = st.fullPathHash;
            normalizedTime = st.normalizedTime;

            return (stateHash != 0);
        }

        /// <summary>
        /// Immediately sends all variables and states of layers.
        /// This is a very bandwidth intensive operation.
        /// </summary>
        public void SendAll()
        {
            _forceAllOnTimed = true;
        }

        #region Play.
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void Play(string name)
        {
            Play(Animator.StringToHash(name));
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void Play(int hash)
        {
            for (int i = 0; i < _animator.layerCount; i++)
                Play(hash, i, 0f);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void Play(string name, int layer)
        {
            Play(Animator.StringToHash(name), layer);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void Play(int hash, int layer)
        {
            Play(hash, layer, 0f);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void Play(string name, int layer, float normalizedTime)
        {
            Play(Animator.StringToHash(name), layer, normalizedTime);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void Play(int hash, int layer, float normalizedTime)
        {
            if (!_canSynchronizeAnimator)
                return;
            if (_animator.HasState(layer, hash) || hash == 0)
            {
                _animator.Play(hash, layer, normalizedTime);
                _unsynchronizedLayerStates[layer] = new(Time.frameCount);
            }
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void PlayInFixedTime(string name, float fixedTime)
        {
            PlayInFixedTime(Animator.StringToHash(name), fixedTime);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void PlayInFixedTime(int hash, float fixedTime)
        {
            for (int i = 0; i < _animator.layerCount; i++)
                PlayInFixedTime(hash, i, fixedTime);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void PlayInFixedTime(string name, int layer, float fixedTime)
        {
            PlayInFixedTime(Animator.StringToHash(name), layer, fixedTime);
        }
        /// <summary>
        /// Plays a state.
        /// </summary>
        public void PlayInFixedTime(int hash, int layer, float fixedTime)
        {
            if (!_canSynchronizeAnimator)
                return;
            if (_animator.HasState(layer, hash) || hash == 0)
            {
                _animator.PlayInFixedTime(hash, layer, fixedTime);
                _unsynchronizedLayerStates[layer] = new(Time.frameCount);
            }
        }
        #endregion

        #region Crossfade.
        /// <summary>
        /// Creates a crossfade from the current state to any other state using normalized times.
        /// </summary>
        /// <param name="stateName"></param>
        /// <param name="normalizedTransitionDuration"></param>
        /// <param name="layer"></param>
        /// <param name="normalizedTimeOffset"></param>
        /// <param name="normalizedTransitionTime"></param>
        public void CrossFade(string stateName, float normalizedTransitionDuration, int layer, float normalizedTimeOffset = float.NegativeInfinity, float normalizedTransitionTime = 0.0f)
        {
            CrossFade(Animator.StringToHash(stateName), normalizedTransitionDuration, layer, normalizedTimeOffset, normalizedTransitionTime);
        }
        /// <summary>
        /// Creates a crossfade from the current state to any other state using normalized times.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="normalizedTransitionDuration"></param>
        /// <param name="layer"></param>
        /// <param name="normalizedTimeOffset"></param>
        /// <param name="normalizedTransitionTime"></param>
        public void CrossFade(int hash, float normalizedTransitionDuration, int layer, float normalizedTimeOffset = 0.0f, float normalizedTransitionTime = 0.0f)
        {
            if (!_canSynchronizeAnimator)
                return;
            if (_animator.HasState(layer, hash) || hash == 0)
            {
                _animator.CrossFade(hash, normalizedTransitionDuration, layer, normalizedTimeOffset, normalizedTransitionTime);
                _unsynchronizedLayerStates[layer] = new(Time.frameCount, hash, false, normalizedTransitionDuration, normalizedTimeOffset, normalizedTransitionTime);
            }
        }
        /// <summary>
        /// Creates a crossfade from the current state to any other state using times in seconds.
        /// </summary>
        /// <param name="stateName"></param>
        /// <param name="fixedTransitionDuration"></param>
        /// <param name="layer"></param>
        /// <param name="fixedTimeOffset"></param>
        /// <param name="normalizedTransitionTime"></param>
        public void CrossFadeInFixedTime(string stateName, float fixedTransitionDuration, int layer, float fixedTimeOffset = 0.0f, float normalizedTransitionTime = 0.0f)
        {
            CrossFadeInFixedTime(Animator.StringToHash(stateName), fixedTransitionDuration, layer, fixedTimeOffset, normalizedTransitionTime);
        }
        /// <summary>
        /// Creates a crossfade from the current state to any other state using times in seconds.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="fixedTransitionDuration"></param>
        /// <param name="layer"></param>
        /// <param name="fixedTimeOffset"></param>
        /// <param name="normalizedTransitionTime"></param>
        public void CrossFadeInFixedTime(int hash, float fixedTransitionDuration, int layer, float fixedTimeOffset = 0.0f, float normalizedTransitionTime = 0.0f)
        {
            if (!_canSynchronizeAnimator)
                return;
            if (_animator.HasState(layer, hash) || hash == 0)
            {
                _animator.CrossFadeInFixedTime(hash, fixedTransitionDuration, layer, fixedTimeOffset, normalizedTransitionTime);
                _unsynchronizedLayerStates[layer] = new(Time.frameCount, hash, true, fixedTransitionDuration, fixedTimeOffset, normalizedTransitionTime);
            }
        }
        #endregion

        #region Triggers.
        /// <summary>
        /// Sets a trigger on the animator and sends it over the network.
        /// </summary>
        /// <param name="hash"></param>
        public void SetTrigger(int hash)
        {
            if (!_canSynchronizeAnimator)
                return;
            UpdateTrigger(hash, true);
        }
        /// <summary>
        /// Sets a trigger on the animator and sends it over the network.
        /// </summary>
        /// <param name="hash"></param>
        public void SetTrigger(string name)
        {
            SetTrigger(Animator.StringToHash(name));
        }

        /// <summary>
        /// Resets a trigger on the animator and sends it over the network.
        /// </summary>
        /// <param name="hash"></param>
        public void ResetTrigger(int hash)
        {
            UpdateTrigger(hash, false);
        }
        /// <summary>
        /// Resets a trigger on the animator and sends it over the network.
        /// </summary>
        /// <param name="hash"></param>
        public void ResetTrigger(string name)
        {
            ResetTrigger(Animator.StringToHash(name));
        }

        /// <summary>
        /// Updates a trigger, sets or resets.
        /// </summary>
        /// <param name="set"></param>
        private void UpdateTrigger(int hash, bool set)
        {
            if (!_canSynchronizeAnimator)
                return;

            bool clientAuth = ClientAuthoritative;
            //If there is an owner perform checks.
            if (base.Owner.IsValid)
            {
                //If client auth and not owner.
                if (clientAuth && !base.IsOwner)
                    return;
            }
            //There is no owner.
            else
            {
                if (!base.IsServerStarted)
                    return;
            }

            //Update locally.
            if (set)
                _animator.SetTrigger(hash);
            else
                _animator.ResetTrigger(hash);

            /* Can send if any of the following are true:
             * ClientAuth + Owner.
             * ClientAuth + No Owner + IsServer
             * !ClientAuth + IsServer. */
            bool canSend = (clientAuth && base.IsOwner)
                || (clientAuth && !base.Owner.IsValid)
                || (!clientAuth && base.IsServerStarted);

            //Only queue a send if proper side.
            if (canSend)
            {
                for (byte i = 0; i < _parameterDetails.Count; i++)
                {
                    if (_parameterDetails[i].Hash == hash)
                    {
                        _triggerUpdates.Add(new(i, set));
                        return;
                    }
                }
                //Fall through, hash not found.
                base.NetworkManager.LogWarning($"Hash {hash} not found while trying to update a trigger.");
            }
        }
        #endregion

        #region Remote actions.
        /// <summary>
        /// Called on clients to receive an animator update.
        /// </summary>
        /// <param name="data"></param>
        [TargetRpc(ValidateTarget = false)]
        private void TargetAnimatorUpdated(NetworkConnection connection, ArraySegment<byte> data)
        {
            if (!_canSynchronizeAnimator)
                return;

            //If receiver is client host then do nothing, clientHost need not process.
            if (base.IsServerInitialized && connection.IsLocalClient)
                return;

            bool clientAuth = ClientAuthoritative;
            bool isOwner = base.IsOwner;
            /* If set for client auth and owner then do not process.
             * This could be the case if an update was meant to come before
             * ownership gain but came out of late due to out of order when using unreliable. 
             * Cannot check sendToOwner given clients may not
             * always be aware of owner depending on ShareIds setting. */
            if (clientAuth && isOwner)
                return;
            /* If not client auth and not to send to owner, and is owner
             * then also return. */
            if (!clientAuth && !_sendToOwner && isOwner)
                return;

            ReceivedServerData rd = new(data);
            _fromServerBuffer.Enqueue(rd);

            if (_startTick == 0)
                _startTick = (base.TimeManager.LocalTick + _interpolation);
        }
        /// <summary>
        /// Called on server to receive an animator update.
        /// </summary>
        /// <param name="data"></param>
        [ServerRpc]
        private void ServerAnimatorUpdated(ArraySegment<byte> data)
        {
            if (!_canSynchronizeAnimator)
                return;
            if (!ClientAuthoritative)
            {
                base.Owner.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Connection Id {base.Owner.ClientId} has been kicked for trying to update this object without client authority.");
                return;
            }

            /* Server does not need to apply interpolation.
             * Even as clientHost when CSP is being used the
             * clientHost will always be on the latest tick.
             * Spectators on the other hand will remain behind
             * a little depending on their components interpolation. */
            ApplyParametersUpdated(ref data);
            _clientAuthoritativeUpdates.AddToBuffer(ref data);
        }
        #endregion

        #region Editor.
#if UNITY_EDITOR
        protected override void Reset()
        {
            base.Reset();
            if (_animator == null)
                SetAnimator(GetComponent<Animator>());
        }
#endif
        #endregion

    }
}
﻿#if UNITY_EDITOR
using FishNet.Editing;
using System.Collections.Generic;
using FishNet.Managing;
using UnityEditor;
using UnityEditor.Animations;
using UnityEngine;

namespace FishNet.Component.Animating.Editing
{

    [CustomEditor(typeof(NetworkAnimator), true)]
    [CanEditMultipleObjects]
    public class NetworkAnimatorEditor : Editor
    {
        private SerializedProperty _animator;
        private SerializedProperty _interpolation;
        private SerializedProperty _synchronizeWhenDisabled;
        private SerializedProperty _smoothFloats;
        private SerializedProperty _clientAuthoritative;
        private SerializedProperty _sendToOwner;
        private RuntimeAnimatorController _lastRuntimeAnimatorController;
        private AnimatorController _lastAnimatorController;

        protected virtual void OnEnable()
        {
            _animator = serializedObject.FindProperty(nameof(_animator));
            _interpolation = serializedObject.FindProperty(nameof(_interpolation));
            _synchronizeWhenDisabled = serializedObject.FindProperty(nameof(_synchronizeWhenDisabled));
            _smoothFloats = serializedObject.FindProperty(nameof(_smoothFloats));

            _clientAuthoritative = serializedObject.FindProperty(nameof(_clientAuthoritative));
            _sendToOwner = serializedObject.FindProperty(nameof(_sendToOwner));
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            NetworkAnimator na = (NetworkAnimator)target;

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour(na), typeof(NetworkAnimator), false);
            GUI.enabled = true;

            
#pragma warning disable CS0162 // Unreachable code detected
                EditorGUILayout.HelpBox(EditingConstants.PRO_ASSETS_LOCKED_TEXT, MessageType.Warning);
#pragma warning restore CS0162 // Unreachable code detected

            //Animator
            EditorGUILayout.LabelField("Animator", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_animator);
            EditorGUILayout.PropertyField(_synchronizeWhenDisabled);
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Synchronization Processing.
            EditorGUILayout.LabelField("Synchronization Processing", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_interpolation);
            EditorGUILayout.PropertyField(_smoothFloats);
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Authority.
            EditorGUILayout.LabelField("Authority", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_clientAuthoritative);
            if (_clientAuthoritative.boolValue == false)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_sendToOwner);
                EditorGUI.indentLevel--;
            }
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            DrawParameters(na);

            serializedObject.ApplyModifiedProperties();
        }


        private void DrawParameters(NetworkAnimator na)
        {
            EditorGUILayout.LabelField("* Synchronized Parameters", EditorStyles.boldLabel);
            EditorGUILayout.HelpBox("This setting allows you to optionally completely prevent the synchronization of certain parameters. Both Fish-Networking free and Pro will only synchronize changes as they occur.", MessageType.Info);

            if (Application.isPlaying)
            {
                EditorGUILayout.HelpBox("This feature can only be configured while out of play mode.", MessageType.Info);
                return;
            }
            if (na == null)
                return;
            Animator animator = na.Animator;
            if (animator == null)
                return;

            RuntimeAnimatorController runtimeController = (animator.runtimeAnimatorController is AnimatorOverrideController aoc) ? aoc.runtimeAnimatorController : animator.runtimeAnimatorController;
            if (runtimeController == null)
            {
                na.IgnoredParameters.Clear();
                return;
            }

            /* If runtime controller changed 
             * or editor controller is null
             * then get new editor controller. */
            if (runtimeController != _lastRuntimeAnimatorController || _lastAnimatorController == null)
                _lastAnimatorController = (AnimatorController)AssetDatabase.LoadAssetAtPath(AssetDatabase.GetAssetPath(runtimeController), typeof(AnimatorController));
            _lastRuntimeAnimatorController = runtimeController;

            Color defaultColor = GUI.backgroundColor;
            float width = Screen.width;
            float spacePerEntry = 125f;
            //Buttons seem to be longer than spacePerEntry. Why, because who knows...
            float extraSpaceJustBecause = 60;
            float spacer = 20f;
            width -= spacer;
            int entriesPerWidth = Mathf.Max(1, Mathf.FloorToInt(width / (spacePerEntry + extraSpaceJustBecause)));

            List<AnimatorControllerParameter> aps = new();
            //Create a parameter detail for each parameter that can be synchronized.
            int count = 0;
            foreach (AnimatorControllerParameter item in _lastAnimatorController.parameters)
            {
                count++;
                //Over 240 parameters; who would do this!?
                if (count >= 240)
                    continue;

                aps.Add(item);
            }

            int apsCount = aps.Count;
            for (int i = 0; i < apsCount; i++)
            {
                using (GUILayout.HorizontalScope hs = new())
                {
                    GUILayout.Space(spacer);
                    int z = 0;
                    while (z < entriesPerWidth && (z + i < apsCount))
                    {
                        //If this z+i would exceed entries then break.
                        if (z + i >= apsCount)
                            break;

                        AnimatorControllerParameter item = aps[i + z];
                        string parameterName = item.name;
                        bool ignored = na.IgnoredParameters.Contains(parameterName);

                        Color c = (ignored) ? Color.gray : Color.green;
                        GUI.backgroundColor = c;
                        if (GUILayout.Button(item.name, GUILayout.Width(spacePerEntry)))
                        {
                            if (Application.isPlaying)
                            {
                                NetworkManagerExtensions.Log("Synchronized parameters may not be changed while playing.");
                            }
                            else
                            {
                                if (ignored)
                                    na.IgnoredParameters.Remove(parameterName);
                                else
                                    na.IgnoredParameters.Add(parameterName);
                            }
                            UnityEditor.EditorUtility.SetDirty(target);
                        }

                        z++;
                    }

                    i += (z - 1);
                }

                GUI.backgroundColor = defaultColor;
            }
        }



    }

}


#endif﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Server;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using FishNet.Managing.Timing;
using UnityEngine;
using UnityEngine.Scripting;
using static FishNet.Object.NetworkObject;

namespace FishNet.Component.Transforming
{
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Component/NetworkTransform")]
    public sealed class NetworkTransform : NetworkBehaviour
    {
        #region Types.
        [Serializable]
        public enum ComponentConfigurationType
        {
            Disabled = 0,
            CharacterController = 1,
            Rigidbody = 2,
            Rigidbody2D = 3,
        }

        private struct ReceivedClientData
        {
            /// <summary>
            /// Level of detail indexes which have data.
            /// </summary>
            public bool HasData;
            /// <summary>
            /// Most recent data.
            /// </summary>
            public PooledWriter Writer;
            /// <summary>
            /// Channel the current data arrived on.
            /// </summary>
            public Channel Channel;
            /// <summary>
            /// LocalTick of the side receiving this update, typically the server.
            /// </summary>
            public uint LocalTick;

            /// <summary>
            /// Updates current values.
            /// </summary>
            /// <param name="updateHasData">True to set all HasData to true.</param>
            public void Update(ArraySegment<byte> data, Channel channel, bool updateHasData, uint localTick)
            {
                if (Writer == null)
                    Writer = WriterPool.Retrieve();

                Writer.Clear();
                Writer.WriteArraySegment(data);
                Channel = channel;
                LocalTick = localTick;

                if (updateHasData)
                    HasData = true;
            }

            /// <summary>
            /// Will cause this data to send on the reliable channel once even if data is unchanged.
            /// </summary>
            public void SendReliably()
            {
                HasData = true;
                Channel = Channel.Reliable;
            }

            public void ResetState()
            {
                HasData = false;
                WriterPool.StoreAndDefault(ref Writer);
            }
        }

        [Serializable]
        public struct SnappedAxes
        {
            public bool X;
            public bool Y;
            public bool Z;
        }

        [Flags]
        private enum ChangedDelta : uint
        {
            Unset = 0,
            PositionX = 1,
            PositionY = 2,
            PositionZ = 4,
            Rotation = 8,
            Extended = 16,
            ScaleX = 32,
            ScaleY = 64,
            ScaleZ = 128,
            Nested = 256,
            All = ~0u,
        }

        [Flags]
        private enum ChangedFull
        {
            Unset = 0,
            Position = 1,
            Rotation = 2,
            Scale = 4,
            Childed = 8,
            Teleport = 16,
        }

        [Flags]
        private enum UpdateFlagA : byte
        {
            Unset = 0,
            X2 = 1,
            X4 = 2,
            Y2 = 4,
            Y4 = 8,
            Z2 = 16,
            Z4 = 32,
            Rotation = 64,
            Extended = 128
        }

        [Flags]
        private enum UpdateFlagB : byte
        {
            Unset = 0,
            X2 = 1,
            X4 = 2,
            Y2 = 4,
            Y4 = 8,
            Z2 = 16,
            Z4 = 32,
            Child = 64,
            Teleport = 128
        }

        public class GoalData : IResettable
        {
            public uint ReceivedTick;
            public RateData Rates = new();
            public TransformData Transforms = new();

            [Preserve]
            public GoalData() { }

            public void ResetState()
            {
                ReceivedTick = 0;
                Transforms.ResetState();
                Rates.ResetState();
            }

            public void InitializeState() { }
        }

        public class RateData : IResettable
        {
            /// <summary>
            /// Rate for position after smart calculations.
            /// </summary>
            public float Position;
            /// <summary>
            /// Rate for rotation after smart calculations.
            /// </summary>
            public float Rotation;
            /// <summary>
            /// Rate for scale after smart calculations.
            /// </summary>
            public float Scale;
            /// <summary>
            /// Unaltered rate for position calculated through position change and tickspan.
            /// </summary>
            public float LastUnalteredPositionRate;
            /// <summary>
            /// Number of ticks the rates are calculated for.
            /// If TickSpan is 2 then the rates are calculated under the assumption the transform changed over 2 ticks.
            /// </summary>
            public uint TickSpan;
            /// <summary>
            /// Time remaining until transform is expected to reach it's goal.
            /// </summary>
            internal float TimeRemaining;

            [Preserve]
            public RateData() { }

            public void Update(RateData rd)
            {
                Update(rd.Position, rd.Rotation, rd.Scale, rd.LastUnalteredPositionRate, rd.TickSpan, rd.TimeRemaining);
            }

            /// <summary>
            /// Updates rates.
            /// </summary>
            public void Update(float position, float rotation, float scale, float unalteredPositionRate, uint tickSpan, float timeRemaining)
            {
                Position = position;
                Rotation = rotation;
                Scale = scale;
                LastUnalteredPositionRate = unalteredPositionRate;
                TickSpan = tickSpan;
                TimeRemaining = timeRemaining;
            }

            public void ResetState()
            {
                Position = 0f;
                Rotation = 0f;
                Scale = 0f;
                LastUnalteredPositionRate = 0f;
                TickSpan = 0;
                TimeRemaining = 0f;
            }

            public void InitializeState() { }
        }

        public class TransformData : IResettable
        {
            public enum ExtrapolateState : byte
            {
                Disabled = 0,
                Available = 1,
                Active = 2
            }

            /// <summary>
            /// True if default state. This becomes false during an update and true when resetting state.
            /// </summary>
            public bool IsDefault { get; private set; } = true;

            /// <summary>
            /// Tick this data was received or created.
            /// </summary>
            public uint Tick;
            /// <summary>
            /// True if this data has already been checked for snapping.
            /// Snapping calls may occur multiple times when data is received, depending why or how it came in.
            /// This check prevents excessive work.
            /// </summary>
            public bool SnappingChecked;
            /// <summary>
            /// Local position in the data.
            /// </summary>
            public Vector3 Position;
            /// <summary>
            /// Local rotation in the data.
            /// </summary>
            public Quaternion Rotation;
            /// <summary>
            /// Local scale in the data.
            /// </summary>
            public Vector3 Scale;
            /// <summary>
            /// Position to extrapolate towards.
            /// </summary>
            public Vector3 ExtrapolatedPosition;
            /// <summary>
            /// Current state of extrapolation.
            /// </summary>
            public ExtrapolateState ExtrapolationState;
            /// <summary>
            /// NetworkBehaviour which is the parent of this object for Tick.
            /// </summary>
            public NetworkBehaviour ParentBehaviour;

            [Preserve]
            public TransformData() { }

            internal void Update(TransformData copy)
            {
                Update(copy.Tick, copy.Position, copy.Rotation, copy.Scale, copy.ExtrapolatedPosition, copy.ParentBehaviour);
            }

            internal void Update(uint tick, Vector3 position, Quaternion rotation, Vector3 scale, Vector3 extrapolatedPosition, NetworkBehaviour parentBehaviour)
            {
                IsDefault = false;
                Tick = tick;
                Position = position;
                Rotation = rotation;
                Scale = scale;
                ExtrapolatedPosition = extrapolatedPosition;
                ParentBehaviour = parentBehaviour;
            }

            public void ResetState()
            {
                IsDefault = true;
                Tick = 0;
                SnappingChecked = false;
                Position = Vector3.zero;
                Rotation = Quaternion.identity;
                Scale = Vector3.zero;
                ExtrapolatedPosition = Vector3.zero;
                ExtrapolationState = ExtrapolateState.Disabled;
                ParentBehaviour = null;
            }

            public void InitializeState() { }
        }
        #endregion

        #region Public.
        /// <summary>
        /// 
        /// </summary>
        /// <param name="prev"></param>
        /// <param name="next"></param>
        [APIExclude]
        public delegate void DataReceivedChanged(TransformData prev, TransformData next);

        /// <summary>
        /// Called when new data is received. Previous and next data are provided. Next data may be manipulated.
        /// </summary>
        public event DataReceivedChanged OnDataReceived;

        /// <summary>
        /// Called when GoalData is updated.
        /// </summary>
        public event Action<GoalData> OnNextGoal;

        /// <summary>
        /// Called when the transform has reached it's goal.
        /// </summary>
        public event Action OnInterpolationComplete;

        /// <summary>
        /// True if the local client used TakeOwnership and is awaiting an ownership change.
        /// </summary>
        public bool TakenOwnership { get; private set; }

        /// <summary>
        /// NetworkBehaviour this transform is a child of.
        /// </summary>
        public NetworkBehaviour ParentBehaviour { get; private set; }
        #endregion

        #region Serialized.
        /// <summary>
        /// Attached movement component to automatically configure.
        /// </summary>
        [Tooltip("Attached movement component to automatically configure.")]
        [SerializeField]
        private ComponentConfigurationType _componentConfiguration = ComponentConfigurationType.Disabled;
        /// <summary>
        /// True to synchronize when this transform changes parent.
        /// </summary>
        [Tooltip("True to synchronize when this transform changes parent.")]
        [SerializeField]
        private bool _synchronizeParent;
        /// <summary>
        /// How much to compress each transform property.
        /// </summary>
        [Tooltip("How much to compress each transform property.")]
        [SerializeField]
        private TransformPackingData _packing = new()
        {
            Position = AutoPackType.Packed,
            Rotation = AutoPackType.Packed,
            Scale = AutoPackType.Unpacked
        };
        /// <summary>
        /// How many ticks to interpolate.
        /// </summary>
        [Tooltip("How many ticks to interpolate.")]
        [Range(1, MAX_INTERPOLATION)]
        [SerializeField]
        private ushort _interpolation = 2;
        /// <summary>
        /// How many ticks to extrapolate.
        /// </summary>
        [Tooltip("How many ticks to extrapolate.")]
        [Range(0, 1024)]
        [SerializeField]
#pragma warning disable CS0414 //Not in use.
        private ushort _extrapolation = 2;
#pragma warning restore CS0414 //Not in use.
        /// <summary>
        /// True to enable teleport threshhold.
        /// </summary>
        [Tooltip("True to enable teleport threshhold.")]
        [SerializeField]
        private bool _enableTeleport;
        /// <summary>
        /// How far the transform must travel in a single update to cause a teleport rather than smoothing. Using 0f will teleport every update.
        /// </summary>
        [Tooltip("How far the transform must travel in a single update to cause a teleport rather than smoothing. Using 0f will teleport every update.")]
        [Range(0f, float.MaxValue)]
        [SerializeField]
        private float _teleportThreshold = 1f;
        /// <summary>
        /// True if owner controls how the object is synchronized.
        /// </summary>
        [Tooltip("True if owner controls how the object is synchronized.")]
        [SerializeField]
        private bool _clientAuthoritative = true;
        /// <summary>
        /// True to synchronize movements on server to owner when not using client authoritative movement.
        /// </summary>
        [Tooltip("True to synchronize movements on server to owner when not using client authoritative movement.")]
        [SerializeField]
        private bool _sendToOwner = true;

        /// <summary>
        /// Gets SendToOwner.
        /// </summary>
        public bool GetSendToOwner() => _sendToOwner;

        /// <summary>
        /// Sets SendToOwner. Only the server may call this method.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetSendToOwner(bool value)
        {
            _sendToOwner = value;
            if (base.IsServerInitialized)
                ObserversSetSendToOwner(value);
        }

        /// <summary>
        /// How often in ticks to synchronize. This is default to 1 but can be set longer to send less often. This value may also be changed at runtime. Enabling Network level of detail for this NetworkTransform disables manual control of this feature as it will be handled internally.
        /// </summary>
        [Tooltip("How often in ticks to synchronize. This is default to 1 but can be set longer to send less often. This value may also be changed at runtime. Enabling Network level of detail for this NetworkTransform disables manual control of this feature as it will be handled internally.")]
        [Range(1, byte.MaxValue)]
        [SerializeField]
        private byte _interval = 1;
        /// <summary>
        /// True to synchronize position. Even while checked only changed values are sent.
        /// </summary>
        [Tooltip("True to synchronize position. Even while checked only changed values are sent.")]
        [SerializeField]
        private bool _synchronizePosition = true;

        /// <summary>
        /// Sets if to synchronize position.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetSynchronizePosition(bool value) => _synchronizePosition = value;

        /// <summary>
        /// Axes to snap on position.
        /// </summary>
        [Tooltip("Axes to snap on position.")]
        [SerializeField]
        private SnappedAxes _positionSnapping = new();

        /// <summary>
        /// Sets which Position axes to snap.
        /// </summary>
        /// <param name="axes">Axes to snap.</param>
        public void SetPositionSnapping(SnappedAxes axes) => _positionSnapping = axes;

        /// <summary>
        /// True to synchronize rotation. Even while checked only changed values are sent.
        /// </summary>
        [Tooltip("True to synchronize rotation. Even while checked only changed values are sent.")]
        [SerializeField]
        private bool _synchronizeRotation = true;

        /// <summary>
        /// Sets if to synchronize rotation.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetSynchronizeRotation(bool value) => _synchronizeRotation = value;

        /// <summary>
        /// Axes to snap on rotation.
        /// </summary>
        [Tooltip("Axes to snap on rotation.")]
        [SerializeField]
        private SnappedAxes _rotationSnapping = new();

        /// <summary>
        /// Sets which Scale axes to snap.
        /// </summary>
        /// <param name="axes">Axes to snap.</param>
        public void SetRotationSnapping(SnappedAxes axes) => _rotationSnapping = axes;

        /// <summary>
        /// True to synchronize scale. Even while checked only changed values are sent.
        /// </summary>
        [Tooltip("True to synchronize scale. Even while checked only changed values are sent.")]
        [SerializeField]
        private bool _synchronizeScale = true;

        /// <summary>
        /// Sets if to synchronize scale.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetSynchronizeScale(bool value) => _synchronizeScale = value;

        /// <summary>
        /// Axes to snap on scale.
        /// </summary>
        [Tooltip("Axes to snap on scale.")]
        [SerializeField]
        private SnappedAxes _scaleSnapping = new();

        /// <summary>
        /// Sets which Scale axes to snap.
        /// </summary>
        /// <param name="axes">Axes to snap.</param>
        public void SetScaleSnapping(SnappedAxes axes) => _scaleSnapping = axes;
        #endregion

        #region Private.
        /// <summary>
        /// Packing data with all values set to uncompressed.
        /// </summary>
        private TransformPackingData _unpacked = new()
        {
            Position = AutoPackType.Unpacked,
            Rotation = AutoPackType.Unpacked,
            Scale = AutoPackType.Unpacked
        };
        /// <summary>
        /// True if the last DataReceived was on the reliable channel. Default to true so initial values do not extrapolate.
        /// </summary>
        private bool _lastReceiveReliable = true;
        /// <summary>
        /// Last transform which this object was a child of.
        /// </summary>
        private Transform _parentTransform;
        /// <summary>
        /// Values changed over time that server has sent to clients since last reliable has been sent.
        /// </summary>
        private ChangedDelta _serverChangedSinceReliable;
        /// <summary>
        /// Values changed over time that client has sent to server since last reliable has been sent.
        /// </summary>
        private ChangedDelta _clientChangedSinceReliable = ChangedDelta.Unset;
        /// <summary>
        /// Last tick an ObserverRpc passed checks.
        /// </summary>
        private uint _lastObserversRpcTick;
        /// <summary>
        /// Last tick a ServerRpc passed checks.
        /// </summary>
        private uint _lastServerRpcTick;
        /// <summary>
        /// Last received data from an authoritative client.
        /// </summary>
        private ReceivedClientData _authoritativeClientData = new();
        /// <summary>
        /// True if subscribed to TimeManager for ticks.
        /// </summary>
        private bool _subscribedToTicks;
        /// <summary>
        /// True if subscribed to TimeManager for update.
        /// </summary>
        private bool _subscribedToUpdate;
        /// <summary>
        /// Starting interpolation on the rigidbody.
        /// </summary>
        private RigidbodyInterpolation? _initializedRigidbodyInterpolation;
        /// <summary>
        /// Starting interpolation on the rigidbody2d.
        /// </summary>
        private RigidbodyInterpolation2D? _initializedRigidbodyInterpolation2d;
        /// <summary>
        /// Last TransformData to be received from the server.
        /// </summary>
        private TransformData _lastReceivedServerTransformData;
        /// <summary>
        /// Last TransformData to be received from the server.
        /// </summary>
        private TransformData _lastReceivedClientTransformData;
        /// <summary>
        /// Last RateData to be calculated from LastReceivedTransformData.
        /// </summary>
        private readonly RateData _lastCalculatedRateData = new();
        /// <summary>
        /// GoalDatas to move towards.
        /// </summary>
        private readonly Queue<GoalData> _goalDataQueue = new();
        /// <summary>
        /// Current GoalData being used.
        /// </summary>
        private GoalData _currentGoalData;
        /// <summary>
        /// True if the transform has changed since it started.
        /// </summary>
        private bool _changedSinceStart;
        /// <summary>
        /// Number of intervals remaining before synchronization.
        /// </summary>
        private short _intervalsRemaining;
        /// <summary>
        /// Last sent transform data.
        /// </summary>
        private TransformData _lastSentTransformData;
        /// <summary>
        /// Writers for changed data.
        /// </summary>
        private PooledWriter _toClientChangedWriter;
        /// <summary>
        /// If not unset a force send will occur on or after this tick.
        /// </summary>
        private uint _forceSendTick = Managing.Timing.TimeManager.UNSET_TICK;
        /// <summary>
        /// Returns all properties as changed.
        /// </summary>
        private ChangedDelta _fullChanged => ChangedDelta.All;
        /// <summary>
        /// When true teleport will be sent with the next changed data.
        /// </summary>
        private bool _teleport;
        /// <summary>
        /// Cached transform
        /// </summary>
        private Transform _cachedTransform;
        /// <summary>
        /// Cached TimeManager reference for performance.
        /// </summary>
        private TimeManager _timeManager;
        #endregion

        #region Const.
        /// <summary>
        /// Maximum possible interpolation value.
        /// </summary>
        public const ushort MAX_INTERPOLATION = 250;
        #endregion

        private void Awake()
        {
            _interval = Math.Max(_interval, (byte)1);
        }

        private void OnDestroy()
        {
            base.ResetState(true);
            ResetState_OnDestroy();
        }

        public override void OnStartNetwork()
        {
            _cachedTransform = transform;
            _timeManager = base.TimeManager;

            ChangeTickSubscription(true);
        }

        public override void OnStartServer()
        {
            _lastReceivedClientTransformData = ObjectCaches<TransformData>.Retrieve();
            InitializeFields(true);
            SetDefaultGoalData();
        }

        public override void OnSpawnServer(NetworkConnection connection)
        {
            base.OnSpawnServer(connection);
            /* If not on the root then the initial properties may need to be synchronized
             * since the spawn message only sends root information. If initial
             * properties have changed update spawning connection. */
            if (base.NetworkObject.gameObject != gameObject && _changedSinceStart)
            {
                //Send latest.
                PooledWriter writer = WriterPool.Retrieve();
                SerializeChanged(_fullChanged, writer);
                TargetUpdateTransform(connection, writer.GetArraySegment(), Channel.Reliable);
                writer.Store();
            }
        }

        public override void OnStartClient()
        {
            _lastReceivedServerTransformData = ObjectCaches<TransformData>.Retrieve();
            ChangeUpdateSubscription(subscribe: true);
            ConfigureComponents();
            InitializeFields(false);
            SetDefaultGoalData();
        }

        public override void OnOwnershipServer(NetworkConnection prevOwner)
        {
            ConfigureComponents();
            _intervalsRemaining = 0;
            //Reset last tick since each client sends their own ticks.
            _lastServerRpcTick = 0;

            TryClearGoalDatas_OwnershipChange(prevOwner, true);
        }

        public override void OnOwnershipClient(NetworkConnection prevOwner)
        {
            ConfigureComponents();
            _intervalsRemaining = 0;

            //Not new owner.
            if (!base.IsOwner)
            {
                /* If client authoritative and ownership was lost
                 * then default goals must be set to force the
                 * object to it's last transform. */
                if (_clientAuthoritative)
                    SetDefaultGoalData();
            }

            TryClearGoalDatas_OwnershipChange(prevOwner, false);
        }

        public override void OnStopNetwork()
        {
            ResetState();
            ChangeUpdateSubscription(subscribe: false);
        }

        /// <summary>
        /// Tries to clear the GoalDatas queue during an ownership change.
        /// </summary>
        private void TryClearGoalDatas_OwnershipChange(NetworkConnection prevOwner, bool asServer)
        {
            if (_clientAuthoritative)
            {
                //If not server
                if (!asServer)
                {
                    //If owner now then clear as the owner controls the object now and shouldnt use past datas.
                    if (base.IsOwner)
                        _goalDataQueue.Clear();
                }
                //as Server.
                else
                {
                    //If new owner is valid then clear to allow new owner datas.
                    if (base.Owner.IsValid)
                        _goalDataQueue.Clear();
                }
            }
            /* Server authoritative never clears because the
             * clients do not control this object thus should always
             * follow the queue. */
        }

        private void TimeManager_OnUpdate()
        {
            MoveToTarget(Time.deltaTime);
        }

        /// <summary>
        /// Adds collections required.
        /// </summary>
        private void InitializeFields(bool asServer)
        {
            bool asClientAndNotHost = (!asServer && !base.IsServerStarted);

            /* Even though these collections are nullified on clean up
             * they could still exist on the reinitialization for clientHost if
             * an object is despawned to a pool then very quickly respawned
             * before the clientHost side has not processed the despawn yet.
             * Because of this check count rather than null. */
            if (asClientAndNotHost || asServer)
            {
                //Prefer to reset existing.
                if (_lastSentTransformData != null)
                    _lastSentTransformData.ResetState();
                else
                    _lastSentTransformData = ResettableObjectCaches<TransformData>.Retrieve();
            }

            if (asServer)
            {
                if (_toClientChangedWriter != null)
                    _toClientChangedWriter.Clear();
                else
                    _toClientChangedWriter = WriterPool.Retrieve();
            }
        }

        /// <summary>
        /// Configures components automatically.
        /// </summary>

        /// <summary>
        /// Configures components automatically.
        /// </summary>
        private void ConfigureComponents()
        {
            //Disabled.
            if (_componentConfiguration == ComponentConfigurationType.Disabled)
                return;

            //RB.
            if (_componentConfiguration == ComponentConfigurationType.Rigidbody)
            {
                if (TryGetComponent(out Rigidbody c))
                {
                    //If first time set starting interpolation.
                    if (_initializedRigidbodyInterpolation == null)
                        _initializedRigidbodyInterpolation = c.interpolation;

                    bool isKinematic = CanMakeKinematic();
                    c.isKinematic = isKinematic;

                    if (isKinematic)
                        c.interpolation = RigidbodyInterpolation.None;
                    else
                        c.interpolation = _initializedRigidbodyInterpolation.Value;
                }
            }
            //RB2D
            else if (_componentConfiguration == ComponentConfigurationType.Rigidbody2D)
            {
                if (TryGetComponent(out Rigidbody2D c))
                {
                    //If first time set starting interpolation.
                    if (_initializedRigidbodyInterpolation2d == null)
                        _initializedRigidbodyInterpolation2d = c.interpolation;

                    bool isKinematic = CanMakeKinematic();
                    c.isKinematic = isKinematic;
                    c.simulated = !isKinematic;

                    if (isKinematic)
                        c.interpolation = RigidbodyInterpolation2D.None;
                    else
                        c.interpolation = _initializedRigidbodyInterpolation2d.Value;
                }
            }
            //CC
            else if (_componentConfiguration == ComponentConfigurationType.CharacterController)
            {
                if (TryGetComponent(out CharacterController c))
                {
                    //Client auth.
                    if (_clientAuthoritative)
                    {
                        c.enabled = base.IsController;
                    }
                    //Server auth.
                    else
                    {
                        //Not CSP.
                        if (_sendToOwner)
                            c.enabled = base.IsServerInitialized;
                        //Most likely CSP.
                        else
                            c.enabled = (base.IsServerInitialized || base.IsOwner);
                    }
                }
            }

            bool CanMakeKinematic()
            {
                bool isServerStarted = base.IsServerStarted;

                //When not client auth, kinematic is always true if not server.
                if (!_clientAuthoritative)
                    return !isServerStarted;

                /* If here then is client-auth. */

                //Owner shouldn't be kinematic as they are controller.
                if (base.IsOwner)
                    return false;

                //Is server, and there is no owner.
                if (isServerStarted && !base.Owner.IsActive)
                    return false;

                return true;
            }
        }

        /// <summary>
        /// Called when a tick occurs.
        /// </summary>
        private void TimeManager_OnPostTick()
        {
            //If to force send via tick delay do so and reset force send tick.
            if (_forceSendTick != Managing.Timing.TimeManager.UNSET_TICK && _timeManager.LocalTick > _forceSendTick)
            {
                _forceSendTick = Managing.Timing.TimeManager.UNSET_TICK;
                ForceSend();
            }

            UpdateParentBehaviour();

            /* Intervals remaining is only used when the interval value
             * is set higher than 1. An interval of 1 indicates to send
             * every tick. Only check to wait more ticks if interval
             * is larger than 1. */
            if (_interval > 1)
            {
                /* If intervalsRemaining is unset then that means the transform
                 * did not change last tick. See if transform changed and if so then
                 * update remaining to _interval. */
                if (_intervalsRemaining == -1)
                {
                    //Transform didn't change, no reason to start remaining.
                    if (!_cachedTransform.hasChanged)
                        return;

                    _intervalsRemaining = _interval;
                }

                //If here then intervalsRemaining can be deducted.
                _intervalsRemaining--;
                //Interval not met yet.
                if (_intervalsRemaining > 0)
                    return;
                //Intervals remainin is met. Reset to -1 to await new change.
                else
                    _intervalsRemaining = -1;
            }

            bool isServerInitialized = base.IsServerInitialized;
            bool isClientInitialized = base.IsClientInitialized;

            if (isServerInitialized)
            {
                /* If client is not initialized then
                 * call a move to targe ton post tick to ensure
                 * anything with instant rates gets moved. */
                if (!isClientInitialized)
                    MoveToTarget((float)_timeManager.TickDelta);
                //
                SendToClients();
            }

            if (isClientInitialized)
                SendToServer(_lastSentTransformData);
        }

        /// <summary>
        /// Tries to subscribe to TimeManager ticks.
        /// </summary>
        private void ChangeTickSubscription(bool subscribe)
        {
            if (subscribe == _subscribedToTicks || base.NetworkManager == null)
                return;

            _subscribedToTicks = subscribe;
            if (subscribe)
                base.NetworkManager.TimeManager.OnPostTick += TimeManager_OnPostTick;
            else
                base.NetworkManager.TimeManager.OnPostTick -= TimeManager_OnPostTick;
        }

        private void ChangeUpdateSubscription(bool subscribe)
        {
            if (subscribe == _subscribedToUpdate || _timeManager == null)
                return;

            _subscribedToUpdate = subscribe;
            if (subscribe)
                _timeManager.OnUpdate += TimeManager_OnUpdate;
            else
                _timeManager.OnUpdate -= TimeManager_OnUpdate;
        }

        /// <summary>
        /// Returns if controlling logic can be run. This may be the server when there is no owner, even if client authoritative, and more.
        /// </summary>
        /// <returns></returns>
        private bool CanControl()
        {
            //Client auth.
            if (_clientAuthoritative)
            {
                return base.IsController;
            }
            //Server auth.
            else
            {
                if (base.IsServerInitialized)
                    return true;
            }

            //Fall through.
            return false;
        }

        /// <summary>
        /// When called by the controller of this object the next changed data will be teleported to by spectators.
        /// </summary>
        public void Teleport()
        {
            if (CanControl())
                _teleport = true;
        }

        /// <summary>
        /// Sets SendToOwner value.
        /// </summary>
        /// <param name="value"></param>
        [ObserversRpc(BufferLast = true, ExcludeServer = true)]
        private void ObserversSetSendToOwner(bool value)
        {
            _sendToOwner = value;
        }

        /// <summary>
        /// Resets last sent information to force a resend of current values after a number of ticks.
        /// </summary>
        public void ForceSend(uint ticks)
        {
            /* If there is a pending delayed force send then queue it
             * immediately and set a new delay tick. */
            if (_forceSendTick != Managing.Timing.TimeManager.UNSET_TICK)
                ForceSend();
            _forceSendTick = _timeManager.LocalTick + ticks;
        }

        /// <summary>
        /// Resets last sent information to force a resend of current values.
        /// </summary>
        public void ForceSend()
        {
            _lastSentTransformData.ResetState();
            if (_authoritativeClientData.Writer != null)
                _authoritativeClientData.SendReliably();
        }

        /// <summary>
        /// Updates the interval value over the network.
        /// </summary>
        /// <param name="value">New interval.</param>
        public void SetInterval(byte value)
        {
            bool canSet = (base.IsServerInitialized && !_clientAuthoritative) || (base.IsServerInitialized && _clientAuthoritative && !base.Owner.IsValid) || (_clientAuthoritative && base.IsOwner);

            if (!canSet)
                return;

            if (base.IsServerInitialized)
                ObserversSetInterval(value);
            else
                ServerSetInterval(value);
        }

        /// <summary>
        /// Updates the interval value.
        /// </summary>
        /// <param name="value"></param>
        private void SetIntervalInternal(byte value)
        {
            value = (byte)Mathf.Max(value, 1);
            _interval = value;
        }

        /// <summary>
        /// Sets interval over the network.
        /// </summary>
        [ServerRpc(RunLocally = true)]
        private void ServerSetInterval(byte value)
        {
            if (!_clientAuthoritative)
            {
                base.Owner.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Connection Id {base.Owner.ClientId} has been kicked for trying to update this object without client authority.");
                return;
            }

            SetIntervalInternal(value);
        }

        /// <summary>
        /// Sets interval over the network.
        /// </summary>
        [ObserversRpc(BufferLast = true, RunLocally = true)]
        private void ObserversSetInterval(byte value)
        {
            SetIntervalInternal(value);
        }

        /// <summary>
        /// Creates goal data using current position.
        /// </summary>
        private void SetDefaultGoalData()
        {
            Transform t = _cachedTransform;
            NetworkBehaviour parentBehaviour = null;
            //If there is a parent try to output the behaviour on it.
            if (_synchronizeParent)
            {
                if (base.NetworkObject.CurrentParentNetworkBehaviour != null)
                {
                    t.parent.TryGetComponent(out parentBehaviour);
                    if (parentBehaviour == null)
                    {
                        LogInvalidParent();
                    }
                    else
                    {
                        _parentTransform = t.parent;
                        ParentBehaviour = parentBehaviour;
                    }
                }
            }

            _teleport = false;
            SetLastReceived(_lastReceivedServerTransformData);
            SetLastReceived(_lastReceivedClientTransformData);
            //SetInstantRates(_currentGoalData.Rates, 0, -1f);

            void SetLastReceived(TransformData td)
            {
                //Could be null if not initialized due to server or client side not being used.
                if (td == null)
                    return;
                td.Update(0, t.localPosition, t.localRotation, t.localScale, t.localPosition, parentBehaviour);
            }
        }

        /// <summary>
        /// Prints an invalid parent debug.
        /// </summary>
        private void LogInvalidParent()
        {
            base.NetworkManager.LogWarning($"{gameObject.name} [Id {base.ObjectId}] is childed but the parent {_cachedTransform.parent.name} does not contain a NetworkBehaviour component. To synchronize parents the parent object must have a NetworkBehaviour component, even if empty.");
        }

        /// <summary>
        /// Serializes only changed data into writer.
        /// </summary>
        private void SerializeChanged(ChangedDelta changed, PooledWriter writer)
        {
            UpdateFlagA flagsA = UpdateFlagA.Unset;
            UpdateFlagB flagsB = UpdateFlagB.Unset;
            /* Do not use compression when childed. Depending
             * on the scale of the parent compression may
             * not be accurate enough. */
            TransformPackingData packing = ChangedContains(changed, ChangedDelta.Nested) ? _unpacked : _packing;

            int startIndexA = writer.Position;
            writer.Skip(1);
            //Original axis value.
            float original;
            //Compressed axis value.
            float compressed;
            //Multiplier for compression.
            float multiplier = 100f;
            /* Maximum value compressed may be
             * to send as compressed. */
            float maxValue = (short.MaxValue - 1);

            Transform t = _cachedTransform;
            /* Position. */
            if (_synchronizePosition)
            {
                AutoPackType localPacking = packing.Position;
                //PositionX
                if (ChangedContains(changed, ChangedDelta.PositionX))
                {
                    original = t.localPosition.x;
                    compressed = original * multiplier;
                    if (localPacking != AutoPackType.Unpacked && Math.Abs(compressed) <= maxValue)
                    {
                        flagsA |= UpdateFlagA.X2;
                        writer.WriteInt16((short)compressed);
                    }
                    else
                    {
                        flagsA |= UpdateFlagA.X4;
                        writer.WriteSingle(original);
                    }
                }

                //PositionY
                if (ChangedContains(changed, ChangedDelta.PositionY))
                {
                    original = t.localPosition.y;
                    compressed = original * multiplier;
                    if (localPacking != AutoPackType.Unpacked && Math.Abs(compressed) <= maxValue)
                    {
                        flagsA |= UpdateFlagA.Y2;
                        writer.WriteInt16((short)compressed);
                    }
                    else
                    {
                        flagsA |= UpdateFlagA.Y4;
                        writer.WriteSingle(original);
                    }
                }

                //PositionZ
                if (ChangedContains(changed, ChangedDelta.PositionZ))
                {
                    original = t.localPosition.z;
                    compressed = original * multiplier;
                    if (localPacking != AutoPackType.Unpacked && Math.Abs(compressed) <= maxValue)
                    {
                        flagsA |= UpdateFlagA.Z2;
                        writer.WriteInt16((short)compressed);
                    }
                    else
                    {
                        flagsA |= UpdateFlagA.Z4;
                        writer.WriteSingle(original);
                    }
                }
            }

            /* Rotation. */
            if (_synchronizeRotation)
            {
                if (ChangedContains(changed, ChangedDelta.Rotation))
                {
                    flagsA |= UpdateFlagA.Rotation;
                    /* Rotation can always use pack settings even
                     * if childed. Unsual transform scale shouldn't affect rotation. */
                    writer.WriteQuaternion(t.localRotation, _packing.Rotation);
                }
            }

            /* If there is a teleport pending then apply
             * extended flag since thats where teleport resides. */
            bool teleport = _teleport;
            if (teleport)
                changed |= ChangedDelta.Extended;

            if (ChangedContains(changed, ChangedDelta.Extended))
            {
                AutoPackType localPacking = packing.Scale;
                flagsA |= UpdateFlagA.Extended;
                int startIndexB = writer.Position;
                writer.Skip(1);

                /* Redundant to do the teleport check here since it was done
                 * just above, but for code consistency the teleport updateflag
                 * is set within this conditional with rest of the extended
                 * datas. */
                if (teleport)
                {
                    flagsB |= UpdateFlagB.Teleport;
                    _teleport = false;
                }

                /* Scale. */
                if (_synchronizeScale)
                {
                    //ScaleX
                    if (ChangedContains(changed, ChangedDelta.ScaleX))
                    {
                        original = t.localScale.x;
                        compressed = original * multiplier;
                        if (localPacking != AutoPackType.Unpacked && Math.Abs(compressed) <= maxValue)
                        {
                            flagsB |= UpdateFlagB.X2;
                            writer.WriteInt16((short)compressed);
                        }
                        else
                        {
                            flagsB |= UpdateFlagB.X4;
                            writer.WriteSingle(original);
                        }
                    }

                    //ScaleY
                    if (ChangedContains(changed, ChangedDelta.ScaleY))
                    {
                        original = t.localScale.y;
                        compressed = original * multiplier;
                        if (localPacking != AutoPackType.Unpacked && Math.Abs(compressed) <= maxValue)
                        {
                            flagsB |= UpdateFlagB.Y2;
                            writer.WriteInt16((short)compressed);
                        }
                        else
                        {
                            flagsB |= UpdateFlagB.Y4;
                            writer.WriteSingle(original);
                        }
                    }

                    //ScaleZ
                    if (ChangedContains(changed, ChangedDelta.ScaleZ))
                    {
                        original = t.localScale.z;
                        compressed = original * multiplier;
                        if (localPacking != AutoPackType.Unpacked && Math.Abs(compressed) <= maxValue)
                        {
                            flagsB |= UpdateFlagB.Z2;
                            writer.WriteInt16((short)compressed);
                        }
                        else
                        {
                            flagsB |= UpdateFlagB.Z4;
                            writer.WriteSingle(original);
                        }
                    }
                }

                //Childed.
                if (ChangedContains(changed, ChangedDelta.Nested) && ParentBehaviour != null)
                {
                    flagsB |= UpdateFlagB.Child;
                    writer.WriteNetworkBehaviour(ParentBehaviour);
                }

                writer.InsertUInt8Unpacked((byte)flagsB, startIndexB);
            }

            //Insert flags.
            writer.InsertUInt8Unpacked((byte)flagsA, startIndexA);

            bool ChangedContains(ChangedDelta whole, ChangedDelta part)
            {
                return (whole & part) == part;
            }
        }

        /// <summary>
        /// Deerializes a received packet.
        /// </summary>
        private void DeserializePacket(ArraySegment<byte> data, TransformData prevTransformData, TransformData nextTransformData, ref ChangedFull changedFull)
        {
            PooledReader reader = ReaderPool.Retrieve(data, base.NetworkManager);
            UpdateFlagA flagsA = (UpdateFlagA)reader.ReadUInt8Unpacked();

            int readerRemaining;
            readerRemaining = reader.Remaining;
            //X
            if (UpdateFlagAContains(flagsA, UpdateFlagA.X2))
                nextTransformData.Position.x = reader.ReadInt16() / 100f;
            else if (UpdateFlagAContains(flagsA, UpdateFlagA.X4))
                nextTransformData.Position.x = reader.ReadSingle();
            else
                nextTransformData.Position.x = prevTransformData.Position.x;
            //Y
            if (UpdateFlagAContains(flagsA, UpdateFlagA.Y2))
                nextTransformData.Position.y = reader.ReadInt16() / 100f;
            else if (UpdateFlagAContains(flagsA, UpdateFlagA.Y4))
                nextTransformData.Position.y = reader.ReadSingle();
            else
                nextTransformData.Position.y = prevTransformData.Position.y;
            //Z
            if (UpdateFlagAContains(flagsA, UpdateFlagA.Z2))
                nextTransformData.Position.z = reader.ReadInt16() / 100f;
            else if (UpdateFlagAContains(flagsA, UpdateFlagA.Z4))
                nextTransformData.Position.z = reader.ReadSingle();
            else
                nextTransformData.Position.z = prevTransformData.Position.z;
            //If remaining has changed then a position was read.
            if (readerRemaining != reader.Remaining)
                changedFull |= ChangedFull.Position;

            //Rotation.
            if (UpdateFlagAContains(flagsA, UpdateFlagA.Rotation))
            {
                //Always use _packing value even if childed.
                nextTransformData.Rotation = reader.ReadQuaternion(_packing.Rotation);
                changedFull |= ChangedFull.Rotation;
            }
            else
            {
                nextTransformData.Rotation = prevTransformData.Rotation;
            }

            //Extended settings.
            if (UpdateFlagAContains(flagsA, UpdateFlagA.Extended))
            {
                UpdateFlagB flagsB = (UpdateFlagB)reader.ReadUInt8Unpacked();
                readerRemaining = reader.Remaining;

                //X
                if (UpdateFlagBContains(flagsB, UpdateFlagB.X2))
                    nextTransformData.Scale.x = reader.ReadInt16() / 100f;
                else if (UpdateFlagBContains(flagsB, UpdateFlagB.X4))
                    nextTransformData.Scale.x = reader.ReadSingle();
                else
                    nextTransformData.Scale.x = prevTransformData.Scale.x;
                //Y
                if (UpdateFlagBContains(flagsB, UpdateFlagB.Y2))
                    nextTransformData.Scale.y = reader.ReadInt16() / 100f;
                else if (UpdateFlagBContains(flagsB, UpdateFlagB.Y4))
                    nextTransformData.Scale.y = reader.ReadSingle();
                else
                    nextTransformData.Scale.y = prevTransformData.Scale.y;
                //X
                if (UpdateFlagBContains(flagsB, UpdateFlagB.Z2))
                    nextTransformData.Scale.z = reader.ReadInt16() / 100f;
                else if (UpdateFlagBContains(flagsB, UpdateFlagB.Z4))
                    nextTransformData.Scale.z = reader.ReadSingle();
                else
                    nextTransformData.Scale.z = prevTransformData.Scale.z;

                if (reader.Remaining != readerRemaining)
                    changedFull |= ChangedFull.Scale;
                else
                    nextTransformData.Scale = prevTransformData.Scale;

                if (UpdateFlagBContains(flagsB, UpdateFlagB.Teleport))
                    changedFull |= ChangedFull.Teleport;

                if (UpdateFlagBContains(flagsB, UpdateFlagB.Child))
                {
                    nextTransformData.ParentBehaviour = reader.ReadNetworkBehaviour();
                    changedFull |= ChangedFull.Childed;
                }
                else
                {
                    Unnest();
                }
            }
            //No extended settings.
            else
            {
                nextTransformData.Scale = prevTransformData.Scale;
                Unnest();
            }

            void Unnest()
            {
                nextTransformData.ParentBehaviour = null;
            }

            //Returns if whole contains part.
            bool UpdateFlagAContains(UpdateFlagA whole, UpdateFlagA part)
            {
                return (whole & part) == part;
            }

            //Returns if whole contains part.
            bool UpdateFlagBContains(UpdateFlagB whole, UpdateFlagB part)
            {
                return (whole & part) == part;
            }

            reader.Store();
        }

        /// <summary>
        /// Updates the ParentBehaviour field when able to.
        /// </summary>
        private void UpdateParentBehaviour()
        {
            if (!_synchronizeParent)
                return;
            //No permissions to set.
            if (!CanControl())
                return;
            Transform parent = _cachedTransform.parent;

            //No parent.
            if (parent == null)
            {
                /* Check for being set without using nob.SetParent.
                 * Only check if was previously set inside this component; otherwise
                 * this would spam anytime the parent was null. */
                if (base.NetworkObject.RuntimeParentNetworkBehaviour != null)
                    base.NetworkManager.LogWarning($"{gameObject.name} parent object was removed without calling UnsetParent. Use networkObject.UnsetParent() to remove a NetworkObject from it's parent. This is being made a requirement in Fish-Networking v4.");

                ParentBehaviour = null;
                _parentTransform = null;
            }
            //Has a parent, see if eligible.
            else
            {
                //No change.
                if (_parentTransform == parent)
                    return;

                _parentTransform = parent;
                NetworkBehaviour outParentBehaviour;

                if (!parent.TryGetComponent(out outParentBehaviour))
                {
                    ParentBehaviour = null;
                    LogInvalidParent();
                }
                else
                {
                    ParentBehaviour = outParentBehaviour;
                    //Check for being set without using nob.SetParent.
                    if (base.NetworkObject.CurrentParentNetworkBehaviour != ParentBehaviour)
                        base.NetworkManager.LogWarning($"{gameObject.name} parent was set without calling SetParent. Use networkObject.SetParent(obj) to assign a NetworkObject a new parent. This is being made a requirement in Fish-Networking v4.");
                }
            }
        }

        /// <summary>
        /// Sets the transforms parent if it's changed.
        /// </summary>
        /// <param name="parent"></param>
        private void SetParent(NetworkBehaviour parent, RateData rd)
        {
            Transform target = (parent == null) ? null : parent.transform;
            Transform t = _cachedTransform;
            //Unchanged.
            if (target == t.parent)
                return;

            Vector3 scale = t.localScale;
            //Set parent after scale is cached so scale can be maintained after changing parent.
            if (target != null)
                base.NetworkObject.SetParent(parent);
            else
                base.NetworkObject.UnsetParent();

            t.localScale = scale;

            /* Set ratedata to immediate so there's no blending between transform values when
             * getting on or off platforms. */
            if (rd != null)
                rd.Update(-1f, -1f, -1f, rd.LastUnalteredPositionRate, rd.TickSpan, rd.TimeRemaining);
        }

        /// <summary>
        /// Moves to a GoalData. Automatically determins if to use data from server or client.
        /// </summary>
        private void MoveToTarget(float delta)
        {
            if (_currentGoalData == null)
                return;

            //Cannot move if neither is active.
            if (!base.IsServerInitialized && !base.IsClientInitialized)
                return;

            //If client auth and the owner don't move towards target.
            if (_clientAuthoritative)
            {
                if (base.IsOwner || TakenOwnership)
                    return;
            }
            else
            {
                //If not client authoritative, is owner, and don't sync to owner.
                if (base.IsOwner && !_sendToOwner)
                    return;
            }

            //True if not client controlled.
            bool controlledByClient = (_clientAuthoritative && base.Owner.IsActive);
            //If not controlled by client and is server then no reason to move.
            if (!controlledByClient && base.IsServerInitialized)
                return;

            /* Once here it's safe to assume the object will be moving.
             * Any checks which would stop it from moving be it client
             * auth and owner, or server controlled and server, ect,
             * would have already been run. */
            TransformData td = _currentGoalData.Transforms;
            RateData rd = _currentGoalData.Rates;

            //Set parent.
            if (_synchronizeParent)
                SetParent(td.ParentBehaviour, rd);

            float multiplier = 1f;
            int queueCount = _goalDataQueue.Count;
            //Increase move rate slightly if over queue count.
            if (queueCount > (_interpolation + 1))
                multiplier += 0.05f;

            //Rate to update. Changes per property.
            float rate;
            Transform t = _cachedTransform;

            //Snap any bits of the transform that should be.
            SnapProperties(td);

            //Position.
            if (_synchronizePosition)
            {
                rate = rd.Position;
                Vector3 posGoal = (td.ExtrapolationState == TransformData.ExtrapolateState.Active && !_lastReceiveReliable) ? td.ExtrapolatedPosition : td.Position;
                // ReSharper disable once CompareOfFloatsByEqualityOperator
                if (rate == -1f)
                    t.localPosition = td.Position;
                else
                    t.localPosition = Vector3.MoveTowards(t.localPosition, posGoal, rate * delta * multiplier);
            }

            //Rotation.
            if (_synchronizeRotation)
            {
                rate = rd.Rotation;
                // ReSharper disable once CompareOfFloatsByEqualityOperator
                if (rate == -1f)
                    t.localRotation = td.Rotation;
                else
                    t.localRotation = Quaternion.RotateTowards(t.localRotation, td.Rotation, rate * delta);
            }

            //Scale.
            if (_synchronizeScale)
            {
                rate = rd.Scale;
                // ReSharper disable once CompareOfFloatsByEqualityOperator
                if (rate == -1f)
                    t.localScale = td.Scale;
                else
                    t.localScale = Vector3.MoveTowards(t.localScale, td.Scale, rate * delta);
            }

            float timeRemaining = rd.TimeRemaining - (delta * multiplier);
            if (timeRemaining < -delta)
                timeRemaining = -delta;
            rd.TimeRemaining = timeRemaining;

            if (rd.TimeRemaining <= 0f)
            {
                float leftOver = Mathf.Abs(rd.TimeRemaining);
                //If more in buffer then run next buffer.
                if (queueCount > 0)
                {
                    SetCurrentGoalData(_goalDataQueue.Dequeue());
                    if (leftOver > 0f)
                        MoveToTarget(leftOver);
                }
                //No more in buffer, see if can extrapolate.
                else
                {
                    
                        /* If everything matches up then end queue.
                         * Otherwise let it play out until stuff
                         * aligns. Generally the time remaining is enough
                         * but every once in awhile something goes funky
                         * and it's thrown off. */
                        if (!HasChanged(td))
                            _currentGoalData = null;
                        OnInterpolationComplete?.Invoke();
                        
                }
            }
        }

        /// <summary>
        /// Sends transform data to clients if needed.
        /// </summary>
        private void SendToClients()
        {
            //True if clientAuthoritative and there is an owner.
            bool clientAuthoritativeWithOwner = (_clientAuthoritative && base.Owner.IsValid);
            //Channel to send rpc on.
            Channel channel = Channel.Unreliable;
            /* If relaying from client and owner isnt clientHost.
             * If owner is clientHost just send current server values. */
            if (clientAuthoritativeWithOwner && !base.Owner.IsLocalClient)
            {
                /* If there is not new data yet and the last received was not reliable
                 * then a packet maybe did not arrive when expected. See if we need
                 * to force a reliable with the last data based on ticks passed since
                 * last update.*/
                if (!_authoritativeClientData.HasData && _authoritativeClientData.Channel != Channel.Reliable && _authoritativeClientData.Writer != null)
                {
                    /* If ticks have passed beyond interpolation then force
                     * to send reliably. */
                    uint maxPassedTicks = (uint)(1 + _interpolation + _extrapolation);
                    uint localTick = _timeManager.LocalTick;
                    if ((localTick - _authoritativeClientData.LocalTick) > maxPassedTicks)
                        _authoritativeClientData.SendReliably();
                    //Not enough time to send reliably, just don't need update.
                    else
                        return;
                }

                if (_authoritativeClientData.HasData)
                {
                    _changedSinceStart = true;
                    //Resend data from clients.
                    ObserversUpdateClientAuthoritativeTransform(_authoritativeClientData.Writer.GetArraySegment(), _authoritativeClientData.Channel);
                    //Now being sent data can unset.
                    _authoritativeClientData.HasData = false;
                }
            }
            //Sending server transform state.
            else
            {
                PooledWriter writer = _toClientChangedWriter;

                TransformData lastSentData = _lastSentTransformData;
                ChangedDelta changed = GetChanged(lastSentData);

                //If no change.
                if (changed == ChangedDelta.Unset)
                {
                    //No changes since last reliable; transform is up to date.
                    if (_serverChangedSinceReliable == ChangedDelta.Unset)
                        return;

                    _serverChangedSinceReliable = ChangedDelta.Unset;
                    writer = _toClientChangedWriter;
                    /* If here then current is unset but last was not.
                     * Send last as reliable so clients have the latest sent through. */
                    channel = Channel.Reliable;
                }
                //There is change.
                else
                {
                    //Since this is writing new data, reset the writer.
                    writer.Clear();

                    _serverChangedSinceReliable |= changed;

                    _changedSinceStart = true;
                    Transform t = _cachedTransform;
                    /* If here a send for transform values will occur. Update last values.
                     * Tick doesn't need to be set for whoever controls transform. */
                    lastSentData.Update(0, t.localPosition, t.localRotation, t.localScale, t.localPosition, ParentBehaviour);
                    SerializeChanged(changed, writer);
                }

                ObserversUpdateClientAuthoritativeTransform(writer.GetArraySegment(), channel);
            }
        }

        /// <summary>
        /// Sends transform data to server if needed.
        /// </summary>
        private void SendToServer(TransformData lastSentTransformData)
        {
            /* ClientHost does not need to send to the server.
             * Ideally this would still occur and the data be ignored
             * for statistics tracking but to keep the code more simple
             * we won't be doing that. Server out however still is tracked,
             * which is generally considered more important data. */
            if (base.IsServerInitialized)
                return;

            //Not client auth or not owner.
            if (!_clientAuthoritative || !base.IsOwner)
                return;

            //Channel to send on.
            Channel channel = Channel.Unreliable;
            //Values changed since last check.
            ChangedDelta changed = GetChanged(lastSentTransformData);

            //If no change.
            if (changed == ChangedDelta.Unset)
            {
                //No changes since last reliable; transform is up to date.
                if (_clientChangedSinceReliable == ChangedDelta.Unset)
                    return;

                //Set changed to all changes over time and unset changes over time.
                changed = _clientChangedSinceReliable;
                _clientChangedSinceReliable = ChangedDelta.Unset;
                channel = Channel.Reliable;
            }
            //There is change.
            else
            {
                _clientChangedSinceReliable |= changed;
            }

            /* If here a send for transform values will occur. Update last values.
             * Tick doesn't need to be set for whoever controls transform. */
            Transform t = _cachedTransform;
            lastSentTransformData.Update(0, t.localPosition, t.localRotation, t.localScale, t.localPosition, ParentBehaviour);

            //Send latest.
            PooledWriter writer = WriterPool.Retrieve();
            SerializeChanged(changed, writer);
            ServerUpdateTransform(writer.GetArraySegment(), channel);

            writer.Store();
        }

        #region GetChanged.
        /// <summary>
        /// Returns if the transform differs from td.
        /// </summary>
        private bool HasChanged(TransformData td)
        {
            Transform t = _cachedTransform;
            bool changed = (td.Position != t.localPosition || td.Rotation != t.localRotation || td.Scale != t.localScale);

            return changed;
        }

        /// <summary>
        /// Returns if there is any change between two datas.
        /// </summary>
        private bool HasChanged(TransformData a, TransformData b)
        {
            return (a.Position != b.Position) || (a.Rotation != b.Rotation) || (a.Scale != b.Scale) || (a.ParentBehaviour != b.ParentBehaviour);
        }
        ///// <summary>
        ///// Returns if there is any change between two datas and outputs what has changed.
        ///// </summary>
        //private bool HasChanged(TransformData a, TransformData b, ref ChangedFull changedFull)
        //{
        //    bool hasChanged = false;

        //    if (a.Position != b.Position)
        //    {
        //        hasChanged = true;
        //        changedFull |= ChangedFull.Position;
        //    }
        //    if (a.Rotation != b.Rotation)
        //    {
        //        hasChanged = true;
        //        changedFull |= ChangedFull.Rotation;
        //    }
        //    if (a.Scale != b.Scale)
        //    {
        //        hasChanged = true;
        //        changedFull |= ChangedFull.Scale;
        //    }
        //    if (a.ParentBehaviour != b.ParentBehaviour)
        //    {
        //        hasChanged = true;
        //        changedFull |= ChangedFull.Childed;
        //    }

        //    return hasChanged;
        //}
        /// <summary>
        /// Gets transform values that have changed against goalData.
        /// </summary>
        private ChangedDelta GetChanged(TransformData transformData)
        {
            //If default return full changed.
            if (transformData == null || transformData.IsDefault)
                return _fullChanged;

            /* If parent behaviour exist.
             * Parent isn't sent as a delta so
             * if it exist always send regardless
             * of the previously sent transform
             * data. */
            return GetChanged(transformData.Position, transformData.Rotation, transformData.Scale, transformData.ParentBehaviour);
        }

        /// <summary>
        /// Gets transform values that have changed against specified proprties.
        /// </summary>
        private ChangedDelta GetChanged(Vector3 lastPosition, Quaternion lastRotation, Vector3 lastScale, NetworkBehaviour lastParentBehaviour)
        {
            ChangedDelta changed = ChangedDelta.Unset;
            Transform t = _cachedTransform;

            Vector3 position = t.localPosition;
            if (Mathf.Abs(position.x - lastPosition.x) >= 0.001f)
                changed |= ChangedDelta.PositionX;
            if (Mathf.Abs(position.y - lastPosition.y) >= 0.001f)
                changed |= ChangedDelta.PositionY;
            if (Mathf.Abs(position.z - lastPosition.z) >= 0.001f)
                changed |= ChangedDelta.PositionZ;

            Quaternion rotation = t.localRotation;
            if (!rotation.Matches(lastRotation, true))
                changed |= ChangedDelta.Rotation;

            ChangedDelta startChanged;
            startChanged = changed;

            Vector3 scale = t.localScale;
            if (Mathf.Abs(scale.x - lastScale.x) >= 0.001f)
                changed |= ChangedDelta.ScaleX;
            if (Mathf.Abs(scale.y - lastScale.y) >= 0.001f)
                changed |= ChangedDelta.ScaleY;
            if (Mathf.Abs(scale.z - lastScale.z) >= 0.001f)
                changed |= ChangedDelta.ScaleZ;

            if (changed != ChangedDelta.Unset && ParentBehaviour != null)
                changed |= ChangedDelta.Nested;

            //If added scale or childed then also add extended.
            if (startChanged != changed)
                changed |= ChangedDelta.Extended;

            return changed;
        }
        #endregion

        #region Rates.
        /// <summary>
        /// Snaps transform properties using snapping settings.
        /// </summary>
        private void SnapProperties(TransformData transformData, bool force = false)
        {
            //Already snapped.
            if (transformData.SnappingChecked)
                return;

            transformData.SnappingChecked = true;
            Transform t = _cachedTransform;

            //Position.
            if (_synchronizePosition)
            {
                Vector3 startPosition = t.localPosition;
                Vector3 position;
                position.x = (force || _positionSnapping.X) ? transformData.Position.x : t.localPosition.x;
                position.y = (force || _positionSnapping.Y) ? transformData.Position.y : t.localPosition.y;
                position.z = (force || _positionSnapping.Z) ? transformData.Position.z : t.localPosition.z;
                t.localPosition = position;
            }

            //Rotation.
            if (_synchronizeRotation)
            {
                Vector3 eulers;
                Vector3 goalEulers = transformData.Rotation.eulerAngles;
                eulers.x = (force || _rotationSnapping.X) ? goalEulers.x : t.localEulerAngles.x;
                eulers.y = (force || _rotationSnapping.Y) ? goalEulers.y : t.localEulerAngles.y;
                eulers.z = (force || _rotationSnapping.Z) ? goalEulers.z : t.localEulerAngles.z;
                t.localEulerAngles = eulers;
            }

            //Scale.
            if (_synchronizeScale)
            {
                Vector3 scale;
                scale.x = (force || _scaleSnapping.X) ? transformData.Scale.x : t.localScale.x;
                scale.y = (force || _scaleSnapping.Y) ? transformData.Scale.y : t.localScale.y;
                scale.z = (force || _scaleSnapping.Z) ? transformData.Scale.z : t.localScale.z;
                t.localScale = scale;
            }
        }

        /// <summary>
        /// Sets move rates which will occur instantly.
        /// </summary>
        private void SetInstantRates(RateData rd, uint tickDifference, float timeRemaining)
        {
            //Was default to 1 tickDiff and -1 time remaining.
            rd.Update(-1f, -1f, -1f, -1f, tickDifference, timeRemaining);
        }

        /// <summary>
        /// Sets move rates which will occur over time.
        /// </summary>
        private void SetCalculatedRates(TransformData prevTd, RateData prevRd, GoalData nextGd, ChangedFull changedFull, bool hasChanged, Channel channel)
        {
            /* Only update rates if data has changed.
             * When data comes in reliably for eventual consistency
             * it's possible that it will be the same as the last
             * unreliable packet. When this happens no change has occurred
             * and the distance of change woudl also be 0; this prevents
             * the NT from moving. Only need to compare data if channel is reliable. */
            TransformData td = nextGd.Transforms;
            if (channel == Channel.Reliable && !hasChanged)
            {
                nextGd.Rates.Update(prevRd);
                return;
            }

            float timePassed;
            uint tickDifference = GetTickDifference(prevTd, nextGd, 1, out timePassed);

            //Distance between properties.
            float distance;
            float positionRate = 0f;
            float rotationRate = 0f;
            float scaleRate = 0f;

            RateData rd = nextGd.Rates;

            //Quick exit/check for teleport.
            if (ChangedFullContains(changedFull, ChangedFull.Teleport))
            {
                SetInstantRates(rd, tickDifference, timePassed);
                return;
            }

            //Correction to apply towards rates when a rate change is detected as abnormal.
            float abnormalCorrection = 1f;
            float unalteredPositionRate = rd.LastUnalteredPositionRate;

            //Position.
            if (ChangedFullContains(changedFull, ChangedFull.Position))
            {
                Vector3 lastPosition = prevTd.Position;
                distance = Vector3.Distance(lastPosition, td.Position);

                //If distance teleports assume rest do.
                if (_enableTeleport)
                {
                    //Over threshold.
                    if (distance >= _teleportThreshold)
                    {
                        SetInstantRates(rd, tickDifference, timePassed);
                        return;
                    }
                }

                //Check to teleport only position due to low distance.
                if (LowDistance(distance, false))
                {
                    unalteredPositionRate = -1f;
                    positionRate = -1f;
                }
                else
                {
                    //Check position rates now.
                    //Position distance already calculated.
                    unalteredPositionRate = distance / timePassed;
                    /* Try to detect abnormal rate changes.
                     *
                     * This won't occur if the user
                     * is moving using the tick system but will likely happen when the transform
                     * is being moved in update.
                     *
                     * Update will iterate a varying amount of times per tick,
                     * which will result in distances being slightly different. This is
                     * rarely an issue when the frame rate is high and the distance
                     * variance is very little, but for games which are running at about
                     * the same frame rate as the tick it's possible the object will
                     * move twice the distance every few ticks. EG: if running 60 fps/50 tick.
                     * Execution may look like this..
                     * frame, tick, frame, tick, frame, frame, tick. The frame, frame would
                     * result in double movement distance. */

                    //If last position rate is known then compare against it.
                    if (unalteredPositionRate > 0f && rd.LastUnalteredPositionRate > 0f)
                    {
                        float percentage = Mathf.Abs(1f - (unalteredPositionRate / rd.LastUnalteredPositionRate));
                        /* If percentage change is more than 25% then speed is considered
                         * to have changed drastically. */
                        if (percentage > 0.25f)
                        {
                            float c = (rd.LastUnalteredPositionRate / unalteredPositionRate);
                            /* Sometimes stop and goes can incorrectly trigger
                             * an abnormal detection. Fortunately abnornalties tend
                             * to either skip a tick or send twice in one tick.
                             * Because of this it's fairly safe to assume that if the calculated
                             * correction is not ~0.5f or ~2f then it's a false detection. */
                            float allowedDifference = 0.1f;
                            if ((c < 1f && Mathf.Abs(0.5f - c) < allowedDifference) || (c > 1f && Mathf.Abs(2f - c) < allowedDifference))
                            {
                                abnormalCorrection = c;
                            }
                            /* If an abnormality has been marked then assume new rate
                             * is proper. When an abnormal rate occurs unintentionally
                             * the values will fix themselves next tick, therefor when
                             * rate changes drastically twice assume its intentional or
                             * that the rate had simply fixed itself, both which would unset
                             * abnormal rate detected. */
                        }
                    }

                    //abnormalCorrection = 1f;
                    positionRate = (unalteredPositionRate * abnormalCorrection);
                    if (positionRate <= 0f)
                        positionRate = -1f;
                }
            }

            //Rotation.
            if (ChangedFullContains(changedFull, ChangedFull.Rotation))
            {
                Quaternion lastRotation = prevTd.Rotation;
                distance = lastRotation.Angle(td.Rotation, true);
                if (LowDistance(distance, true))
                {
                    rotationRate = -1f;
                }
                else
                {
                    rotationRate = (distance / timePassed) * abnormalCorrection;
                    if (rotationRate <= 0f)
                        rotationRate = -1f;
                }
            }

            //Scale.
            if (ChangedFullContains(changedFull, ChangedFull.Scale))
            {
                Vector3 lastScale = prevTd.Scale;
                distance = Vector3.Distance(lastScale, td.Scale);
                if (LowDistance(distance, false))
                {
                    scaleRate = -1f;
                }
                else
                {
                    scaleRate = (distance / timePassed) * abnormalCorrection;
                    if (scaleRate <= 0f)
                        scaleRate = -1f;
                }
            }

            rd.Update(positionRate, rotationRate, scaleRate, unalteredPositionRate, tickDifference, timePassed);

            //Returns if whole contains part.
            bool ChangedFullContains(ChangedFull whole, ChangedFull part)
            {
                return (whole & part) == part;
            }

            /* Returns if the provided distance is extremely small.
             * This is used to decide if a property should be teleported.
             * When distances are exceptionally small smoothing rate
             * calculations may result as an invalid value. */
            bool LowDistance(float dist, bool rotation)
            {
                if (rotation)
                    return (dist < 1f);
                else
                    return (dist < 0.0001f);
            }
        }

        /// <summary>
        /// Gets the tick difference between two GoalDatas.
        /// </summary>
        private uint GetTickDifference(TransformData prevTd, GoalData nextGd, uint minimum, out float timePassed)
        {
            TransformData nextTd = nextGd.Transforms;

            uint lastTick = prevTd.Tick;
            /* Ticks passed between datas. If 0 then the last data
             * was either not set or reliable, in which case the tick
             * difference should be considered 1. */
            if (lastTick == 0)
                lastTick = (nextTd.Tick - _interval);

            long tickDifference = (nextTd.Tick - lastTick);
            if (tickDifference < minimum)
                tickDifference = minimum;

            timePassed = (float)base.NetworkManager.TimeManager.TicksToTime((uint)tickDifference);
            return (uint)tickDifference;
        }
        #endregion

        /// <summary>
        /// Sets extrapolation data on next.
        /// </summary>
        private void SetExtrapolation(TransformData prev, TransformData next, Channel channel)
        {
            //Default value.
            next.ExtrapolationState = TransformData.ExtrapolateState.Disabled;

            
        }

        /// <summary>
        /// Updates a client with transform data.
        /// </summary>
        [TargetRpc(ValidateTarget = false)]
        private void TargetUpdateTransform(NetworkConnection conn, ArraySegment<byte> data, Channel channel)
        {
#if DEVELOPMENT
            //If receiver is client host then do nothing, clientHost need not process.
            if (base.IsServerInitialized && conn.IsLocalClient)
                return;
#endif
            /* Zero data was sent, this should not be possible.
             * This is a patch to a NetworkLOD bug until it can
             * be resolved properly. */
            if (data.Count == 0)
                return;

            DataReceived(data, channel, false);
        }

        /// <summary>
        /// Updates clients with transform data.
        /// </summary>
        [ObserversRpc]
        private void ObserversUpdateClientAuthoritativeTransform(ArraySegment<byte> data, Channel channel)
        {
            if (!_clientAuthoritative && base.IsOwner && !_sendToOwner)
                return;
            if (_clientAuthoritative && base.IsOwner)
                return;
            if (base.IsServerInitialized)
                return;
            //Not new data.
            uint lastPacketTick = _timeManager.LastPacketTick.LastRemoteTick;
            if (lastPacketTick <= _lastObserversRpcTick)
                return;

            _lastObserversRpcTick = lastPacketTick;
            DataReceived(data, channel, false);
        }

        /// <summary>
        /// Updates the transform on the server.
        /// </summary>
        [ServerRpc]
        private void ServerUpdateTransform(ArraySegment<byte> data, Channel channel)
        {
            if (!_clientAuthoritative)
            {
                base.Owner.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Connection Id {base.Owner.ClientId} has been kicked for trying to update this object without client authority.");
                return;
            }

            TimeManager tm = base.TimeManager;
            //Not new data.
            uint lastPacketTick = tm.LastPacketTick.LastRemoteTick;
            if (lastPacketTick <= _lastServerRpcTick)
                return;
            _lastServerRpcTick = lastPacketTick;

            _authoritativeClientData.Update(data, channel, updateHasData: true, tm.LocalTick);
            DataReceived(data, channel, true);
        }

        /// <summary>
        /// Processes received data for lcients and server.
        /// </summary>
        private void DataReceived(ArraySegment<byte> data, Channel channel, bool asServer)
        {
            if (base.IsDeinitializing)
                return;

            TransformData prevTd = (asServer) ? _lastReceivedClientTransformData : _lastReceivedServerTransformData;
            RateData prevRd = _lastCalculatedRateData;

            ChangedFull changedFull = ChangedFull.Unset;
            GoalData nextGd = ResettableObjectCaches<GoalData>.Retrieve();
            TransformData nextTd = nextGd.Transforms;
            UpdateTransformData(data, prevTd, nextTd, ref changedFull);

            OnDataReceived?.Invoke(prevTd, nextTd);
            SetExtrapolation(prevTd, nextTd, channel);

            bool hasChanged = HasChanged(prevTd, nextTd);

            //If server only teleport.
            if (asServer && !base.IsClientStarted)
            {
                uint tickDifference = GetTickDifference(prevTd, nextGd, 1, out float timePassed);
                SetInstantRates(nextGd.Rates, tickDifference, timePassed);
            }
            //Otherwise use timed.
            else
            {
                SetCalculatedRates(prevTd, prevRd, nextGd, changedFull, hasChanged, channel);
            }

            _lastReceiveReliable = (channel == Channel.Reliable);
            /* If channel is reliable then this is a settled packet.
             * Set tick to UNSET. When this occurs time calculations
             * assume only 1 tick has passed. */
            if (channel == Channel.Reliable)
                nextTd.Tick = Managing.Timing.TimeManager.UNSET_TICK;

            prevTd.Update(nextTd);
            prevRd.Update(nextGd.Rates);

            nextGd.ReceivedTick = _timeManager.LocalTick;

            bool currentDataNull = (_currentGoalData == null);
            /* If extrapolating then immediately break the extrapolation
             * in favor of newest results. This will keep the buffer
             * at 0 until the transform settles but the only other option is
             * to stop the movement, which would defeat purpose of extrapolation,
             * or slow down the transform while buffer rebuilds. Neither choice
             * is great but later on I might try slowing down the transform slightly
             * to give the buffer a chance to rebuild. */
            if (!currentDataNull && _currentGoalData.Transforms.ExtrapolationState == TransformData.ExtrapolateState.Active)
            {
                SetCurrentGoalData(nextGd);
            }
            /* If queue isn't started and its buffered enough
             * to satisfy interpolation then set ready
             * and set current data.
             *
             * Also if reliable then begin moving. */
            else if (currentDataNull && _goalDataQueue.Count >= _interpolation || channel == Channel.Reliable)
            {
                if (_goalDataQueue.Count > 0)
                {
                    SetCurrentGoalData(_goalDataQueue.Dequeue());
                    /* If is reliable and has changed then also
                     * enqueue latest. */
                    if (hasChanged)
                        _goalDataQueue.Enqueue(nextGd);
                }
                else
                {
                    SetCurrentGoalData(nextGd);
                }
            }
            /* If here then there's not enough in buffer to begin
             * so add onto the buffer. */
            else
            {
                _goalDataQueue.Enqueue(nextGd);
            }

            /* If the queue is excessive beyond interpolation then
             * dequeue extras to prevent from dropping behind too
             * quickly. This shouldn't be an issue with normal movement
             * as the NT speeds up if the buffer unexpectedly grows, but
             * when connections are unstable results may come in chunks
             * and for a better experience the older parts of the chunks
             * will be dropped. */
            if (_goalDataQueue.Count > (_interpolation + 3))
            {
                while (_goalDataQueue.Count > _interpolation)
                {
                    GoalData tmpGd = _goalDataQueue.Dequeue();
                    ResettableObjectCaches<GoalData>.Store(tmpGd);
                }

                //Snap to the next data to fix any smoothing timings.
                SetCurrentGoalData(_goalDataQueue.Dequeue());
                SetInstantRates(_currentGoalData!.Rates, 1, -1f);
                SnapProperties(_currentGoalData.Transforms, true);
            }
        }

        /// <summary>
        /// Sets CurrentGoalData value.
        /// </summary>
        private void SetCurrentGoalData(GoalData data)
        {
            if (_currentGoalData != null)
                ResettableObjectCaches<GoalData>.Store(_currentGoalData);

            _currentGoalData = data;
            OnNextGoal?.Invoke(data);
        }

        /// <summary>
        /// Updates a TransformData from packetData.
        /// </summary>
        private void UpdateTransformData(ArraySegment<byte> packetData, TransformData prevTransformData, TransformData nextTransformData, ref ChangedFull changedFull)
        {
            DeserializePacket(packetData, prevTransformData, nextTransformData, ref changedFull);
            nextTransformData.Tick = _timeManager.LastPacketTick.LastRemoteTick;
        }

        /// <summary>
        /// Configures this NetworkTransform for CSP.
        /// </summary>
        internal void ConfigureForPrediction(PredictionType predictionType)
        {
            _clientAuthoritative = false;
            _sendToOwner = false;

            //Do not try to change component configuration if its already specified.
            if (_componentConfiguration != ComponentConfigurationType.Disabled)
            {
                if (predictionType == PredictionType.Rigidbody)
                    _componentConfiguration = ComponentConfigurationType.Rigidbody;
                else if (predictionType == PredictionType.Rigidbody2D)
                    _componentConfiguration = ComponentConfigurationType.Rigidbody2D;
                else if (predictionType == PredictionType.Other)
                    /* If other or CC then needs to be configured.
                     * When CC it will be configured properly, if there
                     * is no CC then no action will be taken. */
                    _componentConfiguration = ComponentConfigurationType.CharacterController;
            }

            ConfigureComponents();
        }

        /// <summary>
        /// Updates which properties are synchronized.
        /// </summary>
        /// <param name="value">Properties to synchronize.</param>
        public void SetSynchronizedProperties(SynchronizedProperty value)
        {
            //If sending from the server.
            if (base.IsServerInitialized)
            {
                //If no owner, or not client auth.
                if (base.IsController || !_clientAuthoritative)
                    ObserversSetSynchronizedProperties(value);
                else
                    return;
            }
            //Sending from client.
            else if (_clientAuthoritative && base.IsOwner)
            {
                ServerSetSynchronizedProperties(value);
            }
            //Cannot change.
            else
            {
                return;
            }

            //Update locally.
            SetSynchronizedPropertiesInternal(value);
        }

        /// <summary>
        /// Sets synchronized values based on value.
        /// </summary>
        [ServerRpc]
        private void ServerSetSynchronizedProperties(SynchronizedProperty value)
        {
            if (!_clientAuthoritative)
            {
                base.Owner.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Connection Id {base.Owner.ClientId} has been kicked for trying to update this object without client authority.");
                return;
            }

            SetSynchronizedPropertiesInternal(value);
            //Send to observers.
            ObserversSetSynchronizedProperties(value);
        }

        /// <summary>
        /// Sets synchronized values based on value.
        /// </summary>
        [ObserversRpc(BufferLast = true, ExcludeServer = true)]
        private void ObserversSetSynchronizedProperties(SynchronizedProperty value)
        {
            SetSynchronizedPropertiesInternal(value);
        }

        /// <summary>
        /// Sets synchronized values based on value.
        /// </summary>
        private void SetSynchronizedPropertiesInternal(SynchronizedProperty value)
        {
            _synchronizeParent = SynchronizedPropertyContains(value, SynchronizedProperty.Parent);
            _synchronizePosition = SynchronizedPropertyContains(value, SynchronizedProperty.Position);
            _synchronizeRotation = SynchronizedPropertyContains(value, SynchronizedProperty.Rotation);
            _synchronizeScale = SynchronizedPropertyContains(value, SynchronizedProperty.Scale);

            bool SynchronizedPropertyContains(SynchronizedProperty whole, SynchronizedProperty part)
            {
                return (whole & part) == part;
            }
        }

        /// <summary>
        /// Deinitializes this component.
        /// </summary>
        private void ResetState()
        {
            _teleport = false;
            ChangeTickSubscription(false);
            /* Reset server and client side since this is called from
             * OnStopNetwork. */

            _lastObserversRpcTick = TimeManager.UNSET_TICK;
            _authoritativeClientData.ResetState();

            WriterPool.StoreAndDefault(ref _toClientChangedWriter);

            ObjectCaches<bool>.StoreAndDefault(ref _authoritativeClientData.HasData);
            ObjectCaches<ChangedDelta>.StoreAndDefault(ref _serverChangedSinceReliable);

            ResettableObjectCaches<TransformData>.StoreAndDefault(ref _lastReceivedClientTransformData);
            ResettableObjectCaches<TransformData>.StoreAndDefault(ref _lastReceivedServerTransformData);
            //Goaldatas. Would only exist if client or clientHost.
            while (_goalDataQueue.Count > 0)
                ResettableObjectCaches<GoalData>.Store(_goalDataQueue.Dequeue());

            if (_lastSentTransformData != null)
                _lastSentTransformData.ResetState();
            ResettableObjectCaches<GoalData>.StoreAndDefault(ref _currentGoalData);
        }

        /// <summary>
        /// Deinitializes this component for OnDestroy.
        /// </summary>
        private void ResetState_OnDestroy()
        {
            ResettableObjectCaches<TransformData>.StoreAndDefault(ref _lastSentTransformData);
            WriterPool.StoreAndDefault(ref _toClientChangedWriter);
        }
    }
}﻿namespace FishNet.Component.Transforming
{
    [System.Flags]
    public enum SynchronizedProperty : byte
    {
        None = 0,
        Parent = 1,
        Position = 2,
        Rotation = 4,
        Scale = 8
    }
}﻿#if UNITY_EDITOR
using FishNet.Editing;
using GameKit.Dependencies.Utilities;
using UnityEditor;
using UnityEngine;
using LayoutTools = GameKit.Dependencies.Utilities.EditorGuiLayoutTools;


namespace FishNet.Component.Transforming.Editing
{
    [CustomEditor(typeof(NetworkTransform), true)]
    [CanEditMultipleObjects]
    public class NetworkTransformEditor : Editor
    {
        private SerializedProperty _componentConfiguration;
        private SerializedProperty _synchronizeParent;
        private SerializedProperty _packing;
        private SerializedProperty _interpolation;
        private SerializedProperty _extrapolation;
        private SerializedProperty _enableTeleport;
        private SerializedProperty _teleportThreshold;
        private SerializedProperty _clientAuthoritative;
        private SerializedProperty _sendToOwner;
        private SerializedProperty _interval;
        private SerializedProperty _synchronizePosition;
        private SerializedProperty _positionSnapping;
        private SerializedProperty _synchronizeRotation;
        private SerializedProperty _rotationSnapping;
        private SerializedProperty _synchronizeScale;
        private SerializedProperty _scaleSnapping;


        protected virtual void OnEnable()
        {
            _componentConfiguration = serializedObject.FindProperty(nameof(_componentConfiguration));
            _synchronizeParent = serializedObject.FindProperty("_synchronizeParent");
            _packing = serializedObject.FindProperty("_packing");
            _interpolation = serializedObject.FindProperty("_interpolation");
            _extrapolation = serializedObject.FindProperty("_extrapolation");
            _enableTeleport = serializedObject.FindProperty("_enableTeleport");
            _teleportThreshold = serializedObject.FindProperty("_teleportThreshold");
            _clientAuthoritative = serializedObject.FindProperty("_clientAuthoritative");
            _sendToOwner = serializedObject.FindProperty("_sendToOwner");
            _interval = serializedObject.FindProperty(nameof(_interval));
            _synchronizePosition = serializedObject.FindProperty("_synchronizePosition");
            _positionSnapping = serializedObject.FindProperty("_positionSnapping");
            _synchronizeRotation = serializedObject.FindProperty("_synchronizeRotation");
            _rotationSnapping = serializedObject.FindProperty("_rotationSnapping");
            _synchronizeScale = serializedObject.FindProperty("_synchronizeScale");
            _scaleSnapping = serializedObject.FindProperty("_scaleSnapping");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            LayoutTools.AddObjectField("Script:", MonoScript.FromMonoBehaviour((NetworkTransform)target), typeof(NetworkTransform), false, EditorLayoutEnableType.Disabled);

            bool isPro = false;
            
            if (isPro)
                EditorGUILayout.HelpBox(EditingConstants.PRO_ASSETS_UNLOCKED_TEXT, MessageType.None);
            else
                EditorGUILayout.HelpBox(EditingConstants.PRO_ASSETS_LOCKED_TEXT, MessageType.Warning);

            //Misc.
            EditorGUILayout.LabelField("Misc", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_componentConfiguration);
            EditorGUILayout.PropertyField(_synchronizeParent, new GUIContent("Synchronize Parent"));
            EditorGUILayout.PropertyField(_packing);
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Smoothing.
            EditorGUILayout.LabelField("Smoothing", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_interpolation);
            EditorGUILayout.PropertyField(_extrapolation, new GUIContent("* Extrapolation"));
            EditorGUILayout.PropertyField(_enableTeleport);
            if (_enableTeleport.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_teleportThreshold);
                EditorGUI.indentLevel--;
            }

            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Authority.
            EditorGUILayout.LabelField("Authority", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_clientAuthoritative);
            if (!_clientAuthoritative.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_sendToOwner);
                EditorGUI.indentLevel--;
            }

            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Synchronizing.
            EditorGUILayout.LabelField("Synchronizing.", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            //Interval.
            EditorGUILayout.PropertyField(_interval, new GUIContent("Send Interval"));
            //Position.
            EditorGUILayout.PropertyField(_synchronizePosition);
            if (_synchronizePosition.boolValue)
            {
                EditorGUI.indentLevel += 2;
                EditorGUILayout.PropertyField(_positionSnapping);
                EditorGUI.indentLevel -= 2;
            }

            //Rotation.
            EditorGUILayout.PropertyField(_synchronizeRotation);
            if (_synchronizeRotation.boolValue)
            {
                EditorGUI.indentLevel += 2;
                EditorGUILayout.PropertyField(_rotationSnapping);
                EditorGUI.indentLevel -= 2;
            }

            //Scale.
            EditorGUILayout.PropertyField(_synchronizeScale);
            if (_synchronizeScale.boolValue)
            {
                EditorGUI.indentLevel += 2;
                EditorGUILayout.PropertyField(_scaleSnapping);
                EditorGUI.indentLevel -= 2;
            }

            EditorGUI.indentLevel--;

            serializedObject.ApplyModifiedProperties();
        }
    }
}
#endifusing FishNet.Object;
using GameKit.Dependencies.Utilities;
using GameKit.Dependencies.Utilities.Types;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;
using TimeManagerCls = FishNet.Managing.Timing.TimeManager;

namespace FishNet.Component.Prediction
{
    public abstract class NetworkCollider : NetworkBehaviour
    {
        #region Types.
        private struct CollisionData
        {
            /// <summary>
            /// Tick when entering collision.
            /// </summary>
            public uint EnterTick;
            /// <summary>
            /// Tick when exiting collision.
            /// </summary>
            public uint ExitTick;

            public CollisionData(uint enterTick) : this()
            {
                EnterTick = enterTick;
                ExitTick = FishNet.Managing.Timing.TimeManager.UNSET_TICK;
            }

            public CollisionData(uint enterTick, uint exitTick) : this()
            {
                EnterTick = enterTick;
                ExitTick = exitTick;
            }
        }
        #endregion

        /// <summary>
        /// Called when another collider enters this collider.
        /// </summary>
        public event Action<Collider> OnEnter;
        /// <summary>
        /// Called when another collider stays in this collider.
        /// </summary>
        public event Action<Collider> OnStay;
        /// <summary>
        /// Called when another collider exits this collider.
        /// </summary>
        public event Action<Collider> OnExit;
        /// <summary>
        /// True to run collisions for colliders which are triggers, false to run collisions for colliders which are not triggers.
        /// </summary>
        [HideInInspector]
        protected bool IsTrigger;
        /// <summary>
        /// Maximum number of simultaneous hits to check for. Larger values decrease performance but allow detection to work for more overlapping colliders. Typically the default value of 16 is more than sufficient.
        /// </summary>
        [Tooltip("Maximum number of simultaneous hits to check for. Larger values decrease performance but allow detection to work for more overlapping colliders. Typically the default value of 16 is more than sufficient.")]
        [SerializeField]
        private ushort _maximumSimultaneousHits = 16;
        /// <summary>
        /// Units to extend collision traces by. This is used to prevent missed overlaps when colliders do not intersect enough.
        /// </summary>
        [Tooltip("Units to extend collision traces by. This is used to prevent missed overlaps when colliders do not intersect enough.")]
        [Range(0f, 100f)]
        [SerializeField]
        private float _additionalSize = 0.1f;
        /// <summary>
        /// Layers to trace on. This is used when value is not nothing.
        /// </summary>
        [Tooltip("Layers to trace on. This is used when value is not nothing.")]
        [SerializeField]
        private LayerMask _layers = (LayerMask)0;

        /// <summary>
        /// The colliders on this object.
        /// </summary>
        private Collider[] _colliders;
        /// <summary>
        /// The hits from the last check.
        /// </summary>
        private Collider[] _hits;
        // /// <summary>
        // /// The history of collider data.
        // /// </summary>
        // private ResettableRingBuffer<ColliderData> _colliderDataHistory;
        private Dictionary<Collider, CollisionData> _enteredColliders;

        /// <summary>
        /// True if colliders have been searched for at least once.
        /// We cannot check the null state on _colliders because Unity has a habit of initializing collections on it's own.
        /// </summary>
        private bool _collidersFound;
        /// <summary>
        /// Last layer of the gameObject.
        /// </summary>
        private int _lastGameObjectLayer = -1;
        /// <summary>
        /// Interactable layers for the layer of this gameObject.
        /// </summary>
        private int _interactableLayers;

        protected virtual void Awake()
        {
            //_colliderDataHistory = ResettableCollectionCaches<ColliderData>.RetrieveRingBuffer();
            //_colliderDataHistory = new();
            _enteredColliders = CollectionCaches<Collider, CollisionData>.RetrieveDictionary();
            _hits = CollectionCaches<Collider>.RetrieveArray();
            if (_hits.Length < _maximumSimultaneousHits)
                _hits = new Collider[_maximumSimultaneousHits];
        }

        private void OnDestroy()
        {
            CollectionCaches<Collider, CollisionData>.StoreAndDefault(ref _enteredColliders);
            CollectionCaches<Collider>.StoreAndDefault(ref _hits, _hits.Length);
        }

        public override void OnStartNetwork()
        {
            FindColliders();

            //Initialize the ringbuffer. Server only needs 1 tick worth of history.
            // uint historyTicks = (base.IsServerStarted) ? 1 : TimeManager.TimeToTicks(_historyDuration);
            //_colliderDataHistory.Initialize((int)historyTicks);

            //Events needed by server and client.
            TimeManager.OnPrePhysicsSimulation += TimeManager_OnPostPhysicsSimulation;
        }

        public override void OnStartClient()
        {
            //Events only needed by the client.
            PredictionManager.OnPostReplicateReplay += PredictionManager_OnPostReplicateReplay;
            PredictionManager.OnPostReconcileSyncTransforms += PredictionManagerOnPreReconcile;
        }

        private void PredictionManagerOnPreReconcile(uint clientTick, uint serverTick)
        {
            if (_enteredColliders.Count > 0)
            {
                List<Collider> entriesToRemove = CollectionCaches<Collider>.RetrieveList();

                foreach (KeyValuePair<Collider, CollisionData> kvp in _enteredColliders)
                {
                    if (kvp.Value.ExitTick < clientTick)
                        entriesToRemove.Add(kvp.Key);
                }
                foreach (Collider entry in entriesToRemove)
                    _enteredColliders.Remove(entry);

                CollectionCaches<Collider>.Store(entriesToRemove);
            }
            
            CheckColliders(clientTick);
        }

        public override void OnStopClient()
        {
            //Events only needed by the client.
            PredictionManager.OnPostReplicateReplay -= PredictionManager_OnPostReplicateReplay;
            PredictionManager.OnPostReconcileSyncTransforms -= PredictionManagerOnPreReconcile;
        }

        public override void OnStopNetwork()
        {
            TimeManager.OnPrePhysicsSimulation -= TimeManager_OnPostPhysicsSimulation;
        }

        /// <summary>
        /// When using TimeManager for physics timing, this is called immediately after the physics simulation has occured for the tick.
        /// While using Unity for physics timing, this is called during Update, only if a physics frame.
        /// This may be useful if you wish to run physics differently for stacked scenes.
        private void TimeManager_OnPostPhysicsSimulation(float delta)
        {
            CheckColliders(TimeManager.LocalTick);
        }

        /// <summary>
        /// Called after physics is simulated when replaying a replicate method.
        /// </summary>
        private void PredictionManager_OnPostReplicateReplay(uint clientTick, uint serverTick)
        {
            CheckColliders(clientTick);
        }

        /// <summary>
        /// Units to extend collision traces by. This is used to prevent missed overlaps when colliders do not intersect enough.
        /// </summary>
        public virtual float GetAdditionalSize() => _additionalSize;

        /// <summary>
        /// Checks for any trigger changes;
        /// </summary>
        private void CheckColliders(uint tick)
        {
            //Should not be possible as tick always starts on 1.
            if (tick == TimeManagerCls.UNSET_TICK)
                return;

            HashSet<Collider> current = CollectionCaches<Collider>.RetrieveHashSet();
            Dictionary<Collider, CollisionData> entered = _enteredColliders;

            /* Previous may not be set here if there were
             * no collisions during the previous tick. */

            // The rotation of the object for box colliders.
            Quaternion rotation = transform.rotation;

            //If layers are specified then do not use GOs layers, use specified.
            if (_layers != (LayerMask)0)
            {
                _interactableLayers = _layers;
            }
            //Use GOs layers.
            else
            {
                int currentLayer = gameObject.layer;
                if (_lastGameObjectLayer != currentLayer)
                {
                    _lastGameObjectLayer = currentLayer;
                    _interactableLayers = Layers.GetInteractableLayersValue(currentLayer);
                }
            }

            //Check each collider for triggers.
            foreach (Collider col in _colliders)
            {
                if (!col.enabled)
                    continue;
                if (IsTrigger != col.isTrigger)
                    continue;

                //Number of hits from the checks.
                int hits;
                if (col is SphereCollider sphereCollider)
                    hits = GetSphereColliderHits(sphereCollider, _interactableLayers);
                else if (col is CapsuleCollider capsuleCollider)
                    hits = GetCapsuleColliderHits(capsuleCollider, _interactableLayers);
                else if (col is BoxCollider boxCollider)
                    hits = GetBoxColliderHits(boxCollider, rotation, _interactableLayers);
                else
                    hits = 0;

                /* Check hits for enter/exit callbacks. */
                for (int i = 0; i < hits; i++)
                {
                    Collider hit = _hits[i];
                    if (hit == null || hit == col)
                        continue;

                    current.Add(hit);

                    //Already entered.
                    if (entered.TryGetValueIL2CPP(hit, out CollisionData collisionData))
                    {
                        /* If entered tick is beyond the tick being checked then
                         * that means the collider entered at a later time, and something
                         * is not aligning. Invoke OnExit and OnEnter again. */
                        if (collisionData.EnterTick >= tick || collisionData.ExitTick != TimeManagerCls.UNSET_TICK)
                        {
                            OnExit?.Invoke(hit);
                            OnEnter?.Invoke(hit);
                            //Also update position in collection.
                            entered[hit] = new CollisionData(tick);
                        }
                    }
                    //Not yet in entered state.
                    else
                    {
                        OnEnter?.Invoke(hit);
                        //Also update position in collection.
                        entered[hit] = new CollisionData(tick);
                    }

                    //Always invoke OnStay when collider hits.
                    OnStay?.Invoke(hit);
                }

                List<Collider> collidersExited = CollectionCaches<Collider>.RetrieveList();
                /* Check to invoke exit on any colliders which are no longer
                 * in the entered state. */
                foreach (Collider c in entered.Keys)
                {
                    //Collider was still entered, no need to check exit.
                    if (current.Contains(c))
                        continue;
                    //Should not be possible to exit the same time as entering unless
                    if (entered[c].EnterTick == tick)
                        continue;

                    collidersExited.Add(c);
                }

                //Invoke for exited and remove from entered.
                foreach (Collider c in collidersExited)
                {
                    /* If here then the entered collider was not hit
                     * this trace. Invoke exit and remove from entered. */
                    OnExit?.Invoke(c);

                    

                    if (base.IsServerStarted)
                        entered.Remove(c);
                    else
                        entered[c] = new(entered[c].EnterTick, tick);
                    //entered.Remove(c);
                }
            }

            CollectionCaches<Collider>.Store(current);
        }

        /// <summary>
        /// Checks for Sphere collisions.
        /// </summary>
        /// <returns>Number of colliders hit.</returns>
        private int GetSphereColliderHits(SphereCollider sphereCollider, int layerMask)
        {
            sphereCollider.GetSphereOverlapParams(out Vector3 center, out float radius);
            radius += GetAdditionalSize();
            return gameObject.scene.GetPhysicsScene().OverlapSphere(center, radius, _hits, layerMask, QueryTriggerInteraction.UseGlobal);
        }

        /// <summary>
        /// Checks for Capsule collisions.
        /// </summary>
        /// <returns>Number of colliders hit.</returns>
        private int GetCapsuleColliderHits(CapsuleCollider capsuleCollider, int layerMask)
        {
            capsuleCollider.GetCapsuleCastParams(out Vector3 start, out Vector3 end, out float radius);
            radius += GetAdditionalSize();
            return gameObject.scene.GetPhysicsScene().OverlapCapsule(start, end, radius, _hits, layerMask, QueryTriggerInteraction.UseGlobal);
        }

        /// <summary>
        /// Checks for Box collisions.
        /// </summary>
        /// <returns>Number of colliders hit.</returns>
        private int GetBoxColliderHits(BoxCollider boxCollider, Quaternion rotation, int layerMask)
        {
            boxCollider.GetBoxOverlapParams(out Vector3 center, out Vector3 halfExtents);
            Vector3 additional = (Vector3.one * GetAdditionalSize());
            halfExtents += additional;
            return gameObject.scene.GetPhysicsScene().OverlapBox(center, halfExtents, _hits, rotation, layerMask, QueryTriggerInteraction.UseGlobal);
        }

        /// <summary>
        /// Finds colliders to use.
        /// <paramref name="rebuild"/>True to rebuild the colliders even if they are already populated.
        /// </summary>
        public void FindColliders(bool rebuild = false)
        {
            if (_collidersFound && !rebuild)
                return;
            _collidersFound = true;

            _colliders = GetComponents<Collider>();
        }

        /// <summary>
        /// Resets this NetworkBehaviour so that it may be added to an object pool.
        /// </summary>
        public override void ResetState(bool asServer)
        {
            base.ResetState(asServer);
            ClearColliderDataHistory();
        }

        /// <summary>
        /// Resets datas in collider data history and clears collection.
        /// </summary>
        private void ClearColliderDataHistory()
        {
            _enteredColliders.Clear();
        }
    }
}using FishNet.Managing;
using FishNet.Object;
using GameKit.Dependencies.Utilities;
using GameKit.Dependencies.Utilities.Types;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using TimeManagerCls = FishNet.Managing.Timing.TimeManager;

namespace FishNet.Component.Prediction
{

    public abstract class NetworkCollider2D : NetworkBehaviour
    {
        #region Types.
        private struct Collider2DData : IResettable
        {
            /// <summary>
            /// Tick which the collisions happened.
            /// </summary>
            public uint Tick;
            /// <summary>
            /// Hits for Tick.
            /// </summary>
            public HashSet<Collider2D> Hits;

            public Collider2DData(uint tick, HashSet<Collider2D> hits)
            {
                Tick = tick;
                Hits = hits;
            }

            public void InitializeState() { }
            public void ResetState()
            {
                Tick = TimeManagerCls.UNSET_TICK;
                CollectionCaches<Collider2D>.StoreAndDefault(ref Hits);
            }
        }
        #endregion

        /// <summary>
        /// Called when another collider enters this collider.
        /// </summary>
        public event Action<Collider2D> OnEnter;
        /// <summary>
        /// Called when another collider stays in this collider.
        /// </summary>
        public event Action<Collider2D> OnStay;
        /// <summary>
        /// Called when another collider exits this collider.
        /// </summary>
        public event Action<Collider2D> OnExit;
        /// <summary>
        /// True to run collisions for colliders which are triggers, false to run collisions for colliders which are not triggers.
        /// </summary>
        [HideInInspector]
        protected bool IsTrigger;
        /// <summary>
        /// Maximum number of simultaneous hits to check for. Larger values decrease performance but allow detection to work for more overlapping colliders. Typically the default value of 16 is more than sufficient.
        /// </summary>
        [Tooltip("Maximum number of simultaneous hits to check for. Larger values decrease performance but allow detection to work for more overlapping colliders. Typically the default value of 16 is more than sufficient.")]
        [SerializeField]
        private ushort _maximumSimultaneousHits = 16;
        /// <summary>
        /// How long of collision history to keep. Lower values will result in marginally better memory usage at the cost of collision histories desynchronizing on clients with excessive latency.
        /// </summary>
        [Tooltip("How long of collision history to keep. Lower values will result in marginally better memory usage at the cost of collision histories desynchronizing on clients with excessive latency.")]
        [Range(0.1f, 2f)]
        [SerializeField]
        private float _historyDuration = 0.5f;
        /// <summary>
        /// Units to extend collision traces by. This is used to prevent missed overlaps when colliders do not intersect enough.
        /// </summary>
        [Tooltip("Units to extend collision traces by. This is used to prevent missed overlaps when colliders do not intersect enough.")]
        [Range(0f, 100f)]
        [SerializeField]
        private float _additionalSize = 0.1f;
        /// <summary>
        /// Layers to trace on. This is used when value is not nothing.
        /// </summary>
        [Tooltip("Layers to trace on. This is used when value is not nothing.")]
        [SerializeField]
        private LayerMask _layers = (LayerMask)0;

        /// <summary>
        /// The colliders on this object.
        /// </summary>
        private Collider2D[] _colliders;
        /// <summary>
        /// The hits from the last check.
        /// </summary>
        private Collider2D[] _hits;
        /// <summary>
        /// The history of collider data.
        /// </summary>
        private ResettableRingBuffer<Collider2DData> _colliderDataHistory;
        /// <summary>
        /// True if colliders have been searched for at least once.
        /// We cannot check the null state on _colliders because Unity has a habit of initializing collections on it's own.
        /// </summary>
        private bool _collidersFound;
        /// <summary>
        /// True to cache collision histories for comparing start and exits.
        /// </summary>
        private bool _useCache => (OnEnter != null || OnExit != null);
        /// <summary>
        /// Last layer of the gameObject.
        /// </summary>
        private int _lastGameObjectLayer = -1;
        /// <summary>
        /// Interactable layers for the layer of this gameObject.
        /// </summary>
        private int _interactableLayers;

        protected virtual void Awake()
        {
            _colliderDataHistory = new();
            //_colliderDataHistory = ResettableCollectionCaches<Collider2DData>.RetrieveRingBuffer();
            _hits = CollectionCaches<Collider2D>.RetrieveArray();
            if (_hits.Length < _maximumSimultaneousHits)
                _hits = new Collider2D[_maximumSimultaneousHits];
        }

        private void OnDestroy()
        {
            //ResettableCollectionCaches<Collider2DData>.StoreAndDefault(ref _colliderDataHistory);
            CollectionCaches<Collider2D>.StoreAndDefault(ref _hits, _hits.Length);
        }

        public override void OnStartNetwork()
        {
            FindColliders();

            //Initialize the ringbuffer. Server only needs 1 tick worth of history.
            uint historyTicks = (base.IsServerStarted) ? 1 : TimeManager.TimeToTicks(_historyDuration);
            _colliderDataHistory.Initialize((int)historyTicks);

            //Events needed by server and client.
            TimeManager.OnPostPhysicsSimulation += TimeManager_OnPostPhysicsSimulation;
        }

        public override void OnStartClient()
        {
            //Events only needed by the client.
            PredictionManager.OnPostPhysicsTransformSync += PredictionManager_OnPostPhysicsTransformSync;
            PredictionManager.OnPostReplicateReplay += PredictionManager_OnPostReplicateReplay;
        }

        public override void OnStopClient()
        {
            //Events only needed by the client.
            PredictionManager.OnPostPhysicsTransformSync -= PredictionManager_OnPostPhysicsTransformSync;
            PredictionManager.OnPostReplicateReplay -= PredictionManager_OnPostReplicateReplay;

        }

        public override void OnStopNetwork()
        {
            TimeManager.OnPostPhysicsSimulation -= TimeManager_OnPostPhysicsSimulation;
        }

        /// <summary>
        /// Called after Physics SyncTransforms are run after a reconcile.
        /// This will only invoke if physics are set to TimeManager, within the TimeManager inspector.
        /// </summary>
        private void PredictionManager_OnPostPhysicsTransformSync(uint clientTick, uint serverTick)
        {
            /* This callback will only occur when client only.
             * SInce this is the case remove histories prior
             * to clientTick. */
            if (clientTick > 0)
                CleanHistory(clientTick - 1);
            CheckColliders(clientTick, true);
        }

        /// <summary>
        /// When using TimeManager for physics timing, this is called immediately after the physics simulation has occured for the tick.
        /// While using Unity for physics timing, this is called during Update, only if a physics frame.
        /// This may be useful if you wish to run physics differently for stacked scenes.
        private void TimeManager_OnPostPhysicsSimulation(float delta)
        {
            CheckColliders(TimeManager.LocalTick, false);
        }

        /// <summary>
        /// Called after physics is simulated when replaying a replicate method.
        /// </summary>
        private void PredictionManager_OnPostReplicateReplay(uint clientTick, uint serverTick)
        {
            CheckColliders(clientTick, true);
        }

        /// <summary>
        /// Cleans history up to, while excluding tick.
        /// </summary>
        
        private void CleanHistory(uint tick)
        {
            if (_useCache)
            {
                int removeCount = 0;
                int historyCount = _colliderDataHistory.Count;
                for (int i = 0; i < historyCount; i++)
                {
                    if (_colliderDataHistory[i].Tick >= tick)
                        break;
                    removeCount++;
                }

                _colliderDataHistory.RemoveRange(true, removeCount, resetRemoved: true);
            }
            //Cache is not used.
            else
            {
                ClearColliderDataHistory();
            }
        }


        /// <summary>
        /// Units to extend collision traces by. This is used to prevent missed overlaps when colliders do not intersect enough.
        /// </summary>
        protected virtual float GetAdditionalSize() => _additionalSize;

        /// <summary>
        /// Checks for any trigger changes;
        /// </summary>
        
        private void CheckColliders(uint tick, bool replay)
        {
            //Should not be possible as tick always starts on 1.
            if (tick == TimeManagerCls.UNSET_TICK)
                return;

            const int INVALID_HISTORY_VALUE = -1;

            HashSet<Collider2D> current = CollectionCaches<Collider2D>.RetrieveHashSet();
            HashSet<Collider2D> previous = null;

            int previousHitsIndex = INVALID_HISTORY_VALUE;
            /* Server only keeps 1 history so
             * if server is started then
             * simply clean one. When the server is
             * started replay will never be true, so this
             * will only call once per tick. */
            if (base.IsServerStarted && tick > 0)
                CleanHistory(tick - 1);

            if (_useCache)
            {
                if (replay)
                {
                    previousHitsIndex = GetHistoryIndex(tick - 1, false);
                    if (previousHitsIndex != -1)
                        previous = _colliderDataHistory[previousHitsIndex].Hits;
                }
                //Not replaying.
                else
                {
                    if (_colliderDataHistory.Count > 0)
                    {
                        Collider2DData cd = _colliderDataHistory[_colliderDataHistory.Count - 1];
                        /* If the hit tick one before current then it can be used, otherwise
                        * use a new collection for previous. */
                        if (cd.Tick == (tick - 1))
                            previous = cd.Hits;
                    }
                }
            }
            //Not using history, clear it all.
            else
            {
                ClearColliderDataHistory();
            }

            /* Previous may not be set here if there were
             * no collisions during the previous tick. */

            // The rotation of the object for box colliders.
            Quaternion rotation = transform.rotation;

            //If layers are specified then do not use GOs layers, use specified.
            if (_layers != (LayerMask)0)
            {
                _interactableLayers = _layers;
            }
            //Use GOs layers.
            else
            {
                int currentLayer = gameObject.layer;
                if (_lastGameObjectLayer != currentLayer)
                {
                    _lastGameObjectLayer = currentLayer;
                    _interactableLayers = Layers.GetInteractableLayersValue(currentLayer);
                }
            }

            // Check each collider for triggers.
            foreach (Collider2D col in _colliders)
            {
                if (!col.enabled)
                    continue;
                if (IsTrigger != col.isTrigger)
                    continue;

                //Number of hits from the checks.
                int hits;
                if (col is CircleCollider2D circleCollider)
                    hits = GetCircleCollider2DHits(circleCollider, _interactableLayers);
                else if (col is BoxCollider2D boxCollider)
                    hits = GetBoxCollider2DHits(boxCollider, rotation, _interactableLayers);
                else
                    hits = 0;

                // Check the hits for triggers.
                for (int i = 0; i < hits; i++)
                {
                    Collider2D hit = _hits[i];
                    if (hit == null || hit == col)
                        continue;

                    /* If not in previous then add and
                     * invoke enter. */
                    if (previous == null || !previous.Contains(hit))
                        OnEnter?.Invoke(hit);

                    //Also add to current hits.
                    current.Add(hit);
                    OnStay?.Invoke(hit);
                }
            }

            if (previous != null)
            {
                //Check for stays and exits.
                foreach (Collider2D col in previous)
                {
                    //If it was in previous but not current, it has exited.
                    if (!current.Contains(col))
                        OnExit?.Invoke(col);
                }
            }

            //If not using the cache then clean up collections.
            if (_useCache)
            {
                //If not replaying add onto the end. */
                if (!replay)
                {
                    AddToEnd();
                }
                /* If a replay then set current colliders
                 * to one entry past historyIndex. If the next entry
                 * beyond historyIndex is for the right tick it can be
                 * updated, otherwise a result has to be inserted. */
                else
                {
                    /* Previous hits was not found in history so we
                     * cannot assume current results go right after the previousIndex.
                     * Find whichever index is the closest to tick and return it. 
                     * 
                     * If an exact match is not found for tick then the entry just after
                     * tick will be returned. This will let us insert current hits right
                     * before that entry. */
                    if (previousHitsIndex == -1)
                    {
                        int currentIndex = GetHistoryIndex(tick, true);
                        AddDataToIndex(currentIndex);
                    }
                    //If previous hits are known then the index to update is right after previous index.
                    else
                    {
                        int insertIndex = (previousHitsIndex + 1);
                        /* InsertIndex is out of bounds which means
                         * to add onto the end. */
                        if (insertIndex >= _colliderDataHistory.Count)
                            AddToEnd();
                        //Not the last entry to insert in the middle.
                        else
                            AddDataToIndex(insertIndex);
                    }

                    /* Adds data to an index. If the tick
                     * matches on index with the current tick then
                     * replace the entry. Otherwise insert to the
                     * correct location. */
                    void AddDataToIndex(int index)
                    {
                        Collider2DData colliderData = new(tick, current);
                        /* If insertIndex is the same tick then replace, otherwise
                         * put in front of. */
                        //Replace.
                        if (_colliderDataHistory[index].Tick == tick)
                        {
                            _colliderDataHistory[index].ResetState();
                            _colliderDataHistory[index] = colliderData;
                        }
                        //Insert before.
                        else
                        {
                            _colliderDataHistory.Insert(index, colliderData);
                        }
                    }
                }

                void AddToEnd()
                {
                    Collider2DData colliderData = new(tick, current);
                    _colliderDataHistory.Add(colliderData);
                }

            }
            /* If not using caching then store results from this run. */
            else
            {
                CollectionCaches<Collider2D>.Store(current);
            }

            //Returns history index for a tick.
            /* GetClosest will return the closest match which is
             * past lTick if lTick could not be found. */
            int GetHistoryIndex(uint lTick, bool getClosest)
            {
                for (int i = 0; i < _colliderDataHistory.Count; i++)
                {
                    uint localTick = _colliderDataHistory[i].Tick;
                    if (localTick == lTick)
                        return i;
                    /* Tick is too high, any further results
                     * will also be too high. */
                    if (localTick > tick)
                    {
                        if (getClosest)
                            return i;
                        else
                            return INVALID_HISTORY_VALUE;
                    }
                }

                //Fall through.
                return INVALID_HISTORY_VALUE;
            }
        }

        /// <summary>
        /// Checks for circle collisions.
        /// </summary>
        /// <returns>Number of colliders hit.</returns>
        private int GetCircleCollider2DHits(CircleCollider2D circleCollider, int layerMask)
        {
            circleCollider.GetCircleOverlapParams(out Vector3 center, out float radius);
            radius += GetAdditionalSize();
            return gameObject.scene.GetPhysicsScene2D().OverlapCircle(center, radius, _hits, layerMask);
        }

        /// <summary>
        /// Checks for Box collisions.
        /// </summary>
        /// <returns>Number of colliders hit.</returns>
        private int GetBoxCollider2DHits(BoxCollider2D boxCollider, Quaternion rotation, int layerMask)
        {
            boxCollider.GetBox2DOverlapParams(out Vector3 center, out Vector3 halfExtents);
            Vector3 additional = (Vector3.one * GetAdditionalSize());
            halfExtents += additional;
            return gameObject.scene.GetPhysicsScene2D().OverlapBox(center, halfExtents, rotation.z, _hits, layerMask);
        }

        /// <summary>
        /// Finds colliders to use.
        /// <paramref name="rebuild"/>True to rebuild the colliders even if they are already populated.
        /// </summary>
        public void FindColliders(bool rebuild = false)
        {
            if (_collidersFound && !rebuild)
                return;
            _collidersFound = true;

            _colliders = GetComponents<Collider2D>();
        }

        /// <summary>
        /// Resets this NetworkBehaviour so that it may be added to an object pool.
        /// </summary>
        
        public override void ResetState(bool asServer)
        {
            base.ResetState(asServer);
            ClearColliderDataHistory();
        }

        /// <summary>
        /// Resets datas in collider data history and clears collection.
        /// </summary>
        private void ClearColliderDataHistory()
        {
            foreach (Collider2DData cd in _colliderDataHistory)
                cd.ResetState();
            _colliderDataHistory.Clear();
        }
    }


}using UnityEngine;

namespace FishNet.Component.Prediction
{
    public sealed class NetworkCollision : NetworkCollider
    {
        protected override void Awake()
        {
            base.IsTrigger = false;
            base.Awake();
        }
    }

}using UnityEngine;

namespace FishNet.Component.Prediction
{
    public sealed class NetworkCollision2D : NetworkCollider2D
    {
        protected override void Awake()
        {
            base.IsTrigger = false;
            base.Awake();
        }

    }

}namespace FishNet.Component.Prediction
{

    public sealed class NetworkTrigger : NetworkCollider
    {
        protected override void Awake()
        {
            base.IsTrigger = true;
            base.Awake();
        }

    }

}namespace FishNet.Component.Prediction
{

    public sealed class NetworkTrigger2D : NetworkCollider2D
    {
        protected override void Awake()
        {
            base.IsTrigger = true;
            base.Awake();
        }
    }

}﻿using FishNet.Managing.Predicting;
using UnityEngine;

namespace FishNet.Component.Prediction
{
    public partial class OfflineRigidbody : MonoBehaviour
    {
        #region Serialized.
        /// <summary>
        /// Type of prediction movement which is being used.
        /// </summary>
        [Tooltip("Type of prediction movement which is being used.")]
        [SerializeField]
        private RigidbodyType _rigidbodyType;  
        /// <summary>
        /// True to also get rigidbody components within children.
        /// </summary>
        [Tooltip("True to also get rigidbody components within children.")]
        [SerializeField]
        private bool _getInChildren;
        #endregion

        #region Private.
        /// <summary>
        /// Pauser for rigidbodies.
        /// </summary>
        private RigidbodyPauser _rigidbodyPauser = new();
        /// <summary>
        /// TimeManager subscribed to.
        /// </summary>
        private PredictionManager _predictionManager;
        #endregion

        private void Awake()
        {
            InitializeOnce();
        }


        private void OnDestroy()
        {
            ChangeSubscription(false);
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        private void InitializeOnce()
        {
            _predictionManager = InstanceFinder.PredictionManager;
            UpdateRigidbodies();
            ChangeSubscription(true);
        }

        /// <summary>
        /// Sets a new PredictionManager to use.
        /// </summary>
        /// <param name="tm"></param>
        public void SetPredictionManager(PredictionManager pm)
        {
            if (pm == _predictionManager)
                return;

            //Unsub from current.
            ChangeSubscription(false);
            //Sub to newest.
            _predictionManager = pm;
            ChangeSubscription(true);
        }

        /// <summary>
        /// Finds and assigns rigidbodie using configured settings.
        /// </summary>
        public void UpdateRigidbodies()
        {
            _rigidbodyPauser.UpdateRigidbodies(transform, _rigidbodyType, _getInChildren);
        }

        /// <summary>
        /// Changes the subscription to the TimeManager.
        /// </summary>
        private void ChangeSubscription(bool subscribe)
        {
            if (_predictionManager == null)
                return;

            if (subscribe)
            {
                _predictionManager.OnPreReconcile += _predictionManager_OnPreReconcile;
                _predictionManager.OnPostReconcile += _predictionManager_OnPostReconcile;
            }
            else
            {
                _predictionManager.OnPreReconcile -= _predictionManager_OnPreReconcile;
                _predictionManager.OnPostReconcile -= _predictionManager_OnPostReconcile;
            }
        }

        private void _predictionManager_OnPreReconcile(uint clientTick, uint serverTick)
        {
            _rigidbodyPauser.Pause();
        }

        private void _predictionManager_OnPostReconcile(uint clientTick, uint serverTick)
        {
            _rigidbodyPauser.Unpause();
        }
    }


}



﻿using FishNet.Managing;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using UnityEngine;

namespace FishNet.Component.Prediction
{
    /// <summary>
    /// Pauses and unpauses rigidbodies. While paused rigidbodies cannot be interacted with or simulated.
    /// </summary>
    public class RigidbodyPauser : IResettable
    {
        #region Types.
        /// <summary>
        /// Data for a rigidbody before being set kinematic.
        /// </summary>
        private struct RigidbodyData
        {
            /// <summary>
            /// Rigidbody for data.
            /// </summary>
            public Rigidbody Rigidbody;
            /// <summary>
            /// Cached velocity when being set kinematic.
            /// </summary>
            public Vector3 Velocity;
            /// <summary>
            /// Cached velocity when being set kinematic.
            /// </summary>
            public Vector3 AngularVelocity;
            /// <summary>
            /// True if the rigidbody was kinematic prior to being paused.
            /// </summary>
            public bool IsKinematic;
            /// <summary>
            /// Detection mode of the Rigidbody.
            /// </summary>
            public CollisionDetectionMode CollisionDetectionMode;

            public RigidbodyData(Rigidbody rb)
            {
                Rigidbody = rb;
                Velocity = Vector3.zero;
                AngularVelocity = Vector3.zero;
                IsKinematic = rb.isKinematic;
                CollisionDetectionMode = rb.collisionDetectionMode;
            }

            public void Update(Rigidbody rb)
            {
                Velocity = rb.velocity;
                AngularVelocity = rb.angularVelocity;
                IsKinematic = rb.isKinematic;
                CollisionDetectionMode = rb.collisionDetectionMode;
            }
        }

        /// <summary>
        /// Data for a rigidbody2d before being set kinematic.
        /// </summary>
        private struct Rigidbody2DData
        {
            /// <summary>
            /// Rigidbody for data.
            /// </summary>
            public Rigidbody2D Rigidbody2d;
            /// <summary>
            /// Cached velocity when being set kinematic.
            /// </summary>
            public Vector2 Velocity;
            /// <summary>
            /// Cached velocity when being set kinematic.
            /// </summary>
            public float AngularVelocity;
            /// <summary>
            /// True if the rigidbody was kinematic prior to being paused.
            /// </summary>
            public bool IsKinematic;
            /// <summary>
            /// True if the rigidbody was simulated prior to being paused.
            /// </summary>
            public bool Simulated;
            /// <summary>
            /// Detection mode of the rigidbody.
            /// </summary>
            public CollisionDetectionMode2D CollisionDetectionMode;

            public Rigidbody2DData(Rigidbody2D rb)
            {
                Rigidbody2d = rb;
                Velocity = Vector2.zero;
                AngularVelocity = 0f;
                Simulated = rb.simulated;
                IsKinematic = rb.isKinematic;
                CollisionDetectionMode = rb.collisionDetectionMode;
            }

            public void Update(Rigidbody2D rb)
            {
                Velocity = rb.velocity;
                AngularVelocity = rb.angularVelocity;
                Simulated = rb.simulated;
                IsKinematic = rb.isKinematic;
                CollisionDetectionMode = rb.collisionDetectionMode;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// True if the rigidbodies are considered paused.
        /// </summary>
        public bool Paused { get; private set; }
        #endregion

        #region Private.
        /// <summary>
        /// Rigidbody datas for found rigidbodies.
        /// </summary>
        private List<RigidbodyData> _rigidbodyDatas = new();
        /// <summary>
        /// Rigidbody2D datas for found rigidbodies;
        /// </summary>
        private List<Rigidbody2DData> _rigidbody2dDatas = new();
        /// <summary>
        /// True to get rigidbodies in children of transform.
        /// </summary>
        private bool _getInChildren;
        /// <summary>
        /// Transform to get rigidbodies on.
        /// </summary>
        private Transform _transform;
        /// <summary>
        /// Type of prediction movement which is being used.
        /// </summary>
        private RigidbodyType _rigidbodyType;
        /// <summary>
        /// True if initialized at least once.
        /// </summary>
        private bool _initialized;
        #endregion

        /// <summary>
        /// Assigns rigidbodies using initialized settings.
        /// </summary>
        public void UpdateRigidbodies()
        {
            if (!_initialized)
            {
                InstanceFinder.NetworkManager.LogError($"T{GetType().Name} has not been initialized yet. This method cannot be used.");
                return;
            }

            UpdateRigidbodies(_transform, _rigidbodyType, _getInChildren);
        }

        /// <summary>
        /// Assigns rigidbodies manually and initializes component.
        /// </summary>
        public void UpdateRigidbodies(Rigidbody[] rbs)
        {
            List<Rigidbody> rigidbodies = CollectionCaches<Rigidbody>.RetrieveList();
            foreach (Rigidbody rb in rbs)
                rigidbodies.Add(rb);
            
            UpdateRigidbodies(rigidbodies);

            CollectionCaches<Rigidbody>.Store(rigidbodies);
        }
        /// <summary>
        /// Assigns rigidbodies manually and initializes component.
        /// </summary>
        private void UpdateRigidbodies(List<Rigidbody> rbs) 
        {
            _rigidbodyDatas.Clear();

            foreach (Rigidbody rb in rbs)
                _rigidbodyDatas.Add(new(rb));

            _initialized = true;
        }

        /// <summary>
        /// Assigns rigidbodies manually and initializes component.
        /// </summary>
        public void UpdateRigidbodies2D(Rigidbody2D[] rbs)
        {
            List<Rigidbody2D> rigidbodies = CollectionCaches<Rigidbody2D>.RetrieveList();
            foreach (Rigidbody2D rb in rbs)
                rigidbodies.Add(rb);
            
            UpdateRigidbodies2D(rigidbodies);

            CollectionCaches<Rigidbody2D>.Store(rigidbodies);
        }
        /// <summary>
        /// Assigns rigidbodies manually and initializes component.
        /// </summary>
        private void UpdateRigidbodies2D(List<Rigidbody2D> rbs) 
        {
            _rigidbody2dDatas.Clear();

            foreach (Rigidbody2D rb in rbs)
                _rigidbody2dDatas.Add(new(rb));

            _initialized = true;
        }

        /// <summary>
        /// Assigns rigidbodies.
        /// </summary>
        /// <param name="rbs">Rigidbodies2D to use.</param>
        public void UpdateRigidbodies(Transform t, RigidbodyType rbType, bool getInChildren)
        {
            _rigidbodyType = rbType;
            _getInChildren = getInChildren;

            //3D.
            if (rbType == RigidbodyType.Rigidbody)
            {
                List<Rigidbody> rigidbodies = CollectionCaches<Rigidbody>.RetrieveList();
                
                if (getInChildren)
                {
                    Rigidbody[] rbs = t.GetComponentsInChildren<Rigidbody>();
                    for (int i = 0; i < rbs.Length; i++)
                        rigidbodies.Add(rbs[i]);
                }
                else
                {
                    Rigidbody rb = t.GetComponent<Rigidbody>();
                    if (rb != null)
                        rigidbodies.Add(rb);
                }
                
                UpdateRigidbodies(rigidbodies);
                CollectionCaches<Rigidbody>.Store(rigidbodies);
            }
            //2D.
            else
            {
                List<Rigidbody2D> rigidbodies = CollectionCaches<Rigidbody2D>.RetrieveList();
                
                if (getInChildren)
                {
                    Rigidbody2D[] rbs = t.GetComponentsInChildren<Rigidbody2D>();
                    for (int i = 0; i < rbs.Length; i++)
                        rigidbodies.Add(rbs[i]);
                }
                else
                {
                    Rigidbody2D rb = t.GetComponent<Rigidbody2D>();
                    if (rb != null)
                        rigidbodies.Add(rb);
                }
                
                UpdateRigidbodies2D(rigidbodies);
                CollectionCaches<Rigidbody2D>.Store(rigidbodies);
            }
        }

        /// <summary>
        /// Pauses rigidbodies preventing them from interacting.
        /// </summary>
        public void Pause()
        {
            if (Paused)
                return;
            Paused = true;


            /* Iterate move after pausing.
             * This ensures when the children RBs update values
             * they are not updating from a new scene, where the root
             * may have moved them */

            //3D.
            if (_rigidbodyType == RigidbodyType.Rigidbody)
            {
                for (int i = 0; i < _rigidbodyDatas.Count; i++)
                {
                    if (!PauseRigidbody(i))
                    {
                        _rigidbodyDatas.RemoveAt(i);
                        i--;
                    }
                }

                //Sets isKinematic status and returns if successful.
                bool PauseRigidbody(int index)
                {
                    RigidbodyData rbData = _rigidbodyDatas[index];
                    Rigidbody rb = rbData.Rigidbody;
                    if (rb == null)
                        return false;

                    rbData.Update(rb);
                    _rigidbodyDatas[index] = rbData;
                    rb.collisionDetectionMode = CollisionDetectionMode.Discrete;
                    rb.isKinematic = true;
                    //rb.detectCollisions = false;

                    return true;
                }
            }
            //2D.
            else
            {
                for (int i = 0; i < _rigidbody2dDatas.Count; i++)
                {
                    if (!PauseRigidbody(i))
                    {
                        _rigidbody2dDatas.RemoveAt(i);
                        i--;
                    }
                }

                //Sets isKinematic status and returns if successful.
                bool PauseRigidbody(int index)
                {
                    Rigidbody2DData rbData = _rigidbody2dDatas[index];
                    Rigidbody2D rb = rbData.Rigidbody2d;
                    if (rb == null)
                        return false;

                    rbData.Update(rb);
                    _rigidbody2dDatas[index] = rbData;
                    rb.collisionDetectionMode = CollisionDetectionMode2D.Discrete;
                    rb.isKinematic = true;
                    rb.simulated = false;

                    return true;
                }
            }
        }

        /// <summary>
        /// Unpauses rigidbodies allowing them to interact normally.
        /// </summary>
        public void Unpause()
        {
            if (!Paused)
                return;
            Paused = false;

            //3D.
            if (_rigidbodyType == RigidbodyType.Rigidbody)
            {
                for (int i = 0; i < _rigidbodyDatas.Count; i++)
                {
                    if (!UnpauseRigidbody(i))
                    {
                        _rigidbodyDatas.RemoveAt(i);
                        i--;
                    }
                }

                //Sets isKinematic status and returns if successful.
                bool UnpauseRigidbody(int index)
                {
                    RigidbodyData rbData = _rigidbodyDatas[index];
                    Rigidbody rb = rbData.Rigidbody;
                    if (rb == null)
                        return false;

                    /* If data has RB updated as kinematic then
                     * do not unpause. This means either something else
                     * is handling the kinematic state of the dev
                     * made it kinematic. */
                    if (rbData.IsKinematic)
                        return true;

                    // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                    rb.isKinematic = rbData.IsKinematic;
                    //rb.detectCollisions = rbData.DetectCollisions;
                    rb.collisionDetectionMode = rbData.CollisionDetectionMode;
                    if (!rb.isKinematic)
                    {
                        rb.velocity = rbData.Velocity;
                        rb.angularVelocity = rbData.AngularVelocity;
                    }
                    return true;
                }
            }
            //2D.
            else
            {
                for (int i = 0; i < _rigidbody2dDatas.Count; i++)
                {
                    if (!UnpauseRigidbody(i))
                    {
                        _rigidbody2dDatas.RemoveAt(i);
                        i--;
                    }
                }

                //Sets isKinematic status and returns if successful.
                bool UnpauseRigidbody(int index)
                {
                    Rigidbody2DData rbData = _rigidbody2dDatas[index];
                    Rigidbody2D rb = rbData.Rigidbody2d;
                    if (rb == null)
                        return false;

                    //Same as RB, only unpause if data is stored in an unpaused state.
                    if (rbData.IsKinematic || !rbData.Simulated)
                        return true;

                    // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                    rb.isKinematic = rbData.IsKinematic;
                    // ReSharper disable once ConditionIsAlwaysTrueOrFalse
                    rb.simulated = rbData.Simulated;
                    rb.collisionDetectionMode = rbData.CollisionDetectionMode;
                    if (!rb.isKinematic)
                    {
                        rb.velocity = rbData.Velocity;
                        rb.angularVelocity = rbData.AngularVelocity;
                    }
                    return true;
                }
            }
        }

        public void ResetState()
        {
            _rigidbodyDatas.Clear();
            _rigidbody2dDatas.Clear();
            _getInChildren = default;
            _transform = default;
            _rigidbodyType = default;
            _initialized = default;
            Paused = default;
        }

        public void InitializeState() { }
    }
}﻿using FishNet.CodeGenerating;
using FishNet.Serializing;
using UnityEngine;
using UnityEngine.Scripting;

namespace FishNet.Component.Prediction
{
    [UseGlobalCustomSerializer]
    [Preserve]
    public struct RigidbodyState
    {        
        public Vector3 Position;
        public Quaternion Rotation;
        public bool IsKinematic;
        public Vector3 Velocity;
        public Vector3 AngularVelocity;

        public RigidbodyState(Rigidbody rb, bool isKinematic) : this(rb)
        {
            Position = rb.transform.position;
            Rotation = rb.transform.rotation;
            IsKinematic = isKinematic;
            Velocity = rb.velocity;
            AngularVelocity = rb.angularVelocity;
        }
        public RigidbodyState(Rigidbody rb)
        {
            Position = rb.transform.position;
            Rotation = rb.transform.rotation;
            IsKinematic = rb.isKinematic;
            Velocity = rb.velocity;
            AngularVelocity = rb.angularVelocity;
        }
    }

    [UseGlobalCustomSerializer]
    [Preserve]
    public struct Rigidbody2DState
    {
        public Vector3 Position;
        public Quaternion Rotation;
        public Vector2 Velocity;
        public float AngularVelocity;
        public bool Simulated;
        public bool IsKinematic;

        public Rigidbody2DState(Rigidbody2D rb, bool simulated)
        {
            Position = rb.transform.position;
            Rotation = rb.transform.rotation;
            Velocity = rb.velocity;
            AngularVelocity = rb.angularVelocity;
            Simulated = simulated;
            IsKinematic = rb.isKinematic;
        }

        public Rigidbody2DState(Rigidbody2D rb)
        {
            Position = rb.transform.position;
            Rotation = rb.transform.rotation;
            Velocity = rb.velocity;
            AngularVelocity = rb.angularVelocity;
            Simulated = rb.simulated;
            IsKinematic = rb.isKinematic;
        }
    }

    [Preserve]
    public static class RigidbodyStateSerializers
    {
        public static void WriteRigidbodyState(this Writer writer, RigidbodyState value)
        {
            writer.WriteVector3(value.Position);
            writer.WriteQuaternion32(value.Rotation);
            writer.WriteBoolean(value.IsKinematic);
            if (!value.IsKinematic)
            {
                writer.WriteVector3(value.Velocity);
                writer.WriteVector3(value.AngularVelocity);
            }
        }

        public static RigidbodyState ReadRigidbodyState(this Reader reader)
        {
            RigidbodyState state = new()
            {
                Position = reader.ReadVector3(),
                Rotation = reader.ReadQuaternion32(),
                IsKinematic = reader.ReadBoolean()
            };

            if (!state.IsKinematic)
            {
                state.Velocity = reader.ReadVector3();
                state.AngularVelocity = reader.ReadVector3();
            }

            return state;
        }

        public static void WriteRigidbody2DState(this Writer writer, Rigidbody2DState value)
        {
            writer.WriteVector3(value.Position);
            writer.WriteQuaternion32(value.Rotation);
            writer.WriteBoolean(value.Simulated);
            writer.WriteBoolean(value.IsKinematic);

            if (value.Simulated)
            {
                writer.WriteVector2(value.Velocity);
                writer.WriteSingle(value.AngularVelocity);
            }
        }

        public static Rigidbody2DState ReadRigidbody2DState(this Reader reader)
        {
            Rigidbody2DState state = new()
            {
                Position = reader.ReadVector3(),
                Rotation = reader.ReadQuaternion32(),
                Simulated = reader.ReadBoolean(),
                IsKinematic = reader.ReadBoolean()
            };

            if (state.Simulated)
            {
                state.Velocity = reader.ReadVector2();
                state.AngularVelocity = reader.ReadSingle();
            }

            return state;
        }


    }

    [Preserve]
    public static class RigidbodyStateExtensions
    {
        /// <summary>
        /// Gets a RigidbodyState.
        /// </summary>
        public static RigidbodyState GetState(this Rigidbody rb)
        {
            return new(rb);
        }
        /// <summary>
        /// Sets a state to a rigidbody.
        /// </summary>
        public static void SetState(this Rigidbody rb, RigidbodyState state)
        {
            Transform t = rb.transform;
            t.position = state.Position;
            t.rotation = state.Rotation;
            rb.velocity = state.Velocity;
            rb.angularVelocity = state.AngularVelocity;
        }

        /// <summary>
        /// Gets a Rigidbody2DState.
        /// </summary>
        public static Rigidbody2DState GetState(this Rigidbody2D rb)
        {
            return new(rb);
        }
        /// <summary>
        /// Sets a state to a rigidbody.
        /// </summary>
        public static void SetState(this Rigidbody2D rb, Rigidbody2DState state)
        {
            Transform t = rb.transform;
            t.position = state.Position;
            t.rotation = state.Rotation;
            rb.velocity = state.Velocity;
            rb.angularVelocity = state.AngularVelocity;
        }

    }
}
﻿namespace FishNet.Component.Prediction
{
    /// <summary>
    /// Type of prediction movement being used.
    /// </summary>
    public enum RigidbodyType : byte
    {
        Rigidbody = 0,
        Rigidbody2D = 1
    }

}﻿using FishNet.Connection;
using FishNet.Managing;
using FishNet.Object;
using System;
using UnityEngine;
using UnityEngine.Serialization;

namespace FishNet.Component.Spawning
{
    /// <summary>
    /// Spawns a player object for clients when they connect.
    /// </summary>
    [AddComponentMenu("FishNet/Component/PlayerSpawner")]
    public class PlayerSpawner : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Called on the server when a player is spawned.
        /// </summary>
        public event Action<NetworkObject> OnSpawned;
        #endregion

        #region Serialized.
        /// <summary>
        /// Prefab to spawn for the player.
        /// </summary>
        [Tooltip("Prefab to spawn for the player.")]
        [SerializeField]
        private NetworkObject _playerPrefab;

        /// <summary>
        /// Sets the PlayerPrefab to use.
        /// </summary>
        /// <param name="nob"></param>
        public void SetPlayerPrefab(NetworkObject nob) => _playerPrefab = nob;

        /// <summary>
        /// True to add player to the active scene when no global scenes are specified through the SceneManager.
        /// </summary>
        [Tooltip("True to add player to the active scene when no global scenes are specified through the SceneManager.")]
        [SerializeField]
        private bool _addToDefaultScene = true;
        /// <summary>
        /// Areas in which players may spawn.
        /// </summary>
        [Tooltip("Areas in which players may spawn.")]
        public Transform[] Spawns = new Transform[0];
        #endregion

        #region Private.
        /// <summary>
        /// First instance of the NetworkManager found. This will be either the NetworkManager on or above this object, or InstanceFinder.NetworkManager.
        /// </summary>
        private NetworkManager _networkManager;
        /// <summary>
        /// Next spawns to use.
        /// </summary>
        private int _nextSpawn;
        #endregion

        private void Awake()
        {
            InitializeOnce();
        }

        private void OnDestroy()
        {
            if (_networkManager != null)
                _networkManager.SceneManager.OnClientLoadedStartScenes -= SceneManager_OnClientLoadedStartScenes;
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        private void InitializeOnce()
        {
            _networkManager = GetComponentInParent<NetworkManager>();
            if (_networkManager == null)
                _networkManager = InstanceFinder.NetworkManager;
            
            if (_networkManager == null)
            {
                NetworkManagerExtensions.LogWarning($"PlayerSpawner on {gameObject.name} cannot work as NetworkManager wasn't found on this object or within parent objects.");
                return;
            }

            _networkManager.SceneManager.OnClientLoadedStartScenes += SceneManager_OnClientLoadedStartScenes;
        }

        /// <summary>
        /// Called when a client loads initial scenes after connecting.
        /// </summary>
        private void SceneManager_OnClientLoadedStartScenes(NetworkConnection conn, bool asServer)
        {
            if (!asServer)
                return;
            if (_playerPrefab == null)
            {
                NetworkManagerExtensions.LogWarning($"Player prefab is empty and cannot be spawned for connection {conn.ClientId}.");
                return;
            }

            Vector3 position;
            Quaternion rotation;
            SetSpawn(_playerPrefab.transform, out position, out rotation);

            NetworkObject nob = _networkManager.GetPooledInstantiated(_playerPrefab, position, rotation, true);
            _networkManager.ServerManager.Spawn(nob, conn);

            //If there are no global scenes 
            if (_addToDefaultScene)
                _networkManager.SceneManager.AddOwnerToDefaultScene(nob);

            OnSpawned?.Invoke(nob);
        }

        /// <summary>
        /// Sets a spawn position and rotation.
        /// </summary>
        /// <param name="pos"></param>
        /// <param name="rot"></param>
        private void SetSpawn(Transform prefab, out Vector3 pos, out Quaternion rot)
        {
            //No spawns specified.
            if (Spawns.Length == 0)
            {
                SetSpawnUsingPrefab(prefab, out pos, out rot);
                return;
            }

            Transform result = Spawns[_nextSpawn];
            if (result == null)
            {
                SetSpawnUsingPrefab(prefab, out pos, out rot);
            }
            else
            {
                pos = result.position;
                rot = result.rotation;
            }

            //Increase next spawn and reset if needed.
            _nextSpawn++;
            if (_nextSpawn >= Spawns.Length)
                _nextSpawn = 0;
        }

        /// <summary>
        /// Sets spawn using values from prefab.
        /// </summary>
        /// <param name="prefab"></param>
        /// <param name="pos"></param>
        /// <param name="rot"></param>
        private void SetSpawnUsingPrefab(Transform prefab, out Vector3 pos, out Quaternion rot)
        {
            pos = prefab.position;
            rot = prefab.rotation;
        }
    }
}﻿using FishNet.Managing;
using FishNet.Object;
using System.Collections.Generic;
using FishNet.Managing.Server;
using FishNet.Transporting;
using UnityEngine;

namespace FishNet.Component.Spawning
{
    /// <summary>
    /// Spawns network objects when the server starts.
    /// </summary>
    [AddComponentMenu("FishNet/Component/ServerSpawner")]
    public class ServerSpawner : MonoBehaviour
    {
        #region Serialized
        [Tooltip("True to spawn the objects as soon as the server starts. False if you wish to call Spawn manually.")]
        [SerializeField]
        private bool _automaticallySpawn = true;
        /// <summary>
        /// NetworkObjects to spawn when the server starts.
        /// </summary>
        [Tooltip("NetworkObjects to spawn when the server starts.")]
        [SerializeField]
        private List<NetworkObject> _networkObjects = new();
        #endregion

        #region Private.
        /// <summary>
        /// First instance of the ServerManager found. This will be either the ServerManager on or above this object, or InstanceFinder.ServerManager.
        /// </summary>
        private ServerManager _serverManager;
        #endregion

        private void Awake()
        {
            InitializeOnce();
        }

        private void OnDestroy()
        {
            if (_serverManager == null)
                return;

            //Unsubscribe even if not automatically spawning; this is to protect against the user unchecking during play mode.
            _serverManager.OnServerConnectionState -= ServerManager_OnServerConnectionState;
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        private void InitializeOnce()
        {
            _serverManager = GetComponentInParent<ServerManager>();
            if (_serverManager == null)
                _serverManager = InstanceFinder.ServerManager;

            if (_serverManager == null)
            {
                NetworkManagerExtensions.LogWarning($"PlayerSpawner on {gameObject.name} cannot work as NetworkManager wasn't found on this object or within parent objects.");
                return;
            }

            //Only subscribe if to automatically spawn.
            if (_automaticallySpawn)
                _serverManager.OnServerConnectionState += ServerManager_OnServerConnectionState;
        }

        private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs args)
        {
            //If not started then exit.
            if (args.ConnectionState != LocalConnectionState.Started)
                return;

            //If more than 1 server is started then exit. This means the user is using multipass and another server already started.
            if (!_serverManager.IsOnlyOneServerStarted())
                return;

            Spawn_Internally();
        }

        private void Spawn_Internally()
        {
            if (_serverManager == null)
                return;
            
            //Spawn the objects now.
            foreach (NetworkObject networkObject in _networkObjects)
            {
                NetworkObject nob = _serverManager.NetworkManager.GetPooledInstantiated(networkObject, asServer: true);
                _serverManager.Spawn(nob);
            }
        }

        /// <summary>
        /// Spawns all provided NetworkObjects.
        /// </summary>
        /// <remarks>This will spawn the objects again even if they were already spawned automatically or manually before.</remarks>
        public void Spawn() => Spawn_Internally();
        
   }
}﻿using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using FishNet.CodeGenerating;
using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Server;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Component.Ownership
{
    /// <summary>
    /// Adding this component allows any client to take ownership of the object and begin modifying it immediately.
    /// </summary>
    public class PredictedOwner : NetworkBehaviour
    {
        #region Public.

        /// <summary>
        /// True if the local client used TakeOwnership and is awaiting an ownership change.
        /// </summary>
        public bool TakingOwnership { get; private set; }

        /// <summary>
        /// Owner on client prior to taking ownership. This can be used to reverse a failed ownership attempt.
        /// </summary>
        public NetworkConnection PreviousOwner { get; private set; } = NetworkManager.EmptyConnection;

        #endregion

        #region Serialized.

        /// <summary>
        /// True if to enable this component.
        /// </summary>
        [Tooltip("True if to enable this component.")] [SerializeField]
        private bool _allowTakeOwnership = true;
        private readonly SyncVar<bool> _allowTakeOwnershipSyncVar = new();

        /// <summary>
        /// Sets the next value for AllowTakeOwnership and synchronizes it.
        /// Only the server may use this method.
        /// </summary>
        /// <param name="value">Next value to use.</param>
        [Server]
        public void SetAllowTakeOwnership(bool value) => _allowTakeOwnershipSyncVar.Value = value;

        #endregion

        protected virtual void Awake()
        {
            _allowTakeOwnershipSyncVar.Value = _allowTakeOwnership;
            _allowTakeOwnershipSyncVar.UpdateSendRate(0f);
            _allowTakeOwnershipSyncVar.OnChange += _allowTakeOwnershipSyncVar_OnChange;
        }

        /// <summary>
        /// Called when SyncVar value changes for AllowTakeOwnership.
        /// </summary>
        private void _allowTakeOwnershipSyncVar_OnChange(bool prev, bool next, bool asServer)
        {
            if (asServer || !base.IsHostStarted)
                _allowTakeOwnership = next;
        }

        /// <summary>
        /// Called on the client after gaining or losing ownership.
        /// </summary>
        /// <param name="prevOwner">Previous owner of this object.</param>
        public override void OnOwnershipClient(NetworkConnection prevOwner)
        {
            /* Unset taken ownership either way.
             * If the new owner it won't be used,
             * if no longer owner then another client
             * took it. */
            TakingOwnership = false;
            PreviousOwner = base.Owner;
        }

        [Client]
        
        [Obsolete("Use TakeOwnership(bool).")]
        public virtual void TakeOwnership() => TakeOwnership(includeNested: true);

        /// <summary>
        /// Gives ownership of this to the local client and allows immediate control.
        /// </summary>
        /// <param name="includeNested">True to also take ownership of nested objects.</param>
        public virtual void TakeOwnership(bool includeNested)
        {
            if (!_allowTakeOwnershipSyncVar.Value)
                return;
            //Already owner.
            if (base.IsOwner)
                return;

            NetworkConnection c = base.ClientManager.Connection;
            TakingOwnership = true;
            //If not server go through the server.
            if (!base.IsServerStarted)
            {
                base.NetworkObject.SetLocalOwnership(c, includeNested);
                ServerTakeOwnership(includeNested);
            }
            //Otherwise take directly without rpcs.
            else
            {
                OnTakeOwnership(c, includeNested);
            }
        }


        /// <summary>
        /// Takes ownership of this object.
        /// </summary>
        [ServerRpc(RequireOwnership = false)]
        private void ServerTakeOwnership(bool includeNested, NetworkConnection caller = null)
        {
            OnTakeOwnership(caller, includeNested);
        }
        
        [Server]
        
        [Obsolete("Use OnTakeOwnership(bool).")]
        protected virtual void OnTakeOwnership(NetworkConnection caller) => OnTakeOwnership(caller, recursive: false);

        /// <summary>
        /// Called on the server when a client tries to take ownership of this object.
        /// </summary>
        /// <param name="caller">Connection trying to take ownership.</param>
        [Server]
        protected virtual void OnTakeOwnership(NetworkConnection caller, bool recursive)
        {
            //Client somehow disconnected between here and there.
            if (!caller.IsActive)
                return;
            //Feature is not enabled.
            if (!_allowTakeOwnershipSyncVar.Value)
                return;
            //Already owner.
            if (caller == base.Owner)
                return;

            base.GiveOwnership(caller);
            if (recursive)
            {
                List<NetworkObject> allNested = base.NetworkObject.GetNetworkObjects(GetNetworkObjectOption.AllNestedRecursive);
                
                foreach (NetworkObject nob in allNested)
                {
                    PredictedOwner po = nob.PredictedOwner;
                    if (po != null)
                        po.OnTakeOwnership(caller, recursive: true);
                }

                CollectionCaches<NetworkObject>.Store(allNested);
            }
            /* No need to send a response back because an ownershipchange will handle changes.
             * Although if you were to override with this your own behavior
             * you could send responses for approved/denied. */
        }
    }
}﻿using FishNet.Connection;
using FishNet.Object;
using UnityEngine;

namespace FishNet.Component.Ownership
{
    /// <summary>
    /// Adding this component allows any client to use predictive spawning on this prefab.
    /// </summary>
    public class PredictedSpawn : NetworkBehaviour
    {
        #region Serialized.
        /// <summary>
        /// True to allow clients to predicted spawn this object.
        /// </summary>
        public bool GetAllowSpawning() => _allowSpawning;
        /// <summary>
        /// Sets to allow predicted spawning. This must be set on client and server.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetAllowSpawning(bool value) => _allowSpawning = value;
        [Tooltip("True to allow clients to predicted spawn this object.")]
        [SerializeField]
        private bool _allowSpawning = true;
        /// <summary>
        /// True to allow clients to predicted despawn this object.
        /// </summary>
        public bool GetAllowDespawning() => _allowDespawning;
        /// <summary>
        /// Sets to allow predicted despawning. This must be set on client and server.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetAllowDespawning(bool value) => _allowDespawning = value;
        [Tooltip("True to allow clients to predicted despawn this object.")]
        [SerializeField]
        private bool _allowDespawning = true;
        #endregion

        /// <summary>
        /// Called on the client when trying to predicted spawn this object.
        /// </summary>
        /// <param name="owner">Owner specified to spawn with.</param>
        /// <returns>True if able to spawn.</returns>
        public virtual bool OnTrySpawnClient(NetworkConnection owner = null)
        {
            return GetAllowSpawning();
        }
        /// <summary>
        /// Called on the server when a client tries to predicted spawn this object.
        /// </summary>
        /// <param name="spawner">Connection trying to predicted spawn this object.</param>
        /// <param name="owner">Owner specified to spawn with.</param>
        /// <returns>True if able to spawn.</returns>
        public virtual bool OnTrySpawnServer(NetworkConnection spawner, NetworkConnection owner = null)
        {
            return GetAllowSpawning();
        }

        /// <summary>
        /// Called on the client when trying to predicted spawn this object.
        /// </summary>
        /// <returns>True if able to despawn.</returns>
        public virtual bool OnTryDespawnClient()
        {
            return GetAllowDespawning();
        }
        /// <summary>
        /// Called on the server when a client tries to predicted despawn this object.
        /// </summary>
        /// <param name="despawner">Connection trying to predicted despawn this object.</param>
        /// <returns>True if able to despawn.</returns>
        public virtual bool OnTryDespawnServer(NetworkConnection despawner)
        {
            return GetAllowDespawning();
        }



    }

}﻿namespace FishNet.Component.Transforming
{
    public enum AdaptiveInterpolationType
    {
        /// <summary>
        /// Adaptive interpolation is disabled. An exact interpolation value is used.
        /// </summary>
        Off = 0,
        /// <summary>
        /// Visual disturbances caused by desynchronization are definite without predicting future states.
        /// </summary>
        ExtremelyLow = 1,
        /// <summary>
        /// Visual disturbances caused by desynchronization are likely without predicting future states.
        /// </summary>
        VeryLow = 2,
        /// <summary>
        /// Visual disturbances caused by desynchronization are still possible but less likely.
        /// </summary>
        Low = 3,
        /// <summary>
        /// Visual disturbances caused by desynchronization are likely without predicting a small amount of future states.
        /// </summary>
        Moderate = 4,
        /// <summary>
        /// Visual disturbances caused by desynchronization are very unlikely. Graphics are using a generous amount interpolation.
        /// </summary>
        High = 5,
        /// <summary>
        /// Visual disturbances caused by desynchronization are extremely unlikely. Graphics are using a generous amount interpolation.
        /// </summary>
        VeryHigh = 6,
    }


}
﻿using FishNet.Managing.Timing;
using FishNet.Object;
using UnityEngine;

namespace FishNet.Component.Transforming.Beta
{
    [System.Serializable]
    public struct InitializationSettings
    {
        /// <summary>
        /// While this script is typically placed on a nested graphical object, the targetTransform would be the object which moves every tick; the TargetTransform can be the same object this script resides but may not be a rigidbody if true;
        /// </summary>
        [Tooltip("While this script is typically placed on a nested graphical object, the targetTransform would be the object which moves every tick; the TargetTransform can be the same object this script resides but may not be a rigidbody if true;")]
        [SerializeField]
        public Transform TargetTransform;
        /// <summary>
        /// The transform which is smoothed.
        /// </summary>
        [Tooltip("The transform which is smoothed.")]
        [System.NonSerialized]
        internal Transform GraphicalTransform;
        /// <summary>
        /// True to detacth this object from its parent on client start.
        /// </summary>
        [Tooltip("True to detach this object from it's parent on client start.")]
        public bool DetachOnStart;
        /// <summary>
        /// True to re-attach this object to it's parent on client stop.
        /// </summary>
        [Tooltip("True to re-attach this object to it's parent on client stop.")]
        public bool AttachOnStop;
        /// <summary>
        /// True to begin moving soon as movement data becomes available. Movement will ease in until at interpolation value. False to prevent movement until movement data count meet interpolation.
        /// </summary>
        /// <remarks>This is not yet used.</remarks>
        [Tooltip("True to begin moving soon as movement data becomes available. Movement will ease in until at interpolation value. False to prevent movement until movement data count meet interpolation.")]
        public bool MoveImmediately => false;
        /// <summary>
        /// NetworkBehaviour which initialized these settings. This value may be null if not initialized from a NetworkBehaviour.
        /// </summary>
        [System.NonSerialized]
        internal NetworkBehaviour InitializingNetworkBehaviour;
        /// <summary>
        /// TimeManager initializing these settings.
        /// </summary>
        [System.NonSerialized]
        internal TimeManager InitializingTimeManager;

        public void SetNetworkedRuntimeValues(NetworkBehaviour initializingNetworkBehaviour, Transform graphicalTransform)
        {
            InitializingNetworkBehaviour = initializingNetworkBehaviour;
            GraphicalTransform = graphicalTransform;
            InitializingTimeManager = initializingNetworkBehaviour.TimeManager;
        }
        /// <summary>
        /// Sets values used at runtime. NetworkBehaviour is nullified when calling this method.
        /// </summary>
        public void SetOfflineRuntimeValues(TimeManager timeManager, Transform graphicalTransform)
        {
            InitializingNetworkBehaviour = null;
            GraphicalTransform = graphicalTransform;
            InitializingTimeManager = timeManager;
        }
     
    }
}﻿using FishNet.Object;
using UnityEngine;

namespace FishNet.Component.Transforming.Beta
{
    [System.Serializable]
    public struct MovementSettings
    {
        /// <summary>
        /// True to enable teleport threshold.
        /// </summary>
        [Tooltip("True to enable teleport threshold.")]
        public bool EnableTeleport;
        /// <summary>
        /// How far the object must move between ticks to teleport rather than smooth.
        /// </summary>
        [Tooltip("How far the object must move between ticks to teleport rather than smooth.")]
        [Range(0f, ushort.MaxValue)]
        public float TeleportThreshold;
        /// <summary>
        /// Amount of adaptive interpolation to use. Adaptive interpolation increases interpolation with the local client's latency. Lower values of adaptive interpolation results in smaller interpolation increases.
        /// In most cases adaptive interpolation is only used with prediction where objects might be affected by other moving objects.
        /// </summary>
        [Tooltip("Amount of adaptive interpolation to use. Adaptive interpolation increases interpolation with the local client's latency. Lower values of adaptive interpolation results in smaller interpolation increases. In most cases adaptive interpolation is only used with prediction where objects might be affected by other moving objects.")]
        public AdaptiveInterpolationType AdaptiveInterpolationValue;
        /// <summary>
        /// Number of ticks to smooth over when not using adaptive interpolation.
        /// </summary>
        [Tooltip("Number of ticks to smooth over when not using adaptive interpolation.")]
        public byte InterpolationValue;
        /// <summary>
        /// Properties to smooth. Any value not selected will become offset with every movement.
        /// </summary>
        [Tooltip("Properties to smooth. Any value not selected will become offset with every movement.")]
        public TransformPropertiesFlag SmoothedProperties;
        /// <summary>
        /// True to keep non-smoothed properties at their original localspace every tick. A false value will keep the properties in the same world space as they were before each tick.
        /// </summary>
        [Tooltip("True to keep non-smoothed properties at their original localspace every tick. A false value will keep the properties in the same world space as they were before each tick.")]
        public bool SnapNonSmoothedProperties;
        
        public MovementSettings(bool unityReallyNeedsToSupportParameterlessInitializersOnStructsAlready)
        {
            EnableTeleport = false;
            TeleportThreshold = 0f;
            AdaptiveInterpolationValue = AdaptiveInterpolationType.Off;
            InterpolationValue = 2;
            SmoothedProperties = TransformPropertiesFlag.Everything;
            SnapNonSmoothedProperties = false;
        }

    }
}﻿using FishNet.Object;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Component.Transforming.Beta
{
    /// <summary>
    /// Smoothes this object between ticks.
    /// </summary>
    /// <remarks>This can be configured to smooth over a set interval of time, or to smooth adaptively and make path corrections for prediction.</remarks>
    public class NetworkTickSmoother : NetworkBehaviour
    {
        #region Public.
        /// <summary>
        /// Logic for owner smoothing.
        /// </summary>
        public TickSmootherController SmootherController { get; private set; }
        #endregion

        /// <summary>
        /// Settings required to initialize the smoother.
        /// </summary>
        [Tooltip("Settings required to initialize the smoother.")]
        [SerializeField]
        private InitializationSettings _initializationSettings = new();
        /// <summary>
        /// How smoothing occurs when the controller of the object.
        /// </summary>
        [Tooltip("How smoothing occurs when the controller of the object.")]
        [SerializeField]
        private MovementSettings _controllerMovementSettings = new(true);
        /// <summary>
        /// How smoothing occurs when spectating the object.
        /// </summary>
        [Tooltip("How smoothing occurs when spectating the object.")]
        [SerializeField]
        private MovementSettings _spectatorMovementSettings = new(true);
        
        private void OnDestroy()
        {
            if (SmootherController != null)
                SmootherController.OnDestroy();
            StoreControllers();
        }

        public override void OnStartClient()
        {
            RetrieveControllers();

            _initializationSettings.SetNetworkedRuntimeValues(initializingNetworkBehaviour: this, graphicalTransform: transform);
            SmootherController.Initialize(_initializationSettings, _controllerMovementSettings, _spectatorMovementSettings);

            SmootherController.StartSmoother();
        }

        public override void OnStopClient()
        {
            if (SmootherController == null)
                return;
            
            SmootherController.StopSmoother();
        }

        /// <summary>
        /// Stores smoothers if they have value.
        /// </summary>
        private void StoreControllers()
        {
            if (SmootherController == null)
                return;

            ResettableObjectCaches<TickSmootherController>.Store(SmootherController);
            SmootherController = null;
        }

        /// <summary>
        /// Stores current smoothers and retrieves new ones.
        /// </summary>
        private void RetrieveControllers()
        {
            StoreControllers();
            SmootherController = ResettableObjectCaches<TickSmootherController>.Retrieve();
        }
    }
}﻿using FishNet.Managing;
using FishNet.Managing.Timing;
using GameKit.Dependencies.Utilities;
using UnityEngine;
using UnityEngine.Serialization;

namespace FishNet.Component.Transforming.Beta
{
    /// <summary>
    /// Smoothes this object between ticks.
    /// </summary>
    /// <remarks>This can be configured to smooth over a set interval of time, or to smooth adaptively and make path corrections for prediction.</remarks>
    public class OfflineTickSmoother : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Logic for owner smoothing.
        /// </summary>
        public TickSmootherController SmootherController { get; private set; }
        /// <summary>
        /// True if this component is initialized.
        /// </summary>
        /// <remarks>This API is for internal use and may change at any time.</remarks>
        public bool IsInitialized { get; private set; }
        #endregion

        #region Serialized.
        /// <summary>
        /// True to automatically initialize in Awake using InstanceFinder. When false you will need to manually call Initialize.
        /// </summary>
        [Tooltip("True to automatically initialize in Awake using InstanceFinder. When false you will need to manually call Initialize.")]
        [SerializeField]
        private bool _automaticallyInitialize = true;
        /// <summary>
        /// Settings required to initialize the smoother.
        /// </summary>
        [Tooltip("Settings required to initialize the smoother.")]
        [SerializeField]
        private InitializationSettings _initializationSettings = new();
        /// <summary>
        /// How smoothing occurs when the controller of the object.
        /// </summary>
        [FormerlySerializedAs("_controllerMovementSettings")]
        [Tooltip("How smoothing occurs when the controller of the object.")]
        [SerializeField]
        private MovementSettings _movementSettings = new(true);
        #endregion
        
        private void Awake()
        {
            RetrieveControllers();
            AutomaticallyInitialize();
        }

        private void OnDestroy()
        {
            if (SmootherController != null)
            {
                SmootherController.StopSmoother();
                SmootherController.OnDestroy();
            }

            StoreControllers();
            
            IsInitialized = false;
        }

        /// <summary>
        /// Automatically initializes if feature is enabled.
        /// </summary>
        private void AutomaticallyInitialize()
        {
            if (!_automaticallyInitialize)
                return;

            TimeManager tm = InstanceFinder.TimeManager;
            if (tm == null)
            {
                NetworkManagerExtensions.LogWarning($"Automatic initialization failed on {gameObject.name}. You must manually call Initialize.");
                return;
            }

            Initialize(tm);
        }

        /// <summary>
        /// Initializes using a specified TimeManager.
        /// </summary>
        /// <param name="timeManager"></param>
        public void Initialize(TimeManager timeManager)
        {
            if (timeManager == null)
            {
                NetworkManagerExtensions.LogError($"TimeManager cannot be null when initializing.");
                return;
            }

            SmootherController.SetTimeManager(timeManager);

            _initializationSettings.SetOfflineRuntimeValues(timeManager, graphicalTransform: transform);
            SmootherController.Initialize(_initializationSettings, _movementSettings, default);
            SmootherController.StartSmoother();

            IsInitialized = true;
        }

        /// <summary>
        /// Sets a transform as the target to follow.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetTargetTransform(Transform value) 
        {
            if (IsInitialized) 
            {
                NetworkManagerExtensions.LogError($"Target can only be set before Initialize is called.");
                return;
            }
            
            _initializationSettings.TargetTransform = value;
        }

        /// <summary>
        /// Stores smoothers if they have value.
        /// </summary>
        private void StoreControllers()
        {
            if (SmootherController == null)
                return;

            ResettableObjectCaches<TickSmootherController>.Store(SmootherController);
            SmootherController = null;
        }

        /// <summary>
        /// Stores current smoothers and retrieves new ones.
        /// </summary>
        private void RetrieveControllers()
        {
            StoreControllers();
            SmootherController = ResettableObjectCaches<TickSmootherController>.Retrieve();
        }
    }
}﻿using FishNet.Managing.Predicting;
using FishNet.Managing.Timing;
using FishNet.Object;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Component.Transforming.Beta
{
    /// <summary>
    /// Smoothes this object between ticks.
    /// </summary>
    /// <remarks>This can be configured to smooth over a set interval of time, or to smooth adaptively and make path corrections for prediction.</remarks>
    public class TickSmootherController : IResettable
    {
        #region Public.
        /// <summary>
        /// Logic for owner smoothing.
        /// </summary>
        public UniversalTickSmoother UniversalSmoother { get; private set; }
        #endregion

        #region Private.
        /// <summary>
        /// 
        /// </summary>
        private InitializationSettings _initializationSettings = new();
        /// <summary>
        /// 
        /// </summary>
        private MovementSettings _ownerMovementSettings = new();
        /// <summary>
        /// 
        /// </summary>
        private MovementSettings _spectatorMovementSettings = new();
        /// <summary>
        /// True if OnDestroy has been called.
        /// </summary>
        private bool _destroyed;
        /// <summary>
        /// Cached timeManager reference.
        /// </summary>
        private TimeManager _timeManager;
        /// <summary>
        /// NetworkBehaviour which initialized this object. Value may be null when initialized for an Offline smoother.
        /// </summary>
        private NetworkBehaviour _initializingNetworkBehaviour;
        /// <summary>
        /// Transform which initialized this object.
        /// </summary>
        private Transform _graphicalTransform;
        /// <summary>
        /// True if initialized with a null NetworkBehaviour.
        /// </summary>
        private bool _initializedOffline;
        /// <summary>
        /// True if subscribed to events used for adaptiveInterpolation.
        /// </summary>
        private bool _subscribedToAdaptiveEvents;
        /// <summary>
        /// True if currently subscribed to events.
        /// </summary>
        private bool _subscribed;
        /// <summary>
        /// True if initialized.
        /// </summary>
        private bool _isInitialized;
        #endregion

        public void Initialize(InitializationSettings initializationSettings, MovementSettings ownerSettings, MovementSettings spectatorSettings)
        {
            _initializingNetworkBehaviour = initializationSettings.InitializingNetworkBehaviour;
            _graphicalTransform = initializationSettings.GraphicalTransform;

            _initializationSettings = initializationSettings;
            _ownerMovementSettings = ownerSettings;
            _spectatorMovementSettings = spectatorSettings;

            _initializedOffline = (initializationSettings.InitializingNetworkBehaviour == null);

            _isInitialized = true;
        }

        public void OnDestroy()
        {
            ChangeSubscriptions(false);
            StoreSmoother();
            _destroyed = true;
            _isInitialized = false;
        }

        public void StartSmoother()
        {
            if (!_isInitialized)
                return;

            bool canStart = (_initializedOffline) ? StartOffline() : StartOnline();

            if (!canStart)
                return;

            RetrieveSmoothers();

            UniversalSmoother.Initialize(_initializationSettings, _ownerMovementSettings, _spectatorMovementSettings);

            UniversalSmoother.StartSmoother();

            bool StartOnline()
            {
                NetworkBehaviour nb = _initializingNetworkBehaviour;

                SetTimeManager(nb.TimeManager);

                return true;
            }

            bool StartOffline()
            {
                if (_timeManager == null)
                    return false;

                return true;
            }
        }

        public void StopSmoother()
        {
            ChangeSubscriptions(subscribe: false);

            if (!_initializedOffline)
                StopOnline();

            if (UniversalSmoother != null)
                UniversalSmoother.StopSmoother();

            void StopOnline()
            {
                SetTimeManager(tm: null);
            }

            //Intentionally left blank.
            //void StopOffline() { }
        }

        public void TimeManager_OnUpdate()
        {
            UniversalSmoother.OnUpdate(Time.deltaTime);
        }

        public void TimeManager_OnPreTick()
        {
            UniversalSmoother.OnPreTick();
        }

        /// <summary>
        /// Called after a tick completes.
        /// </summary>
        public void TimeManager_OnPostTick()
        {
            if (_timeManager != null)
                UniversalSmoother.OnPostTick(_timeManager.LocalTick);
        }

        private void PredictionManager_OnPostReplicateReplay(uint clientTick, uint serverTick)
        {
            UniversalSmoother.OnPostReplicateReplay(clientTick);
        }

        
        private void TimeManager_OnRoundTripTimeUpdated(long rttMs)
        {
            UniversalSmoother.UpdateRealtimeInterpolation();
        }

        /// <summary>
        /// Stores smoothers if they have value.
        /// </summary>
        private void StoreSmoother()
        {
            if (UniversalSmoother == null)
                return;

            ResettableObjectCaches<UniversalTickSmoother>.Store(UniversalSmoother);
            UniversalSmoother = null;
        }

        /// <summary>
        /// Stores current smoothers and retrieves new ones.
        /// </summary>
        private void RetrieveSmoothers()
        {
            StoreSmoother();
            UniversalSmoother = ResettableObjectCaches<UniversalTickSmoother>.Retrieve();
        }

        // /// <summary>
        // /// Sets a target transform to follow.
        // /// </summary>
        // public void SetTargetTransform(Transform value)
        // {
        //     Transform currentTargetTransform = _initializationSettings.TargetTransform;
        //
        //     if (value == currentTargetTransform)
        //         return;
        //
        //     bool clientStartCalled = (_initializedOffline && _timeManager != null) || (_initializingNetworkBehaviour != null && _initializingNetworkBehaviour.OnStartClientCalled);
        //
        //     bool previousTargetTransformIsValid = (currentTargetTransform != null);
        //
        //     //If target is different and old is not null then reset.
        //     if (previousTargetTransformIsValid && clientStartCalled)
        //         OnStopClient();
        //
        //     _initializationSettings.TargetTransform = value;
        //     if (previousTargetTransformIsValid && clientStartCalled)
        //         OnStartClient();
        // }

        /// <summary>
        /// Sets a new PredictionManager to use.
        /// </summary>
        public void SetTimeManager(TimeManager tm)
        {
            if (tm == _timeManager)
                return;

            //Unsub from current.
            ChangeSubscriptions(false);
            //Sub to newest.
            _timeManager = tm;
            ChangeSubscriptions(true);
        }

        /// <summary>
        /// Changes the subscription to the TimeManager.
        /// </summary>
        private void ChangeSubscriptions(bool subscribe)
        {
            if (_destroyed)
                return;
            TimeManager tm = _timeManager;
            if (tm == null)
                return;

            if (subscribe == _subscribed)
                return;
            _subscribed = subscribe;

            bool adaptiveIsOff = (_ownerMovementSettings.AdaptiveInterpolationValue == AdaptiveInterpolationType.Off && _spectatorMovementSettings.AdaptiveInterpolationValue == AdaptiveInterpolationType.Off);

            if (subscribe)
            {
                tm.OnUpdate += TimeManager_OnUpdate;
                tm.OnPreTick += TimeManager_OnPreTick;
                tm.OnPostTick += TimeManager_OnPostTick;

                if (!adaptiveIsOff)
                {
                    tm.OnRoundTripTimeUpdated += TimeManager_OnRoundTripTimeUpdated;
                    PredictionManager pm = tm.NetworkManager.PredictionManager;
                    pm.OnPostReplicateReplay += PredictionManager_OnPostReplicateReplay;
                    _subscribedToAdaptiveEvents = true;
                }
            }
            else
            {
                tm.OnUpdate -= TimeManager_OnUpdate;
                tm.OnPreTick -= TimeManager_OnPreTick;
                tm.OnPostTick -= TimeManager_OnPostTick;

                if (_subscribedToAdaptiveEvents)
                {
                    tm.OnRoundTripTimeUpdated -= TimeManager_OnRoundTripTimeUpdated;
                    PredictionManager pm = tm.NetworkManager.PredictionManager;
                    pm.OnPostReplicateReplay -= PredictionManager_OnPostReplicateReplay;
                }
            }
        }

        public void ResetState()
        {
            _initializationSettings = default;
            _ownerMovementSettings = default;
            _spectatorMovementSettings = default;

            _destroyed = false;
            _timeManager = null;
            _initializingNetworkBehaviour = null;
            _graphicalTransform = null;
            
            _subscribed = false;
            _subscribedToAdaptiveEvents = false;

            _isInitialized = false;
        }

        public void InitializeState() { }
    }
}﻿using System;
using FishNet.Managing;
using FishNet.Managing.Timing;
using FishNet.Object;
using FishNet.Object.Prediction;
using FishNet.Utility.Extension;
using GameKit.Dependencies.Utilities;
using UnityEngine;
using UnityEngine.Scripting;

namespace FishNet.Component.Transforming.Beta
{
    /// <summary>
    /// This class is under regular development and it's API may change at any time.
    /// </summary>
    public sealed class UniversalTickSmoother : IResettable
    {
        #region Types.
        [Preserve]
        private struct TickTransformProperties
        {
            public readonly uint Tick;
            public readonly TransformProperties Properties;

            public TickTransformProperties(uint tick, Transform t)
            {
                Tick = tick;
                Properties = new(t.localPosition, t.localRotation, t.localScale);
            }

            public TickTransformProperties(uint tick, Transform t, Vector3 localScale)
            {
                Tick = tick;
                Properties = new(t.localPosition, t.localRotation, localScale);
            }

            public TickTransformProperties(uint tick, TransformProperties tp)
            {
                Tick = tick;
                Properties = tp;
            }

            public TickTransformProperties(uint tick, TransformProperties tp, Vector3 localScale)
            {
                Tick = tick;
                tp.Scale = localScale;
                Properties = tp;
            }
        }
        #endregion

        #region public.
        /// <summary>
        /// True if currently initialized.
        /// </summary>
        public bool IsInitialized { get; private set; }
        #endregion

        #region Private.
        /// <summary>
        /// How quickly to move towards goal values.
        /// </summary>
        private MoveRates _moveRates = new();
        /// <summary>
        /// True if a pretick occurred since last postTick.
        /// </summary>
        private bool _preTicked;
        /// <summary>
        /// World values of the graphical after it's been aligned to initialized values in PreTick.
        /// </summary>
        private TransformProperties _trackerPreTickWorldValues;
        /// <summary>
        /// World values of the graphical after it's been aligned to initialized values in PreTick.
        /// </summary>
        private TransformProperties _graphicsPreTickWorldValues;
        /// <summary>
        /// Cached value of adaptive interpolation value.
        /// </summary>
        private AdaptiveInterpolationType _cachedAdaptiveInterpolationValue;
        /// <summary>
        /// Cached value of flat interpolation value.
        /// </summary>
        private byte _cachedInterpolationValue;
        /// <summary>
        /// Cached properties to smooth of the graphical.
        /// </summary>
        private TransformPropertiesFlag _cachedSmoothedProperties;
        /// <summary>
        /// Cached value of snapping non-smoothed properties.
        /// </summary>
        private bool _cachedSnapNonSmoothedProperties;
        /// <summary>
        /// Squared distance target must travel to cause a teleport.
        /// </summary>
        private float _cachedTeleportThreshold;
        /// <summary>
        /// True if to detach on network start.
        /// </summary>
        private bool _detachOnStart;
        /// <summary>
        /// True to re-attach on network stop.
        /// </summary>
        private bool _attachOnStop;
        /// <summary>
        /// True to begin moving soon as movement data becomes available. Movement will ease in until at interpolation value. False to prevent movement until movement data count meet interpolation.
        /// </summary>
        private bool _moveImmediately;
        /// <summary>
        /// Transform the graphics should follow.
        /// </summary>
        private Transform _targetTransform;
        /// <summary>
        /// Cached value of the object to smooth.
        /// </summary>
        private Transform _graphicalTransform;
        /// <summary>
        /// Empty gameObject containing a transform which has properties checked after each simulation.
        /// If the graphical starts off as nested of targetTransform then this object is created where the graphical object is.
        /// Otherwise, this object is placed directly beneath targetTransform.
        /// </summary>
        private Transform _trackerTransform;
        /// <summary>
        /// TimeManager tickDelta.
        /// </summary>
        private float _tickDelta;
        /// <summary>
        /// NetworkBehaviour this is initialized for. Value may be null.
        /// </summary>
        private NetworkBehaviour _initializingNetworkBehaviour;
        /// <summary>
        /// TimeManager this is initialized for.
        /// </summary>
        private TimeManager _initializingTimeManager;
        /// <summary>
        /// Value to multiply movement by. This is used to reduce or increase the rate the movement buffer is consumed.
        /// </summary>
        private float _movementMultiplier = 1f;
        /// <summary>
        /// TransformProperties to move towards.
        /// </summary>
        private BasicQueue<TickTransformProperties> _transformProperties;
        /// <summary>
        /// True if to smooth using owner settings, false for spectator settings.
        /// This is only used for performance gains.
        /// </summary>
        private bool _useOwnerSettings;
        /// <summary>
        /// Last tick this was teleported on.
        /// </summary>
        private uint _teleportedTick = TimeManager.UNSET_TICK;
        /// <summary>
        /// Current interpolation value, be it a flat value or adaptive.
        /// </summary>
        private byte _realtimeInterpolation;
        /// <summary>
        /// Settings to use for owners.
        /// </summary>
        private MovementSettings _controllerMovementSettings;
        /// <summary>
        /// Settings to use for spectators.
        /// </summary>
        private MovementSettings _spectatorMovementSettings;
        /// <summary>
        /// True if moving has started and has not been stopped.
        /// </summary>
        private bool _isMoving;
        #endregion

        #region Const.
        /// <summary>
        /// Maximum allowed entries to be queued over the interpolation amount.
        /// </summary>
        private const int MAXIMUM_QUEUED_OVER_INTERPOLATION = 3;
        #endregion

        [Preserve]
        public UniversalTickSmoother() { }

        ~UniversalTickSmoother()
        {
            //This is a last resort for if something didnt deinitialize right.
            ResetState();
        }

        [Obsolete("This method is no longer used. Use TrySetGraphicalTrackerLocalProperties(TransformProperties).")] //Remove V5
        public void SetGraphicalInitializedOffsetValues(TransformProperties value) { }

        [Obsolete("This method is no longer used. Use GetGraphicalTrackerLocalProperties.")] //Remove V5
        public TransformProperties GetGraphicalInitializedOffsetValues() => default;

        /// <summary>
        /// Tries to set local properties for the graphical tracker transform.
        /// </summary>
        /// <param name="localValues">New values.</param>
        /// <returns>Returns true if the tracker has been setup and values have been applied to teh tracker transform.</returns>
        /// <remarks>When false is returned the values are cached and will be set when tracker is created. A cached value will be used every time the tracker is setup; to disable this behavior call this method with null value.</remarks>
        public bool TrySetGraphicalTrackerLocalProperties(TransformProperties? localValues)
        {
            if (_trackerTransform == null || localValues == null)
            {
                _queuedTrackerProperties = localValues;
                return false;
            }


            _trackerTransform.SetLocalProperties(localValues.Value);
            return true;
        }

        [Obsolete("This method is no longer used. Use TrySetGraphicalTrackerLocalProperties(TransformProperties).")] //Remove V5
        public void SetAdditionalGraphicalOffsetValues(TransformProperties localValues) { }

        [Obsolete("This method is no longer used. Use GetGraphicalTrackerLocalProperties.")] //Remove V5
        public TransformProperties GetAdditionalGraphicalOffsetValues() => default;

        public TransformProperties GetGraphicalTrackerLocalProperties()
        {
            if (_trackerTransform != null)
                return new(_trackerTransform.localPosition, _trackerTransform.localRotation, _trackerTransform.localScale);
            if (_queuedTrackerProperties != null)
                return _queuedTrackerProperties.Value;

            //Fall through.
            NetworkManager manager = (_initializingNetworkBehaviour == null) ? null : _initializingNetworkBehaviour.NetworkManager;
            manager.LogWarning($"Graphical tracker properties cannot be returned because tracker is not setup yet, and no setup properties have been specified. Use TrySetGraphicalTrackerProperties to set setup properties or call this method after IsInitialized is true.");
            return default;
        }

        /// <summary>
        /// Properties for the tracker which are queued to be set when the tracker is setup.
        /// </summary>
        private TransformProperties? _queuedTrackerProperties;

        /// <summary>
        /// Updates the smoothedProperties value.
        /// </summary>
        /// <param name="value">New value.</param>
        /// <param name="forOwnerOrOfflineSmoother">True if updating owner smoothing settings, or updating settings on an offline smoother. False to update spectator settings</param>
        public void SetSmoothedProperties(TransformPropertiesFlag value, bool forOwnerOrOfflineSmoother)
        {
            _controllerMovementSettings.SmoothedProperties = value;
            SetCaches(forOwnerOrOfflineSmoother);
        }

        /// <summary>
        /// Updates the interpolationValue when not using adaptive interpolation. Calling this method will also disable adaptive interpolation.
        /// </summary>
        /// <param name="value"></param>
        public void SetInterpolationValue(byte value, bool forOwnerOrOfflineSmoother) => SetInterpolationValue(value, forOwnerOrOfflineSmoother, unsetAdaptiveInterpolation: true);

        /// <summary>
        /// Updates the interpolationValue when not using adaptive interpolation. Calling this method will also disable adaptive interpolation.
        /// </summary>
        private void SetInterpolationValue(byte value, bool forOwnerOrOfflineSmoother, bool unsetAdaptiveInterpolation)
        {
            if (value < 1)
                value = 1;

            if (forOwnerOrOfflineSmoother)
                _controllerMovementSettings.InterpolationValue = value;
            else
                _spectatorMovementSettings.InterpolationValue = value;

            if (unsetAdaptiveInterpolation)
                SetAdaptiveInterpolation(AdaptiveInterpolationType.Off, forOwnerOrOfflineSmoother);
        }

        /// <summary>
        /// Updates the adaptiveInterpolation value.
        /// </summary>
        /// <param name="adaptiveInterpolation">New value.</param>
        public void SetAdaptiveInterpolation(AdaptiveInterpolationType value, bool forOwnerOrOfflineSmoother)
        {
            if (forOwnerOrOfflineSmoother)
                _controllerMovementSettings.AdaptiveInterpolationValue = value;
            else
                _spectatorMovementSettings.AdaptiveInterpolationValue = value;

            UpdateRealtimeInterpolation();
        }

        public void Initialize(InitializationSettings initializationSettings, MovementSettings ownerSettings, MovementSettings spectatorSettings)
        {
            ResetState();

            Transform graphicalTransform = initializationSettings.GraphicalTransform;
            Transform targetTransform = initializationSettings.TargetTransform;

            if (!TransformsAreValid(graphicalTransform, targetTransform))
                return;

            _transformProperties = CollectionCaches<TickTransformProperties>.RetrieveBasicQueue();
            _controllerMovementSettings = ownerSettings;
            _spectatorMovementSettings = spectatorSettings;

            /* Unset scale smoothing if not detaching. This is to prevent
             * the scale from changing with the parent if nested, as that
             * would result in the scale being modified twice, once on the parent
             * and once on the graphical. Thanks deo_wh for find! */
            if (!initializationSettings.DetachOnStart)
            {
                _controllerMovementSettings.SmoothedProperties &= ~TransformPropertiesFlag.Scale;
                _spectatorMovementSettings.SmoothedProperties &= ~TransformPropertiesFlag.Scale;
            }

            _initializingNetworkBehaviour = initializationSettings.InitializingNetworkBehaviour;
            _initializingTimeManager = initializationSettings.InitializingTimeManager;
            _targetTransform = targetTransform;
            _graphicalTransform = graphicalTransform;
            _tickDelta = (float)initializationSettings.InitializingTimeManager.TickDelta;
            _detachOnStart = initializationSettings.DetachOnStart;
            _attachOnStop = initializationSettings.AttachOnStop;
            _moveImmediately = initializationSettings.MoveImmediately;

            SetCaches(GetUseOwnerSettings());

            //Use set method as it has sanity checks.
            SetInterpolationValue(_controllerMovementSettings.InterpolationValue, forOwnerOrOfflineSmoother: true, unsetAdaptiveInterpolation: false);
            SetInterpolationValue(_spectatorMovementSettings.InterpolationValue, forOwnerOrOfflineSmoother: false, unsetAdaptiveInterpolation: false);

            SetAdaptiveInterpolation(_controllerMovementSettings.AdaptiveInterpolationValue, forOwnerOrOfflineSmoother: true);
            SetAdaptiveInterpolation(_spectatorMovementSettings.AdaptiveInterpolationValue, forOwnerOrOfflineSmoother: false);

            SetupTrackerTransform();
            /* This is called after setting up the tracker transform in the scenario
             * the user set additional offsets before this was initialized. */
            if (_queuedTrackerProperties != null)
                TrySetGraphicalTrackerLocalProperties(_queuedTrackerProperties.Value);

            void SetupTrackerTransform()
            {
                _trackerTransform = new GameObject($"{_graphicalTransform.name}_Tracker").transform;

                if (_detachOnStart)
                {
                    _trackerTransform.SetParent(_targetTransform);
                }
                else
                {
                    Transform trackerParent = _graphicalTransform.IsChildOf(targetTransform) ? _graphicalTransform.parent : targetTransform;
                    _trackerTransform.SetParent(trackerParent);
                }

                _trackerTransform.SetLocalPositionRotationAndScale(_graphicalTransform.localPosition, graphicalTransform.localRotation, graphicalTransform.localScale);
            }

            IsInitialized = true;
        }

        /// <summary>
        /// Returns if configured transforms are valid.
        /// </summary>
        /// <returns></returns>
        private bool TransformsAreValid(Transform graphicalTransform, Transform targetTransform)
        {
            if (graphicalTransform == null)
            {
                NetworkManagerExtensions.LogError($"Graphical transform cannot be null.");
                return false;
            }
            if (targetTransform == null)
            {
                NetworkManagerExtensions.LogError($"Target transform on {graphicalTransform} cannot be null.");
                return false;
            }
            if (targetTransform == graphicalTransform)
            {
                NetworkManagerExtensions.LogError($"Target transform cannot be the same as graphical transform on {graphicalTransform}.");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Returns true if to use adaptive interpolation.
        /// </summary>
        /// <returns></returns>
        private bool GetUseAdaptiveInterpolation()
        {
            if (_cachedAdaptiveInterpolationValue == AdaptiveInterpolationType.Off || _initializingTimeManager.NetworkManager.IsServerOnlyStarted)
                return false;

            return true;
        }

        /// <summary>
        /// Gets if to use owner values.
        /// </summary>
        /// <remarks>OwnerSettings can be used to read determine this as both owner and spectator settings will have the name InitializingNetworkBehaviour.</remarks>
        /// <returns></returns>
        private bool GetUseOwnerSettings() => (_initializingNetworkBehaviour == null) || _initializingNetworkBehaviour.IsOwner || !_initializingNetworkBehaviour.Owner.IsValid;

        /// <summary>
        /// Updates OwnerDuringPreTick value and caches if needed.
        /// </summary>
        private void SetUseOwnerSettings(bool value, bool force = false)
        {
            if (value == _useOwnerSettings && !force)
                return;

            _useOwnerSettings = value;

            SetCaches(value);
        }

        /// <summary>
        /// Updates OwnerDuringPreTick value and caches if needed.
        /// </summary>
        private void SetCaches(bool useOwnerSettings)
        {
            MovementSettings movementSettings = (useOwnerSettings) ? _controllerMovementSettings : _spectatorMovementSettings;

            _cachedSmoothedProperties = movementSettings.SmoothedProperties;
            _cachedSnapNonSmoothedProperties = movementSettings.SnapNonSmoothedProperties;
            _cachedAdaptiveInterpolationValue = movementSettings.AdaptiveInterpolationValue;
            _cachedInterpolationValue = movementSettings.InterpolationValue;

            _cachedTeleportThreshold = (movementSettings.EnableTeleport) ? (movementSettings.TeleportThreshold * movementSettings.TeleportThreshold) : MoveRates.UNSET_VALUE;
        }

        /// <summary>
        /// Deinitializes this smoother resetting values.
        /// </summary>
        public void Deinitialize()
        {
            ResetState();
            IsInitialized = false;
        }

        /// <summary>
        /// Updates interpolation based on localClient latency when using adaptive interpolation, or uses set value when adaptive interpolation is off.
        /// </summary>
        public void UpdateRealtimeInterpolation()
        {
            /*  If not networked, server is started, or if not
             * using adaptive interpolation then use
             * flat interpolation.*/
            if (!GetUseAdaptiveInterpolation())
            {
                _realtimeInterpolation = _cachedInterpolationValue;
                return;
            }

            /* If here then adaptive interpolation is being calculated. */

            TimeManager tm = _initializingTimeManager;

            //Calculate roughly what client state tick would be.
            uint localTick = tm.LocalTick;
            //This should never be the case; this is a precautionary against underflow.
            if (localTick == TimeManager.UNSET_TICK)
                return;

            //Ensure at least 1 tick.
            long rttTime = tm.RoundTripTime;
            uint rttTicks = tm.TimeToTicks(rttTime) + 1;

            uint clientStateTick = (localTick - rttTicks);
            float interpolation = (localTick - clientStateTick);

            //Minimum interpolation is that of adaptive interpolation level.
            interpolation += (byte)_cachedAdaptiveInterpolationValue;

            //Ensure interpolation is not more than a second.
            if (interpolation > tm.TickRate)
                interpolation = tm.TickRate;
            else if (interpolation > byte.MaxValue)
                interpolation = byte.MaxValue;

            /* Only update realtime interpolation if it changed more than 1
             * tick. This is to prevent excessive changing of interpolation value, which
             * could result in noticeable speed ups/slow downs given movement multiplier
             * may change when buffer is too full or short. */
            if (_realtimeInterpolation == 0 || Math.Abs(_realtimeInterpolation - interpolation) > 1)
                _realtimeInterpolation = (byte)Math.Ceiling(interpolation);
        }

        /// <summary>
        /// This should be called when OnStartClient is invoked on the initializing NetworkBehaviour.
        /// </summary>
        /// <remarks>This does not need to be called if there is no initializing NetworkBehaviour.</remarks>
        public void StartSmoother()
        {
            DetachOnStart();
        }

        /// <summary>
        /// This should be called when OnStopClient is invoked on the initializing NetworkBehaviour.
        /// </summary>
        /// <remarks>This does not need to be called if there is no initializing NetworkBehaviour.</remarks>
        internal void StopSmoother()
        {
            AttachOnStop();
        }

        /// <summary>
        /// Called every frame.
        /// </summary>
        public void OnUpdate(float delta)
        {
            if (!CanSmooth())
                return;

            MoveToTarget(delta);
        }

        /// <summary>
        /// Called when the TimeManager invokes OnPreTick.
        /// </summary>
        public void OnPreTick()
        {
            if (!CanSmooth())
                return;

            SetUseOwnerSettings(GetUseOwnerSettings());

            _preTicked = true;
            DiscardExcessiveTransformPropertiesQueue();
            _graphicsPreTickWorldValues = _graphicalTransform.GetWorldProperties();
            _trackerPreTickWorldValues = GetTrackerWorldProperties();
        }

        /// <summary>
        /// Called when the TimeManager invokes OnPostReplay.
        /// </summary>
        /// <param name="clientTick">Replay tick for the local client.</param>
        /// <remarks>This is dependent on the initializing NetworkBehaviour being set.</remarks>
        public void OnPostReplicateReplay(uint clientTick)
        {
            if (!NetworkObjectIsReconciling())
                return;

            if (_transformProperties.Count == 0)
                return;
            if (clientTick <= _teleportedTick)
                return;
            uint firstTick = _transformProperties.Peek().Tick;
            //Already in motion to first entry, or first entry passed tick.
            if (clientTick <= firstTick)
                return;

            ModifyTransformProperties(clientTick, firstTick);
        }

        /// <summary>
        /// Called when TimeManager invokes OnPostTick.
        /// </summary>
        /// <param name="clientTick">Local tick of the client.</param>
        public void OnPostTick(uint clientTick)
        {
            if (!CanSmooth())
                return;
            if (clientTick <= _teleportedTick)
                return;

            //If preticked then previous transform values are known.
            if (_preTicked)
            {
                DiscardExcessiveTransformPropertiesQueue();

                //Only needs to be put to pretick position if not detached.
                if (!_detachOnStart)
                    _graphicalTransform.SetWorldProperties(_graphicsPreTickWorldValues);

                //SnapNonSmoothedProperties();
                AddTransformProperties(clientTick);
            }
            //If did not pretick then the only thing we can do is snap to instantiated values.
            else
            {
                //Only set to position if not to detach.
                if (!_detachOnStart)
                    _graphicalTransform.SetWorldProperties(GetTrackerWorldProperties());
            }
        }

        /// <summary>
        /// Snaps non-smoothed properties to original positoin if setting is enabled.
        /// </summary>
        private void SnapNonSmoothedProperties()
        {
            //Feature is not enabled.
            if (!_cachedSnapNonSmoothedProperties)
                return;

            TransformPropertiesFlag smoothedProperties = _cachedSmoothedProperties;

            //Everything is smoothed.
            if (smoothedProperties == TransformPropertiesFlag.Everything)
                return;

            TransformProperties goalValeus = GetTrackerWorldProperties();

            if (!smoothedProperties.FastContains(TransformPropertiesFlag.Position))
                _graphicalTransform.position = goalValeus.Position;
            if (!smoothedProperties.FastContains(TransformPropertiesFlag.Rotation))
                _graphicalTransform.rotation = goalValeus.Rotation;
            if (!smoothedProperties.FastContains(TransformPropertiesFlag.Scale))
                _graphicalTransform.localScale = goalValeus.Scale;
        }

        /// <summary>
        /// Returns if the initialized NetworkBehaviour's NetworkObject is reconcilling.
        /// </summary>
        private bool NetworkObjectIsReconciling() => (_initializingNetworkBehaviour == null || _initializingNetworkBehaviour.NetworkObject.IsObjectReconciling);

        /// <summary>
        /// Teleports the graphical to it's starting position and clears the internal movement queue.
        /// </summary>
        public void Teleport()
        {
            if (_initializingTimeManager == null)
                return;

            //If using adaptive interpolation then set the tick which was teleported.
            if (_controllerMovementSettings.AdaptiveInterpolationValue != AdaptiveInterpolationType.Off)
            {
                TimeManager tm = (_initializingTimeManager == null) ? InstanceFinder.TimeManager : _initializingTimeManager;
                if (tm != null)
                    _teleportedTick = tm.LocalTick;
            }

            ClearTransformPropertiesQueue();

            _graphicalTransform.SetWorldProperties(_trackerTransform.GetWorldProperties());
        }

        /// <summary>
        /// Clears the pending movement queue.
        /// </summary>
        private void ClearTransformPropertiesQueue()
        {
            _transformProperties.Clear();
            //Also unset move rates since there is no more queue.
            _moveRates = new(MoveRates.UNSET_VALUE);
        }

        /// <summary>
        /// Discards datas over interpolation limit from movement queue.
        /// </summary>
        private void DiscardExcessiveTransformPropertiesQueue()
        {
            int propertiesCount = _transformProperties.Count;
            int dequeueCount = (propertiesCount - (_realtimeInterpolation + MAXIMUM_QUEUED_OVER_INTERPOLATION));

            //If there are entries to dequeue.
            if (dequeueCount > 0)
            {
                TickTransformProperties tpp = default;
                for (int i = 0; i < dequeueCount; i++)
                    tpp = _transformProperties.Dequeue();

                SetMoveRates(tpp.Properties);
            }
        }

        /// <summary>
        /// Adds a new transform properties and sets move rates if needed.
        /// </summary>
        private void AddTransformProperties(uint tick)
        {
            TickTransformProperties tpp = new(tick, GetTrackerWorldProperties());
            _transformProperties.Enqueue(tpp);

            //If first entry then set move rates.
            if (_transformProperties.Count == 1)
            {
                TransformProperties gfxWorldProperties = _graphicalTransform.GetWorldProperties();
                SetMoveRates(gfxWorldProperties);
            }
        }

        /// <summary>
        /// Modifies a transform property for a tick. This does not error check for empty collections.
        /// </summary>
        /// <param name="firstTick">First tick in the queue. If 0 this will be looked up.</param>
        private void ModifyTransformProperties(uint clientTick, uint firstTick)
        {
            int queueCount = _transformProperties.Count;
            uint tick = clientTick;
            /*Ticks will always be added incremental by 1 so it's safe to jump ahead the difference
             * of tick and firstTick. */
            int index = (int)(tick - firstTick);
            //Replace with new data.
            if (index < queueCount)
            {
                if (tick != _transformProperties[index].Tick)
                {
                    //Should not be possible.
                }
                else
                {
                    TransformProperties newProperties = GetTrackerWorldProperties();
                    /* Adjust transformProperties to ease into any corrections.
                     * The corrected value is used the more the index is to the end
                     * of the queue. */
                    /* We want to be fully eased in by the last entry of the queue. */

                    int lastPossibleIndex = (queueCount - 1);
                    int adjustedQueueCount = (lastPossibleIndex - 1);
                    if (adjustedQueueCount < 1)
                        adjustedQueueCount = 1;
                    float easePercent = ((float)index / adjustedQueueCount);

                    //If easing.
                    if (easePercent < 1f)
                    {
                        if (easePercent < 1f)
                            easePercent = (float)Math.Pow(easePercent, (adjustedQueueCount - index));

                        TransformProperties oldProperties = _transformProperties[index].Properties;
                        newProperties.Position = Vector3.Lerp(oldProperties.Position, newProperties.Position, easePercent);
                        newProperties.Rotation = Quaternion.Lerp(oldProperties.Rotation, newProperties.Rotation, easePercent);
                        newProperties.Scale = Vector3.Lerp(oldProperties.Scale, newProperties.Scale, easePercent);
                    }

                    _transformProperties[index] = new(tick, newProperties);
                }
            }
            else
            {
                //This should never happen.
            }
        }

        /// <summary>
        /// Gets properties of the tracker.
        /// </summary>
        private TransformProperties GetTrackerWorldProperties()
        {
            /* Return lossyScale if graphical is not attached. Otherwise,
             * graphical should retain the tracker localScale so it changes
             * with root. */
            
            Vector3 scale = (_detachOnStart) ? _trackerTransform.lossyScale : _trackerTransform.localScale;
            return new(_trackerTransform.position, _trackerTransform.rotation, scale);
        }
        
        /// <summary>
        /// Returns if prediction can be used on this rigidbody.
        /// </summary>
        /// <returns></returns>
        private bool CanSmooth()
        {
            //No graphical object is set.
            if (_graphicalTransform == null)
                return false;

            return _initializingTimeManager.NetworkManager.IsClientStarted;
        }

        /// <summary>
        /// Sets new rates based on next entries in transformProperties queue, against a supplied TransformProperties.
        /// </summary>
        private void SetMoveRates(in TransformProperties prevValues)
        {
            if (_transformProperties.Count == 0)
            {
                _moveRates = new(MoveRates.UNSET_VALUE);
                return;
            }

            TransformProperties nextValues = _transformProperties.Peek().Properties;

            float duration = _tickDelta;

            _moveRates = MoveRates.GetMoveRates(prevValues, nextValues, duration, _cachedTeleportThreshold);
            _moveRates.TimeRemaining = duration;

            SetMovementMultiplier();
        }

        private void SetMovementMultiplier()
        {
            if (_moveImmediately)
            {
                float percent = Mathf.InverseLerp(0, _realtimeInterpolation, _transformProperties.Count);
                _movementMultiplier = percent;

                _movementMultiplier = Mathf.Clamp(_movementMultiplier, 0.5f, 1.05f);
            }
            //For the time being, not moving immediately uses these multiplier calculations.
            else
            {
                /* If there's more in queue than interpolation then begin to move faster based on overage.
                 * Move 5% faster for every overage. */
                int overInterpolation = (_transformProperties.Count - _realtimeInterpolation);
                //If needs to be adjusted.
                if (overInterpolation != 0)
                {
                    _movementMultiplier += (0.015f * overInterpolation);
                }
                //If does not need to be adjusted.
                else
                {
                    //If interpolation is 1 then slow down just barely to accomodate for frame delta variance.
                    if (_realtimeInterpolation == 1)
                        _movementMultiplier = 1f;
                }

                _movementMultiplier = Mathf.Clamp(_movementMultiplier, 0.95f, 1.05f);
            }
        }

        /// <summary>
        /// Moves transform to target values.
        /// </summary>
        private void MoveToTarget(float delta)
        {
            int tpCount = _transformProperties.Count;

            //No data.
            if (tpCount == 0)
                return;

            if (_moveImmediately)
            {
                _isMoving = true;
            }
            else
            {
                //Enough in buffer to move.
                if (tpCount >= _realtimeInterpolation)
                {
                    _isMoving = true;
                }
                else if (!_isMoving)
                {
                    return;
                }
                /* If buffer is considerably under goal then halt
                 * movement. This will allow the buffer to grow. */
                else if ((tpCount - _realtimeInterpolation) < -4)
                {
                    _isMoving = false;
                    return;
                }
            }

            TickTransformProperties ttp = _transformProperties.Peek();

            TransformPropertiesFlag smoothedProperties = _cachedSmoothedProperties;

            _moveRates.Move(_graphicalTransform, ttp.Properties, smoothedProperties, (delta * _movementMultiplier), useWorldSpace: true);

            float tRemaining = _moveRates.TimeRemaining;
            //if TimeLeft is <= 0f then transform is at goal. Grab a new goal if possible.
            if (tRemaining <= 0f)
            {
                //Dequeue current entry and if there's another call a move on it.
                _transformProperties.Dequeue();

                //If there are entries left then setup for the next.
                if (_transformProperties.Count > 0)
                {
                    SetMoveRates(ttp.Properties);
                    //If delta is negative then call move again with abs.
                    if (tRemaining < 0f)
                        MoveToTarget(Mathf.Abs(tRemaining));
                }
                //No remaining, set to snap.
                else
                {
                    ClearTransformPropertiesQueue();
                }
            }
        }

        private void DetachOnStart()
        {
            if (!_detachOnStart)
                return;

            TransformProperties gfxWorldProperties = _graphicalTransform.GetWorldProperties();
            _graphicalTransform.SetParent(null);
            _graphicalTransform.SetWorldProperties(gfxWorldProperties);
        }

        /// <summary>
        /// Attachs to Target transform is possible.
        /// </summary>
        private void AttachOnStop()
        {
            //Never detached.
            if (!_detachOnStart)
                return;
            //Graphical is null, nothing can be moved.
            if (_graphicalTransform == null)
                return;
            if (ApplicationState.IsQuitting())
                return;

            /* If not to re-attach or if there's no target to reference
             * then the graphical must be destroyed. */
            bool destroy = !_attachOnStop || (_targetTransform == null);
            //If not to re-attach then destroy graphical if needed.
            if (destroy)
            {
                UnityEngine.Object.Destroy(_graphicalTransform.gameObject);
                return;
            }

            _graphicalTransform.SetParent(_targetTransform.parent);
            _graphicalTransform.SetLocalProperties(_trackerTransform.GetLocalProperties());
        }

        public void ResetState()
        {
            if (!IsInitialized)
                return;

            AttachOnStop();

            _initializingNetworkBehaviour = null;
            _initializingTimeManager = null;
            _graphicalTransform = null;
            _targetTransform = null;

            _teleportedTick = TimeManager.UNSET_TICK;
            _movementMultiplier = 1f;
            CollectionCaches<TickTransformProperties>.StoreAndDefault(ref _transformProperties);
            _moveRates = default;
            _preTicked = default;
            _queuedTrackerProperties = null;
            _trackerPreTickWorldValues = default;
            _graphicsPreTickWorldValues = default;
            _realtimeInterpolation = default;
            _isMoving = default;

            if (_trackerTransform != null)
                UnityEngine.Object.Destroy(_trackerTransform.gameObject);
        }

        public void InitializeState() { }
    }
}﻿#if UNITY_EDITOR
using FishNet.Object;
using GameKit.Dependencies.Utilities;
using UnityEditor;
using UnityEngine;

namespace FishNet.Component.Transforming.Beta.Editing
{
    [CustomPropertyDrawer(typeof(MovementSettings))]
    public class MovementSettingsDrawer : PropertyDrawer
    {
        private PropertyDrawerTool _propertyDrawer;

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            EditorGUI.BeginProperty(position, label, property);

            _propertyDrawer = new(position);

            //_propertyDrawer.DrawLabel(label, FontStyle.Bold); 

            EditorGUI.indentLevel++;

            SerializedProperty enableTeleport = property.FindPropertyRelative("EnableTeleport");
            SerializedProperty teleportThreshold = property.FindPropertyRelative("TeleportThreshold");
            SerializedProperty adaptiveInterpolationValue = property.FindPropertyRelative("AdaptiveInterpolationValue");
            SerializedProperty interpolationValue = property.FindPropertyRelative("InterpolationValue");
            SerializedProperty smoothedProperties = property.FindPropertyRelative("SmoothedProperties");
            SerializedProperty snapNonSmoothedProperties = property.FindPropertyRelative("SnapNonSmoothedProperties");

            _propertyDrawer.DrawProperty(enableTeleport, "Enable Teleport");
            if (enableTeleport.boolValue == true)
                _propertyDrawer.DrawProperty(teleportThreshold, "Teleport Threshold", indent: 1);

            _propertyDrawer.DrawProperty(adaptiveInterpolationValue, "Adaptive Interpolation");
            if ((AdaptiveInterpolationType)adaptiveInterpolationValue.intValue == AdaptiveInterpolationType.Off)
                _propertyDrawer.DrawProperty(interpolationValue, "Interpolation Value", indent: 1);

            _propertyDrawer.DrawProperty(smoothedProperties, "Smoothed Properties");
            if ((uint)smoothedProperties.intValue != (uint)TransformPropertiesFlag.Everything)
                _propertyDrawer.DrawProperty(snapNonSmoothedProperties, "Snap Non-Smoothed Properties", indent: 1);

            _propertyDrawer.SetIndentToStarting();

            EditorGUI.EndProperty();
        }

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label) => _propertyDrawer.GetPropertyHeight();
    }
}
#endif﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Component.Transforming.Beta
{


    [CustomEditor(typeof(NetworkTickSmoother), true)]
    [CanEditMultipleObjects]
    public class NetworkTickSmootherEditor : Editor
    {
        private SerializedProperty _initializationSettings;
        private SerializedProperty _controllerMovementSettings;
        private SerializedProperty _spectatorMovementSettings;
        
        private bool _showControllerSmoothingSettings;
        private bool _showSpectatorSmoothingSettings;
        
        protected virtual void OnEnable()
        {
            _initializationSettings = serializedObject.FindProperty(nameof(_initializationSettings));
            _controllerMovementSettings = serializedObject.FindProperty(nameof(_controllerMovementSettings));
            _spectatorMovementSettings = serializedObject.FindProperty(nameof(_spectatorMovementSettings));
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour((NetworkTickSmoother)target), typeof(NetworkTickSmoother), false);
            GUI.enabled = true;

            //EditorGUILayout.LabelField("Initialization Settings", EditorStyles.boldLabel);
            
            EditorGUILayout.PropertyField(_initializationSettings);
            
            _showControllerSmoothingSettings = EditorGUILayout.Foldout(_showControllerSmoothingSettings, new GUIContent("Controller Smoothing", "Smoothing applied when object controller. This would be the owner, or if there is no owner and are also server."));
            if (_showControllerSmoothingSettings)
                EditorGUILayout.PropertyField(_controllerMovementSettings);

            _showSpectatorSmoothingSettings = EditorGUILayout.Foldout(_showSpectatorSmoothingSettings, new GUIContent("Spectator Smoothing", "Smoothing applied when object not the owner. This is when server and there is an owner, or when client and not the owner."));
            if (_showSpectatorSmoothingSettings)
                EditorGUILayout.PropertyField(_spectatorMovementSettings);
            
            
            //EditorGUI.indentLevel--;

            serializedObject.ApplyModifiedProperties();
        }

    }
}
#endif﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Component.Transforming.Beta
{


    [CustomEditor(typeof(OfflineTickSmoother), true)]
    [CanEditMultipleObjects]
    public class OfflineTickSmootherEditor : Editor
    {
        private SerializedProperty _automaticallyInitialize;
        private SerializedProperty _initializationSettings;
        private SerializedProperty _movementSettings;
        
        private bool _showMovementSettings;
        
        protected virtual void OnEnable()
        {
            _automaticallyInitialize = serializedObject.FindProperty(nameof(_automaticallyInitialize));
            _initializationSettings = serializedObject.FindProperty(nameof(_initializationSettings));
            _movementSettings = serializedObject.FindProperty(nameof(_movementSettings));
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour((OfflineTickSmoother)target), typeof(OfflineTickSmoother), false);
            GUI.enabled = true;

            //EditorGUILayout.LabelField("Initialization Settings", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(_automaticallyInitialize);
            EditorGUILayout.PropertyField(_initializationSettings);
            
            _showMovementSettings = EditorGUILayout.Foldout(_showMovementSettings, "Smoothing");
            if (_showMovementSettings)
                EditorGUILayout.PropertyField(_movementSettings);
            
            
            //EditorGUI.indentLevel--;

            serializedObject.ApplyModifiedProperties();
        }

    }
}
#endif﻿using FishNet.Managing.Statistic;
using GameKit.Dependencies.Utilities.Types;
using UnityEngine;

namespace FishNet.Component.Utility
{
    /// <summary>
    /// Add to any object to display current ping(round trip time).
    /// </summary>
    [AddComponentMenu("FishNet/Component/BandwidthDisplay")]
    public class BandwidthDisplay : MonoBehaviour
    {
        #region Types.
        private enum Corner
        {
            TopLeft,
            TopRight,
            BottomLeft,
            BottomRight
        }

        public class InOutAverage
        {
            private RingBuffer<ulong> _in;
            private RingBuffer<ulong> _out;

            public InOutAverage(byte seconds)
            {
                _in = new(seconds);
                _out = new(seconds);
            }

            public void AddIn(ulong value) => _in.Add(value);
            public void AddOut(ulong value) => _out.Add(value);

            public ulong GetAverage(bool inAverage)
            {
                RingBuffer<ulong> buffer = (inAverage) ? _in : _out;

                int count = buffer.Count;
                if (count == 0)
                    return 0;

                ulong total = 0;
                foreach (ulong v in buffer)
                    total += v;

                return (total / (uint)count);
            }

            public void ResetState()
            {
                _in.Clear();
                _out.Clear();
            }

            public void InitializeState(int capacity)
            {
                _in.Initialize(capacity);
                _out.Initialize(capacity);
            }
        }
        #endregion

        #region Public.
#if UNITY_EDITOR || !UNITY_SERVER
        /// <summary>
        /// Averages for client.
        /// </summary>
        public InOutAverage ClientAverages { get; private set; }
        /// <summary>
        /// Averages for server.
        /// </summary>
        public InOutAverage ServerAverages { get; private set; }
#endif
        #endregion

        #region Serialized.
        /// <summary>
        /// Color for text.
        /// </summary>
        [Tooltip("Color for text.")]
        [SerializeField]
        private Color _color = Color.white;
        /// <summary>
        /// Which corner to display network statistics in.
        /// </summary>
        [Tooltip("Which corner to display network statistics in.")]
        [SerializeField]
        private Corner _placement = Corner.TopRight;
        /// <summary>
        /// Number of seconds used to gather data per second. Lower values will show more up to date usage per second while higher values provide a better over-all estimate.
        /// </summary>
        [Tooltip("Number of seconds used to gather data per second. Lower values will show more up to date usage per second while higher values provide a better over-all estimate.")]
        [SerializeField]
        [Range(1, byte.MaxValue)]
        private byte _secondsAveraged = 1;

        /// <summary>
        /// rue to show outgoing data bytes.
        /// </summary>
        [Tooltip("True to show outgoing data bytes.")]
        [SerializeField]
        private bool _showOutgoing = true;

        /// <summary>
        /// Sets ShowOutgoing value.
        /// </summary>
        /// <param name="value"></param>
        public void SetShowOutgoing(bool value) => _showOutgoing = value;

        /// <summary>
        /// True to show incoming data bytes.
        /// </summary>
        [Tooltip("True to show incoming data bytes.")]
        [SerializeField]
        private bool _showIncoming = true;

        /// <summary>
        /// Sets ShowIncoming value.
        /// </summary>
        /// <param name="value"></param>
        public void SetShowIncoming(bool value) => _showIncoming = value;
        #endregion

#if UNITY_EDITOR || !UNITY_SERVER

        #region Private.
        /// <summary>
        /// Style for drawn ping.
        /// </summary>
        private readonly GUIStyle _style = new();
        /// <summary>
        /// Text to show for client in/out data.
        /// </summary>
        private string _clientText;
        /// <summary>
        /// Text to show for server in/out data.
        /// </summary>
        private string _serverText;
        /// <summary>
        /// First found NetworkTrafficStatistics.
        /// </summary>
        private NetworkTraficStatistics _networkTrafficStatistics;
        #endregion

        private void Start()
        {
            SetSecondsAveraged(_secondsAveraged);

            _networkTrafficStatistics = InstanceFinder.NetworkManager.StatisticsManager.NetworkTraffic;
            //Subscribe to both traffic updates.
            _networkTrafficStatistics.OnClientNetworkTraffic += NetworkTraffic_OnClientNetworkTraffic;
            _networkTrafficStatistics.OnServerNetworkTraffic += NetworkTraffic_OnServerNetworkTraffic;

            if (!_networkTrafficStatistics.UpdateClient && !_networkTrafficStatistics.UpdateServer)
                Debug.LogWarning($"StatisticsManager.NetworkTraffic is not updating for client nor server. To see results ensure your NetworkManager has a StatisticsManager component added with the NetworkTraffic values configured.");
        }

        private void OnDestroy()
        {
            if (_networkTrafficStatistics != null)
            {
                _networkTrafficStatistics.OnClientNetworkTraffic -= NetworkTraffic_OnClientNetworkTraffic;
                _networkTrafficStatistics.OnServerNetworkTraffic -= NetworkTraffic_OnServerNetworkTraffic;
            }
        }

        /// <summary>
        /// Sets a new number of seconds to average from.
        /// </summary>
        public void SetSecondsAveraged(byte seconds)
        {
            if (seconds <= 0)
                seconds = 1;

            ClientAverages = new(seconds);
            ServerAverages = new(seconds);
        }

        /// <summary>
        /// Called when client network traffic is updated.
        /// </summary>
        private void NetworkTraffic_OnClientNetworkTraffic(NetworkTrafficArgs obj)
        {
            string nl = System.Environment.NewLine;
            string result = string.Empty;

            ClientAverages.AddIn(obj.FromServerBytes);
            ClientAverages.AddOut(obj.ToServerBytes);

            if (_showIncoming)
                result += $"Client In: {NetworkTraficStatistics.FormatBytesToLargest(ClientAverages.GetAverage(inAverage: true))}/s{nl}";
            if (_showOutgoing)
                result += $"Client Out: {NetworkTraficStatistics.FormatBytesToLargest(ClientAverages.GetAverage(inAverage: false))}/s{nl}";

            _clientText = result;
        }

        /// <summary>
        /// Called when server network traffic is updated.
        /// </summary>
        private void NetworkTraffic_OnServerNetworkTraffic(NetworkTrafficArgs obj)
        {
            string nl = System.Environment.NewLine;
            string result = string.Empty;

            ServerAverages.AddIn(obj.ToServerBytes);
            ServerAverages.AddOut(obj.FromServerBytes);

            if (_showIncoming)
                result += $"Server In: {NetworkTraficStatistics.FormatBytesToLargest(ServerAverages.GetAverage(inAverage: true))}/s{nl}";
            if (_showOutgoing)
                result += $"Server Out: {NetworkTraficStatistics.FormatBytesToLargest(ServerAverages.GetAverage(inAverage: false))}/s{nl}";

            _serverText = result;
        }

        private void OnGUI()
        {
            _style.normal.textColor = _color;
            _style.fontSize = 15;

            float width = 100f;
            float height = 0f;
            if (_showIncoming)
                height += 15f;
            if (_showOutgoing)
                height += 15f;

            bool isClient = InstanceFinder.IsClientStarted;
            bool isServer = InstanceFinder.IsServerStarted;
            if (!isClient)
                ResetCalculationsAndDisplay(forServer: false);
            if (!isServer)
                ResetCalculationsAndDisplay(forServer: true);
            if (isServer && isClient)
                height *= 2f;

            float edge = 10f;

            float horizontal;
            float vertical;

            if (_placement == Corner.TopLeft)
            {
                horizontal = 10f;
                vertical = 10f;
                _style.alignment = TextAnchor.UpperLeft;
            }
            else if (_placement == Corner.TopRight)
            {
                horizontal = Screen.width - width - edge;
                vertical = 10f;
                _style.alignment = TextAnchor.UpperRight;
            }
            else if (_placement == Corner.BottomLeft)
            {
                horizontal = 10f;
                vertical = Screen.height - height - edge;
                _style.alignment = TextAnchor.LowerLeft;
            }
            else
            {
                horizontal = Screen.width - width - edge;
                vertical = Screen.height - height - edge;
                _style.alignment = TextAnchor.LowerRight;
            }

            GUI.Label(new(horizontal, vertical, width, height), (_clientText + _serverText), _style);
        }

        [ContextMenu("Reset Averages")]
        public void ResetAverages()
        {
            ResetCalculationsAndDisplay(forServer: true);
            ResetCalculationsAndDisplay(forServer: false);
        }

        private void ResetCalculationsAndDisplay(bool forServer)
        {
            if (forServer)
            {
                _serverText = string.Empty;
                ServerAverages.ResetState();
            }
            else
            {
                _clientText = string.Empty;
                ClientAverages.ResetState();
            }
        }
#endif
    }
}﻿using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Scened;
using FishNet.Transporting;
using FishNet.Utility;
using GameKit.Dependencies.Utilities;
using GameKit.Dependencies.Utilities.Types;
using System.IO;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnitySceneManager = UnityEngine.SceneManagement.SceneManager;

namespace FishNet.Component.Scenes
{

    /// <summary>
    /// Add to a NetworkManager object to change between Online and Offline scene based on connection states of the server or client.
    /// </summary>
    [AddComponentMenu("FishNet/Component/DefaultScene")]
    public class DefaultScene : MonoBehaviour
    {

        #region Serialized.
        [Tooltip("True to load the online scene as global, false to load it as connection.")]
        [SerializeField]
        private bool _enableGlobalScenes = true;
        /// <summary>
        /// True to replace all scenes with the offline scene immediately.
        /// </summary>
        [Tooltip("True to replace all scenes with the offline scene immediately.")]
        [SerializeField]
        private bool _startInOffline;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Scene to load when disconnected. Server and client will load this scene.")]
        [SerializeField, Scene]
        private string _offlineScene;
        /// <summary>
        /// Sets which offline scene to use.
        /// </summary>
        /// <param name="sceneName">Scene name to use as the offline scene.</param>
        public void SetOfflineScene(string sceneName) => _offlineScene = sceneName;
        /// <summary>
        /// Scene to load when disconnected. Server and client will load this scene.
        /// </summary>
        /// <returns></returns>
        public string GetOfflineScene() => _offlineScene;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Scene to load when connected. Server and client will load this scene.")]
        [SerializeField, Scene]
        private string _onlineScene;
        /// <summary>
        /// Sets which online scene to use.
        /// </summary>
        /// <param name="sceneName">Scene name to use as the online scene.</param>
        public void SetOnlineScene(string sceneName) => _onlineScene = sceneName;
        /// <summary>
        /// Scene to load when connected. Server and client will load this scene.
        /// </summary>
        /// <returns></returns>
        public string GetOnlineScene() => _onlineScene;
        /// <summary>
        /// Which scenes to replace when loading into OnlineScene.
        /// </summary>
        [Tooltip("Which scenes to replace when loading into OnlineScene.")]
        [SerializeField]
        private ReplaceOption _replaceScenes = ReplaceOption.All;
        #endregion

        #region Private.
        /// <summary>
        /// NetworkManager for this component.
        /// </summary>
        private NetworkManager _networkManager;
        #endregion

        private void OnEnable()
        {
            Initialize();
        }

        private void OnDestroy()
        {
            Deinitialize();
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        private void Initialize()
        {
            _networkManager = GetComponentInParent<NetworkManager>();
            if (_networkManager == null)
            {
                NetworkManagerExtensions.LogError($"NetworkManager not found on {gameObject.name} or any parent objects. DefaultScene will not work.");
                return;
            }
            //A NetworkManager won't be initialized if it's being destroyed.
            if (!_networkManager.Initialized)
                return;
            if (_onlineScene == string.Empty || _offlineScene == string.Empty)
            {

                NetworkManagerExtensions.LogWarning("Online or Offline scene is not specified. Default scenes will not load.");
                return;
            }

            _networkManager.ClientManager.OnClientConnectionState += ClientManager_OnClientConnectionState;
            _networkManager.ServerManager.OnServerConnectionState += ServerManager_OnServerConnectionState;
            _networkManager.SceneManager.OnLoadEnd += SceneManager_OnLoadEnd;
            _networkManager.ServerManager.OnAuthenticationResult += ServerManager_OnAuthenticationResult;
            if (_startInOffline)
                LoadOfflineScene();
        }

        private void Deinitialize()
        {
            if (!ApplicationState.IsQuitting() && _networkManager != null && _networkManager.Initialized)
            {
                _networkManager.ClientManager.OnClientConnectionState -= ClientManager_OnClientConnectionState;
                _networkManager.ServerManager.OnServerConnectionState -= ServerManager_OnServerConnectionState;
                _networkManager.SceneManager.OnLoadEnd -= SceneManager_OnLoadEnd;
                _networkManager.ServerManager.OnAuthenticationResult -= ServerManager_OnAuthenticationResult;
            }
        }

        /// <summary>
        /// Called when a scene load ends.
        /// </summary>
        private void SceneManager_OnLoadEnd(SceneLoadEndEventArgs obj)
        {
            bool onlineLoaded = false;
            foreach (Scene s in obj.LoadedScenes)
            {
                if (s.name == GetSceneName(_onlineScene))
                {
                    onlineLoaded = true;
                    break;
                }
            }

            //If online scene was loaded then unload offline.
            if (onlineLoaded)
                UnloadOfflineScene();
        }

        /// <summary>
        /// Called after the local server connection state changes.
        /// </summary>
        private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs obj)
        {
            /* When server starts load online scene as global.
             * Since this is a global scene clients will automatically
             * join it when connecting. */
            if (obj.ConnectionState == LocalConnectionState.Started)
            {
                /* If not exactly one server is started then
                 * that means either none are started, which isnt true because
                 * we just got a started callback, or two+ are started.
                 * When a server has already started there's no reason to load
                 * scenes again. */
                if (!_networkManager.ServerManager.IsOnlyOneServerStarted())
                    return;

                //If here can load scene.
                SceneLoadData sld = new(GetSceneName(_onlineScene));
                sld.ReplaceScenes = _replaceScenes;
                if (_enableGlobalScenes)
                    _networkManager.SceneManager.LoadGlobalScenes(sld);
                else
                    _networkManager.SceneManager.LoadConnectionScenes(sld);
            }
            //When server stops load offline scene.
            else if (obj.ConnectionState == LocalConnectionState.Stopped && !_networkManager.ServerManager.IsAnyServerStarted())
            {
                LoadOfflineScene();
            }
        }

        /// <summary>
        /// Called after the local client connection state changes.
        /// </summary>
        private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs obj)
        {
            if (obj.ConnectionState == LocalConnectionState.Stopped)
            {
                //Only load offline scene if not also server.
                if (!_networkManager.IsServerStarted)
                    LoadOfflineScene();
            }
        }

        /// <summary>
        /// Called when a client completes authentication.
        /// </summary>
        private void ServerManager_OnAuthenticationResult(NetworkConnection arg1, bool authenticated)
        {
            /* This is only for loading connection scenes.
             * If using global there is no need to continue. */
            if (_enableGlobalScenes)
                return;
            if (!authenticated)
                return;

            SceneLoadData sld = new(GetSceneName(_onlineScene));
            _networkManager.SceneManager.LoadConnectionScenes(arg1, sld);
        }


        /// <summary>
        /// Loads offlineScene as single.
        /// </summary>
        private void LoadOfflineScene()
        {
            //Already in offline scene.
            if (UnitySceneManager.GetActiveScene().name == GetSceneName(_offlineScene))
                return;
            //Only use scene manager if networking scenes. I may add something in later to do both local and networked.
            UnitySceneManager.LoadScene(_offlineScene);
        }

        /// <summary>
        /// Unloads the offline scene.
        /// </summary>
        private void UnloadOfflineScene()
        {
            Scene s = UnitySceneManager.GetSceneByName(GetSceneName(_offlineScene));
            if (string.IsNullOrEmpty(s.name))
                return;

            UnitySceneManager.UnloadSceneAsync(s);
        }

        /// <summary>
        /// Returns a scene name from fullPath.
        /// </summary>
        /// <param name="fullPath"></param>
        /// <returns></returns>
        private string GetSceneName(string fullPath)
        {
            return Path.GetFileNameWithoutExtension(fullPath);
        }
    }

}﻿using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Timing;
using FishNet.Object;
using FishNet.Object.Prediction;
using FishNet.Utility.Extension;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Component.Transforming
{
    /// <summary>
    /// Detaches the object which this component resides and follows another.
    /// </summary>
    public class DetachableNetworkTickSmoother : NetworkBehaviour
    {
        #region Serialized.
        /// <summary>
        /// True to attach the object to it's original parent when OnStopClient is called.
        /// </summary>
        [Tooltip("True to attach the object to it's original parent when OnStopClient is called.")]
        [SerializeField]
        private bool _attachOnStop = true;

        /// <summary>
        /// Object to follow, and smooth towards.
        /// </summary>
        [Tooltip("Object to follow, and smooth towards.")]
        [SerializeField]
        private Transform _followObject;
        /// <summary>
        /// How many ticks to interpolate over.
        /// </summary>
        [Tooltip("How many ticks to interpolate over.")]
        [Range(1, byte.MaxValue)]
        [SerializeField]
        private byte _interpolation = 1;
        /// <summary>
        /// True to enable teleport threshhold.
        /// </summary>
        [Tooltip("True to enable teleport threshold.")]
        [SerializeField]
        private bool _enableTeleport;
        /// <summary>
        /// How far the object must move between ticks to teleport rather than smooth.
        /// </summary>
        [Tooltip("How far the object must move between ticks to teleport rather than smooth.")]
        [Range(0f, ushort.MaxValue)]
        [SerializeField]
        private float _teleportThreshold;

        /// <summary>
        /// True to synchronize the position of the followObject.
        /// </summary>
        [Tooltip("True to synchronize the position of the followObject.")]
        [SerializeField]
        private bool _synchronizePosition = true;
        /// <summary>
        /// True to synchronize the rotation of the followObject.
        /// </summary>
        [Tooltip("True to synchronize the rotation of the followObject.")]
        [SerializeField]
        private bool _synchronizeRotation;
        /// <summary>
        /// True to synchronize the scale of the followObject.
        /// </summary>
        [Tooltip("True to synchronize the scale of the followObject.")]
        [SerializeField]
        private bool _synchronizeScale;
        #endregion

        #region Private.
        /// <summary>
        /// TimeManager subscribed to.
        /// </summary>
        private TimeManager _timeManager;
        /// <summary>
        /// Parent of the object prior to detaching.
        /// </summary>
        private Transform _parent;
        /// <summary>
        /// Local properties of the graphical during instantation.
        /// </summary>
        private TransformProperties _transformInstantiatedLocalProperties;
        /// <summary>
        /// World properties of the followObject during  post tick.
        /// </summary>
        private TransformProperties _postTickFollowObjectWorldProperties;

        /// <summary>
        /// How quickly to move towards target.
        /// </summary>
        private MoveRates _moveRates = new(MoveRates.INSTANT_VALUE);
        /// <summary>
        /// True if initialized.
        /// </summary>
        private bool _initialized;
        /// <summary>
        /// Cached TickDelta of the TimeManager.
        /// </summary>
        private float _tickDelta;
        #endregion

        private void Awake()
        {
            _transformInstantiatedLocalProperties = transform.GetLocalProperties();
        }

        private void OnDestroy()
        {
            ChangeSubscription(false);
        }

        public override void OnStartClient()
        {
            bool error = false;
            if (transform.parent == null)
            {
                NetworkManagerExtensions.LogError($"{GetType().Name} on gameObject {gameObject.name} requires a parent to detach from.");
                error = true;
            }
            if (_followObject == null)
            {
                NetworkManagerExtensions.LogError($"{GetType().Name} on gameObject {gameObject}, root {transform.root} requires followObject to be set.");
                error = true;
            }

            if (error)
                return;

            _parent = transform.parent;
            transform.SetParent(null);

            SetTimeManager(base.TimeManager);
            //Unsub first in the rare chance we already subbed such as a stop callback issue.
            ChangeSubscription(false);
            ChangeSubscription(true);

            _postTickFollowObjectWorldProperties = _followObject.GetWorldProperties();
            _tickDelta = (float)base.TimeManager.TickDelta;
            _initialized = true;
        }

        public override void OnStopClient()
        {
#if UNITY_EDITOR
            if (ApplicationState.IsQuitting())
                return;
#endif
            //Reattach to parent.
            if (_attachOnStop && _parent != null)
            {
                //Reparent
                transform.SetParent(_parent);
                //Set to instantiated local values.
                transform.SetLocalProperties(_transformInstantiatedLocalProperties);
            }

            _postTickFollowObjectWorldProperties.ResetState();
            ChangeSubscription(false);

            _initialized = false;
        }

        [Client(Logging = LoggingType.Off)]
        private void Update()
        {
            MoveTowardsFollowTarget();
        }

        /// <summary>
        /// Called after a tick completes.
        /// </summary>
        private void _timeManager_OnPostTick()
        {
            if (!_initialized)
                return;

            _postTickFollowObjectWorldProperties.Update(_followObject);
            //Unset values if not following the transform property.
            if (!_synchronizePosition)
                _postTickFollowObjectWorldProperties.Position = transform.position;
            if (!_synchronizeRotation)
                _postTickFollowObjectWorldProperties.Rotation = transform.rotation;
            if (!_synchronizeScale)
                _postTickFollowObjectWorldProperties.Scale = transform.localScale;
            SetMoveRates();
        }

        /// <summary>
        /// Sets a new PredictionManager to use.
        /// </summary>
        /// <param name="tm"></param>
        private void SetTimeManager(TimeManager tm)
        {
            if (tm == _timeManager)
                return;

            //Unsub from current.
            ChangeSubscription(false);
            //Sub to newest.
            _timeManager = tm;
            ChangeSubscription(true);
        }


        /// <summary>
        /// Changes the subscription to the TimeManager.
        /// </summary>
        private void ChangeSubscription(bool subscribe)
        {
            if (_timeManager == null)
                return;

            if (subscribe)
                _timeManager.OnPostTick += _timeManager_OnPostTick;
            else
                _timeManager.OnPostTick -= _timeManager_OnPostTick;
        }

        /// <summary>
        /// Moves towards targetObject.
        /// </summary>
        private void MoveTowardsFollowTarget()
        {
            if (!_initialized)
                return;

            _moveRates.Move(transform, _postTickFollowObjectWorldProperties, Time.deltaTime, useWorldSpace: true);
        }

        private void SetMoveRates()
        {
            if (!_initialized)
                return;

            float duration = (_tickDelta * _interpolation);
            /* If interpolation is 1 then add on a tiny amount
             * of more time to compensate for frame time, so that
             * the smoothing does not complete before the next tick,
             * as this would result in jitter. */
            if (_interpolation == 1)
                duration += Mathf.Max(Time.deltaTime, (1f / 50f));

            float teleportT = (_enableTeleport) ? _teleportThreshold : MoveRates.UNSET_VALUE;
            _moveRates = MoveRates.GetWorldMoveRates(transform, _followObject, duration, teleportT);
        }


    }


}

﻿using FishNet.Managing.Logging;
using FishNet.Managing.Timing;
using FishNet.Object;
using FishNet.Object.Prediction;
using GameKit.Dependencies.Utilities;
using UnityEngine;
#pragma warning disable CS0618 // Type or member is obsolete

namespace FishNet.Component.Transforming
{
    /// <summary>
    /// Smoothes an object between ticks.
    /// This can be used on objects without NetworkObject components.
    /// </summary>
    public class MonoTickSmoother : MonoBehaviour
    {
        //Lazy way to display obsolete message w/o using a custom editor.
        [Header("This component will be obsoleted soon.")]
        [Header("Use NetworkTickSmoother or OfflineTickSmoother.")]
        [Header(" ")]
            
        #region Serialized.
        /// <summary>
        /// True to use InstanceFinder to locate the TimeManager. When false specify which TimeManager to use by calling SetTimeManager.
        /// </summary>
        [Tooltip("True to use InstanceFinder to locate the TimeManager. When false specify which TimeManager to use by calling SetTimeManager.")]
        [SerializeField]
        private bool _useInstanceFinder = true;
        /// <summary>
        /// GraphicalObject you wish to smooth.
        /// </summary>
        [Tooltip("GraphicalObject you wish to smooth.")]
        [SerializeField]
        private Transform _graphicalObject;
        /// <summary>
        /// True to enable teleport threshhold.
        /// </summary>
        [Tooltip("True to enable teleport threshold.")]
        [SerializeField]
        private bool _enableTeleport;
        /// <summary>
        /// How far the object must move between ticks to teleport rather than smooth.
        /// </summary>
        [Tooltip("How far the object must move between ticks to teleport rather than smooth.")]
        [Range(0f, ushort.MaxValue)]
        [SerializeField]
        private float _teleportThreshold;
        #endregion

        #region Private.
        /// <summary>
        /// TimeManager subscribed to.
        /// </summary>
        private TimeManager _timeManager;
        /// <summary>
        /// BasicTickSmoother for this script.
        /// </summary>
        private LocalTransformTickSmoother _tickSmoother;
        #endregion

        private void OnEnable()
        {
            Initialize();
        }

        private void OnDisable()
        {
            _tickSmoother.ResetState();
            ChangeSubscription(false);
            ObjectCaches<LocalTransformTickSmoother>.StoreAndDefault(ref _tickSmoother);
        }

        [Client(Logging = LoggingType.Off)]
        private void Update()
        {
            _tickSmoother?.Update();
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        private void Initialize()
        {
            _tickSmoother = ObjectCaches<LocalTransformTickSmoother>.Retrieve();
            if (_useInstanceFinder)
            {
                _timeManager = InstanceFinder.TimeManager;
                ChangeSubscription(true);
            }
        }

        /// <summary>
        /// Sets a new PredictionManager to use.
        /// </summary>
        /// <param name="tm"></param>
        public void SetTimeManager(TimeManager tm)
        {
            if (tm == _timeManager)
                return;

            //Unsub from current.
            ChangeSubscription(false);
            //Sub to newest.
            _timeManager = tm;
            ChangeSubscription(true);
        }


        /// <summary>
        /// Changes the subscription to the TimeManager.
        /// </summary>
        private void ChangeSubscription(bool subscribe)
        {
            if (_timeManager == null)
                return;

            if (subscribe)
            {
                if (_tickSmoother != null)
                {
                    float tDistance = (_enableTeleport) ? _teleportThreshold : MoveRates.UNSET_VALUE;
                    _tickSmoother.InitializeOnce(_graphicalObject, tDistance, (float)_timeManager.TickDelta, 1);
                }
                _timeManager.OnPreTick += _timeManager_OnPreTick;
                _timeManager.OnPostTick += _timeManager_OnPostTick;
            }
            else
            {
                _timeManager.OnPreTick -= _timeManager_OnPreTick;
                _timeManager.OnPostTick -= _timeManager_OnPostTick;
            }
        }


        /// <summary>
        /// Called before a tick starts.
        /// </summary>
        private void _timeManager_OnPreTick()
        {
            _tickSmoother.OnPreTick();
        }

        /// <summary>
        /// Called after a tick completes.
        /// </summary>
        private void _timeManager_OnPostTick()
        {
            _tickSmoother.OnPostTick();
        }


    }


}

﻿using FishNet.Managing.Timing;
using UnityEngine;

namespace FishNet.Component.Utility
{
    /// <summary>
    /// Add to any object to display current ping(round trip time).
    /// </summary>
    [AddComponentMenu("FishNet/Component/PingDisplay")]
    public class PingDisplay : MonoBehaviour
    {
        #region Types.
        private enum Corner
        {
            TopLeft,
            TopRight,
            BottomLeft,
            BottomRight
        }
        #endregion

        #region Serialized.
        /// <summary>
        /// Color for text.
        /// </summary>
        [Tooltip("Color for text.")]
        [SerializeField]
        private Color _color = Color.white;
        /// <summary>
        /// Which corner to display ping in.
        /// </summary>
        [Tooltip("Which corner to display ping in.")]
        [SerializeField]
        private Corner _placement = Corner.TopRight;
        /// <summary>
        /// True to show the real ping. False to include tick rate latency within the ping.
        /// </summary>
        [Tooltip("True to show the real ping. False to include tick rate latency within the ping.")]
        [SerializeField]
        private bool _hideTickRate = true;
        #endregion

#if UNITY_EDITOR || !UNITY_SERVER

        #region Private.
        /// <summary>
        /// Style for drawn ping.
        /// </summary>
        private GUIStyle _style = new();
        #endregion

        private void OnGUI()
        {
            //Only clients can see pings.
            if (!InstanceFinder.IsClientStarted)
                return;

            _style.normal.textColor = _color;
            _style.fontSize = 15;
            float width = 85f;
            float height = 15f;
            float edge = 10f;

            float horizontal;
            float vertical;

            if (_placement == Corner.TopLeft)
            {
                horizontal = 10f;
                vertical = 10f;
            }
            else if (_placement == Corner.TopRight)
            {
                horizontal = Screen.width - width - edge;
                vertical = 10f;
            }
            else if (_placement == Corner.BottomLeft)
            {
                horizontal = 10f;
                vertical = Screen.height - height - edge;
            }
            else
            {
                horizontal = Screen.width - width - edge;
                vertical = Screen.height - height - edge;
            }

            long ping;
            TimeManager tm = InstanceFinder.TimeManager;
            if (tm == null)
            {
                ping = 0;
            }
            else
            {
                ping = tm.RoundTripTime;
                long deduction = 0;
                if (_hideTickRate)
                    deduction = (long)(tm.TickDelta * 2000d);

                ping = (long)Mathf.Max(1, ping - deduction);
            }

            GUI.Label(new(horizontal, vertical, width, height), $"Ping: {ping}ms", _style);
        }
#endif

    }


}﻿#if UNITY_EDITOR
using GameKit.Dependencies.Utilities;
using UnityEditor;
using LayoutTools = GameKit.Dependencies.Utilities.EditorGuiLayoutTools;

namespace FishNet.Component.Transforming.Editing
{


    [CustomEditor(typeof(DetachableNetworkTickSmoother), true)]
    [CanEditMultipleObjects]
    public class DetachableNetworkTickSmootherEditor : Editor
    {
        private SerializedProperty _attachOnStop;
        private SerializedProperty _followObject;
        private SerializedProperty _interpolation;
        private SerializedProperty _enableTeleport;
        private SerializedProperty _teleportThreshold;
        private SerializedProperty _synchronizePosition;
        private SerializedProperty _synchronizeRotation;
        private SerializedProperty _synchronizeScale;

        protected virtual void OnEnable()
        {
            _attachOnStop = serializedObject.FindProperty(nameof(_attachOnStop));
            _followObject = serializedObject.FindProperty(nameof(_followObject));
            _interpolation = serializedObject.FindProperty(nameof(_interpolation));
            _enableTeleport = serializedObject.FindProperty(nameof(_enableTeleport));
            _teleportThreshold = serializedObject.FindProperty(nameof(_teleportThreshold));
            _synchronizePosition = serializedObject.FindProperty(nameof(_synchronizePosition));
            _synchronizeRotation = serializedObject.FindProperty(nameof(_synchronizeRotation));
            _synchronizeScale = serializedObject.FindProperty(nameof(_synchronizeScale));
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            LayoutTools.AddObjectField("Script:", MonoScript.FromMonoBehaviour((DetachableNetworkTickSmoother)target), typeof(DetachableNetworkTickSmoother), false, EditorLayoutEnableType.Disabled);

            EditorGUILayout.HelpBox("This component will be obsoleted soon. Use NetworkTickSmoother or OfflineTickSmoother.", MessageType.Warning);
            //Misc.
            EditorGUILayout.LabelField("Misc", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_attachOnStop);
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Smoothing.
            EditorGUILayout.LabelField("Smoothing", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_followObject);
            EditorGUILayout.PropertyField(_interpolation);
            
            EditorGUILayout.PropertyField(_enableTeleport);
            if (_enableTeleport.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_teleportThreshold);
                EditorGUI.indentLevel--;
            }
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Authority.
            EditorGUILayout.LabelField("Synchronizing", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_synchronizePosition);
            EditorGUILayout.PropertyField(_synchronizeRotation);
            EditorGUILayout.PropertyField(_synchronizeScale);
            EditorGUI.indentLevel--;
       
            serializedObject.ApplyModifiedProperties();
        }
    }

}
#endif﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif

#if UNITY_EDITOR
using FishNet.Editing.PrefabCollectionGenerator;
using UnityEditor;
#endif

using FishNet.Connection;
using FishNet.Managing.Client;
using FishNet.Managing.Server;
using FishNet.Managing.Timing;
using FishNet.Managing.Transporting;
using UnityEngine;
using FishNet.Managing.Scened;
using FishNet.Object;
using FishNet.Documenting;
using System.Collections.Generic;
using System;
using FishNet.Managing.Observing;
using System.Linq;
using FishNet.Managing.Debugging;
using FishNet.Managing.Object;
using FishNet.Transporting;
using FishNet.Managing.Statistic;
using FishNet.Utility.Performance;
using FishNet.Component.ColliderRollback;
using FishNet.Managing.Predicting;
using GameKit.Dependencies.Utilities;



namespace FishNet.Managing
{
    /// <summary>
    /// Acts as a container for all things related to your networking session.
    /// </summary>
    [DefaultExecutionOrder(short.MinValue)]
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/NetworkManager")]
    public sealed partial class NetworkManager : MonoBehaviour
    {
        #region Types.
        /// <summary>
        /// How to persist with multiple NetworkManagers.
        /// </summary>
        public enum PersistenceType
        {
            /// <summary>
            /// Destroy any new NetworkManagers.
            /// </summary>
            DestroyNewest,
            /// <summary>
            /// Destroy previous NetworkManager when a new NetworkManager occurs.
            /// </summary>
            DestroyOldest,
            /// <summary>
            /// Allow multiple NetworkManagers, do not destroy any automatically.
            /// </summary>
            AllowMultiple
        }
        #endregion

        #region Public.
        /// <summary>
        /// True if this instance of the NetworkManager is initialized.
        /// </summary>
        public bool Initialized { get; private set; }

        /// <summary>
        /// 
        /// </summary>
        private static List<NetworkManager> _instances = new();

        /// <summary>
        /// Currently initialized NetworkManagers.
        /// </summary>
        public static IReadOnlyList<NetworkManager> Instances
        {
            get
            {
                /* Remove null instances of NetworkManager.
                 * This shouldn't happen because instances are removed
                 * OnDestroy but none the less something is causing
                 * it. */
                for (int i = 0; i < _instances.Count; i++)
                {
                    if (_instances[i] == null)
                    {
                        _instances.RemoveAt(i);
                        i--;
                    }
                }

                return _instances;
            }
        }

        /// <summary>
        /// PredictionManager for this NetworkManager.
        /// </summary>
        internal PredictionManager PredictionManager { get; private set; }

        /// <summary>
        /// ServerManager for this NetworkManager.
        /// </summary>
        public ServerManager ServerManager { get; private set; }

        /// <summary>
        /// ClientManager for this NetworkManager.
        /// </summary>
        public ClientManager ClientManager { get; private set; }

        /// <summary>
        /// TransportManager for this NetworkManager.
        /// </summary>
        public TransportManager TransportManager { get; private set; }

        /// <summary>
        /// TimeManager for this NetworkManager.
        /// </summary>
        public TimeManager TimeManager { get; private set; }

        /// <summary>
        /// SceneManager for this NetworkManager.
        /// </summary>
        public SceneManager SceneManager { get; private set; }

        /// <summary>
        /// ObserverManager for this NetworkManager.
        /// </summary>
        public ObserverManager ObserverManager { get; private set; }

        /// <summary>
        /// DebugManager for this NetworkManager.
        /// </summary>
        public DebugManager DebugManager { get; private set; }

        /// <summary>
        /// StatisticsManager for this NetworkManager.
        /// </summary>
        public StatisticsManager StatisticsManager { get; private set; }

        /// <summary>
        /// An empty connection reference. Used when a connection cannot be found to prevent object creation.
        /// </summary>
        [APIExclude]
        public static NetworkConnection EmptyConnection { get; private set; } = new();
        #endregion

        #region Internal.
        /// <summary>
        /// Starting index for RpcLinks.
        /// </summary>
        internal static ushort StartingRpcLinkIndex;
#if DEVELOPMENT
        /// <summary>
        /// Logs data about parser to help debug.
        /// </summary>
        internal PacketIdHistory PacketIdHistory = new();
#endif
        #endregion

        #region Serialized.
#if UNITY_EDITOR
        /// <summary>
        /// True to refresh the DefaultPrefabObjects collection whenever the editor enters play mode. This is an attempt to alleviate the DefaultPrefabObjects scriptable object not refreshing when using multiple editor applications such as ParrelSync.
        /// </summary>
        [Tooltip("True to refresh the DefaultPrefabObjects collection whenever the editor enters play mode. This is an attempt to alleviate the DefaultPrefabObjects scriptable object not refreshing when using multiple editor applications such as ParrelSync.")]
        [SerializeField]
        private bool _refreshDefaultPrefabs = false;
#endif
        /// <summary>
        /// True to have your application run while in the background.
        /// </summary>
        [Tooltip("True to have your application run while in the background.")]
        [SerializeField]
        private bool _runInBackground = true;
        /// <summary>
        /// True to make this instance DontDestroyOnLoad. This is typical if you only want one NetworkManager.
        /// </summary>
        [Tooltip("True to make this instance DontDestroyOnLoad. This is typical if you only want one NetworkManager.")]
        [SerializeField]
        private bool _dontDestroyOnLoad = true;

        /// <summary>
        /// Object pool to use for this NetworkManager. Value may be null.
        /// </summary>
        public ObjectPool ObjectPool => _objectPool;

        [Tooltip("Object pool to use for this NetworkManager. Value may be null.")]
        [SerializeField]
        private ObjectPool _objectPool;
        /// <summary>
        /// How to persist when other NetworkManagers are introduced.
        /// </summary>
        [Tooltip("How to persist when other NetworkManagers are introduced.")]
        [SerializeField]
        private PersistenceType _persistence = PersistenceType.DestroyNewest;
        #endregion

        #region Private.
        /// <summary>
        /// True if this NetworkManager can persist after Awake checks.
        /// </summary>
        private bool _canPersist;
        #endregion

        #region Const.
        /// <summary>
        /// Version of this release.
        /// </summary>
        public const string FISHNET_VERSION = "4.6.9";
        /// <summary>
        /// Maximum framerate allowed.
        /// </summary>
        internal const ushort MAXIMUM_FRAMERATE = 500;
        #endregion

        private void Awake()
        {
            InitializeLogging();
            if (!ValidateSpawnablePrefabs(true))
                return;

            if (StartingRpcLinkIndex == 0)
                StartingRpcLinkIndex = (ushort)(Enums.GetHighestValue<PacketId>() + 1);

            bool isDefaultPrefabs = (SpawnablePrefabs != null && SpawnablePrefabs is DefaultPrefabObjects);
#if UNITY_EDITOR
            /* If first instance then force
             * default prefabs to repopulate.
             * This is only done in editor because
             * cloning tools sometimes don't synchronize
             * scriptable object changes, which is what
             * the default prefabs is. */
            if (_refreshDefaultPrefabs && _instances.Count == 0 && isDefaultPrefabs)
            {
                Generator.IgnorePostProcess = true;
                Debug.Log("DefaultPrefabCollection is being refreshed.");
                Generator.GenerateFull(initializeAdded: false);
                Generator.IgnorePostProcess = false;
            }
#endif
            //If default prefabs then also make a new instance and sort them.
            if (isDefaultPrefabs)
            {
                DefaultPrefabObjects originalDpo = (DefaultPrefabObjects)SpawnablePrefabs;
                //If not editor then a new instance must be made and sorted.
                DefaultPrefabObjects instancedDpo = ScriptableObject.CreateInstance<DefaultPrefabObjects>();
                instancedDpo.AddObjects(originalDpo.Prefabs.ToList(), checkForDuplicates: false, initializeAdded: false);
                instancedDpo.Sort();
                SpawnablePrefabs = instancedDpo;
            }

            _canPersist = CanInitialize();
            if (!_canPersist)
                return;

            if (TryGetComponent<NetworkObject>(out _))
                InternalLogError($"NetworkObject component found on the NetworkManager object {gameObject.name}. This is not allowed and will cause problems. Remove the NetworkObject component from this object.");

            SpawnablePrefabs.InitializePrefabRange(0);
            SpawnablePrefabs.SetCollectionId(0);

            SetDontDestroyOnLoad();
            SetRunInBackground();
            DebugManager = GetOrCreateComponent<DebugManager>();
            TransportManager = GetOrCreateComponent<TransportManager>();

            ServerManager = GetOrCreateComponent<ServerManager>();
            ClientManager = GetOrCreateComponent<ClientManager>();
            TimeManager = GetOrCreateComponent<TimeManager>();
            SceneManager = GetOrCreateComponent<SceneManager>();
            ObserverManager = GetOrCreateComponent<ObserverManager>();
            RollbackManager = GetOrCreateComponent<RollbackManager>();
            PredictionManager = GetOrCreateComponent<PredictionManager>();
            StatisticsManager = GetOrCreateComponent<StatisticsManager>();
            if (_objectPool == null)
                _objectPool = GetOrCreateComponent<DefaultObjectPool>();

            InitializeComponents();

            _instances.Add(this);
            Initialized = true;
        }

        private void Start()
        {
            ServerManager.StartForHeadless();
        }

        private void OnDestroy()
        {
            _instances.Remove(this);
        }

        /// <summary>
        /// Initializes components. To be called after all components are added.
        /// </summary>
        private void InitializeComponents()
        {
            TimeManager.InitializeOnce_Internal(this);
            TimeManager.OnLateUpdate += TimeManager_OnLateUpdate;
            SceneManager.InitializeOnce_Internal(this);
            TransportManager.InitializeOnce_Internal(this);
            ClientManager.InitializeOnce_Internal(this);
            ServerManager.InitializeOnce_Internal(this);
            ObserverManager.InitializeOnce_Internal(this);
            RollbackManager.InitializeOnce_Internal(this);
            PredictionManager.InitializeOnce(this);
            StatisticsManager.InitializeOnce_Internal(this);
            _objectPool.InitializeOnce(this);
        }

        /// <summary>
        /// Updates the frame rate based on server and client status.
        /// </summary>
        internal void UpdateFramerate()
        {
            bool clientStarted = ClientManager.Started;
            bool serverStarted = ServerManager.Started;
            
            int frameRate = 0;
            //If both client and server are started then use whichever framerate is higher.
            if (clientStarted && serverStarted)
                frameRate = Math.Max(ServerManager.FrameRate, ClientManager.FrameRate);
            else if (clientStarted)
                frameRate = ClientManager.FrameRate;
            else if (serverStarted)
                frameRate = ServerManager.FrameRate;

            /* Make sure framerate isn't set to max on server.
             * If it is then default to tick rate. If framerate is
             * less than tickrate then also set to tickrate. */
#if UNITY_SERVER && !UNITY_EDITOR
            ushort minimumServerFramerate = (ushort)(TimeManager.TickRate + 15);
            if (frameRate == MAXIMUM_FRAMERATE)
                frameRate = minimumServerFramerate;
            else if (frameRate < TimeManager.TickRate)
                frameRate = minimumServerFramerate;
#endif
            //If there is a framerate to set.
            if (frameRate > 0)
                Application.targetFrameRate = frameRate;
        }

        /// <summary>
        /// Called when MonoBehaviours call LateUpdate.
        /// </summary>
        private void TimeManager_OnLateUpdate()
        {
            /* Some reason runinbackground becomes unset
             * or the setting goes ignored some times when it's set
             * in awake. Rather than try to fix or care why Unity
             * does this just set it in LateUpdate(or Update). */
            SetRunInBackground();
            //Let's object pooler do regular work.
            _objectPool.LateUpdate();
        }


        /// <summary>
        /// Returns if this NetworkManager can initialize.
        /// </summary>
        /// <returns></returns>
        private bool CanInitialize()
        {
            /* If allow multiple then any number of
             * NetworkManagers are allowed. Don't
             * automatically destroy any. */
            if (_persistence == PersistenceType.AllowMultiple)
                return true;

            List<NetworkManager> instances = Instances.ToList();
            //This is the first instance, it may initialize.
            if (instances.Count == 0)
                return true;

            //First instance of NM.
            NetworkManager firstInstance = instances[0];

            //If to destroy the newest.
            if (_persistence == PersistenceType.DestroyNewest)
            {
                InternalLog($"NetworkManager on object {gameObject.name} is being destroyed due to persistence type {_persistence}. A NetworkManager instance already exist on {firstInstance.name}.");
                DestroyImmediate(gameObject);
                //This one is being destroyed because its the newest.
                return false;
            }
            //If to destroy the oldest.
            else if (_persistence == PersistenceType.DestroyOldest)
            {
                InternalLog($"NetworkManager on object {firstInstance.name} is being destroyed due to persistence type {_persistence}. A NetworkManager instance has been created on {gameObject.name}.");
                DestroyImmediate(firstInstance.gameObject);
                //This being the new one will persist, allow initialization.
                return true;
            }
            //Unhandled.
            else
            {
                InternalLog($"Persistance type of {_persistence} is unhandled on {gameObject.name}. Initialization will not proceed.");
                return false;
            }
        }

        /// <summary>
        /// Validates SpawnablePrefabs field and returns if validated successfully.
        /// </summary>
        /// <returns></returns>
        private bool ValidateSpawnablePrefabs(bool print)
        {
            //If null and object is in a scene.
            if (SpawnablePrefabs == null && !string.IsNullOrEmpty(gameObject.scene.name))
            {
                //First try to fetch the file, only if editor and not in play mode.
#if UNITY_EDITOR
                if (!ApplicationState.IsPlaying())
                {
                    SpawnablePrefabs = Generator.GetDefaultPrefabObjects();
                    if (SpawnablePrefabs != null)
                    {
                        Debug.Log($"SpawnablePrefabs was set to DefaultPrefabObjects automatically on object {gameObject.name} in scene {gameObject.scene.name}.");
                        EditorUtility.SetDirty(this);
                        return true;
                    }
                }
#endif
                //Always throw an error as this would cause failure.
                if (print)
                    Debug.LogError($"SpawnablePrefabs is null on {gameObject.name}. Select the NetworkManager in scene {gameObject.scene.name} and choose a prefabs file. Choosing DefaultPrefabObjects will automatically populate prefabs for you.");
                return false;
            }

            return true;
        }

        /// <summary>
        /// Sets DontDestroyOnLoad if configured to.
        /// </summary>
        private void SetDontDestroyOnLoad()
        {
            if (_dontDestroyOnLoad)
                DontDestroyOnLoad(this);
        }

        /// <summary>
        /// Sets Application.runInBackground to runInBackground.
        /// </summary>
        private void SetRunInBackground()
        {
            Application.runInBackground = _runInBackground;
        }

        /// <summary>
        /// Gets a component, creating and adding it if it does not exist.
        /// </summary>
        /// <param name="presetValue">Value which may already be set. When not null this is returned instead.</param>
        private T GetOrCreateComponent<T>(T presetValue = null) where T : UnityEngine.Component
        {
            //If already set then return set value.
            if (presetValue != null)
                return presetValue;

            if (gameObject.TryGetComponent(out T result))
                return result;
            else
                return gameObject.AddComponent<T>();
        }

        /// <summary>
        /// Clears a client collection after disposing of the NetworkConnections.
        /// </summary>
        /// <param name="clients"></param>
        internal void ClearClientsCollection(Dictionary<int, NetworkConnection> clients, int transportIndex = -1)
        {
            //True to dispose all connections.
            bool disposeAll = (transportIndex < 0);
            List<int> cache = CollectionCaches<int>.RetrieveList();


            foreach (KeyValuePair<int, NetworkConnection> kvp in clients)
            {
                NetworkConnection value = kvp.Value;
                //If to check transport index.
                if (!disposeAll)
                {
                    if (value.TransportIndex == transportIndex)
                    {
                        cache.Add(kvp.Key);
                        value.ResetState();
                    }
                }
                //Not using transport index, no check required.
                else
                {
                    value.ResetState();
                }
            }

            //If all are being disposed the collection can be cleared.
            if (disposeAll)
            {
                clients.Clear();
            }
            //Otherwise, only remove those which were disposed.
            else
            {
                foreach (int item in cache)
                    clients.Remove(item);
            }

            CollectionCaches<int>.Store(cache);
        }

        #region Editor.
#if UNITY_EDITOR
        private void OnValidate()
        {
            if (SpawnablePrefabs == null)
                Reset();
        }

        private void Reset()
        {
            ValidateSpawnablePrefabs(true);
        }

#endif
        #endregion
    }
}﻿using FishNet.Documenting;
using FishNet.Managing.Logging;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing
{
    public partial class NetworkManager : MonoBehaviour
    {
        #region Serialized.
        /// <summary>
        /// Logging configuration to use. When empty default logging settings will be used.
        /// </summary>
        [Tooltip("Logging configuration to use. When empty default logging settings will be used.")]
        [SerializeField]
        private LoggingConfiguration _logging;
        #endregion

        #region Const.
        private const string ERROR_LOGGING_PREFIX = "Error - ";
        private const string WARNING_LOGGING_PREFIX = "Warning - ";
        private const string COMMON_LOGGING_PREFIX = "Log - ";
        #endregion

        /// <summary>
        /// Initializes logging settings.
        /// </summary>
        private void InitializeLogging()
        {
            if (_logging == null)
                _logging = ScriptableObject.CreateInstance<LevelLoggingConfiguration>();
            else
                _logging = _logging.Clone();

            _logging.InitializeOnce();
        }


        /// <summary>
        /// True if can log for loggingType.
        /// </summary>
        /// <param name="loggingType">Type of logging being filtered.</param>
        /// <returns></returns>
        internal bool InternalCanLog(LoggingType loggingType)
        {
            return _logging.CanLog(loggingType);
        }

        /// <summary>
        /// Performs a common log, should logging settings permit it.
        /// </summary>
        internal void InternalLog(string value)
        {
            _logging.Log(value);
        }

        /// <summary>
        /// Performs a log using the loggingType, should logging settings permit it.
        /// </summary>
        internal void InternalLog(LoggingType loggingType, string value)
        {
            if (loggingType == LoggingType.Common)
                _logging.Log(value);
            else if (loggingType == LoggingType.Warning)
                _logging.LogWarning(value);
            else if (loggingType == LoggingType.Error)
                _logging.LogError(value);
        }

        /// <summary>
        /// Performs a warning log, should logging settings permit it.
        /// </summary>
        internal void InternalLogWarning(string value)
        {
            _logging.LogWarning(value);
        }

        /// <summary>
        /// Performs an error log, should logging settings permit it.
        /// </summary>
        internal void InternalLogError(string value)
        {
            _logging.LogError(value);
        }
    }

    public static class NetworkManagerExtensions
    {

        /// <summary>
        /// True if can log for loggingType.
        /// </summary>
        
        internal static bool CanLog(this NetworkManager networkManager, LoggingType loggingType)
        {
            if (GetNetworkManager(ref networkManager))
                return networkManager.InternalCanLog(loggingType);
            else
                return false;
        }

        /// <summary>
        /// Performs a log using the loggingType, should logging settings permit it.
        /// </summary>
        
        public static void Log(this NetworkManager networkManager, LoggingType loggingType, string value)
        {
            if (loggingType == LoggingType.Common)
                networkManager.Log(value);
            else if (loggingType == LoggingType.Warning)
                networkManager.LogWarning(value);
            else if (loggingType == LoggingType.Error)
                networkManager.LogError(value);
        }

        /// <summary>
        /// Performs a common log, should logging settings permit it.
        /// </summary>
        
        public static void Log(this NetworkManager networkManager, string message)
        {
            if (GetNetworkManager(ref networkManager))
                networkManager.InternalLog(message);
            else
                Debug.Log(message);
        }
        /// <summary>
        /// Performs a warning log, should logging settings permit it.
        /// </summary>
        
        public static void LogWarning(this NetworkManager networkManager, string message)
        {
            if (GetNetworkManager(ref networkManager))
                networkManager.InternalLogWarning(message);
            else
                Debug.LogWarning(message);
        }

        /// <summary>
        /// Performs an error log, should logging settings permit it.
        /// </summary>
        
        public static void LogError(this NetworkManager networkManager, string message)
        {
            if (GetNetworkManager(ref networkManager))
                networkManager.InternalLogError(message);
            else
                Debug.LogError(message);
        }

        /// <summary>
        /// Gets a NetworkManager, first using a preferred option.
        /// </summary>
        /// <returns>True if a NetworkManager was found.</returns>
        private static bool GetNetworkManager(ref NetworkManager preferredNm)
        {
            if (preferredNm != null)
                return true;

            preferredNm = InstanceFinder.NetworkManager;
            return (preferredNm != null);
        }

        #region Backwards compatibility.
        /// <summary>
        /// Performs a common log, should logging settings permit it.
        /// </summary>
        
        public static void Log(string msg) => NetworkManagerExtensions.Log(null, msg);
        /// <summary>
        /// Performs a warning log, should logging settings permit it.
        /// </summary>
        
        public static void LogWarning(string msg) => NetworkManagerExtensions.LogWarning(null, msg);
        /// <summary>
        /// Performs an error log, should logging settings permit it.
        /// </summary>
        
        public static void LogError(string msg) => NetworkManagerExtensions.LogError(null, msg);
        /// <summary>
        /// True if can log for loggingType.
        /// </summary>
        
        public static bool CanLog(LoggingType lt) => NetworkManagerExtensions.CanLog(null, lt);


        #endregion
    }

}﻿using FishNet.Object;
using FishNet.Utility.Performance;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing
{
    public sealed partial class NetworkManager : MonoBehaviour
    {
        /// <summary>
        /// Returns an instantiated or pooled object using supplied values. When a value is not specified it uses default values to the prefab or NetworkManager.       
        /// </summary>
        public NetworkObject GetPooledInstantiated(NetworkObject prefab, Transform parent, bool asServer) => GetPooledInstantiated(prefab.PrefabId, prefab.SpawnableCollectionId, ObjectPoolRetrieveOption.MakeActive, parent, position: null, rotation: null, scale: null, asServer);

        /// <summary>
        /// Returns an instantiated or pooled object using supplied values. When a value is not specified it uses default values to the prefab or NetworkManager.       
        /// </summary>
        public NetworkObject GetPooledInstantiated(NetworkObject prefab, bool asServer) => GetPooledInstantiated(prefab.PrefabId, prefab.SpawnableCollectionId, ObjectPoolRetrieveOption.MakeActive, parent: null, position: null, rotation: null, scale: null, asServer);

        /// <summary>
        /// Returns an instantiated or pooled object using supplied values. When a value is not specified it uses default values to the prefab or NetworkManager.       
        /// </summary>
        public NetworkObject GetPooledInstantiated(NetworkObject prefab, Vector3 position, Quaternion rotation, bool asServer) => GetPooledInstantiated(prefab.PrefabId, prefab.SpawnableCollectionId, ObjectPoolRetrieveOption.MakeActive, parent: null, position, rotation, scale: null, asServer);

        /// <summary>
        /// Returns an instantiated or pooled object using supplied values. When a value is not specified it uses default values to the prefab or NetworkManager.       
        /// </summary>
        public NetworkObject GetPooledInstantiated(GameObject prefab, bool asServer)
        {
            if (SetPrefabInformation(prefab, out _, out int prefabId, out ushort collectionId))
                return GetPooledInstantiated(prefabId, collectionId, ObjectPoolRetrieveOption.MakeActive, parent: null, position: null, rotation: null, scale: null, asServer);
            //Fallthrough, failure.
            return null;
        }

        /// <summary>
        /// Returns an instantiated or pooled object using supplied values. When a value is not specified it uses default values to the prefab or NetworkManager.       
        /// </summary>
        public NetworkObject GetPooledInstantiated(GameObject prefab, Transform parent, bool asServer)
        {
            if (SetPrefabInformation(prefab, out _, out int prefabId, out ushort collectionId))
                return GetPooledInstantiated(prefabId, collectionId, ObjectPoolRetrieveOption.MakeActive, parent, position: null, rotation: null, scale: null, asServer);
            //Fallthrough, failure.
            return null;
        }

        /// <summary>
        /// Returns an instantiated or pooled object using supplied values. When a value is not specified it uses default values to the prefab or NetworkManager.       
        /// </summary>
        public NetworkObject GetPooledInstantiated(GameObject prefab, Vector3 position, Quaternion rotation, bool asServer)
        {
            if (SetPrefabInformation(prefab, out _, out int prefabId, out ushort collectionId))
                return GetPooledInstantiated(prefabId, collectionId, ObjectPoolRetrieveOption.MakeActive, parent: null, position, rotation, scale: null, asServer);
            //Fallthrough, failure.
            return null;
        }

        /// <summary>
        /// Returns an instantiated or pooled object using supplied values. When a value is not specified it uses default values to the prefab or NetworkManager.       
        /// </summary>
        public NetworkObject GetPooledInstantiated(NetworkObject prefab, Vector3 position, Quaternion rotation, Transform parent, bool asServer) => GetPooledInstantiated(prefab.PrefabId, prefab.SpawnableCollectionId, ObjectPoolRetrieveOption.MakeActive, parent, position, rotation, scale: null, asServer);

        /// <summary>
        /// Returns an instantiated or pooled object using supplied values. When a value is not specified it uses default values to the prefab or NetworkManager.       
        /// </summary>
        public NetworkObject GetPooledInstantiated(GameObject prefab, Vector3 position, Quaternion rotation, Transform parent, bool asServer)
        {
            if (SetPrefabInformation(prefab, out _, out int prefabId, out ushort collectionId))
                return GetPooledInstantiated(prefabId, collectionId, ObjectPoolRetrieveOption.MakeActive, parent, position, rotation, scale: null, asServer);
            //Fallthrough, failure.
            return null;
        }

        /// <summary>
        /// Returns an instantiated or pooled object using supplied values. When a value is not specified it uses default values to the prefab or NetworkManager.
        /// </summary>
        public NetworkObject GetPooledInstantiated(int prefabId, ushort collectionId, bool asServer) => GetPooledInstantiated(prefabId, collectionId, ObjectPoolRetrieveOption.MakeActive, parent: null, position: null, rotation: null, scale: null, asServer: asServer);

        /// <summary>
        /// Returns an instantiated or pooled object using supplied values. When a value is not specified it uses default values to the prefab or NetworkManager.
        /// </summary>
        public NetworkObject GetPooledInstantiated(int prefabId, ushort collectionId, Vector3 position, Quaternion rotation, bool asServer) => GetPooledInstantiated(prefabId, collectionId, ObjectPoolRetrieveOption.MakeActive, parent: null, position, rotation, scale: null, asServer);

        /// <summary>
        /// Returns an instantiated or pooled object using supplied values. When a value is not specified it uses default values to the prefab or NetworkManager.
        /// </summary>
        /// <param name="makeActive">True to make the NetworkObject active if not already. Using false will not prevent an object from activating via instantation, but rather indicates to not set active manually prior to returning a NetworkObject.</param>
        [Obsolete("Use GetPooledInstantiated(int, ushort, RetrieveOption, parent, Vector3?, Quaternion? Vector3?, bool) instead.")] //Remove in V5
        public NetworkObject GetPooledInstantiated(int prefabId, ushort collectionId, Transform parent, Vector3? position, Quaternion? rotation, Vector3? scale, bool makeActive, bool asServer) => _objectPool.RetrieveObject(prefabId, collectionId, parent, position, rotation, scale, makeActive, asServer);

        /// <summary>
        /// Returns an instantiated or pooled object using supplied values. When a value is not specified it uses default values to the prefab or NetworkManager.
        /// </summary>
        public NetworkObject GetPooledInstantiated(int prefabId, ushort collectionId, ObjectPoolRetrieveOption options, Transform parent, Vector3? position, Quaternion? rotation, Vector3? scale, bool asServer) => _objectPool.RetrieveObject(prefabId, collectionId, options, parent, position, rotation, scale, asServer);

        /// <summary>
        /// Stores an instantied object.
        /// </summary>
        /// <param name="instantiated">Object which was instantiated.</param>
        /// <param name="asServer">True to store for the server.</param>
        public void StorePooledInstantiated(NetworkObject instantiated, bool asServer) => _objectPool.StoreObject(instantiated, asServer);

        /// <summary>
        /// Stores a NetworkObject if it has pooling enabled, otherwise destroys it.
        /// </summary>
        /// <param name="instantiated">Object which was instantiated.</param>
        /// <param name="asServer">True to store for the server.</param>
        public void StorePooledOrDestroyInstantiated(NetworkObject instantiated, bool asServer)
        {
            if (instantiated.GetDefaultDespawnType() == DespawnType.Destroy)
                Destroy(instantiated.gameObject);
            else
                _objectPool.StoreObject(instantiated, asServer);
        }

        /// <summary>
        /// Instantiates a number of objects and adds them to the pool.
        /// </summary>
        /// <param name="prefab">Prefab to cache.</param>
        /// <param name="count">Quantity to spawn.</param>
        /// <param name="asServer">True if storing prefabs for the server collection. This is only applicable when using DualPrefabObjects.</param>
        public void CacheObjects(NetworkObject prefab, int count, bool asServer) => _objectPool.CacheObjects(prefab, count, asServer);

        /// <summary>
        /// Outputs a prefab, along with it's Id and collectionId. Returns if the information could be found.
        /// </summary>
        private bool SetPrefabInformation(GameObject prefab, out NetworkObject nob, out int prefabId, out ushort collectionId)
        {
            if (!prefab.TryGetComponent(out nob))
            {
                prefabId = 0;
                collectionId = 0;
                InternalLogError($"NetworkObject was not found on {prefab}. An instantiated NetworkObject cannot be returned.");
                return false;
            }
            else
            {
                prefabId = nob.PrefabId;
                collectionId = nob.SpawnableCollectionId;
                return true;
            }
        }
    }
}﻿using FishNet.Component.ColliderRollback;
using UnityEngine;

namespace FishNet.Managing
{
    public sealed partial class NetworkManager : MonoBehaviour
    {

        #region Public.
        /// <summary>
        /// RollbackManager for this NetworkManager.
        /// </summary>
        public RollbackManager RollbackManager { get; private set; }
        #endregion


    }


}﻿using FishNet.Managing.Object;
using FishNet.Object;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityComponent = UnityEngine.Component;


namespace FishNet.Managing
{
    public partial class NetworkManager : MonoBehaviour
    {
        #region Public.
        #region Obsoletes
        [Obsolete("Use IsClientOnlyStarted. Note the difference between IsClientOnlyInitialized and IsClientOnlyStarted.")]
        public bool IsClientOnly => IsClientOnlyStarted;
        [Obsolete("Use IsServerOnlyStarted. Note the difference between IsServerOnlyInitialized and IsServerOnlyStarted.")]
        public bool IsServerOnly => IsServerOnlyStarted;
        [Obsolete("Use IsHostStarted. Note the difference between IsHostInitialized and IsHostStarted.")]
        public bool IsHost => IsHostStarted;
        [Obsolete("Use IsClientStarted. Note the difference between IsClientInitialized and IsClientStarted.")]
        public bool IsClient => IsClientStarted;
        [Obsolete("Use IsServerStarted. Note the difference between IsServerInitialized and IsServerStarted.")]
        public bool IsServer => IsServerStarted;
        #endregion

        /// <summary>
        /// True if server is started.
        /// </summary>
        public bool IsServerStarted => ServerManager.Started;
        /// <summary>
        /// True if only the server is started.
        /// </summary>
        public bool IsServerOnlyStarted => (IsServerStarted && !IsClientStarted);
        /// <summary>
        /// True if the client is authenticated.
        /// </summary>
        public bool IsClientStarted => (ClientManager.Started && ClientManager.Connection.IsAuthenticated);
        /// <summary>
        /// True if only the client is authenticated.
        /// </summary>
        public bool IsClientOnlyStarted => (!IsServerStarted && IsClientStarted);
        /// <summary>
        /// True if client is authenticated, and the server is started.
        /// </summary>
        public bool IsHostStarted => (IsServerStarted && IsClientStarted);
        /// <summary>
        /// True if client nor server are started.
        /// </summary>
        public bool IsOffline => (!IsServerStarted && !IsClientStarted);

        #endregion

        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Collection to use for spawnable objects.")]
        [SerializeField]
        private PrefabObjects _spawnablePrefabs;
        /// <summary>
        /// Collection to use for spawnable objects.
        /// </summary>
        public PrefabObjects SpawnablePrefabs { get => _spawnablePrefabs; set => _spawnablePrefabs = value; }
        /// <summary>
        /// 
        /// </summary>
        private Dictionary<ushort, PrefabObjects> _runtimeSpawnablePrefabs = new();
        /// <summary>
        /// Collection to use for spawnable objects added at runtime, such as addressables.
        /// </summary>
        public IReadOnlyDictionary<ushort, PrefabObjects> RuntimeSpawnablePrefabs => _runtimeSpawnablePrefabs;
        #endregion

        #region Private.
        /// <summary>
        /// Delegates waiting to be invoked when a component is registered.
        /// </summary>
        private Dictionary<string, List<Action<UnityComponent>>> _pendingInvokes = new();
        /// <summary>
        /// Currently registered components.
        /// </summary>
        private Dictionary<string, UnityComponent> _registeredComponents = new();
        #endregion

        /// <summary>
        /// Gets the PrefabObjects to use for spawnableCollectionId.
        /// </summary>
        /// <typeparam name="T">Type of PrefabObjects to return. This is also used to create an instance of type when createIfMissing is true.</typeparam>
        /// <param name="spawnableCollectionId">Id to use. 0 will return the configured SpawnablePrefabs.</param>
        /// <param name="createIfMissing">True to create and assign a PrefabObjects if missing for the collectionId.</param>
        /// <returns></returns>
        public PrefabObjects GetPrefabObjects<T>(ushort spawnableCollectionId, bool createIfMissing) where T : PrefabObjects
        {
            if (spawnableCollectionId == 0)
            {
                if (createIfMissing)
                {
                    InternalLogError($"SpawnableCollectionId cannot be 0 when create missing is true.");
                    return null;
                }
                else
                {
                    return SpawnablePrefabs;
                }
            }

            PrefabObjects po;
            if (!_runtimeSpawnablePrefabs.TryGetValue(spawnableCollectionId, out po))
            {
                //Do not create missing, return null for not found.
                if (!createIfMissing)
                    return null;

                po = ScriptableObject.CreateInstance<T>();
                po.SetCollectionId(spawnableCollectionId);
                _runtimeSpawnablePrefabs[spawnableCollectionId] = po;
            }

            return po;
        }

        /// <summary>
        /// Removes the PrefabObjects collection from memory.
        /// This should only be called after you properly disposed of it's contents properly.
        /// </summary>
        /// <param name="spawnableCollectionId">CollectionId to remove.</param>
        /// <returns>True if collection was found and removed.</returns>
        public bool RemoveSpawnableCollection(ushort spawnableCollectionId)
        {
            return _runtimeSpawnablePrefabs.Remove(spawnableCollectionId);
        }

        /// <summary>
        /// Gets the index a prefab uses. Can be used in conjuction with GetPrefab.
        /// </summary>
        /// <param name="prefab"></param>
        /// <param name="asServer">True if to get from the server collection.</param>
        /// <returns>Returns index if found, and -1 if not found.</returns>
        public int GetPrefabIndex(GameObject prefab, bool asServer)
        {
            int count = SpawnablePrefabs.GetObjectCount();
            for (int i = 0; i < count; i++)
            {
                GameObject go = SpawnablePrefabs.GetObject(asServer, i).gameObject;
                if (go == prefab)
                    return i;
            }

            //Fall through, not found.
            return -1;
        }

        /// <summary>
        /// Returns a prefab with prefabId.
        /// This method will bypass object pooling.
        /// </summary>
        /// <param name="prefabId">PrefabId to get.</param>
        /// <param name="asServer">True if getting the prefab asServer.</param>
        public NetworkObject GetPrefab(int prefabId, bool asServer)
        {
            return SpawnablePrefabs.GetObject(asServer, prefabId);
        }


        #region Registered components
        /// <summary>
        /// Invokes an action when a specified component becomes registered. Action will invoke immediately if already registered.
        /// </summary>
        /// <typeparam name="T">Component type.</typeparam>
        /// <param name="handler">Action to invoke.</param>
        public void RegisterInvokeOnInstance<T>(Action<UnityComponent> handler) where T : UnityComponent
        {
            T result;
            //If not found yet make a pending invoke.
            if (!TryGetInstance(out result))
            {
                string tName = GetInstanceName<T>();
                List<Action<UnityComponent>> handlers;
                if (!_pendingInvokes.TryGetValue(tName, out handlers))
                {
                    handlers = new();
                    _pendingInvokes[tName] = handlers;
                }

                handlers.Add(handler);
            }
            //Already exist, invoke right away.
            else
            {
                handler.Invoke(result);
            }
        }
        /// <summary>
        /// Removes an action to be invokes when a specified component becomes registered.
        /// </summary>
        /// <typeparam name="T">Component type.</typeparam>
        /// <param name="handler">Action to invoke.</param>
        public void UnregisterInvokeOnInstance<T>(Action<UnityComponent> handler) where T : UnityComponent
        {
            string tName = GetInstanceName<T>();
            List<Action<UnityComponent>> handlers;
            if (!_pendingInvokes.TryGetValue(tName, out handlers))
                return;

            handlers.Remove(handler);
            //Do not remove pending to prevent garbage collection later from recreation.
        }
        /// <summary>
        /// Returns if an instance exists for type.
        /// </summary>
        /// <typeparam name="T">Type to check.</typeparam>
        /// <returns></returns>
        public bool HasInstance<T>() where T : UnityComponent
        {
            return TryGetInstance<T>(out _);
        }

        /// <summary>
        /// Returns class of type from registered instances.
        /// A warning will display if not found.
        /// </summary>
        /// <typeparam name="T">Type to get.</typeparam>
        /// <returns></returns>
        public T GetInstance<T>() where T : UnityComponent
        {
            T result;
            if (TryGetInstance(out result))
                return result;
            else
                InternalLogWarning($"Component {GetInstanceName<T>()} is not registered. To avoid this warning use TryGetInstance(T).");

            return default(T);
        }
        /// <summary>
        /// Returns class of type from registered instances.
        /// </summary>
        /// <param name="component">Outputted component.</param>
        /// <typeparam name="T">Type to get.</typeparam>
        /// <returns>True if was able to get instance.</returns>
        public bool TryGetInstance<T>(out T result) where T : UnityComponent
        {
            string tName = GetInstanceName<T>();
            if (_registeredComponents.TryGetValue(tName, out UnityComponent v))
            {
                result = (T)v;
                return true;
            }
            else
            {
                result = default;
                return false;
            }
        }
        /// <summary>
        /// Registers a new component to this NetworkManager.
        /// </summary>
        /// <typeparam name="T">Type to register.</typeparam>
        /// <param name="component">Reference of the component being registered.</param>
        /// <param name="replace">True to replace existing references.</param>
        public void RegisterInstance<T>(T component, bool replace = true) where T : UnityComponent
        {
            string tName = GetInstanceName<T>();
            if (_registeredComponents.ContainsKey(tName) && !replace)
            {
                InternalLogWarning($"Component {tName} is already registered.");
            }
            else
            {
                _registeredComponents[tName] = component;
                RemoveNullPendingDelegates();
                //If in pending invokes also send these out.
                if (_pendingInvokes.TryGetValue(tName, out List<Action<UnityComponent>> dels))
                {
                    for (int i = 0; i < dels.Count; i++)
                        dels[i].Invoke(component);
                    /* Clear delegates but do not remove dictionary entry
                     * to prevent list from being re-initialized. */
                    dels.Clear();
                }
            }
        }

        /// <summary>
        /// Tries to registers a new component to this NetworkManager.
        /// This will not register the instance if another already exists.
        /// </summary>
        /// <typeparam name="T">Type to register.</typeparam>
        /// <param name="component">Reference of the component being registered.</param>
        /// <returns>True if was able to register, false if an instance is already registered.</returns>
        
        public bool TryRegisterInstance<T>(T component) where T : UnityComponent
        {
            string tName = GetInstanceName<T>();
            if (_registeredComponents.ContainsKey(tName))
                return false;
            else
                RegisterInstance(component, false);

            return true;
        }

        /// <summary>
        /// Unregisters a component from this NetworkManager.
        /// </summary>
        /// <typeparam name="T">Type to unregister.</typeparam>
        public void UnregisterInstance<T>() where T : UnityComponent
        {
            string tName = GetInstanceName<T>();
            _registeredComponents.Remove(tName);
        }
        /// <summary>
        /// Removes delegates from pending invokes when may have gone missing.
        /// </summary>
        private void RemoveNullPendingDelegates()
        {
            foreach (List<Action<UnityComponent>> handlers in _pendingInvokes.Values)
            {
                for (int i = 0; i < handlers.Count; i++)
                {
                    if (handlers[i] == null)
                    {
                        handlers.RemoveAt(i);
                        i--;
                    }
                }
            }
        }
        /// <summary>
        /// Returns the name to use for T.
        /// </summary>
        private string GetInstanceName<T>()
        {
            return typeof(T).FullName;
        }
        #endregion


    }

}﻿
namespace FishNet.Managing
{

    public enum RemoteTimeoutType
    {
        /// <summary>
        /// Disable this feature.
        /// </summary>
        Disabled = 0,
        /// <summary>
        /// Only enable in release builds.
        /// </summary>
        Release = 1,
        /// <summary>
        /// Enable in all builds and editor.
        /// </summary>
        Development = 2,
    }

}﻿using FishNet.Broadcast;
using FishNet.Broadcast.Helping;
using FishNet.Managing.Utility;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Client
{
    public sealed partial class ClientManager : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// Handler for registered broadcasts.
        /// </summary>
        private readonly Dictionary<ushort, BroadcastHandlerBase> _broadcastHandlers = new();
        #endregion

        /// <summary>
        /// Registers a method to call when a Broadcast arrives.
        /// </summary>
        /// <typeparam name="T">Type of broadcast being registered.</typeparam>
        /// <param name="handler">Method to call.</param>
        public void RegisterBroadcast<T>(Action<T, Channel> handler) where T : struct, IBroadcast
        {
            if (handler == null)
            {
                NetworkManager.LogError($"Broadcast cannot be registered because handler is null. This may occur when trying to register to objects which require initialization, such as events.");
                return;
            }

            ushort key = BroadcastExtensions.GetKey<T>();
            //Create new IBroadcastHandler if needed.
            BroadcastHandlerBase bhs;
            if (!_broadcastHandlers.TryGetValueIL2CPP(key, out bhs))
            {
                bhs = new ServerBroadcastHandler<T>();
                _broadcastHandlers.Add(key, bhs);
            }
            //Register handler to IBroadcastHandler.
            bhs.RegisterHandler(handler);
        }

        /// <summary>
        /// Unregisters a method call from a Broadcast type.
        /// </summary>
        /// <typeparam name="T">Type of broadcast being unregistered.</typeparam>
        /// <param name="handler">Method to unregister.</param>
        public void UnregisterBroadcast<T>(Action<T, Channel> handler) where T : struct, IBroadcast
        {
            ushort key = BroadcastExtensions.GetKey<T>();
            if (_broadcastHandlers.TryGetValueIL2CPP(key, out BroadcastHandlerBase bhs))
                bhs.UnregisterHandler(handler);
        }

        /// <summary>
        /// Parses a received broadcast.
        /// </summary>
        
        private void ParseBroadcast(PooledReader reader, Channel channel)
        {
            ushort key = reader.ReadUInt16();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.Broadcast, reader, channel);
            // try to invoke the handler for that message
            if (_broadcastHandlers.TryGetValueIL2CPP(key, out BroadcastHandlerBase bhs))
                bhs.InvokeHandlers(reader, channel);
            else
                reader.Skip(dataLength);
        }


        /// <summary>
        /// Sends a Broadcast to the server.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="channel">Channel to send on.</param>
        public void Broadcast<T>(T message, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            //Check local connection state.
            if (!Started)
            {
                NetworkManager.LogWarning($"Cannot send broadcast to server because client is not active.");
                return;
            }

            PooledWriter writer = WriterPool.Retrieve();
            BroadcastsSerializers.WriteBroadcast(NetworkManager, writer, message, ref channel);
            ArraySegment<byte> segment = writer.GetArraySegment();

            NetworkManager.TransportManager.SendToServer((byte)channel, segment);
            writer.Store();
        }

    }


}
﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.Connection;
using FishNet.Managing.Debugging;
using FishNet.Managing.Logging;
using FishNet.Managing.Server;
using FishNet.Managing.Timing;
using FishNet.Managing.Transporting;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Transporting.Multipass;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Managing.Client
{
    /// <summary>
    /// A container for local client data and actions.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/ClientManager")]
    public sealed partial class ClientManager : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// This is set true if the server has notified the client it is using a development build.
        /// Value is set before authentication.
        /// </summary>
        public bool IsServerDevelopment { get; private set; }
        /// <summary>
        /// Called after local client has authenticated.
        /// </summary>
        public event Action OnAuthenticated;
        /// <summary>
        /// Called when the local client connection to the server has timed out.
        /// This is called immediately before disconnecting.
        /// </summary>
        public event Action OnClientTimeOut;
        /// <summary>
        /// Called after the local client connection state changes.
        /// </summary>
        public event Action<ClientConnectionStateArgs> OnClientConnectionState;
        /// <summary>
        /// Called when a client other than self connects.
        /// This is only available when using ServerManager.ShareIds.
        /// </summary>
        public event Action<RemoteConnectionStateArgs> OnRemoteConnectionState;
        /// <summary>
        /// Called when the server sends all currently connected clients.
        /// This is only available when using ServerManager.ShareIds.
        /// </summary>
        public event Action<ConnectedClientsArgs> OnConnectedClients;
        /// <summary>
        /// True if the client connection is connected to the server.
        /// </summary>
        public bool Started { get; private set; }
        /// <summary>
        /// NetworkConnection the local client is using to send data to the server.
        /// </summary>
        public NetworkConnection Connection = NetworkManager.EmptyConnection;
        /// <summary>
        /// Handling and information for objects known to the local client.
        /// </summary>
        public ClientObjects Objects { get; private set; }
        /// <summary>
        /// All currently connected clients. This field only contains data while ServerManager.ShareIds is enabled.
        /// </summary>
        public Dictionary<int, NetworkConnection> Clients = new();
        /// <summary>
        /// NetworkManager for client.
        /// </summary>
        [HideInInspector]
        public NetworkManager NetworkManager { get; private set; }
        #endregion

        #region Serialized.
        /// <summary>
        /// What platforms to enable remote server timeout.
        /// </summary>
        [Tooltip("What platforms to enable remote server timeout.")]
        [SerializeField]
        private RemoteTimeoutType _remoteServerTimeout = RemoteTimeoutType.Development;
        /// <summary>
        /// How long in seconds server must go without sending any packets before the local client disconnects. This is independent of any transport settings.
        /// </summary>
        [Tooltip("How long in seconds server must go without sending any packets before the local client disconnects. This is independent of any transport settings.")]
        [Range(1, ServerManager.MAXIMUM_REMOTE_CLIENT_TIMEOUT_DURATION)]
        [SerializeField]
        private ushort _remoteServerTimeoutDuration = 60;

        /// <summary>
        /// Sets timeout settings. Can be used at runtime.
        /// </summary>
        /// <returns></returns>
        public void SetRemoteServerTimeout(RemoteTimeoutType timeoutType, ushort duration)
        {
            _remoteServerTimeout = timeoutType;
            duration = (ushort)Mathf.Clamp(duration, 1, ServerManager.MAXIMUM_REMOTE_CLIENT_TIMEOUT_DURATION);
            _remoteServerTimeoutDuration = duration;
        }

        //todo add remote server timeout (see ServerManager.RemoteClientTimeout).
        /// <summary>
        /// True to automatically set the frame rate when the client connects.
        /// </summary>
        [Tooltip("True to automatically set the frame rate when the client connects.")]
        [SerializeField]
        private bool _changeFrameRate = true;
        /// <summary>
        /// Maximum frame rate the client may run at. When as host this value runs at whichever is higher between client and server.
        /// </summary>
        internal ushort FrameRate => (_changeFrameRate) ? _frameRate : (ushort)0;
        [Tooltip("Maximum frame rate the client may run at. When as host this value runs at whichever is higher between client and server.")]
        [Range(1, NetworkManager.MAXIMUM_FRAMERATE)]
        [SerializeField]
        private ushort _frameRate = NetworkManager.MAXIMUM_FRAMERATE;

        /// Sets the maximum frame rate the client may run at. Calling this method will enable ChangeFrameRate.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetFrameRate(ushort value)
        {
            _frameRate = (ushort)Mathf.Clamp(value, 0, NetworkManager.MAXIMUM_FRAMERATE);
            _changeFrameRate = true;
            if (NetworkManager != null)
                NetworkManager.UpdateFramerate();
        }
        #endregion

        #region Private.
        /// <summary>
        /// Last unscaled time client got a packet.
        /// </summary>
        private float _lastPacketTime;
        /// <summary>
        /// Used to read splits.
        /// </summary>
        private SplitReader _splitReader = new();
        #endregion

        private void OnDestroy()
        {
            Objects?.SubscribeToSceneLoaded(false);
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="manager"></param>
        internal void InitializeOnce_Internal(NetworkManager manager)
        {
            NetworkManager = manager;
            Objects = new(manager);
            Objects.SubscribeToSceneLoaded(true);
            /* Unsubscribe before subscribing.
             * Shouldn't be an issue but better safe than sorry. */
            SubscribeToEvents(false);
            SubscribeToEvents(true);
            //Listen for client connections from server.
            RegisterBroadcast<ClientConnectionChangeBroadcast>(OnClientConnectionBroadcast);
            RegisterBroadcast<ConnectedClientsBroadcast>(OnConnectedClientsBroadcast);
        }

        /// <summary>
        /// Called when the server sends a connection state change for any client.
        /// </summary>
        /// <param name="args"></param>
        private void OnClientConnectionBroadcast(ClientConnectionChangeBroadcast args, Channel channel)
        {
            //If connecting invoke after added to clients, otherwise invoke before removed.
            RemoteConnectionStateArgs rcs = new((args.Connected) ? RemoteConnectionState.Started : RemoteConnectionState.Stopped, args.Id, -1);

            if (args.Connected)
            {
                Clients[args.Id] = new(NetworkManager, args.Id, -1, false);
                OnRemoteConnectionState?.Invoke(rcs);
            }
            else
            {
                OnRemoteConnectionState?.Invoke(rcs);
                if (Clients.TryGetValue(args.Id, out NetworkConnection c))
                {
                    c.ResetState();
                    Clients.Remove(args.Id);
                }
            }
        }

        /// <summary>
        /// Called when the server sends all currently connected clients.
        /// </summary>
        /// <param name="args"></param>
        private void OnConnectedClientsBroadcast(ConnectedClientsBroadcast args, Channel channel)
        {
            NetworkManager.ClearClientsCollection(Clients);

            List<int> collection = args.Values;
            //No connected clients except self.
            if (collection == null)
            {
                collection = new();
            }
            //Other clients.
            else
            {
                int count = collection.Count;
                for (int i = 0; i < count; i++)
                {
                    int id = collection[i];
                    Clients[id] = new(NetworkManager, id, -1, false);
                }
            }

            OnConnectedClients?.Invoke(new(collection));
        }

        /// <summary>
        /// Changes subscription status to transport.
        /// </summary>
        /// <param name="subscribe"></param>
        private void SubscribeToEvents(bool subscribe)
        {
            if (NetworkManager == null || NetworkManager.TransportManager == null || NetworkManager.TransportManager.Transport == null)
                return;

            if (subscribe)
            {
                NetworkManager.TransportManager.OnIterateIncomingEnd += TransportManager_OnIterateIncomingEnd;
                NetworkManager.TransportManager.Transport.OnClientReceivedData += Transport_OnClientReceivedData;
                NetworkManager.TransportManager.Transport.OnClientConnectionState += Transport_OnClientConnectionState;
                NetworkManager.TimeManager.OnPostTick += TimeManager_OnPostTick;
            }
            else
            {
                NetworkManager.TransportManager.OnIterateIncomingEnd -= TransportManager_OnIterateIncomingEnd;
                NetworkManager.TransportManager.Transport.OnClientReceivedData -= Transport_OnClientReceivedData;
                NetworkManager.TransportManager.Transport.OnClientConnectionState -= Transport_OnClientConnectionState;
                NetworkManager.TimeManager.OnPostTick -= TimeManager_OnPostTick;
            }
        }

        /// <summary>
        /// Gets the transport index being used for the local client.
        /// If only one transport is used this will return 0. If Multipass is being used this will return the client's transport in multipass.
        /// </summary>
        /// <returns></returns>
        public int GetTransportIndex()
        {
            if (NetworkManager.TransportManager.Transport is Multipass mp)
                return mp.ClientTransport.Index;
            else
                return 0;
        }

        /// <summary>
        /// Stops the local client connection.
        /// </summary>
        public bool StopConnection()
        {
            return NetworkManager.TransportManager.Transport.StopConnection(false);
        }

        /// <summary>
        /// Starts the local client connection.
        /// </summary>
        public bool StartConnection()
        {
            return NetworkManager.TransportManager.Transport.StartConnection(false);
        }

        /// <summary>
        /// Sets the transport address and starts the local client connection.
        /// </summary>
        public bool StartConnection(string address)
        {
            NetworkManager.TransportManager.Transport.SetClientAddress(address);
            return StartConnection();
        }

        /// <summary>
        /// Sets the transport address and port, and starts the local client connection.
        /// </summary>
        public bool StartConnection(string address, ushort port)
        {
            NetworkManager.TransportManager.Transport.SetClientAddress(address);
            NetworkManager.TransportManager.Transport.SetPort(port);
            return StartConnection();
        }

        /// <summary>
        /// Called when a connection state changes for the local client.
        /// </summary>
        /// <param name="args"></param>
        private void Transport_OnClientConnectionState(ClientConnectionStateArgs args)
        {
            LocalConnectionState state = args.ConnectionState;
            Started = (state == LocalConnectionState.Started);
            Objects.OnClientConnectionState(args);

            //Clear connection after so objects can update using current Connection value.
            if (!Started)
            {
                Connection = NetworkManager.EmptyConnection;
                NetworkManager.ClearClientsCollection(Clients);
            }
            else
            {
                _lastPacketTime = Time.unscaledTime;
                //Send version.
                PooledWriter writer = WriterPool.Retrieve();
                writer.WritePacketIdUnpacked(PacketId.Version);
                writer.WriteString(NetworkManager.FISHNET_VERSION);
                NetworkManager.TransportManager.SendToServer((byte)Channel.Reliable, writer.GetArraySegment());
                WriterPool.Store(writer);
            }

            if (NetworkManager.CanLog(LoggingType.Common))
            {
                Transport t = NetworkManager.TransportManager.GetTransport(args.TransportIndex);
                string tName = (t == null) ? "Unknown" : t.GetType().Name;
                string socketInformation = string.Empty;
                if (state == LocalConnectionState.Starting)
                    socketInformation = $" Server IP is {t.GetClientAddress()}, port is {t.GetPort()}.";
                NetworkManager.Log($"Local client is {state.ToString().ToLower()} for {tName}.{socketInformation}");
            }

            NetworkManager.UpdateFramerate();
            OnClientConnectionState?.Invoke(args);
        }

        /// <summary>
        /// Called when a socket receives data.
        /// </summary>
        private void Transport_OnClientReceivedData(ClientReceivedDataArgs args)
        {
            ParseReceived(args);
        }

        /// <summary>
        /// Called after IterateIncoming has completed.
        /// </summary>
        private void TransportManager_OnIterateIncomingEnd(bool server)
        {
            /* Should the last packet received be a spawn or despawn
             * then the cache won't yet be iterated because it only
             * iterates when a packet is anything but those two. Because
             * of such if any object caches did come in they must be iterated
             * at the end of the incoming cycle. This isn't as clean as I'd
             * like but it does ensure there will be no missing network object
             * references on spawned objects. */
            if (Started && !server)
                Objects.IterateObjectCache();
        }

        /// <summary>
        /// Parses received data.
        /// </summary>
        private void ParseReceived(ClientReceivedDataArgs args)
        {
            _lastPacketTime = Time.unscaledTime;

            ArraySegment<byte> segment;
            if (NetworkManager.TransportManager.HasIntermediateLayer)
                segment = NetworkManager.TransportManager.ProcessIntermediateIncoming(args.Data, true);
            else
                segment = args.Data;

            NetworkManager.StatisticsManager.NetworkTraffic.LocalClientReceivedData((ulong)segment.Count);
            if (segment.Count <= TransportManager.UNPACKED_TICK_LENGTH)
                return;

            PooledReader reader = ReaderPool.Retrieve(segment, NetworkManager, Reader.DataSource.Server);
            TimeManager tm = NetworkManager.TimeManager;
            tm.LastPacketTick.Update(reader.ReadTickUnpacked(), EstimatedTick.OldTickOption.Discard, false);
            ParseReader(reader, args.Channel);
            ReaderPool.Store(reader);
        }

        internal void ParseReader(PooledReader reader, Channel channel, bool print = false)
        {
            PacketId packetId = PacketId.Unset;
#if !DEVELOPMENT
            try
            {
#endif
            Reader.DataSource dataSource = Reader.DataSource.Server;
            /* This is a special condition where a message may arrive split.
             * When this occurs buffer each packet until all packets are
             * received. */
            if (reader.PeekPacketId() == PacketId.Split)
            {
#if DEVELOPMENT
                NetworkManager.PacketIdHistory.ReceivedPacket(PacketId.Split, packetFromServer: true);
#endif
                //Skip packetId.
                reader.ReadPacketId();
                int expectedMessages;
                _splitReader.GetHeader(reader, out expectedMessages);
                _splitReader.Write(NetworkManager.TimeManager.LastPacketTick.LastRemoteTick, reader, expectedMessages);
                /* If fullMessage returns 0 count then the split
                 * has not written fully yet. Otherwise, if there is
                 * data within then reinitialize reader with the
                 * full message. */
                ArraySegment<byte> fullMessage = _splitReader.GetFullMessage();
                if (fullMessage.Count == 0)
                    return;

                reader.Initialize(fullMessage, NetworkManager, dataSource);
            }

            while (reader.Remaining > 0)
            {
                packetId = reader.ReadPacketId();
#if DEVELOPMENT
                NetworkManager.PacketIdHistory.ReceivedPacket(packetId, packetFromServer: true);
                // if (!NetworkManager.IsServerStarted)
                //     print = true;
                // if (print)
                // {
                //     if (packetId == PacketId.ObserversRpc)
                //         Debug.Log($"PacketId {packetId} - Remaining {reader.Remaining}.");
                //     else
                //         Debug.LogWarning($"PacketId {packetId} - Remaining {reader.Remaining}.");
                // }
                // print = false;
#endif
                bool spawnOrDespawn = (packetId == PacketId.ObjectSpawn || packetId == PacketId.ObjectDespawn);
                /* Length of data. Only available if using unreliable. Unreliable packets
                 * can arrive out of order which means object orientated messages such as RPCs may
                 * arrive after the object for which they target has already been destroyed. When this happens
                 * on lesser solutions they just dump the entire packet. However, since FishNet batches data.
                 * it's very likely a packet will contain more than one packetId. With this mind, length is
                 * sent as well so if any reason the data does have to be dumped it will only be dumped for
                 * that single packetId  but not the rest. Broadcasts don't need length either even if unreliable
                 * because they are not object bound. */

                //Is spawn or despawn; cache packet.
                if (spawnOrDespawn)
                {
                    if (packetId == PacketId.ObjectSpawn)
                        Objects.ReadSpawn(reader);
                    else if (packetId == PacketId.ObjectDespawn)
                        Objects.CacheDespawn(reader);
                }
                //Not spawn or despawn.
                else
                {
                    /* Iterate object cache should any of the
                     * incoming packets rely on it. Objects
                     * in cache will always be received before any messages
                     * that use them. */
                    Objects.IterateObjectCache();
                    //Then process packet normally.
                    if ((ushort)packetId >= NetworkManager.StartingRpcLinkIndex)
                    {
                        Objects.ParseRpcLink(reader, (ushort)packetId, channel);
                    }
                    else if (packetId == PacketId.StateUpdate)
                    {
                        NetworkManager.PredictionManager.ParseStateUpdate(reader, channel);
                    }
                    else if (packetId == PacketId.Replicate)
                    {
                        Objects.ParseReplicateRpc(reader, null, channel);
                    }
                    else if (packetId == PacketId.Reconcile)
                    {
                        Objects.ParseReconcileRpc(reader, channel);
                    }
                    else if (packetId == PacketId.ObserversRpc)
                    {
                        Objects.ParseObserversRpc(reader, channel);
                    }
                    else if (packetId == PacketId.TargetRpc)
                    {
                        Objects.ParseTargetRpc(reader, channel);
                    }
                    else if (packetId == PacketId.Broadcast)
                    {
                        ParseBroadcast(reader, channel);
                    }
                    else if (packetId == PacketId.PingPong)
                    {
                        ParsePingPong(reader);
                    }
                    else if (packetId == PacketId.SyncType)
                    {
                        Objects.ParseSyncType(reader, channel);
                    }
                    else if (packetId == PacketId.PredictedSpawnResult)
                    {
                        Objects.ParsePredictedSpawnResult(reader);
                    }
                    else if (packetId == PacketId.TimingUpdate)
                    {
                        NetworkManager.TimeManager.ParseTimingUpdate(reader);
                    }
                    else if (packetId == PacketId.OwnershipChange)
                    {
                        Objects.ParseOwnershipChange(reader);
                    }
                    else if (packetId == PacketId.Authenticated)
                    {
                        ParseAuthenticated(reader);
                    }
                    else if (packetId == PacketId.Disconnect)
                    {
                        reader.Clear();
                        StopConnection();
                    }
                    else if (packetId == PacketId.Version)
                    {
                        ParseVersion(reader);
                    }
                    else
                    {
                        NetworkManager.LogError($"Client received an unhandled PacketId of {(ushort)packetId} on channel {channel}. Remaining data has been purged.");
#if DEVELOPMENT
                        NetworkManager.LogError(NetworkManager.PacketIdHistory.GetReceivedPacketIds(packetsFromServer: true));
#endif
                        return;
                    }
                }

#if DEVELOPMENT
                if (print)
                    Debug.Log($"Reader remaining {reader.Remaining}");
#endif
            }

            /* Iterate cache when reader is emptied.
             * This is incase the last packet received
             * was a spawned, which wouldn't trigger
             * the above iteration. There's no harm
             * in doing this check multiple times as there's
             * an exit early check. */
            Objects.IterateObjectCache();
#if !DEVELOPMENT
            }
            catch (Exception e)
            {
                NetworkManagerExtensions.LogError($"Client encountered an error while parsing data for packetId {packetId}. Message: {e.Message}.");
            }
#endif
        }

        /// <summary>
        /// Parses a PingPong packet.
        /// </summary>
        /// <param name="reader"></param>
        private void ParsePingPong(PooledReader reader)
        {
            uint clientTick = reader.ReadTickUnpacked();
            NetworkManager.TimeManager.ModifyPing(clientTick);
        }

        /// <summary>
        /// Parses a Version packet.
        /// </summary>
        /// <param name="reader"></param>
        private void ParseVersion(PooledReader reader)
        {
            IsServerDevelopment = reader.ReadBoolean();
        }

        /// <summary>
        /// Parses a received connectionId. This is received before client receives connection state change.
        /// </summary>
        /// <param name="reader"></param>
        private void ParseAuthenticated(PooledReader reader)
        {
            NetworkManager networkManager = NetworkManager;
            int connectionId = reader.ReadNetworkConnectionId();
            //If only a client then make a new connection.
            if (!networkManager.IsServerStarted)
            {
                Clients.TryGetValueIL2CPP(connectionId, out Connection);
                /* This is bad and should never happen unless the connection is dropping
                 * while receiving authenticated. Would have to be a crazy race condition
                 * but with the network anything is possible. */
                if (Connection == null)
                {
                    NetworkManager.LogWarning($"Client connection could not be found while parsing authenticated status. This usually occurs when the client is receiving a packet immediately before losing connection.");
                    Connection = new(networkManager, connectionId, GetTransportIndex(), false);
                }
            }
            /* If also the server then use the servers connection
             * for the connectionId. This is to resolve host problems
             * where LocalConnection for client differs from the server Connection
             * reference, which results in different field values. */
            else
            {
                if (networkManager.ServerManager.Clients.TryGetValueIL2CPP(connectionId, out NetworkConnection conn))
                {
                    Connection = conn;
                }
                else
                {
                    networkManager.LogError($"Unable to lookup LocalConnection for {connectionId} as host.");
                    Connection = new(networkManager, connectionId, GetTransportIndex(), false);
                }
            }

            //If predicted spawning is enabled also get reserved Ids.
            if (NetworkManager.ServerManager.GetAllowPredictedSpawning())
            {
                int count = (int)reader.ReadSignedPackedWhole();
                Queue<int> q = Connection.PredictedObjectIds;
                for (int i = 0; i < count; i++)
                    q.Enqueue(reader.ReadNetworkObjectId());
            }

            /* Set the TimeManager tick to lastReceivedTick.
             * This still doesn't account for latency but
             * it's the best we can do until the client gets
             * a ping response. */
            if (!networkManager.IsServerStarted)
                networkManager.TimeManager.Tick = networkManager.TimeManager.LastPacketTick.LastRemoteTick;

            //Mark as authenticated.
            Connection.ConnectionAuthenticated();
            OnAuthenticated?.Invoke();
            /* Register scene objects for all scenes
             * after being authenticated. This is done after
             * authentication rather than when the connection
             * is started because if also as server an online
             * scene may already be loaded on server, but not
             * for client. This means the sceneLoaded unity event
             * won't fire, and since client isn't authenticated
             * at the connection start phase objects won't be added. */
            Objects.RegisterAndDespawnSceneObjects();
        }

        /// <summary>
        /// Called when the TimeManager calls OnPostTick.
        /// </summary>
        private void TimeManager_OnPostTick()
        {
            CheckServerTimeout();
        }

        /// <summary>
        /// Checks to timeout client connections.
        /// </summary>
        private void CheckServerTimeout()
        {
            /* Not connected or host. There should be no way
             * for server to drop and client not know about it as host.
             * This would mean a game crash or force close in which
             * the client would be gone as well anyway. */
            if (!Started || NetworkManager.IsServerStarted)
                return;
            if (_remoteServerTimeout == RemoteTimeoutType.Disabled)
                return;
#if DEVELOPMENT
            //If development but not set to development return.
            else if (_remoteServerTimeout != RemoteTimeoutType.Development)
                return;
#endif
            //Wait two timing intervals to give packets a chance to come through.
            if (NetworkManager.SceneManager.IsIteratingQueue(2f))
                return;

            /* ServerManager version only checks every so often
             * to perform iterations over time so the checks are not
             * impactful on the CPU. The client however can check every tick
             * since it's simple math. */
            if (Time.unscaledTime - _lastPacketTime > _remoteServerTimeoutDuration)
            {
                OnClientTimeOut?.Invoke();
                NetworkManager.Log($"Server has timed out. You can modify this feature on the ClientManager component.");
                StopConnection();
            }
        }
    }
}﻿using UnityEngine;

namespace FishNet.Managing.Client
{
    public sealed partial class ClientManager : MonoBehaviour
    {
  
    }


}
﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Managing.Client.Editing
{


    [CustomEditor(typeof(ClientManager), true)]
    [CanEditMultipleObjects]
    public class ClientManagerEditor : Editor
    {
        private SerializedProperty _remoteServerTimeout;
        private SerializedProperty _remoteServerTimeoutDuration;
        private SerializedProperty _changeFrameRate;
        private SerializedProperty _frameRate;

        protected virtual void OnEnable()
        {
            _remoteServerTimeout = serializedObject.FindProperty(nameof(_remoteServerTimeout));
            _remoteServerTimeoutDuration = serializedObject.FindProperty(nameof(_remoteServerTimeoutDuration));
            _changeFrameRate = serializedObject.FindProperty(nameof(_changeFrameRate));
            _frameRate = serializedObject.FindProperty(nameof(_frameRate));
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour((ClientManager)target), typeof(ClientManager), false);
            GUI.enabled = true;

            EditorGUILayout.LabelField("Settings", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;

            EditorGUILayout.PropertyField(_remoteServerTimeout);
            if ((RemoteTimeoutType)_remoteServerTimeout.intValue != RemoteTimeoutType.Disabled)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_remoteServerTimeoutDuration, new GUIContent("Timeout"));
                EditorGUI.indentLevel--;
            }

            EditorGUILayout.PropertyField(_changeFrameRate);
            if (_changeFrameRate.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_frameRate);
                EditorGUI.indentLevel--;
            }

            EditorGUI.indentLevel--;

            serializedObject.ApplyModifiedProperties();
        }

    }
}
#endif﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing.Logging;
using FishNet.Managing.Object;
using FishNet.Managing.Server;
using FishNet.Managing.Utility;
using FishNet.Object;
using FishNet.Object.Helping;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using FishNet.Utility.Performance;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using FishNet.Serializing.Helping;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Client
{
    /// <summary>
    /// Handles objects and information about objects for the local client. See ManagedObjects for inherited options.
    /// </summary>
    public partial class ClientObjects : ManagedObjects
    {
        #region Private.
        /// <summary>
        /// NetworkObjects which are cached to be spawned or despawned.
        /// </summary>
        private ClientObjectCache _objectCache;
        #endregion

        internal ClientObjects(NetworkManager networkManager)
        {
            base.Initialize(networkManager);
            _objectCache = new(this, networkManager);
        }

        /// <summary>
        /// Called when a connection state changes for the local server.
        /// </summary>
        internal void OnServerConnectionState(ServerConnectionStateArgs args)
        {
            //Nothing needs to be done if started.
            if (args.ConnectionState == LocalConnectionState.Started)
                return;

            /* If not started and client is active then deinitialize
             * client objects first. This will let the deinit calls
             * perform before the server destroys them. Ideally this
             * would be done when the user shows intent to shutdown
             * the server, but realistically planning for server socket
             * drops is a much more universal solution.
             *
             * Calling StopConnection on the client will set it's local state
             * to Stopping which will result in a deinit. */

            /* Only perform this step if the transport being stopped
             * is the one which client is connected to. */
            if (NetworkManager.IsClientStarted && args.TransportIndex == base.NetworkManager.ClientManager.GetTransportIndex())
                base.NetworkManager.ClientManager.StopConnection();
        }

        /// <summary>
        /// Called when the connection state changes for the local client.
        /// </summary>
        /// <param name="args"></param>
        internal void OnClientConnectionState(ClientConnectionStateArgs args)
        {
            /* If new state is not started then reset
             * environment. */
            if (args.ConnectionState != LocalConnectionState.Started)
            {
                _objectCache.Reset();

                //If not server then deinitialize normally.
                if (!base.NetworkManager.IsServerStarted)
                {
                    base.DespawnWithoutSynchronization(recursive: true, asServer: false);
                }
                //Otherwise invoke stop callbacks only for client side.
                else
                {
                    foreach (NetworkObject n in Spawned.Values)
                    {
                        if (!n.CanDeinitialize(asServer: false))
                            continue;

                        n.InvokeStopCallbacks(false, true);
                        n.SetInitializedStatus(false, false);
                    }
                }

                /* Clear spawned and scene objects as they will be rebuilt.
                 * Spawned would have already be cleared if DespawnSpawned
                 * was called but it won't hurt anything clearing an empty collection. */
                base.Spawned.Clear();
                base.SceneObjects_Internal.Clear();
            }
        }

        /// <summary>
        /// Called when a scene is loaded.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="arg1"></param>
        [APIExclude]
        protected internal override void SceneManager_sceneLoaded(Scene s, LoadSceneMode arg1)
        {
            base.SceneManager_sceneLoaded(s, arg1);

            if (!base.NetworkManager.IsClientStarted)
                return;
            /* When a scene first loads for a client it should disable
             * all network objects in that scene. The server will send
             * spawn messages once it's aware client has loaded the scene. */
            RegisterAndDespawnSceneObjects(s);
        }

        /// <summary>
        /// Adds a NetworkObject to Spawned.
        /// </summary>
        internal override void AddToSpawned(NetworkObject nob, bool asServer)
        {
            base.AddToSpawned(nob, asServer);
            //If being added as client and is also server.
            if (NetworkManager.IsServerStarted)
                nob.SetRenderersVisible(true);
        }

        /// <summary>
        /// Sends a predicted spawn to the server.
        /// </summary>
        internal void PredictedSpawn(NetworkObject networkObject, NetworkConnection ownerConnection)
        {
            //No more Ids to use.
            Queue<int> predictedObjectIds = NetworkManager.ClientManager.Connection.PredictedObjectIds;
            if (!predictedObjectIds.TryPeek(out int objectId))
            {
                NetworkManager.LogError($"Predicted spawn for object {networkObject.name} failed because no more predicted ObjectIds remain. This usually occurs when the client is spawning excessively before the server can respond. Increasing ReservedObjectIds within the ServerManager component or reducing spawn rate could prevent this problem.");
                StoreNetworkObject();
                return;
            }

            networkObject.InitializePredictedObject_Client(base.NetworkManager, objectId, ownerConnection, base.NetworkManager.ClientManager.Connection);
            NetworkManager.ClientManager.Objects.AddToSpawned(networkObject, false);
            networkObject.Initialize(asServer: false, invokeSyncTypeCallbacks: true);

            PooledWriter writer = WriterPool.Retrieve();
            if (WriteSpawn(networkObject, writer, connection: null))
            {
                base.NetworkManager.TransportManager.SendToServer((byte)Channel.Reliable, writer.GetArraySegment());
                //Also dequeue entry, since we only peeked it earlier.
                predictedObjectIds.Dequeue();
            }
            else
            {
                StoreNetworkObject();
            }

            void StoreNetworkObject()
            {
                networkObject.SetIsDestroying();
                networkObject.Deinitialize(asServer: false);
                
                NetworkManager.StorePooledOrDestroyInstantiated(networkObject, asServer: false);
            }

            writer.Store();
        }

        /// <summary>
        /// Sends a predicted despawn to the server.
        /// </summary>
        internal void PredictedDespawn(NetworkObject networkObject)
        {
            PooledWriter writer = WriterPool.Retrieve();
            WriteDepawn(networkObject, writer);
            base.NetworkManager.TransportManager.SendToServer((byte)Channel.Reliable, writer.GetArraySegment());
            writer.Store();

            base.Despawn(networkObject, networkObject.GetDefaultDespawnType(), asServer: false);
        }

        /// <summary>
        /// Writes a predicted despawn.
        /// </summary>
        public void WriteDepawn(NetworkObject nob, Writer writer)
        {
            writer.WritePacketIdUnpacked(PacketId.ObjectDespawn);
            writer.WriteNetworkObject(nob);
        }

        /// <summary>
        /// Registers NetworkObjects in all scenes and despawns them.
        /// </summary>
        internal void RegisterAndDespawnSceneObjects()
        {
            for (int i = 0; i < SceneManager.sceneCount; i++)
                RegisterAndDespawnSceneObjects(SceneManager.GetSceneAt(i));
        }

        /// <summary>
        /// Adds NetworkObjects within s to SceneObjects, and despawns them.
        /// </summary>
        /// <param name="s"></param>
        private void RegisterAndDespawnSceneObjects(Scene s)
        {
            List<NetworkObject> nobs = CollectionCaches<NetworkObject>.RetrieveList();
            Scenes.GetSceneNetworkObjects(s, false, true, true, ref nobs);

            bool isServerStarted = base.NetworkManager.IsServerStarted;

            int nobsCount = nobs.Count;
            for (int i = 0; i < nobsCount; i++)
            {
                NetworkObject nob = nobs[i];
                if (!nob.IsSceneObject)
                    continue;

                //Only set initialized values if not server, as server would have already done so.
                if (!isServerStarted)
                    nob.SetInitializedValues(parentNob: null, force: false);

                if (nob.GetIsNetworked())
                {
                    base.AddToSceneObjects(nob);
                    //Only run if not also server, as this already ran on server.
                    if (!base.NetworkManager.IsServerStarted)
                        nob.gameObject.SetActive(false);
                }
            }

            CollectionCaches<NetworkObject>.Store(nobs);
        }

        /// <summary>
        /// Called when a NetworkObject runs Deactivate.
        /// </summary>
        /// <param name="nob"></param>
        internal override void NetworkObjectDestroyed(NetworkObject nob, bool asServer)
        {
            nob.RemoveClientRpcLinkIndexes();
            base.NetworkObjectDestroyed(nob, asServer);
        }

        /// <summary>
        /// Parses an OwnershipChange packet.
        /// </summary>
        /// <param name="reader"></param>
        internal void ParseOwnershipChange(PooledReader reader)
        {
            NetworkObject nob = reader.ReadNetworkObject();
            NetworkConnection newOwner = reader.ReadNetworkConnection();
            if (nob != null && nob.IsSpawned)
                nob.GiveOwnership(newOwner, asServer: false, recursive: false);
            else
                NetworkManager.LogWarning($"NetworkBehaviour could not be found when trying to parse OwnershipChange packet.");
        }

        /// <summary>
        /// Parses a received syncVar.
        /// </summary>
        /// <param name="reader"></param>
        internal void ParseSyncType(PooledReader reader, Channel channel)
        {
            //cleanup this is unique to synctypes where length comes first.
            //this will change once I tidy up synctypes.
            ushort packetId = (ushort)PacketId.SyncType;
            NetworkBehaviour nb = reader.ReadNetworkBehaviour();
            int length = (int)ReservedLengthWriter.ReadLength(reader, NetworkBehaviour.SYNCTYPE_RESERVE_BYTES);

            if (nb != null && nb.IsSpawned)
            {
                /* Length of data to be read for syncvars.
                 * This is important because syncvars are never
                 * a set length and data must be read through completion.
                 * The only way to know where completion of syncvar is, versus
                 * when another packet starts is by including the length. */
                if (length > 0)
                    nb.ReadSyncType(reader, length);
            }
            else
            {
                SkipDataLength(packetId, reader, length);
            }
        }

        /// <summary>
        /// Parses a 
        /// </summary>
        /// <param name="reader"></param>
        internal void ParsePredictedSpawnResult(PooledReader reader)
        {
            bool success = reader.ReadBoolean();
            int usedObjectId = reader.ReadNetworkObjectId();
            int nextObjectId = reader.ReadNetworkObjectId();
            if (nextObjectId != NetworkObject.UNSET_OBJECTID_VALUE)
                NetworkManager.ClientManager.Connection.PredictedObjectIds.Enqueue(nextObjectId);

            //Server would not allow the predicted spawn.
            if (!success)
            {
                if (Spawned.TryGetValueIL2CPP(usedObjectId, out NetworkObject nob))
                {
                    //TODO support pooling. This first requires a rework of the initialization / clientHost message system.
                    nob.SetIsDestroying(DespawnType.Destroy);
                    UnityEngine.Object.Destroy(nob.gameObject);
                    //nob.Deinitialize(asServer: false);
                    //NetworkManager.StorePooledInstantiated(nob, false);
                }
            }
        }

        /// <summary>
        /// Parses a ReconcileRpc.
        /// </summary>
        /// <param name="reader"></param>
        internal void ParseReconcileRpc(PooledReader reader, Channel channel)
        {
#if DEVELOPMENT
            NetworkBehaviour.ReadDebugForValidatedRpc(base.NetworkManager, reader, out int readerRemainingAfterLength, out string rpcInformation, out uint expectedReadAmount);
#endif

            NetworkBehaviour nb = reader.ReadNetworkBehaviour();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.Reconcile, reader, channel);

            if (nb != null && nb.IsSpawned)
                nb.OnReconcileRpc(null, reader, channel);
            else
                SkipDataLength((ushort)PacketId.ObserversRpc, reader, dataLength);

#if DEVELOPMENT
            NetworkBehaviour.TryPrintDebugForValidatedRpc(fromRpcLink: false, base.NetworkManager, reader, readerRemainingAfterLength, rpcInformation, expectedReadAmount, channel);
#endif
        }

        /// <summary>
        /// Parses an ObserversRpc.
        /// </summary>
        /// <param name="reader"></param>
        internal void ParseObserversRpc(PooledReader reader, Channel channel)
        {
#if DEVELOPMENT
            NetworkBehaviour.ReadDebugForValidatedRpc(base.NetworkManager, reader, out int startReaderRemaining, out string rpcInformation, out uint expectedReadAmount);
#endif

            NetworkBehaviour nb = reader.ReadNetworkBehaviour(logException: false);
            int dataLength = Packets.GetPacketLength((ushort)PacketId.ObserversRpc, reader, channel);
            if (nb != null && nb.IsSpawned)
            {
                nb.ReadObserversRpc(fromRpcLink: false, methodHash: 0, reader, channel);
            }
            else
            {
                base.NetworkManager.Log($"NetworkBehaviour not found for an ObserverRpc. Rpc data will be discarded.");
                SkipDataLength((ushort)PacketId.ObserversRpc, reader, dataLength);
            }

#if DEVELOPMENT
            NetworkBehaviour.TryPrintDebugForValidatedRpc(fromRpcLink: false, base.NetworkManager, reader, startReaderRemaining, rpcInformation, expectedReadAmount, channel);
#endif
        }

        /// <summary>
        /// Parses a TargetRpc.
        /// </summary>
        /// <param name="reader"></param>
        internal void ParseTargetRpc(PooledReader reader, Channel channel)
        {
#if DEVELOPMENT
            NetworkBehaviour.ReadDebugForValidatedRpc(base.NetworkManager, reader, out int startReaderRemaining, out string rpcInformation, out uint expectedReadAmount);
#endif

            NetworkBehaviour nb = reader.ReadNetworkBehaviour();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.TargetRpc, reader, channel);

            if (nb != null && nb.IsSpawned)
                nb.ReadTargetRpc(fromRpcLink: false, methodHash: 0, reader, channel);
            else
                SkipDataLength((ushort)PacketId.TargetRpc, reader, dataLength);
        }

        /// <summary>
        /// Caches a received spawn to be processed after all spawns and despawns are received for the tick.
        /// </summary>
        internal void ReadSpawn(PooledReader reader)
        {
            SpawnType st = (SpawnType)reader.ReadUInt8Unpacked();

            bool sceneObject = st.FastContains(SpawnType.Scene);

            ReadNestedSpawnIds(reader, st, out byte? nobComponentId, out int? parentObjectId, out byte? parentComponentId, _objectCache.ReadSpawningObjects);

            //NeworkObject and owner information.
            int objectId = reader.ReadNetworkObjectForSpawn(out int initializeOrder, out ushort collectionId);
            int ownerId = reader.ReadNetworkConnectionId();
            //Read transform values which differ from serialized values.
            Vector3? localPosition;
            Quaternion? localRotation;
            Vector3? localScale;
            base.ReadTransformProperties(reader, out localPosition, out localRotation, out localScale);

            int prefabId = 0;
            ulong sceneId = 0;
            string sceneName = string.Empty;
            string objectName = string.Empty;

            if (sceneObject)
            {
                base.ReadSceneObjectId(reader, out sceneId);
#if DEVELOPMENT
                if (NetworkManager.ClientManager.IsServerDevelopment)
                    base.CheckReadSceneObjectDetails(reader, ref sceneName, ref objectName);
#endif
            }
            else
            {
                prefabId = reader.ReadNetworkObjectId();
            }

            ArraySegment<byte> payload = base.ReadPayload(reader);
            ArraySegment<byte> rpcLinks = ReadRpcLinks(reader);
            ArraySegment<byte> syncTypes = ReadSyncTypesForSpawn(reader);

            bool isPredictedSpawner = st.FastContains(SpawnType.IsPredictedSpawner);

            //If found in spawn already.
            if (base.Spawned.TryGetValue(objectId, out NetworkObject nob))
            {
                /* If not server then extra checks must be done. Client should never
                 * receive spawn messages for already spawned objects, unless they locally
                 * predicted spawned the object. */
                if (!base.NetworkManager.IsServerStarted)
                {
                    //Not predicted spawner.
                    if (!st.FastContains(SpawnType.IsPredictedSpawner))
                    {
                        NetworkManager.LogWarning($"Received a spawn objectId of {objectId} which was already found in spawned, and was not predicted. This sometimes may occur on clientHost when the server destroys an object unexpectedly before the clientHost gets the spawn message.");
                    }
                    //Is predicted spawner.
                    else
                    {
                        PooledReader segmentReader = ReaderPool.Retrieve(ArraySegment<byte>.Empty, NetworkManager);

                        //RpcLinks.
                        segmentReader.Initialize(rpcLinks, NetworkManager, Reader.DataSource.Server);
                        ApplyRpcLinks(nob, segmentReader);

                        //Payload.
                        segmentReader.Initialize(payload, NetworkManager, Reader.DataSource.Server);
                        ReadPayload(sender: null, nob, segmentReader, segmentReader.Length);

                        //SyncTypes.
                        segmentReader.Initialize(syncTypes, NetworkManager, Reader.DataSource.Server);
                        ApplySyncTypesForSpawn(nob, segmentReader);
                    }

                    /* Nob isn't added to spawn if predicted spawner.
                     * We only wanted to read and apply initial data from the server. */
                    return;
                }
            }
            else
            {
                /* If predicted spawner and not in spawned then simply exit early.
                 * The predicted spawner destroyed the object locally. */
                if (isPredictedSpawner)
                    return;
            }


            _objectCache.AddSpawn(base.NetworkManager, collectionId, objectId, initializeOrder, ownerId, st, nobComponentId, parentObjectId, parentComponentId, prefabId, localPosition, localRotation, localScale, sceneId, sceneName, objectName, payload, rpcLinks, syncTypes);
        }

        /// <summary>
        /// Caches a received despawn to be processed after all spawns and despawns are received for the tick.
        /// </summary>
        /// <param name="reader"></param>
        internal void CacheDespawn(PooledReader reader)
        {
            DespawnType despawnType;
            int objectId = reader.ReadNetworkObjectForDespawn(out despawnType);
            _objectCache.AddDespawn(objectId, despawnType);
        }

        /// <summary>
        /// Iterates object cache which contains spawn and despawn messages.
        /// Parses the packets within the cache and ensures objects are spawned and despawned before their sync values are applied.
        /// This ensures there is no chance a sync value is referencing a spawned object which does not exist yet due to it normally being spawned later in the cache.
        /// </summary>
        internal void IterateObjectCache()
        {
            _objectCache.Iterate();
        }

        /// <summary>
        /// Gets a nested NetworkObject within it's root.
        /// </summary>
        /// <param name="cnob"></param>
        /// <returns></returns>
        internal NetworkObject GetNestedNetworkObject(CachedNetworkObject cnob)
        {
            NetworkObject rootNob;
            int rootObjectId = cnob.ParentObjectId.Value;
            byte componentIndex = cnob.ComponentId.Value;

            /* Spawns are processed after all spawns come in,
             * this ensures no reference race conditions. Turns out because of this
             * the parentNob may be in cache and not actually spawned, if it was spawned the same packet
             * as this one. So when not found in the spawned collection try to
             * find it in Spawning before throwing. */
            rootNob = _objectCache.GetSpawnedObject(rootObjectId);
            //If still null, that's not good.
            if (rootNob == null)
            {
                //Only log if not clientHost.
                if (!base.NetworkManager.IsServerStarted)
                    NetworkManager.LogError($"Nested spawned object with componentIndex of {componentIndex} and a parentId of {rootObjectId} could not be spawned because parent was not found.");
                return null;
            }

            NetworkObject nob = null;
            List<NetworkObject> childNobs = rootNob.InitializedNestedNetworkObjects;

            //Find nob with component index.
            for (int i = 0; i < childNobs.Count; i++)
            {
                if (childNobs[i].ComponentIndex == componentIndex)
                {
                    nob = childNobs[i];
                    break;
                }
            }

            //If child nob was not found.
            if (nob == null)
            {
                //Only log if not clientHost.
                if (!base.NetworkManager.IsServerStarted)
                    NetworkManager.LogError($"Nested spawned object with componentIndex of {componentIndex} could not be found as a child NetworkObject of {rootNob.name}.");
                return null;
            }

            return nob;
        }

        /// <summary>
        /// Applies RPCLinks to a NetworkObject.
        /// This method will exit early if reader is null.
        /// </summary>
        internal void ApplyRpcLinks(NetworkObject nob, PooledReader reader)
        {
            if (reader == null)
                return;

            List<ushort> rpcLinkIndexes = new();

            while (reader.Remaining > 0)
            {
                byte componentId = reader.ReadNetworkBehaviourId();
                ushort count = reader.ReadUInt16Unpacked();

                for (int i = 0; i < count; i++)
                {
                    //Index of RpcLink.
                    ushort linkIndex = reader.ReadUInt16Unpacked();
                    RpcLink link = new(nob.ObjectId, componentId,
                        //RpcHash.
                        reader.ReadUInt16Unpacked(),
                        //packetId for rpc.
                        reader.ReadPacketId());
                    //Add to links.
                    SetRpcLink(linkIndex, link);
                    rpcLinkIndexes.Add(linkIndex);
                }
            }

            nob.SetRpcLinkIndexes(rpcLinkIndexes);
        }

        /// <summary>
        /// Applies initial SyncTypes to a NetworkObject.
        /// A null reader will exit the method early.
        /// </summary>
        internal void ApplySyncTypesForSpawn(NetworkObject nob, PooledReader reader)
        {
            if (reader == null)
                return;
            /* Apply syncTypes. It's very important to do this after all
             * spawns have been processed and added to the manager.Objects collection.
             * Otherwise, the synctype may reference an object spawning the same tick
             * and the result would be null due to said object not being in spawned.
             *
             * At this time the NetworkObject is not initialized so by calling
             * OnSyncType the changes are cached to invoke callbacks after initialization,
             * not during the time of this action. */
            List<NetworkBehaviour> behaviours = nob.NetworkBehaviours;

            while (reader.Remaining > 0)
            {
                byte behaviourId = reader.ReadUInt8Unpacked();
                behaviours[behaviourId].ReadSyncTypesForSpawn(reader);
            }
        }

        /// <summary>
        /// Instantiates a NetworkObject if required and sets transform values.
        /// </summary>
        internal NetworkObject GetInstantiatedNetworkObject(CachedNetworkObject cnob)
        {
            if (cnob.PrefabId == null)
            {
                NetworkManager.LogError($"PrefabId for {cnob.ObjectId} is null. Object will not spawn.");
                return null;
            }

            NetworkManager networkManager = base.NetworkManager;
            int prefabId = cnob.PrefabId.Value;
            NetworkObject result;

            if (prefabId == NetworkObject.UNSET_OBJECTID_VALUE)
            {
                NetworkManager.LogError($"Spawned object has an invalid prefabId. Make sure all objects which are being spawned over the network are within SpawnableObjects on the NetworkManager.");
                return null;
            }

            ushort collectionId = cnob.CollectionId;
            //PrefabObjects to get the prefab from.
            PrefabObjects prefabObjects = networkManager.GetPrefabObjects<PrefabObjects>(collectionId, false);
            //Not found for collectionId > 0. This means the user likely did not setup the collection on client.
            if (prefabObjects == null && collectionId > 0)
            {
                networkManager.LogError($"PrefabObjects collection is not found for CollectionId {collectionId}. Be sure to add your addressables NetworkObject prefabs to the collection on server and client before attempting to spawn them over the network.");
                return null;
            }

            //Only instantiate if not host.
            if (!networkManager.IsHostStarted)
            {
                Transform parentTransform = null;
                //Set parentTransform if there's a parent object.
                if (cnob.HasParent)
                {
                    int objectId = cnob.ParentObjectId.Value;
                    NetworkObject nob = _objectCache.GetSpawnedObject(objectId);

                    if (nob == null)
                    {
                        NetworkObject prefab = prefabObjects.GetObject(false, prefabId);
                        networkManager.LogError($"NetworkObject not found for ObjectId {objectId}. Prefab {prefab.name} will be instantiated without parent synchronization.");
                    }
                    else
                    {
                        byte componentIndex = cnob.ComponentId.Value;
                        NetworkBehaviour nb = nob.GetNetworkBehaviour(componentIndex, false);
                        if (nb != null)
                        {
                            parentTransform = nb.transform;
                        }
                        else
                        {
                            NetworkObject prefab = prefabObjects.GetObject(false, prefabId);
                            networkManager.LogError($"NetworkBehaviour on index {componentIndex} could not be found within NetworkObject {nob.name} with ObjectId {objectId}. Prefab {prefab.name} will be instantiated without parent synchronization.");
                        }
                    }
                }

                ObjectPoolRetrieveOption retrieveOptions = (ObjectPoolRetrieveOption.MakeActive | ObjectPoolRetrieveOption.LocalSpace);
                result = networkManager.GetPooledInstantiated(prefabId, collectionId, retrieveOptions, parentTransform, cnob.Position, cnob.Rotation, cnob.Scale, asServer: false);

                //Only need to set IsGlobal also if not host.
                bool isGlobal = cnob.SpawnType.FastContains(SpawnType.InstantiatedGlobal);
                result.SetIsGlobal(isGlobal);
            }
            //If host then find server instantiated object.
            else
            {
                ServerObjects so = networkManager.ServerManager.Objects;
                if (!so.Spawned.TryGetValueIL2CPP(cnob.ObjectId, out result))
                    result = so.GetFromPending(cnob.ObjectId);

                if (result == null)
                    networkManager.LogWarning($"ObjectId {cnob.ObjectId} could not be found in Server spawned, nor Server pending despawn. This may occur as clientHost when objects are destroyed before the client receives a despawn packet. In most cases this may be ignored.");
            }

            return result;
        }

        /// <summary>
        /// Gets a NetworkObject from Spawned, or object cache.
        /// </summary>
        /// <param name="cnob"></param>
        /// <returns></returns>
        internal NetworkObject GetSpawnedNetworkObject(CachedNetworkObject cnob)
        {
            NetworkObject nob;
            //Try checking already spawned objects first.
            if (base.Spawned.TryGetValueIL2CPP(cnob.ObjectId, out nob))
            {
                return nob;
            }
            /* If not found in already spawned objects see if
             * the networkObject is in the objectCache. It's possible the despawn
             * came immediately or shortly after the spawn message, before
             * the object has been initialized. */
            else
            {
                nob = _objectCache.GetInCached(cnob.ObjectId, ClientObjectCache.CacheSearchType.Any);
                /* Nob may be null if it's a child object being despawned, and the
                 * parent despawn already occurred. */
                return nob;
            }
        }
    }
}﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif

using FishNet.Managing.Object;
using FishNet.Managing.Utility;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using FishNet.Serializing.Helping;

namespace FishNet.Managing.Client
{
    /// <summary>
    /// Handles objects and information about objects for the local client. See ManagedObjects for inherited options.
    /// </summary>
    public partial class ClientObjects : ManagedObjects
    {
        #region Private.
        /// <summary>
        /// RPCLinks of currently spawned objects.
        /// </summary>
        private Dictionary<ushort, RpcLink> _rpcLinks = new();
        #endregion

        /// <summary>
        /// Parses a received RPCLink.
        /// </summary>
        /// <param name="reader"></param>
        /// <param name="index"></param>
        internal void ParseRpcLink(PooledReader reader, ushort index, Channel channel)
        {
#if DEVELOPMENT
            NetworkBehaviour.ReadDebugForValidatedRpc(base.NetworkManager, reader, out int startReaderRemaining, out string rpcInformation, out uint expectedReadAmount);
#endif

            int dataLength;
            //Link index isn't stored.
            if (!_rpcLinks.TryGetValueIL2CPP(index, out RpcLink link))
            {
                dataLength = Packets.GetPacketLength(ushort.MaxValue, reader, channel);
                SkipDataLength(index, reader, dataLength);
            }
            //Found NetworkObject for link.
            else if (Spawned.TryGetValueIL2CPP(link.ObjectId, out NetworkObject nob))
            {
                //Still call GetPacketLength to remove any extra bytes at the front of the reader.
                NetworkBehaviour nb = nob.NetworkBehaviours[link.ComponentIndex];
                if (link.RpcPacketId == PacketId.TargetRpc)
                {
                    Packets.GetPacketLength((ushort)PacketId.TargetRpc, reader, channel);
                    nb.ReadTargetRpc(fromRpcLink: true, link.RpcHash, reader, channel);
                }
                else if (link.RpcPacketId == PacketId.ObserversRpc)
                {
                    Packets.GetPacketLength((ushort)PacketId.ObserversRpc, reader, channel);
                    nb.ReadObserversRpc(fromRpcLink: true, link.RpcHash, reader, channel);
                }
                else if (link.RpcPacketId == PacketId.Reconcile)
                {
                    Packets.GetPacketLength((ushort)PacketId.Reconcile, reader, channel);
                    nb.OnReconcileRpc(link.RpcHash, reader, channel);
                }
            }
            //Could not find NetworkObject.
            else
            {
                dataLength = Packets.GetPacketLength(index, reader, channel);
                SkipDataLength(index, reader, dataLength, link.ObjectId);
            }

#if DEVELOPMENT
            NetworkBehaviour.TryPrintDebugForValidatedRpc(fromRpcLink: true, base.NetworkManager, reader, startReaderRemaining, rpcInformation, expectedReadAmount, channel);
#endif
        }

        /// <summary>
        /// Sets link to rpcLinks key linkIndex.
        /// </summary>
        /// <param name="linkIndex"></param>
        /// <param name="link"></param>
        internal void SetRpcLink(ushort linkIndex, RpcLink link)
        {
            _rpcLinks[linkIndex] = link;
        }

        /// <summary>
        /// Removes link index keys from rpcLinks.
        /// </summary>
        internal void RemoveLinkIndexes(List<ushort> values)
        {
            if (values == null)
                return;

            for (int i = 0; i < values.Count; i++)
                _rpcLinks.Remove(values[i]);
        }
    }
}﻿using FishNet.Connection;
using FishNet.Managing.Object;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Utility.Extension;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Scripting;

namespace FishNet.Managing.Client
{
    /// <summary>
    /// Information about cached network objects.
    /// </summary>
    internal class ClientObjectCache
    {
        #region Types.
        public enum CacheSearchType
        {
            Any = 0,
            Spawning = 1,
            Despawning = 2
        }
        #endregion

        #region Internal.
        /// <summary>
        /// Objects which are being spawned during iteration.
        /// </summary>
        internal Dictionary<int, NetworkObject> IteratedSpawningObjects = new();
        /// <summary>
        /// ObjectIds which have been read this tick.
        /// </summary>
        internal HashSet<int> ReadSpawningObjects = new();
        #endregion

        #region Private.
        /// <summary>
        /// Cached objects buffer. Contains spawns and despawns.
        /// </summary>
        private List<CachedNetworkObject> _cachedObjects = new();
        /// <summary>
        /// NetworkObjects which have been spawned already during the current iteration.
        /// </summary>
        private HashSet<NetworkObject> _iteratedSpawns = new();
        /// <summary>
        /// Despawns which are occurring the same tick as their spawn.
        /// </summary>
        private HashSet<int> _conflictingDespawns = new();
        /// <summary>
        /// ClientObjects reference.
        /// </summary>
        private ClientObjects _clientObjects;
        /// <summary>
        /// NetworkManager for this cache.
        /// </summary>
        private NetworkManager _networkManager;
        // /// <summary>
        // /// True if logged the warning about despawning on the same tick as the spawn.
        // /// This exist to prevent excessive spam of the warning.
        // /// </summary>
        // private bool _loggedSameTickWarning;
        /// <summary>
        /// True if initializeOrder was not default for any spawned objects.
        /// </summary>
        private bool _initializeOrderChanged;
        #endregion

        public ClientObjectCache(ClientObjects cobs, NetworkManager networkManager)
        {
            _clientObjects = cobs;
            _networkManager = networkManager;
        }

        /// <summary>
        /// Returns a NetworkObject found in spawned cache using objectId.
        /// </summary>
        /// <param name="objectId"></param>
        /// <returns></returns>
        public NetworkObject GetInCached(int objectId, CacheSearchType searchType)
        {
            int count = _cachedObjects.Count;
            List<CachedNetworkObject> collection = _cachedObjects;
            for (int i = 0; i < count; i++)
            {
                CachedNetworkObject cnob = collection[i];
                if (cnob.ObjectId == objectId)
                {
                    //Any condition always returns.
                    if (searchType == CacheSearchType.Any)
                        return cnob.NetworkObject;

                    bool spawning = (searchType == CacheSearchType.Spawning);
                    bool spawnAction = (cnob.Action == CachedNetworkObject.ActionType.Spawn);
                    if (spawning == spawnAction)
                        return cnob.NetworkObject;
                    else
                        return null;
                }
            }

            //Fall through.
            return null;
        }

        /// <summary>
        /// Initializes for a spawned NetworkObject.
        /// </summary>
        public void AddSpawn(NetworkManager manager, ushort collectionId, int objectId, int initializeOrder, int ownerId, SpawnType ost, byte? nobComponentId, int? parentObjectId, byte? parentComponentId, int? prefabId, Vector3? localPosition, Quaternion? localRotation, Vector3? localScale, ulong sceneId, string sceneName, string objectName, ArraySegment<byte> payload, ArraySegment<byte> rpcLinks, ArraySegment<byte> syncValues)
        {
            //Set if initialization order has changed.
            _initializeOrderChanged |= (initializeOrder != 0);

            CachedNetworkObject cnob = null;
            //If order has not changed then add normally.
            if (!_initializeOrderChanged)
            {
                cnob = ResettableObjectCaches<CachedNetworkObject>.Retrieve();
                _cachedObjects.Add(cnob);
            }
            //Otherwise see if values need to be sorted.
            else
            {
                /* Spawns will be ordered at the end of their nearest order.
                 * If spawns arrived with Id order of 5, 7, 2 then the result
                 * would be as shown below...
                 * Id 5 / order -5
                 * Id 7 / order -5
                 * Id 2 / order 0
                 * Not as if the values were inserted first such as...
                 * Id 7 / order -5
                 * Id 5 / order -5
                 * Id 2 / order 0
                 * This is to prevent the likeliness of child nobs being out of order
                 * as well to preserve user spawn order if they spawned multiple
                 * objects the same which, with the same order. */

                int written = _cachedObjects.Count;
                for (int i = 0; i < written; i++)
                {
                    CachedNetworkObject item = _cachedObjects[i];
                    /* If item order is larger then that means
                     * initializeOrder has reached the last entry
                     * of its value. Insert just before item index. */
                    if (initializeOrder < item.InitializeOrder)
                    {
                        cnob = ResettableObjectCaches<CachedNetworkObject>.Retrieve();
                        _cachedObjects.Insert(i, cnob);
                        break;
                    }
                }

                //If here and cnob is null then it was not inserted; add to end.
                if (cnob == null)
                {
                    cnob = ResettableObjectCaches<CachedNetworkObject>.Retrieve();
                    _cachedObjects.Add(cnob);
                }
            }

            cnob.InitializeSpawn(manager, collectionId, objectId, initializeOrder, ownerId, ost, nobComponentId, parentObjectId, parentComponentId, prefabId, localPosition, localRotation, localScale, sceneId, sceneName, objectName, payload, rpcLinks, syncValues);

            ReadSpawningObjects.Add(objectId);
        }

        public void AddDespawn(int objectId, DespawnType despawnType)
        {
            CachedNetworkObject cnob = ResettableObjectCaches<CachedNetworkObject>.Retrieve();
            _cachedObjects.Add(cnob);
            cnob.InitializeDespawn(objectId, despawnType);
        }

        /// <summary>
        /// Iterates any written objects.
        /// </summary>
        public void Iterate()
        {
            int written = _cachedObjects.Count;
            if (written == 0)
                return;

            try
            {
                //Indexes which have already been processed.
                HashSet<int> processedIndexes = new();
                List<CachedNetworkObject> collection = _cachedObjects;
                _conflictingDespawns.Clear();
                /* The next iteration will set rpclinks,
                 * synctypes, and so on. */
                for (int i = 0; i < written; i++)
                {
                    /* An index may already be processed if it was pushed ahead.
                     * This can occur if a nested object spawn exists but the root
                     * object has not spawned yet. In this situation the root spawn is
                     * found and performed first. */
                    if (processedIndexes.Contains(i))
                        continue;
                    CachedNetworkObject cnob = collection[i];
                    bool spawn = (cnob.Action == CachedNetworkObject.ActionType.Spawn);

                    /* See if nested, and if so check if root is already spawned.
                     * If parent is not spawned then find it and process the parent first. */
                    if (spawn)
                    {
                        /* When an object is nested or has a parent it is
                         * dependent upon either the root of nested, or the parent,
                         * being spawned to setup properly.
                         *
                         * When either of these are true check spawned objects first
                         * to see if the objects exist. If not check if they are appearing
                         * later in the cache. Root or parent objects can appear later
                         * in the cache depending on the order of which observers are rebuilt.
                         * While it is possible to have the server ensure spawns always send
                         * root/parents first, that's a giant can of worms that's not worth getting into.
                         * Not only are there many scenarios to cover, but it also puts more work
                         * on the server. It's more effective to have the client handle the sorting. */

                        //Nested.
                        if (cnob.HasParent)
                        {
                            bool nested = cnob.IsInitializedNested;
                            //It's not possible to be nested and have a parent. Set the Id to look for based on if nested or parented.
                            int targetObjectId = cnob.ParentObjectId.Value;
                            NetworkObject nob = GetSpawnedObject(targetObjectId);
                            //If not spawned yet.
                            if (nob == null)
                            {
                                bool isClientHost = _networkManager.IsServerStarted;

                                bool found = false;
                                string errMsg;
                                for (int z = (i + 1); z < written; z++)
                                {
                                    CachedNetworkObject zCnob = collection[z];
                                    if (zCnob.ObjectId == targetObjectId)
                                    {
                                        found = true;
                                        if (cnob.Action != CachedNetworkObject.ActionType.Spawn)
                                        {
                                            if (!isClientHost)
                                            {
                                                errMsg = (nested) ? $"ObjectId {targetObjectId} was found for a nested spawn, but ActionType is not spawn. ComponentIndex {cnob.ComponentId} will not be spawned." : $"ObjectId {targetObjectId} was found for a parented spawn, but ActionType is not spawn. ObjectId {cnob.ObjectId} will not be spawned.";
                                                _networkManager.LogError(errMsg);
                                            }
                                            break;
                                        }
                                        else
                                        {
                                            ProcessObject(zCnob, true, z);
                                            break;
                                        }
                                    }
                                }

                                //Root nob could not be found. Only log if not clientHost.
                                if (!found)
                                {
                                    if (!isClientHost)
                                    {
                                        errMsg = (nested) ? $"ObjectId {targetObjectId} could not be found for a nested spawn. ComponentIndex {cnob.ComponentId} will not be spawned." : $"ObjectId {targetObjectId} was found for a parented spawn. ObjectId {cnob.ObjectId} will not be spawned.";
                                        _networkManager.LogError(errMsg);
                                    }
                                }
                            }
                        }
                    }

                    ProcessObject(cnob, spawn, i);
                }

                void ProcessObject(CachedNetworkObject cnob, bool spawn, int index)
                {
                    processedIndexes.Add(index);

                    /* If the NetworkObject is null on lookup then something happened in the retrieval. Exit early.
                     * This can be normal on clientHost when client side gets packets late. When
                     * clientHost this will fail silently.*/

                    if (spawn)
                    {
                        if (cnob.IsSceneObject)
                        {
                            cnob.NetworkObject = _clientObjects.GetSceneNetworkObject(cnob.SceneId, cnob.SceneName, cnob.ObjectName);
                            if (cnob.NetworkObject != null)
                                SetParentAndTransformProperties(cnob);
                        }
                        //Is nested in a prefab.
                        else if (cnob.IsInitializedNested)
                        {
                            cnob.NetworkObject = _clientObjects.GetNestedNetworkObject(cnob);
                            if (cnob.NetworkObject != null)
                                cnob.NetworkObject.transform.SetLocalPositionRotationAndScale(cnob.Position, cnob.Rotation, cnob.Scale);
                        }
                        /* Not sceneObject or initializedNested. Could still be runtime
                         * nested but this also requires instantiation. The instantiation process
                         * handles parenting and position. */
                        else
                        {
                            cnob.NetworkObject = _clientObjects.GetInstantiatedNetworkObject(cnob);
                            //Parenting and transform is done during the instantiation process.
                        }
                    }
                    //Despawn.
                    else
                    {
                        cnob.NetworkObject = _clientObjects.GetSpawnedNetworkObject(cnob);

                        /* //TODO cache recent predicted despawns for up to a few seconds.
                         * If not found and the Id is in recently predicted despawned then simply
                         * do nothing. Otherwise log missing Id. */
                        // /* Do not log unless not nested. Nested nobs sometimes
                        //  * could be destroyed if parent was first. */
                        // if (!_networkManager.IsHostStarted && cnob.NetworkObject == null && !cnob.IsInitializedNested)
                        //     _networkManager.Log($"NetworkObject for ObjectId of {cnob.ObjectId} was found null. Unable to despawn object. This may occur if a nested NetworkObject had it's parent object unexpectedly destroyed. This incident is often safe to ignore.");
                    }

                    NetworkObject nob = cnob.NetworkObject;
                    //No need to error here, the other Gets above would have.
                    if (nob == null)
                        return;

                    if (spawn)
                    {
                        NetworkConnection owner;
                        int objectId;
                        //If not server then initialize by using lookups.
                        if (!_networkManager.IsServerStarted)
                        {
                            objectId = cnob.ObjectId;
                            int ownerId = cnob.OwnerId;
                            //If local client is owner then use localconnection reference.
                            NetworkConnection localConnection = _networkManager.ClientManager.Connection;
                            //If owner is self.
                            if (ownerId == localConnection.ClientId)
                            {
                                owner = localConnection;
                            }
                            else
                            {
                                /* If owner cannot be found then share owners
                                 * is disabled */
                                if (!_networkManager.ClientManager.Clients.TryGetValueIL2CPP(ownerId, out owner))
                                    owner = NetworkManager.EmptyConnection;
                            }
                        }
                        //Otherwise initialize using server values.
                        else
                        {
                            owner = nob.Owner;
                            objectId = nob.ObjectId;
                        }

                        //Preinitialize client side.
                        nob.InitializeEarly(_networkManager, objectId, owner, false);
                        //Read payload.
                        if (cnob.PayloadReader != null)
                            _networkManager.ClientManager.Objects.ReadPayload(NetworkManager.EmptyConnection, nob, cnob.PayloadReader, cnob.PayloadReader.Length);

                        _clientObjects.AddToSpawned(cnob.NetworkObject, false);
                        IteratedSpawningObjects.Add(cnob.ObjectId, cnob.NetworkObject);
                        /* Fixes https://github.com/FirstGearGames/FishNet/issues/323
                         * The redundancy may have been caused by a rework. It would seem
                         * IterateSpawn was always running after the above lines, and not
                         * from anywhere else. So there's no reason we cannot inline it
                         * here. */
                        _clientObjects.ApplyRpcLinks(cnob.NetworkObject, cnob.RpcLinkReader);
                        //IterateSpawn(cnob);
                        _iteratedSpawns.Add(cnob.NetworkObject);

                        /* Enable networkObject here if client only.
                         * This is to ensure Awake fires in the same order
                         * as InitializeOrder settings. There is no need
                         * to perform this action if server because server
                         * would have already spawned in order. */
                        if (!_networkManager.IsServerStarted && cnob.NetworkObject != null)
                            cnob.NetworkObject.gameObject.SetActive(true);
                    }
                    else
                    {
                        /* If spawned already this iteration then the nob
                         * must be initialized so that the start/stop cycles
                         * complete normally. Otherwise, the despawn callbacks will
                         * fire immediately while the start callbacks will run after all
                         * spawns have been iterated.
                         * The downside to this is that synctypes
                         * for spawns later in this iteration will not be initialized
                         * yet, and if the nob being spawned/despawned references
                         * those synctypes the values will be default.
                         *
                         * The alternative is to delay the despawning until after
                         * all spawns are iterated, but that will break the order
                         * reliability. This is unfortunately a lose/lose situation so
                         * the best we can do is let the user know the risk. */
                        NetworkObject n = cnob.NetworkObject;
                        if (_iteratedSpawns.Contains(n))
                        {
                            // if (!_loggedSameTickWarning)
                            // {
                            //     _loggedSameTickWarning = true;
                            //     _networkManager.LogWarning($"NetworkObject {cnob.NetworkObject.name} is being despawned on the same tick it's spawned." +
                            //                    $" When this occurs SyncTypes will not be set on other objects during the time of this despawn." +
                            //                    $" In result, if NetworkObject {cnob.NetworkObject.name} is referencing a SyncType of another object being spawned this tick, the returned values will be default.");
                            // }

                            _conflictingDespawns.Add(cnob.ObjectId);
                            n.gameObject.SetActive(true);
                            n.Initialize(false, true);
                        }

                        //Now being initialized, despawn the object.
                        IterateDespawn(cnob);
                    }
                }

                /* Activate the objects after all data
                 * has been synchronized. This will apply synctypes. */
                for (int i = 0; i < written; i++)
                {
                    CachedNetworkObject cnob = collection[i];
                    if (cnob.Action == CachedNetworkObject.ActionType.Spawn && cnob.NetworkObject != null)
                    {
                        _clientObjects.ApplySyncTypesForSpawn(cnob.NetworkObject, cnob.SyncTypesReader);

                        /* Only continue with the initialization if it wasn't initialized
                         * early to prevent a despawn conflict. */
                        bool canInitialize = (!_conflictingDespawns.Contains(cnob.ObjectId) || !_iteratedSpawns.Contains(cnob.NetworkObject));
                        if (canInitialize)
                            cnob.NetworkObject.Initialize(false, false);
                    }
                }

                //Invoke synctype callbacks.
                for (int i = 0; i < written; i++)
                {
                    CachedNetworkObject cnob = collection[i];
                    if (cnob.Action == CachedNetworkObject.ActionType.Spawn && cnob.NetworkObject != null)
                        cnob.NetworkObject.InvokeOnStartSyncTypeCallbacks(false);
                }
            }
            finally
            {
                //Once all have been iterated reset.
                Reset();
            }
        }

        /// <summary>
        /// Sets parent using information on a CachedNetworkObject then applies transform properties.
        /// </summary>
        /// <param name="cnob"></param>
        private void SetParentAndTransformProperties(CachedNetworkObject cnob)
        {
            if (!_networkManager.IsHostStarted && cnob.NetworkObject != null)
            {
                //Apply runtime parent if needed.
                if (cnob.HasParent)
                {
                    if (_networkManager.ClientManager.Objects.Spawned.TryGetValueIL2CPP(cnob.ParentObjectId.Value, out NetworkObject parentNob))
                    {
                        //If parented to the NOB directly.
                        if (!cnob.ParentComponentId.HasValue)
                            cnob.NetworkObject.SetParent(parentNob);
                        //Parented to a NB.
                        else
                            cnob.NetworkObject.SetParent(parentNob.NetworkBehaviours[cnob.ParentComponentId.Value]);
                    }
                    else
                    {
                        _networkManager.Log($"Parent NetworkObject Id {cnob.ParentObjectId} could not be found in spawned. NetworkObject {cnob.NetworkObject} will not have it's parent set.");
                    }

                    //cnob.NetworkObject.transform.SetLocalPositionRotationAndScale(cnob.Position, cnob.Rotation, cnob.Scale);
                }

                // else
                // {
                //     cnob.NetworkObject.transform.SetWorldPositionRotationAndScale(cnob.Position, cnob.Rotation, cnob.Scale);
                // }
                cnob.NetworkObject.transform.SetLocalPositionRotationAndScale(cnob.Position, cnob.Rotation, cnob.Scale);
            }
        }

        /// <summary>
        /// Deinitializes an object on clients and despawns the NetworkObject.
        /// </summary>
        /// <param name="cnob"></param>
        private void IterateDespawn(CachedNetworkObject cnob)
        {
            _clientObjects.Despawn(cnob.NetworkObject, cnob.DespawnType, false);
        }

        /// <summary>
        /// Returns a NetworkObject found in spawn cache, or Spawned.
        /// </summary>
        /// <param name="objectId"></param>
        internal NetworkObject GetSpawnedObject(int objectId)
        {
            NetworkObject result;
            //If not found in Spawning then check Spawned.
            if (!IteratedSpawningObjects.TryGetValue(objectId, out result))
            {
                Dictionary<int, NetworkObject> spawned = (_networkManager.IsHostStarted) ? _networkManager.ServerManager.Objects.Spawned : _networkManager.ClientManager.Objects.Spawned;
                spawned.TryGetValue(objectId, out result);
            }

            return result;
        }

        /// <summary>
        /// Resets cache.
        /// </summary>
        public void Reset()
        {
            _initializeOrderChanged = false;
            foreach (CachedNetworkObject item in _cachedObjects)
                ResettableObjectCaches<CachedNetworkObject>.Store(item);

            _cachedObjects.Clear();
            _iteratedSpawns.Clear();
            IteratedSpawningObjects.Clear();
            ReadSpawningObjects.Clear();
        }
    }

    /// <summary>
    /// A cached network object which exist in world but has not been Initialized yet.
    /// </summary>
    [Preserve]
    internal class CachedNetworkObject : IResettable
    {
        #region Types.
        public enum ActionType
        {
            Unset = 0,
            Spawn = 1,
            Despawn = 2,
        }
        #endregion

        /// <summary>
        /// True if cached object is nested during initialization.
        /// </summary>
        public bool IsInitializedNested => (ComponentId > 0);

        /// <summary>
        /// True if a scene object.
        /// </summary>
        public bool IsSceneObject => (SceneId != NetworkObject.UNSET_SCENEID_VALUE);

        /// <summary>
        /// True if this object has a parent.
        /// </summary>
        public bool HasParent => (ParentObjectId != null && ParentComponentId != null);

        public ushort CollectionId;
        public int ObjectId;
        public int InitializeOrder;
        public int OwnerId;
        public SpawnType SpawnType;
        public DespawnType DespawnType;
        public byte? ComponentId;
        public int? ParentObjectId;
        public byte? ParentComponentId;
        public int? PrefabId;
        public Vector3? Position;
        public Quaternion? Rotation;
        public Vector3? Scale;
        public ulong SceneId;
        public string SceneName = string.Empty;
        public string ObjectName = string.Empty;

        /// <summary>
        /// True if spawning.
        /// </summary>
        public ActionType Action { get; private set; }

        /// <summary>
        /// Cached NetworkObject.
        /// </summary>
#pragma warning disable 0649
        public NetworkObject NetworkObject;
        /// <summary>
        /// Reader containing payload for the NetworkObject behaviours.
        /// </summary>
        public PooledReader PayloadReader;
        /// <summary>
        /// Reader containing rpc links for the NetworkObject.
        /// </summary>
        public PooledReader RpcLinkReader;
        /// <summary>
        /// Reader containing sync values for the NetworkObject.
        /// </summary>
        public PooledReader SyncTypesReader;
#pragma warning restore 0649

        public void InitializeSpawn(NetworkManager manager, ushort collectionId, int objectId, int initializeOrder, int ownerId, SpawnType objectSpawnType, byte? nobComponentId, int? parentObjectId, byte? parentComponentId, int? prefabId, Vector3? position, Quaternion? rotation, Vector3? scale, ulong sceneId, string sceneName, string objectName, ArraySegment<byte> payload, ArraySegment<byte> rpcLinks, ArraySegment<byte> syncTypes)
        {
            ResetState();
            Action = ActionType.Spawn;
            CollectionId = collectionId;
            ObjectId = objectId;
            InitializeOrder = initializeOrder;
            OwnerId = ownerId;
            SpawnType = objectSpawnType;
            ComponentId = nobComponentId;
            ParentObjectId = parentObjectId;
            ParentComponentId = parentComponentId;
            PrefabId = prefabId;
            Position = position;
            Rotation = rotation;
            Scale = scale;
            SceneId = sceneId;
            SceneName = sceneName;
            ObjectName = objectName;

            if (payload.Count > 0)
                PayloadReader = ReaderPool.Retrieve(payload, manager);
            if (rpcLinks.Count > 0)
                RpcLinkReader = ReaderPool.Retrieve(rpcLinks, manager);
            if (syncTypes.Count > 0)
                SyncTypesReader = ReaderPool.Retrieve(syncTypes, manager);
        }

        /// <summary>
        /// Initializes for a despawned NetworkObject.
        /// </summary>
        /// <param name="nob"></param>
        public void InitializeDespawn(int objectId, DespawnType despawnType)
        {
            ResetState();
            Action = ActionType.Despawn;
            DespawnType = despawnType;
            ObjectId = objectId;
        }

        /// <summary>
        /// Resets values which could malform identify the cached object.
        /// </summary>
        public void ResetState()
        {
            SceneName = string.Empty;
            ObjectName = string.Empty;
            NetworkObject = null;

            ReaderPool.StoreAndDefault(ref PayloadReader);
            ReaderPool.StoreAndDefault(ref RpcLinkReader);
            ReaderPool.StoreAndDefault(ref SyncTypesReader);
        }

        public void InitializeState() { }

        ~CachedNetworkObject()
        {
            NetworkObject = null;
        }
    }
}﻿using UnityEngine;

namespace FishNet.Managing.Debugging
{
    /// <summary>
    /// A container for debugging.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/DebugManager")]
    public class DebugManager : MonoBehaviour
    {
        /// <summary>
        /// True to write additional information about scene objects being sent in spawn messages. This is primarily used to resolve sceneId not found errors.
        /// </summary>
        [Tooltip("True to write additional information about scene objects being sent in spawn messages. This is primarily used to resolve sceneId not found errors.")]
        public bool WriteSceneObjectDetails;
        /// <summary>
        /// True to validate written versus read length of Rpcs. Errors will be thrown if read length is not equal to written length.
        /// </summary>
        [Tooltip("True to validate written versus read length of Rpcs. Errors will be thrown if read length is not equal to written length.")]
        public bool ValidateRpcLengths;
        /// <summary>
        /// True to disable RpcLinks for Observer RPCs.
        /// </summary>
        [Tooltip("True to disable RpcLinks for Observer RPCs.")]
        public bool DisableObserversRpcLinks;
        /// <summary>
        /// True to disable RpcLinks for Target RPCs.
        /// </summary>
        [Tooltip("True to disable RpcLinks for Target RPCs.")]
        public bool DisableTargetRpcLinks;
        /// <summary>
        /// True to disable RpcLinks for Server RPCs.
        /// </summary>
        [Tooltip("True to disable RpcLinks for Server RPCs.")]
        public bool DisableServerRpcLinks;
        /// <summary>
        /// True to disable RpcLinks for Replicate RPCs.
        /// </summary>
        [Tooltip("True to disable RpcLinks for Replicate RPCs.")]
        public bool DisableReplicateRpcLinks;
        /// <summary>
        /// True to disable RpcLinks for Reconcile RPCs.
        /// </summary>
        [Tooltip("True to disable RpcLinks for Reconcile RPCs.")]
        public bool DisableReconcileRpcLinks;

    }


}
﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
#if DEVELOPMENT
using FishNet.Managing.Logging;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using System;
using System.Collections.Generic;
using System.Text;
using FishNet.Transporting.Tugboat;

namespace FishNet.Managing.Debugging
{
    internal class PacketIdHistory
    {
        /// <summary>
        /// Last several non-split packetIds to be received on the client.
        /// </summary>
        private readonly Queue<PacketId> _serverPacketsReceived = new();
        /// <summary>
        /// Last several non-split packetIds to be received on the server.
        /// </summary>
        private readonly Queue<PacketId> _clientPacketsReceived = new();
        /// <summary>
        /// StringBuilder to limit garbage allocation.
        /// </summary>
        private static StringBuilder _stringBuilder = new();
        /// <summary>
        /// Maximum number of packets allowed to be queued.
        /// </summary>
        private const int PACKET_COUNT = 5;

        /// <summary>
        /// Resets data.
        /// </summary>
        internal void ResetState(bool packetsFromServer)
        {
            if (packetsFromServer)
                _serverPacketsReceived.Clear();
            else
                _clientPacketsReceived.Clear();
        }

        /// <summary>
        /// Adds a packet to data.
        /// </summary>
        internal void ReceivedPacket(PacketId pId, bool packetFromServer)
        {
            Queue<PacketId> queue = (packetFromServer) ? _serverPacketsReceived : _clientPacketsReceived;

            queue.Enqueue(pId);

            while (queue.Count > PACKET_COUNT)
                queue.Dequeue();
        }

        /// <summary>
        /// Prints current data.
        /// </summary>
        internal string GetReceivedPacketIds(bool packetsFromServer, bool resetReceived = false)
        {
            string packetOriginTxt = (packetsFromServer) ? "from Server" : "from Client";

            _stringBuilder.Clear();
            Queue<PacketId> queue = GetQueue(packetsFromServer);

            _stringBuilder.AppendLine($"The last {queue.Count} packets to arrive {packetOriginTxt} are:");
            foreach (PacketId item in queue)
                _stringBuilder.AppendLine($"{item.ToString()}");

            //Attach nob information.
            _stringBuilder.Append($"The last parsed NetworkObject is ");
            NetworkObject lastNob = Reader.LastNetworkObject;
            if (lastNob != null)
                _stringBuilder.Append($"Id {lastNob.ObjectId} on gameObject {lastNob.name}");
            else
                _stringBuilder.Append("Unset");

            //Attach nb information.
            _stringBuilder.Append($", and NetworkBehaviour ");
            NetworkBehaviour lastNb = Reader.LastNetworkBehaviour;
            if (lastNb == null)
                _stringBuilder.Append("Unset");
            else
                _stringBuilder.Append($"{lastNb.GetType().Name}");

            _stringBuilder.Append(".");

            if (resetReceived)
                ResetState(packetsFromServer);

            return _stringBuilder.ToString();
        }

        /// <summary>
        /// Returns which packet queue to use.
        /// </summary>
        private Queue<PacketId> GetQueue(bool packetsFromServer) => (packetsFromServer) ? _serverPacketsReceived : _clientPacketsReceived;
    }
}
#endif﻿#if UNITY_EDITOR
using FishNet.Managing.Debugging;
using GameKit.Dependencies.Utilities;
using UnityEditor;
using UnityEngine;
using LayoutTools = GameKit.Dependencies.Utilities.EditorGuiLayoutTools;

namespace FishNet.Managing.Editing
{
    [CustomEditor(typeof(DebugManager))]
    public class DebugManagerEditor : Editor
    {
        private SerializedProperty _writeSceneObjectDetails;
        private SerializedProperty _validateRpcLengths;
        private SerializedProperty _disableObserversRpcLinks;
        private SerializedProperty _disableTargetRpcLinks;
        private SerializedProperty _disableServerRpcLinks;
        private SerializedProperty _disableReplicateRpcLinks;
        private SerializedProperty _disableReconcileRpcLinks;
        
        private void OnEnable()
        {
            _writeSceneObjectDetails = serializedObject.FindProperty(nameof(_writeSceneObjectDetails).MemberToPascalCase());
            _validateRpcLengths = serializedObject.FindProperty(nameof(_validateRpcLengths).MemberToPascalCase());
            _disableObserversRpcLinks = serializedObject.FindProperty(nameof(_disableObserversRpcLinks).MemberToPascalCase());
            _disableTargetRpcLinks = serializedObject.FindProperty(nameof(_disableTargetRpcLinks).MemberToPascalCase());
            _disableServerRpcLinks = serializedObject.FindProperty(nameof(_disableServerRpcLinks).MemberToPascalCase());
            _disableReplicateRpcLinks = serializedObject.FindProperty(nameof(_disableReplicateRpcLinks).MemberToPascalCase());
            _disableReconcileRpcLinks = serializedObject.FindProperty(nameof(_disableReconcileRpcLinks).MemberToPascalCase());
        }
        
        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            DebugManager DebugManager = (DebugManager)target;
            
            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour(DebugManager), typeof(DebugManager), false);
            GUI.enabled = true;
            
            LayoutTools.AddHelpBox("Debug features will only be run in Unity Editor, and development builds. Enabling debug features will increase bandwidth consumption and likely create garbage allocations.", MessageType.Warning);
            
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Detail Writing",EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            LayoutTools.AddPropertyField(_writeSceneObjectDetails, "Scene Objects");
            EditorGUI.indentLevel--;
            
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Packet Validation",EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            LayoutTools.AddPropertyField(_validateRpcLengths, "Rpc Lengths");
            EditorGUI.indentLevel--;
            
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Disable RpcLinks",EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            LayoutTools.AddPropertyField(_disableObserversRpcLinks, "ObserversRpcs");
            LayoutTools.AddPropertyField(_disableTargetRpcLinks, "TargetRpcs");
            LayoutTools.AddPropertyField(_disableServerRpcLinks, "ServerRpcs");
            LayoutTools.AddPropertyField(_disableReplicateRpcLinks, "ReplicateRpcs");
            LayoutTools.AddPropertyField(_disableReconcileRpcLinks, "ReconcileRpcs");
            EditorGUI.indentLevel--;

            serializedObject.ApplyModifiedProperties();
        }
    }
}
#endif﻿#if UNITY_EDITOR
using FishNet.Managing.Object;
using UnityEditor;
using UnityEngine;

namespace FishNet.Managing.Editing
{
    [CustomEditor(typeof(NetworkManager))]
    public class NetworkManagerEditor : Editor
    {
        private SerializedProperty _logging;
        private SerializedProperty _refreshDefaultPrefabs;
        private SerializedProperty _runInBackground;
        private SerializedProperty _dontDestroyOnLoad;
        private SerializedProperty _persistence;
        private SerializedProperty _spawnablePrefabs;
        private SerializedProperty _objectPool;

        private void OnEnable()
        {
            _logging = serializedObject.FindProperty("_logging");
            _refreshDefaultPrefabs = serializedObject.FindProperty("_refreshDefaultPrefabs");
            _runInBackground = serializedObject.FindProperty("_runInBackground");
            _dontDestroyOnLoad = serializedObject.FindProperty("_dontDestroyOnLoad");
            _persistence = serializedObject.FindProperty("_persistence");
            _spawnablePrefabs = serializedObject.FindProperty("_spawnablePrefabs");
            _objectPool = serializedObject.FindProperty("_objectPool");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            NetworkManager networkManager = (NetworkManager)target;

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour(networkManager), typeof(NetworkManager), false);
            GUI.enabled = true;

            //EditorGUILayout.BeginVertical(GUI.skin.box);
            //EditorGUILayout.EndVertical();


            EditorGUILayout.LabelField("Settings", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_runInBackground);
            EditorGUILayout.PropertyField(_dontDestroyOnLoad);
            EditorGUILayout.PropertyField(_persistence);
            EditorGUILayout.Space();
            EditorGUI.indentLevel--;

            EditorGUILayout.LabelField("Logging", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_logging);
            EditorGUILayout.Space();
            EditorGUI.indentLevel--;

            EditorGUILayout.LabelField("Prefabs", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_spawnablePrefabs);
            EditorGUILayout.PropertyField(_objectPool);
            EditorGUILayout.PropertyField(_refreshDefaultPrefabs);

            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            serializedObject.ApplyModifiedProperties();
        }
    }
}
#endif﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.Documenting;
using System;
using System.Runtime.CompilerServices;
using System.Text;
using FishNet.Managing.Timing;
using UnityEngine;

namespace FishNet.Managing.Logging
{
    /// <summary>
    /// Configuration ScriptableObject specifying which data to log. Used in conjuction with NetworkManager.
    /// </summary>
    [CreateAssetMenu(fileName = "New LevelLoggingConfiguration", menuName = "FishNet/Logging/Level Logging Configuration")]
    public class LevelLoggingConfiguration : LoggingConfiguration
    {
        #region Serialized.
        /// <summary>
        /// True to add localtick to logs.
        /// </summary>
        [Tooltip("True to add localtick to logs.")]
        [SerializeField]
        private bool _addLocalTick;
        /// <summary>
        /// True to add timestamps to logs.
        /// </summary>
        [Tooltip("True to add timestamps to logs.")]
        [SerializeField]
        private bool _addTimestamps = true;
        /// <summary>
        /// True to add timestamps when in editor. False to only include timestamps in builds.
        /// </summary>
        [Tooltip("True to add timestamps when in editor. False to only include timestamps in builds.")]
        [SerializeField]
        private bool _enableTimestampsInEditor;
        /// <summary>
        /// Type of logging to use for development builds and editor.
        /// </summary>
        [Tooltip("Type of logging to use for development builds and editor.")]
        [SerializeField]
        private LoggingType _developmentLogging = LoggingType.Common;
        /// <summary>
        /// Type of logging to use for GUI builds.
        /// </summary>
        [Tooltip("Type of logging to use for GUI builds.")]
        [SerializeField]
        private LoggingType _guiLogging = LoggingType.Warning;
        /// <summary>
        /// Type of logging to use for headless builds.
        /// </summary>
        [Tooltip("Type of logging to use for headless builds.")]
        [SerializeField]
        private LoggingType _headlessLogging = LoggingType.Error;
        #endregion

        #region Private.
        /// <summary>
        /// True when initialized.
        /// </summary>
        private bool _initialized;
        /// <summary>
        /// Highest type which can be logged.
        /// </summary>
        private LoggingType _highestLoggingType = LoggingType.Off;
        /// <summary>
        /// Sequential stringbuilder for performance.
        /// </summary>
        private static StringBuilder _stringBuilder = new();
        #endregion

        [APIExclude]
        public void LoggingConstructor(bool loggingEnabled, LoggingType development, LoggingType gui, LoggingType headless)
        {
            base.IsEnabled = loggingEnabled;
            _developmentLogging = development;
            _guiLogging = gui;
            _headlessLogging = headless;
        }

        /// <summary>
        /// Initializes script for use.
        /// </summary>
        /// <param name="manager"></param>
        public override void InitializeOnce()
        {
            byte currentHighest = (byte)LoggingType.Off;
#if UNITY_SERVER
            currentHighest = Math.Max(currentHighest, (byte)_headlessLogging);
#elif DEVELOPMENT
            currentHighest = Math.Max(currentHighest, (byte)_developmentLogging);
#else
            currentHighest = Math.Max(currentHighest, (byte)_guiLogging);
#endif
            _highestLoggingType = (LoggingType)currentHighest;
            _initialized = true;
        }

        /// <summary>
        /// True if can log for loggingType.
        /// </summary>
        /// <param name="loggingType">Type of logging being filtered.</param>
        /// <returns></returns>
        public override bool CanLog(LoggingType loggingType)
        {
            if (!base.IsEnabled)
                return false;

            if (!_initialized)
            {
#if DEVELOPMENT
                if (Application.isPlaying)
                    NetworkManagerExtensions.LogError("CanLog called before being initialized.");
                else
                    return true;
#endif
                return false;
            }

            return ((byte)loggingType <= (byte)_highestLoggingType);
        }

        /// <summary>
        /// Logs a common value if can log.
        /// </summary>
        public override void Log(string value)
        {
            if (CanLog(LoggingType.Common))
                Debug.Log(AddSettingsToLog(value));
        }

        /// <summary>
        /// Logs a warning value if can log.
        /// </summary>
        public override void LogWarning(string value)
        {
            if (CanLog(LoggingType.Warning))
                Debug.LogWarning(AddSettingsToLog(value));
        }

        /// <summary>
        /// Logs an error value if can log.
        /// </summary>
        public override void LogError(string value)
        {
            if (CanLog(LoggingType.Error))
            {
                Debug.LogError(AddSettingsToLog(value));
            }
        }

        /// <summary>
        /// Clones this logging configuration.
        /// </summary>
        /// <returns></returns>
        public override LoggingConfiguration Clone()
        {
            LevelLoggingConfiguration copy = ScriptableObject.CreateInstance<LevelLoggingConfiguration>();
            copy.LoggingConstructor(base.IsEnabled, _developmentLogging, _guiLogging, _headlessLogging);
            copy._addTimestamps = _addTimestamps;
            copy._addLocalTick = _addLocalTick;
            copy._enableTimestampsInEditor = _enableTimestampsInEditor;

            return copy;
        }

        /// <summary>
        /// Adds onto logging message if settings are enabled to.
        /// </summary>
        private string AddSettingsToLog(string value)
        {
            _stringBuilder.Clear();


            if (_addTimestamps && (!Application.isEditor || _enableTimestampsInEditor))
                _stringBuilder.Append($"[{DateTime.Now:yyyy.MM.dd HH:mm:ss}] ");

            if (_addLocalTick)
            {
                TimeManager tm = InstanceFinder.TimeManager;
                uint tick = (tm == null) ? TimeManager.UNSET_TICK : tm.LocalTick;
                _stringBuilder.Append($"LocalTick [{tick}] ");
            }

            //If anything was added onto string builder then add value, and set value to string builder.
            if (_stringBuilder.Length > 0)
            {
                _stringBuilder.Append(value);
                value = _stringBuilder.ToString();
            }

            return value;
        }
    }
}﻿using FishNet.Documenting;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Logging
{

    /// <summary>
    /// Base for logging configurations.
    /// </summary>
    public abstract class LoggingConfiguration : ScriptableObject
    {

        #region Serialized.
        /// <summary>
        /// True to use logging features. False to disable all logging.
        /// </summary>
        [Tooltip("True to use logging features. False to disable all logging.")]
        public bool IsEnabled = true;
        [Obsolete("Use IsEnabled.")] //Remove V5
        public bool LoggingEnabled
        {
            get => IsEnabled;
            set => IsEnabled = value;
        }
        #endregion

        /// <summary>
        /// Initializes script for use.
        /// </summary>
        /// <param name="manager"></param>
        public virtual void InitializeOnce() { }

        /// <summary>
        /// True if can log for loggingType.
        /// </summary>
        /// <param name="loggingType">Type of logging being filtered.</param>
        /// <returns></returns>
        public abstract bool CanLog(LoggingType loggingType);

        /// <summary>
        /// Logs a common value if can log.
        /// </summary>
        public abstract void Log(string value);

        /// <summary>
        /// Logs a warning value if can log.
        /// </summary>
        public abstract void LogWarning(string value);

        /// <summary>
        /// Logs an error value if can log.
        /// </summary>
        public abstract void LogError(string value);

        /// <summary>
        /// Clones this logging configuration.
        /// </summary>
        /// <returns></returns>
        public abstract LoggingConfiguration Clone();
    }
}﻿namespace FishNet.Managing.Logging
{
    /// <summary>
    /// Type of logging being filtered.
    /// </summary>
    public enum LoggingType : byte
    {
        /// <summary>
        /// Disable logging.
        /// </summary>
        Off = 0,
        /// <summary>
        /// Only log errors.
        /// </summary>
        Error = 1,
        /// <summary>
        /// Log warnings and errors.
        /// </summary>
        Warning = 2,
        /// <summary>
        /// Log all common activities, warnings, and errors.
        /// </summary>
        Common = 3
    }
}﻿#if UNITY_EDITOR
using GameKit.Dependencies.Utilities;
using UnityEditor;

namespace FishNet.Managing.Logging.Editing
{
    [CustomEditor(typeof(LevelLoggingConfiguration), true)]
    [CanEditMultipleObjects]
    public class LevelLoggingConfigurationEditor : Editor
    {
        private SerializedProperty _isEnabled;
        private SerializedProperty _addLocalTick;

        private SerializedProperty _addTimestamps;
        private SerializedProperty _enableTimestampsInEditor;

        private SerializedProperty _developmentLogging;
        private SerializedProperty _guiLogging;
        private SerializedProperty _headlessLogging;

        protected virtual void OnEnable()
        {
            _isEnabled = serializedObject.FindProperty(nameof(_isEnabled).MemberToPascalCase());

            _addLocalTick = serializedObject.FindProperty(nameof(_addLocalTick));

            _addTimestamps = serializedObject.FindProperty(nameof(_addTimestamps));
            _enableTimestampsInEditor = serializedObject.FindProperty(nameof(_enableTimestampsInEditor));

            _developmentLogging = serializedObject.FindProperty(nameof(_developmentLogging));
            _guiLogging = serializedObject.FindProperty(nameof(_guiLogging));
            _headlessLogging = serializedObject.FindProperty(nameof(_headlessLogging));
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            
            EditorGUILayout.PropertyField(_isEnabled);

            if (_isEnabled.boolValue == false)
                return;

            EditorGUI.indentLevel++;

            EditorGUILayout.PropertyField(_addLocalTick);

            EditorGUILayout.PropertyField(_addTimestamps);
            if (_addTimestamps.boolValue == true)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_enableTimestampsInEditor);
                EditorGUI.indentLevel--;
            }
            
            EditorGUILayout.PropertyField(_developmentLogging);
            EditorGUILayout.PropertyField(_guiLogging);
            EditorGUILayout.PropertyField(_headlessLogging);

            EditorGUI.indentLevel--;
            
            serializedObject.ApplyModifiedProperties();
        }
    }
}

#endifusing FishNet.Object;

namespace FishNet.Managing.Object
{

    /// <summary>
    /// When using dual prefabs, defines which prefab to spawn for server, and which for clients.
    /// </summary>
    [System.Serializable]
    public struct DualPrefab
    {
        public NetworkObject Server;
        public NetworkObject Client;
    }

}﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.Component.Observing;
using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Managing.Utility;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Object
{
    public abstract partial class ManagedObjects
    {
        #region Public.
        /// <summary>
        /// NetworkObjects which are currently active.
        /// </summary>
        public Dictionary<int, NetworkObject> Spawned = new();
        #endregion

        #region Protected.
        /// <summary>
        /// Returns the next ObjectId to use.
        /// </summary>
        protected internal virtual bool GetNextNetworkObjectId(out int nextNetworkObjectId)
        {
            nextNetworkObjectId = NetworkObject.UNSET_OBJECTID_VALUE;
            return false;
        }

        /// <summary>
        /// NetworkManager handling this.
        /// </summary>
        protected NetworkManager NetworkManager { get; private set; }
        /// <summary>
        /// Objects in currently loaded scenes. These objects can be active or inactive.
        /// Key is the objectId while value is the object. Key is not the same as NetworkObject.ObjectId.
        /// </summary> 
        protected Dictionary<ulong, NetworkObject> SceneObjects_Internal = new();
        /// <summary>
        /// Objects in currently loaded scenes. These objects can be active or inactive.
        /// Key is the objectId while value is the object. Key is not the same as NetworkObject.ObjectId.
        /// </summary>
        public IReadOnlyDictionary<ulong, NetworkObject> SceneObjects => SceneObjects_Internal;
        #endregion

        #region Private.
        /// <summary>
        /// Cached HashGrid. Will be null if not used.
        /// </summary>
        private HashGrid _hashGrid;
        #endregion

        protected virtual void Initialize(NetworkManager manager)
        {
            NetworkManager = manager;
            manager.TryGetInstance(out _hashGrid);
        }

        /// <summary>
        /// Subscribes to SceneManager.SceneLoaded event.
        /// </summary>
        /// <param name="subscribe"></param>
        internal void SubscribeToSceneLoaded(bool subscribe)
        {
            if (subscribe)
                SceneManager.sceneLoaded += SceneManager_sceneLoaded;
            else
                SceneManager.sceneLoaded -= SceneManager_sceneLoaded;
        }

        /// <summary>
        /// Called when a scene is loaded.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="arg1"></param>
        protected internal virtual void SceneManager_sceneLoaded(Scene s, LoadSceneMode arg1) { }

        /// <summary>
        /// Called when a NetworkObject runs Deactivate.
        /// </summary>
        /// <param name="nob"></param>
        internal virtual void NetworkObjectDestroyed(NetworkObject nob, bool asServer)
        {
            if (nob == null)
                return;

            RemoveFromSpawned(nob, fromOnDestroy: true, asServer);
        }

        /// <summary>
        /// Removes a NetworkedObject from spawned.
        /// </summary>
        protected virtual void RemoveFromSpawned(NetworkObject nob, bool fromOnDestroy, bool asServer)
        {
            Spawned.Remove(nob.ObjectId);
            //Do the same with SceneObjects.
            if (fromOnDestroy && nob.IsSceneObject)
                RemoveFromSceneObjects(nob);
        }

        /// <summary>
        /// Despawns a NetworkObject.
        /// </summary>
        internal virtual void Despawn(NetworkObject nob, DespawnType despawnType, bool asServer)
        {
            if (nob == null)
            {
                NetworkManager.LogWarning($"Cannot despawn a null NetworkObject.");
                return;
            }

            /* If not asServer and the object is not initialized on client
             * then it likely is already despawned. This bit of code should
             * never be reached as checks should be placed before-hand. */
            if (!asServer && !nob.IsClientInitialized)
            {
                NetworkManager.LogError($"Object {nob.ToString()} is already despawned. Please report this error.");
                return;
            }


            //True if should be destroyed, false if deactivated.
            bool destroy = false;
            bool wasRemovedFromPending = false;

            /* Only modify object state if asServer,
             * or !asServer and not host. This is so clients, when acting as
             * host, don't destroy objects they lost observation of. */

            /* Nested prefabs can never be destroyed. Only check to
             * destroy if not nested. By nested prefab, this means the object
             * despawning is part of another prefab that is also a spawned
             * network object. */
            if (!nob.IsNested)
            {
                //If as server.
                if (asServer)
                {
                    //Scene object.
                    if (!nob.IsSceneObject)
                    {
                        /* If client-host has visibility
                         * then disable and wait for client-host to get destroy
                         * message. Otherwise destroy immediately. */
                        if (nob.Observers.Contains(NetworkManager.ClientManager.Connection))
                            NetworkManager.ServerManager.Objects.AddToPending(nob);
                        else
                            destroy = true;
                    }
                }
                //Not as server.
                else
                {
                    bool isServer = NetworkManager.IsServerStarted;
                    //Only check to destroy if not a scene object.
                    if (!nob.IsSceneObject)
                    {
                        /* If was removed from pending then also destroy.
                         * Pending objects are ones that exist on the server
                         * side only to await destruction from client side.
                         * Objects can also be destroyed if server is not
                         * active. */ 
                        wasRemovedFromPending = NetworkManager.ServerManager.Objects.RemoveFromPending(nob);
                        destroy = (!isServer || wasRemovedFromPending);
                    }
                }
            }

            TryUnsetParent();
            /* If this had a parent set at runtime then
             * unset parent before checks are completed.
             * If we did not do this then this nob would
             * just be disabled beneath its runtime parent,
             * when it should be pooled separately or destroyed. */
            void TryUnsetParent()
            {
                if (!asServer || wasRemovedFromPending)
                {
                    if (nob.RuntimeParentNetworkBehaviour != null)
                    {
                        nob.UnsetParent();
                        /* DespawnType also has to be updated to use default
                         * for the networkObject since this despawn is happening
                         * automatically. */
                        despawnType = nob.GetDefaultDespawnType();
                    }
                }
            }

            nob.SetIsDestroying(despawnType);
            //Deinitialize to invoke callbacks.
            nob.Deinitialize(asServer);
            //Remove from match condition only if server.
            if (asServer)
                MatchCondition.RemoveFromMatchWithoutRebuild(nob, NetworkManager);
            RemoveFromSpawned(nob, false, asServer);

            //If to destroy.
            if (destroy)
            {
                if (despawnType == DespawnType.Destroy)
                    UnityEngine.Object.Destroy(nob.gameObject);
                else
                    NetworkManager.StorePooledInstantiated(nob, asServer);
            }
            /* If to potentially disable instead of destroy.
             * This is such as something is despawning server side
             * but a clientHost is present, or if a scene object. */
            else
            {
                //If as server.
                if (asServer)
                {
                    /* If not clientHost the object can be disabled.
                     *
                     * Also, if clientHost and clientHost is not an observer, the object
                     * can be disabled. */
                    //If not clientHost then the object can be disabled.
                    if (!NetworkManager.IsClientStarted || !nob.Observers.Contains(NetworkManager.ClientManager.Connection))
                        nob.gameObject.SetActive(false);
                }
                //Not as server.
                else
                {
                    //If the server is not active then the object can be disabled.
                    if (!NetworkManager.IsServerStarted)
                    {
                        nob.gameObject.SetActive(false);
                    }
                    //If also server then checks must be done.
                    else
                    {
                        /* Object is still spawned on the server side. This means
                         * the clientHost likely lost visibility. When this is the case
                         * update clientHost renderers. */
                        if (NetworkManager.ServerManager.Objects.Spawned.ContainsKey(nob.ObjectId))
                            nob.SetRenderersVisible(false);
                        /* No longer spawned on the server, can
                         * deactivate on the client. */
                        else
                            nob.gameObject.SetActive(false);
                    }
                }

                /* Also despawn child objects.
                 * This only must be done when not destroying
                 * as destroying would result in the despawn being
                 * forced.
                 *
                 * Only run if asServer as well. The server will send
                 * individual despawns for each child. */
                if (asServer)
                {
                    List<NetworkObject> childNobs = nob.GetNetworkObjects(GetNetworkObjectOption.AllNested);
                    foreach (NetworkObject childNob in childNobs)
                    {
                        if (childNob != null && !childNob.IsDeinitializing)
                            Despawn(childNob, despawnType, asServer: true);
                    }
                }
            }
        }

        /// <summary>
        /// Initializes a prefab, not to be mistaken for initializing a spawned object.
        /// </summary>
        /// <param name="prefab">Prefab to initialize.</param>
        /// <param name="index">Index within spawnable prefabs.</param>
        public static void InitializePrefab(NetworkObject prefab, int index, ushort? collectionId = null)
        {
            const int invalidIndex = -1;
            if (index == invalidIndex)
            {
                Debug.LogError($"An index of {invalidIndex} cannot be assigned as a PrefabId for {prefab.name}.");
                return;
            }

            if (prefab == null)
                return;

            prefab.PrefabId = (ushort)index;
            if (collectionId != null)
                prefab.SpawnableCollectionId = collectionId.Value;

            prefab.SetInitializedValues(null, force: true);
        }

        /// <summary>
        /// Despawns Spawned NetworkObjects. Scene objects will be disabled, others will be destroyed.
        /// </summary>
        internal virtual void DespawnWithoutSynchronization(bool recursive, bool asServer)
        {
            foreach (NetworkObject nob in Spawned.Values)
            {
                if (nob == null)
                    continue;

                DespawnWithoutSynchronization(nob, recursive, asServer, nob.GetDefaultDespawnType(), removeFromSpawned: false);
            }

            Spawned.Clear();
        }

        /// <summary>
        /// Despawns a network object.
        /// </summary>
        /// <param name="nob"></param>
        protected virtual void DespawnWithoutSynchronization(NetworkObject nob, bool recursive, bool asServer, DespawnType despawnType, bool removeFromSpawned)
        {
#if FISHNET_STABLE_RECURSIVE_DESPAWNS
            recursive = false;
#endif

            GetNetworkObjectOption getOption = (recursive) ? GetNetworkObjectOption.All : GetNetworkObjectOption.Self;
            List<NetworkObject> allNobs = nob.GetNetworkObjects(getOption);

            //True if can deactivate or destroy.
            bool canCleanup = (asServer || !NetworkManager.IsServerStarted);

            foreach (NetworkObject lNob in allNobs)
            {
                lNob.SetIsDestroying(despawnType);
                lNob.Deinitialize(asServer);

                if (canCleanup && removeFromSpawned)
                    RemoveFromSpawned(lNob, fromOnDestroy: false, asServer);
            }

            /* Only need to check the first nob. If it's stored, deactivated,
             * or destroyed, the rest will follow. */
            if (canCleanup)
            {
                NetworkObject firstNob = allNobs[0];

                if (firstNob.IsSceneObject || firstNob.IsInitializedNested)
                {
                    firstNob.gameObject.SetActive(value: false);
                }
                else
                {
                    if (despawnType == DespawnType.Destroy)
                        UnityEngine.Object.Destroy(firstNob.gameObject);
                    else
                        NetworkManager.StorePooledInstantiated(firstNob, asServer);
                }
            }

            CollectionCaches<NetworkObject>.Store(allNobs);
        }

        /// <summary>
        /// Adds a NetworkObject to Spawned.
        /// </summary>
        internal virtual void AddToSpawned(NetworkObject nob, bool asServer)
        {
            Spawned[nob.ObjectId] = nob;
        }

        /// <summary>
        /// Adds a NetworkObject to SceneObjects.
        /// </summary>
        protected internal void AddToSceneObjects(NetworkObject nob)
        {
            SceneObjects_Internal[nob.SceneId] = nob;
        }

        /// <summary>
        /// Removes a NetworkObject from SceneObjects.
        /// </summary>
        /// <param name="nob"></param>
        protected internal void RemoveFromSceneObjects(NetworkObject nob)
        {
            SceneObjects_Internal.Remove(nob.SceneId);
        }

        /// <summary>
        /// Removes a NetworkObject from SceneObjects.
        /// </summary>
        /// <param name="nob"></param>
        protected internal void RemoveFromSceneObjects(ulong sceneId)
        {
            SceneObjects_Internal.Remove(sceneId);
        }

        /// <summary>
        /// Finds a NetworkObject within Spawned.
        /// </summary>
        /// <param name="objectId"></param>
        /// <returns></returns>
        protected internal NetworkObject GetSpawnedNetworkObject(int objectId)
        {
            NetworkObject r;
            if (!Spawned.TryGetValueIL2CPP(objectId, out r))
                NetworkManager.LogError($"Spawned NetworkObject not found for ObjectId {objectId}.");

            return r;
        }

        /// <summary>
        /// Tries to skip data length for a packet.
        /// </summary>
        /// <param name="packetId"></param>
        /// <param name="reader"></param>
        /// <param name="dataLength"></param>
        protected internal void SkipDataLength(ushort packetId, PooledReader reader, int dataLength, int rpcLinkObjectId = -1)
        {
            /* -1 means length wasn't set, which would suggest a reliable packet.
             * Object should never be missing for reliable packets since spawns
             * and despawns are reliable in order. */
            if (dataLength == (int)MissingObjectPacketLength.Reliable)
            {
                string msg;
                bool isRpcLink = (packetId >= NetworkManager.StartingRpcLinkIndex);
                if (isRpcLink)
                {
                    msg = (rpcLinkObjectId == -1) ? $"RPCLink of Id {(PacketId)packetId} could not be found. Remaining data will be purged." : $"ObjectId {rpcLinkObjectId} for RPCLink {(PacketId)packetId} could not be found.";
                }
                else
                {
                    msg = $"NetworkBehaviour could not be found for packetId {(PacketId)packetId}. Remaining data will be purged.";
                }

                /* Default logging for server is errors only. Use error on client and warning
                 * on servers to reduce chances of allocation attacks. */
#if DEVELOPMENT_BUILD || UNITY_EDITOR || !UNITY_SERVER
                NetworkManager.LogError(msg);
#else
                NetworkManager.LogWarning(msg);
#endif
                reader.Clear();
            }
            /* If length is known then is unreliable packet. It's possible
             * this packetId arrived before or after the object was spawned/destroyed.
             * Skip past the data for this packet and use rest in reader. With non-linked
             * RPCs length is sent before object information. */
            else if (dataLength >= 0)
            {
                reader.Skip(Math.Min(dataLength, reader.Remaining));
            }
            /* -2 indicates the length is very long. Don't even try saving
             * the packet, user shouldn't be sending this much data over unreliable. */
            else if (dataLength == (int)MissingObjectPacketLength.PurgeRemaiming)
            {
                reader.Clear();
            }
        }

        /// <summary>
        /// Parses a ReplicateRpc.
        /// </summary>
        internal void ParseReplicateRpc(PooledReader reader, NetworkConnection conn, Channel channel)
        {
#if DEVELOPMENT
            NetworkBehaviour.ReadDebugForValidatedRpc(NetworkManager, reader, out int startReaderRemaining, out string rpcInformation, out uint expectedReadAmount);
#endif

            NetworkBehaviour nb = reader.ReadNetworkBehaviour();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.ServerRpc, reader, channel);
            if (nb != null && nb.IsSpawned)
                nb.OnReplicateRpc(null, reader, conn, channel);
            else
                SkipDataLength((ushort)PacketId.ServerRpc, reader, dataLength);

#if DEVELOPMENT
            NetworkBehaviour.TryPrintDebugForValidatedRpc(fromRpcLink: false, NetworkManager, reader, startReaderRemaining, rpcInformation, expectedReadAmount, channel);
#endif
        }

#if DEVELOPMENT
        /// <summary>
        /// Checks to write a scene object's details into a writer.
        /// </summary>
        protected void CheckWriteSceneObjectDetails(NetworkObject nob, Writer w)
        {
            //Check to write additional information if a scene object.
            if (NetworkManager.DebugManager.WriteSceneObjectDetails)
            {
                w.WriteString(nob.gameObject.scene.name);
                w.WriteString(nob.gameObject.name);
            }
        }

        /// <summary>
        /// Checks to read a scene object's details and populates values if read was successful.
        /// </summary>
        protected void CheckReadSceneObjectDetails(Reader r, ref string sceneName, ref string objectName)
        {
            if (NetworkManager.DebugManager.WriteSceneObjectDetails)
            {
                sceneName = r.ReadStringAllocated();
                objectName = r.ReadStringAllocated();
            }
        }
#endif
    }
}﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using System;
using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Managing.Server;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using FishNet.Serializing.Helping;
using UnityEngine;

namespace FishNet.Managing.Object
{
    public abstract partial class ManagedObjects
    {
        #region Consts.
        /// <summary>
        /// Number of bytes to reserve for a predicted spawn length.
        /// </summary>
        internal const byte PREDICTED_SPAWN_BYTES = 2;
        #endregion

        /// <summary>
        /// Reads and outputs a transforms values.
        /// </summary>
        protected void ReadTransformProperties(Reader reader, out Vector3? localPosition, out Quaternion? localRotation, out Vector3? localScale)
        {
            //Read changed.
            TransformPropertiesFlag tpf = (TransformPropertiesFlag)reader.ReadUInt8Unpacked();
            //Position.
            if (tpf.FastContains(TransformPropertiesFlag.Position))
                localPosition = reader.ReadVector3();
            else
                localPosition = null;
            //Rotation.
            if (tpf.FastContains(TransformPropertiesFlag.Rotation))
                localRotation = reader.ReadQuaternion(NetworkManager.ServerManager.SpawnPacking.Rotation);
            else
                localRotation = null;
            //Scale.
            if (tpf.FastContains(TransformPropertiesFlag.Scale))
                localScale = reader.ReadVector3();
            else
                localScale = null;
        }

        /// <summary>
        /// Writes a spawn to a client or server.
        /// If connection is not null the spawn is sent ot a client, otherwise it will be considered a predicted spawn.
        /// </summary>
        /// <returns>True if spawn was written.</returns>
        internal bool WriteSpawn(NetworkObject nob, PooledWriter writer, NetworkConnection connection)
        {
            writer.WritePacketIdUnpacked(PacketId.ObjectSpawn);

            ReservedLengthWriter asClientReservedWriter = ReservedWritersExtensions.Retrieve();
            bool predictedSpawn = (connection == null);

            if (predictedSpawn)
                asClientReservedWriter.Initialize(writer, PREDICTED_SPAWN_BYTES);

            bool sceneObject = nob.IsSceneObject;
            //Write type of spawn.
            SpawnType st = SpawnType.Unset;
            if (sceneObject)
                st |= SpawnType.Scene;
            else
                st |= (nob.IsGlobal) ? SpawnType.InstantiatedGlobal : SpawnType.Instantiated;

            if (connection == nob.PredictedSpawner)
                st |= SpawnType.IsPredictedSpawner;

            //Call before writing SpawnType so nested can be appended to it if needed.
            PooledWriter nestedWriter = WriteNestedSpawn(nob, ref st);

            writer.WriteUInt8Unpacked((byte)st);
            //Write parent here if writer for parent is valid.
            if (nestedWriter != null)
            {
                writer.WriteArraySegment(nestedWriter.GetArraySegment());
                WriterPool.Store(nestedWriter);
            }

            writer.WriteSpawnedNetworkObject(nob);
            writer.WriteNetworkConnection(nob.Owner);

            //Properties on the transform which diff from serialized value.
            WriteChangedTransformProperties(nob, sceneObject, writer);

            /* Writing a scene object. */
            if (sceneObject)
            {
                writer.WriteUInt64Unpacked(nob.SceneId);
#if DEVELOPMENT
                CheckWriteSceneObjectDetails(nob, writer);
#endif
            }
            /* Writing a spawned object. */
            else
            {
                writer.WriteNetworkObjectId(nob.PrefabId);
            }

            NetworkConnection payloadSender = (predictedSpawn) ? NetworkManager.EmptyConnection : connection;
            WritePayload(payloadSender, nob, writer);

            /* RPCLinks and SyncTypes are ONLY written by the server.
             * Although not necessary, both sides will write the length
             * to keep the reading of spawns consistent. */
            WriteRpcLinks(nob, writer);
            WriteSyncTypesForSpawn(nob, writer, connection);

            bool canWrite;
            //Need to validate predicted spawn length.
            if (predictedSpawn)
            {
                int maxContentLength;
                if (PREDICTED_SPAWN_BYTES == 2)
                {
                    maxContentLength = ushort.MaxValue;
                }
                else
#pragma warning disable CS0162 // Unreachable code detected
                {
                    NetworkManager.LogError($"Unhandled spawn bytes value of {PREDICTED_SPAWN_BYTES}.");
                    maxContentLength = 0;
                }
#pragma warning restore CS0162 // Unreachable code detected

                //Too much content; this really should absolutely never happen.
                canWrite = (asClientReservedWriter.Length <= maxContentLength);
                if (!canWrite)
                    NetworkManager.LogError($"A single predicted spawns may not exceed {maxContentLength} bytes in length. Written length is {asClientReservedWriter.Length}. Predicted spawn for {nob.name} will be despawned immediately.");
                //Not too large.
                else
                    asClientReservedWriter.WriteLength();
            }

            //Not predicted, server can always write.
            else
            {
                canWrite = true;
            }

            asClientReservedWriter.Store();
            return canWrite;
        }

        /// <summary>
        /// Writes RPCLinks for a NetworkObject.
        /// </summary>
        protected void WriteRpcLinks(NetworkObject nob, PooledWriter writer)
        {
            ReservedLengthWriter rw = ReservedWritersExtensions.Retrieve();

            rw.Initialize(writer, NetworkBehaviour.RPCLINK_RESERVED_BYTES);

            if (NetworkManager.IsServerStarted)
            {
                foreach (NetworkBehaviour nb in nob.NetworkBehaviours)
                    nb.WriteRpcLinks(writer);
            }

            rw.WriteLength();

            rw.Store();
        }

        /// <summary>
        /// Reads RpcLinks from a spawn into an arraySegment.
        /// </summary>
        protected ArraySegment<byte> ReadRpcLinks(PooledReader reader)
        {
            uint segmentSize = ReservedLengthWriter.ReadLength(reader, NetworkBehaviour.RPCLINK_RESERVED_BYTES);
            return reader.ReadArraySegment((int)segmentSize);
        }

        /// <summary>
        /// Writes SyncTypes for a NetworkObject.
        /// </summary>
        protected void WriteSyncTypesForSpawn(NetworkObject nob, PooledWriter writer, NetworkConnection connection)
        {
            ReservedLengthWriter rw = ReservedWritersExtensions.Retrieve();

            //SyncTypes.
            rw.Initialize(writer, NetworkBehaviour.SYNCTYPE_RESERVE_BYTES);

            if (NetworkManager.IsServerStarted)
            {
                foreach (NetworkBehaviour nb in nob.NetworkBehaviours)
                    nb.WriteSyncTypesForSpawn(writer, connection);
            }

            rw.WriteLength();
            rw.Store();
        }

        /// <summary>
        /// Reads SyncTypes from a spawn into an arraySegment.
        /// </summary>
        protected ArraySegment<byte> ReadSyncTypesForSpawn(PooledReader reader)
        {
            uint segmentSize = ReservedLengthWriter.ReadLength(reader, NetworkBehaviour.SYNCTYPE_RESERVE_BYTES);
            return reader.ReadArraySegment((int)segmentSize);
        }

        /// <summary>
        /// Writers a nested spawn and returns writer used.
        /// If nested was not written null is returned.
        /// </summary>
        internal PooledWriter WriteNestedSpawn(NetworkObject nob, ref SpawnType st)
        {
            //Check to write parent behaviour or nob.
            NetworkBehaviour parentNb;
            Transform t = nob.transform.parent;
            if (t != null)
            {
                parentNb = nob.CurrentParentNetworkBehaviour;
                /* Check for a NetworkObject if there is no NetworkBehaviour.
                 * There is a small chance the parent object will only contain
                 * a NetworkObject. */
                if (parentNb == null)
                {
                    return null;
                }
                //No parent.
                else
                {
                    if (!parentNb.IsSpawned)
                    {
                        NetworkManager.LogWarning($"Parent {t.name} is not spawned. {nob.name} will not have it's parent sent in the spawn message.");
                        return null;
                    }
                    else
                    {
                        st |= SpawnType.Nested;
                        PooledWriter writer = WriterPool.Retrieve();
                        writer.WriteUInt8Unpacked(nob.ComponentIndex);
                        writer.WriteNetworkBehaviour(parentNb);
                        return writer;
                    }
                }
            }
            //CurrentNetworkBehaviour is not set.
            else
            {
                return null;
            }
        }

        /// <summary>
        /// If flags indicate there is a nested spawn the objectId and NetworkBehaviourId are output.
        /// Otherwise, output value sare set to null.
        /// </summary>
        internal void ReadNestedSpawnIds(PooledReader reader, SpawnType st, out byte? nobComponentIndex, out int? parentObjectId, out byte? parentComponentIndex, HashSet<int> readSpawningObjects = null)
        {
            if (st.FastContains(SpawnType.Nested))
            {
                nobComponentIndex = reader.ReadUInt8Unpacked();
                reader.ReadNetworkBehaviour(out int objectId, out byte componentIndex, readSpawningObjects);
                if (objectId != NetworkObject.UNSET_OBJECTID_VALUE)
                {
                    parentObjectId = objectId;
                    parentComponentIndex = componentIndex;
                    return;
                }
            }

            //Fall through, not nested.
            nobComponentIndex = null;
            parentObjectId = null;
            parentComponentIndex = null;
        }

        /// <summary>
        /// Finishes reading a scene object.
        /// </summary>
        protected void ReadSceneObjectId(PooledReader reader, out ulong sceneId)
        {
            sceneId = reader.ReadUInt64Unpacked();
        }

        /// <summary>
        /// Writes changed transform proeprties to writer.
        /// </summary>
        protected void WriteChangedTransformProperties(NetworkObject nob, bool sceneObject, Writer headerWriter)
        {
            /* Write changed transform properties. */
            TransformPropertiesFlag tpf;
            /* If a scene object or nested during initialization then
             * write changes compared to initialized values. */
            if (sceneObject || nob.InitializedParentNetworkBehaviour != null)
            {
                tpf = nob.GetTransformChanges(nob.SerializedTransformProperties);
            }
            else
            {
                //This should not be possible when spawning non-nested.
                if (nob.PrefabId == NetworkObject.UNSET_PREFABID_VALUE)
                {
                    NetworkManager.LogWarning($"NetworkObject {nob.ToString()} unexpectedly has an unset PrefabId while it's not nested. Please report this warning.");
                    tpf = TransformPropertiesFlag.Everything;
                }
                else
                {
                    PrefabObjects po = NetworkManager.GetPrefabObjects<PrefabObjects>(nob.SpawnableCollectionId, false);
                    tpf = nob.GetTransformChanges(po.GetObject(asServer: true, nob.PrefabId).gameObject);
                }
            }

            headerWriter.WriteUInt8Unpacked((byte)tpf);
            //If properties have changed.
            if (tpf != TransformPropertiesFlag.Unset)
            {
                //Write any changed properties.
                if (tpf.FastContains(TransformPropertiesFlag.Position))
                    headerWriter.WriteVector3(nob.transform.localPosition);
                if (tpf.FastContains(TransformPropertiesFlag.Rotation))
                    headerWriter.WriteQuaternion(nob.transform.localRotation, NetworkManager.ServerManager.SpawnPacking.Rotation);
                if (tpf.FastContains(TransformPropertiesFlag.Scale))
                    headerWriter.WriteVector3(nob.transform.localScale);
            }
        }

        /// <summary>
        /// Writes a despawn.
        /// </summary>
        protected void WriteDespawn(NetworkObject nob, DespawnType despawnType, Writer everyoneWriter)
        {
            everyoneWriter.WritePacketIdUnpacked(PacketId.ObjectDespawn);
            everyoneWriter.WriteNetworkObjectForDespawn(nob, despawnType);
        }

        /// <summary>
        /// Finds a scene NetworkObject and sets transform values.
        /// </summary>
        internal NetworkObject GetSceneNetworkObject(ulong sceneId, string sceneName, string objectName)
        {
            NetworkObject nob;
            SceneObjects_Internal.TryGetValueIL2CPP(sceneId, out nob);
            //If found in scene objects.
            if (nob == null)
            {
#if DEVELOPMENT
                string missingObjectDetails = (sceneName == string.Empty) ? "For more information on the missing object add DebugManager to your NetworkManager and enable WriteSceneObjectDetails" : $"Scene containing the object is '{sceneName}', object name is '{objectName}";
                NetworkManager.LogError($"SceneId of {sceneId} not found in SceneObjects. {missingObjectDetails}. This may occur if your scene differs between client and server, if client does not have the scene loaded, or if networked scene objects do not have a SceneCondition. See ObserverManager in the documentation for more on conditions.");
#else
                NetworkManager.LogError($"SceneId of {sceneId} not found in SceneObjects. This may occur if your scene differs between client and server, if client does not have the scene loaded, or if networked scene objects do not have a SceneCondition. See ObserverManager in the documentation for more on conditions.");
#endif
            }

            return nob;
        }

        /// <summary>
        /// Returns if a NetworkObject meets basic criteria for being predicted spawned.
        /// </summary>
        /// <param name="reader">If not null reader will be cleared on error.</param>
        /// <returns></returns>
        protected bool CanPredictedSpawn(NetworkObject nob, NetworkConnection spawner, bool asServer, Reader reader = null)
        {
            //Does not allow predicted spawning.
            if (!nob.AllowPredictedSpawning)
            {
                if (asServer)
                    spawner.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Connection {spawner.ClientId} tried to spawn an object {nob.name} which does not support predicted spawning.");
                else
                    NetworkManager.LogError($"Object {nob.name} does not support predicted spawning. Add a PredictedSpawn component to the object and configure appropriately.");

                if (reader != null)
                    reader.Clear();
                return false;
            }

            // //Parenting is not yet supported.
            // if (nob.CurrentParentNetworkBehaviour != null)
            // {
            //     if (asServer)
            //         spawner.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Connection {spawner.ClientId} tried to spawn an object that is not root.");
            //     else
            //         NetworkManager.LogError($"Predicted spawning as a child is not supported.");
            //
            //     if (reader != null)
            //         reader.Clear();
            //     return false;
            // }

            //Nested nobs not yet supported.
            if (nob.InitializedNestedNetworkObjects.Count > 0)
            {
                if (asServer)
                    spawner.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Connection {spawner.ClientId} tried to spawn an object {nob.name} which has nested NetworkObjects.");
                else
                    NetworkManager.LogError($"Predicted spawning prefabs which contain nested NetworkObjects is not yet supported but will be in a later release.");

                if (reader != null)
                    reader.Clear();
                return false;
            }

            return true;
        }

        /// <summary>
        /// Returns if a NetworkObject meets basic criteria for being predicted despawned.
        /// </summary>
        /// <param name="reader">If not null reader will be cleared on error.</param>
        /// <returns></returns>
        protected bool CanPredictedDespawn(NetworkObject nob, NetworkConnection despawner, bool asServer, Reader reader = null)
        {
            //Does not allow predicted spawning.
            if (!nob.AllowPredictedDespawning)
            {
                if (asServer)
                    despawner.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Connection {despawner.ClientId} tried to despawn an object {nob.name} which does not support predicted despawning.");
                else
                    NetworkManager.LogError($"Object {nob.name} does not support predicted despawning. Modify the PredictedSpawn component settings to allow predicted despawning.");

                reader?.Clear();
                return false;
            }

            ////Parenting is not yet supported.
            //if (nob.transform.parent != null)
            //{
            //    if (asServer)
            //        despawner.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Connection {despawner.ClientId} tried to despawn an object that is not root.");
            //    else
            //        NetworkManager.LogError($"Predicted despawning as a child is not supported.");

            //    reader?.Clear();
            //    return false;
            //}
            //Nested nobs not yet supported.
            if (nob.InitializedNestedNetworkObjects.Count > 0)
            {
                if (asServer)
                    despawner.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Connection {despawner.ClientId} tried to despawn an object {nob.name} which has nested NetworkObjects.");
                else
                    NetworkManager.LogError($"Predicted despawning prefabs which contain nested NetworkObjects is not yet supported but will be in a later release.");

                reader?.Clear();
                return false;
            }

            //Blocked by PredictedSpawn settings or user logic.
            if ((asServer && !nob.PredictedSpawn.OnTryDespawnServer(despawner)) || (!asServer && !nob.PredictedSpawn.OnTryDespawnClient()))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Reads a payload for a NetworkObject.
        /// </summary>
        internal void ReadPayload(NetworkConnection sender, NetworkObject nob, PooledReader reader, int? payloadLength = null)
        {
            if (!payloadLength.HasValue)
                payloadLength = (int)ReservedLengthWriter.ReadLength(reader, NetworkBehaviour.PAYLOAD_RESERVE_BYTES);
            //If there is a payload.
            if (payloadLength > 0)
            {
                if (nob != null)
                {
                    foreach (NetworkBehaviour networkBehaviour in nob.NetworkBehaviours)
                        networkBehaviour.ReadPayload(sender, reader);
                }
                //NetworkObject could be null if payload is for a predicted spawn.
                else
                {
                    reader.Skip((int)payloadLength);
                }
            }
        }

        /// <summary>
        /// Reads the payload returning it as an arraySegment.
        /// </summary>
        /// <returns></returns>
        internal ArraySegment<byte> ReadPayload(PooledReader reader)
        {
            int payloadLength = (int)ReservedLengthWriter.ReadLength(reader, NetworkBehaviour.PAYLOAD_RESERVE_BYTES);
            return reader.ReadArraySegment(payloadLength);
        }

        /// <summary>
        /// /Writers a payload for a NetworkObject.
        /// </summary>
        protected void WritePayload(NetworkConnection sender, NetworkObject nob, PooledWriter writer)
        {
            ReservedLengthWriter rw = ReservedWritersExtensions.Retrieve();

            rw.Initialize(writer, NetworkBehaviour.PAYLOAD_RESERVE_BYTES);

            foreach (NetworkBehaviour nb in nob.NetworkBehaviours)
                nb.WritePayload(sender, writer);

            rw.WriteLength();
        }

        // /// <summary>
        // /// Writes a payload for a NetworkObject.
        // /// </summary>
        // protected ArraySegment<byte> ReadPayload(PooledReader reader)
        // {
        //     PooledWriter nbWriter = WriterPool.Retrieve();
        //     foreach (NetworkBehaviour nb in nob.NetworkBehaviours)
        //     {
        //         nbWriter.Reset();
        //         nb.WritePayload(conn, nbWriter);
        //         if (nbWriter.Length > 0)
        //         {
        //             writer.WriteUInt8Unpacked(nb.ComponentIndex);
        //             writer.WriteArraySegment(nbWriter.GetArraySegment());
        //         }
        //     }
        // }
    }
}﻿using FishNet.Documenting;

namespace FishNet.Managing.Object
{
    [System.Flags]
    internal enum SpawnType : byte
    {
        Unset = 0,
        /// <summary>
        /// Is nested beneath a NetworkBehaviour.
        /// </summary>
        Nested = 1,
        /// <summary>
        /// Is a scene object.
        /// </summary>
        Scene = 2,
        /// <summary>
        /// Instantiate into active scene.
        /// </summary>
        Instantiated = 4,
        /// <summary>
        /// Instantiate into the global scene.
        /// </summary>
        InstantiatedGlobal = 8,
        /// <summary>
        /// Indicates the receiver is the predicted spawner.
        /// </summary>
        IsPredictedSpawner = 16,
    }

    [APIExclude]
    internal static class SpawnTypeExtensions
    {
        /// <summary>
        /// Returns if whole contains part.
        /// </summary>
        public static bool FastContains(this SpawnType whole, SpawnType part)
        {
            return (whole & part) == part;
        }
    }



}﻿// namespace FishNet.Managing.Object //Remove in V5
// {
//     public enum SpawnParentType : byte
//     {
//         Unset = 0,
//         NetworkObject = 1,
//         NetworkBehaviour = 2
//     }
//
// }using FishNet.Documenting;
using FishNet.Object.Helping;
using System.Collections.Generic;
using UnityEngine;
using GameKit.Dependencies.Utilities;
#if UNITY_EDITOR
using FishNet.Editing;
using UnityEditor;
#endif
using FishNet.Object;

namespace FishNet.Managing.Object
{

    [APIExclude]
    //[CreateAssetMenu(fileName = "New DefaultPrefabObjects", menuName = "FishNet/Spawnable Prefabs/Default Prefab Objects")]
    public class DefaultPrefabObjects : SinglePrefabObjects
    {
        /// <summary>
        /// Sets asset path hashes for prefabs starting at index, or if missing.
        /// </summary
        /// <return>Returns true if one or more NetworkObjects were updated.</return>
        internal bool SetAssetPathHashes(int index)
        {
#if UNITY_EDITOR
            bool dirtied = false;
            int count = base.GetObjectCount();

            if (count == 0)
                return false;
            if (index < 0 || index >= count)
            {
                Debug.LogError($"Index {index} is out of range when trying to set asset path hashes. Collection length is {count}. Defaulf prefabs may need to be rebuilt.");
                return false;
            }

            for (int i = 0; i < count; i++)
            {
                NetworkObject n = base.Prefabs[i];
                if (i < index)
                    continue;

                string pathAndName = $"{AssetDatabase.GetAssetPath(n.gameObject)}{n.gameObject.name}";
                ulong hashcode = Hashing.GetStableHashU64(pathAndName);
                //Already set.
                if (n.AssetPathHash == hashcode)
                    continue;

                n.SetAssetPathHash(hashcode);
                EditorUtility.SetDirty(n);
                dirtied = true;
            }

            return dirtied;
#else
            return false;
#endif
        }

        /// <summary> 
        /// Sorts prefabs by name and path hashcode.
        /// </summary>
        internal void Sort()
        {
            if (base.GetObjectCount() == 0)
                return;

            Dictionary<ulong, NetworkObject> hashcodesAndNobs = new();
            List<ulong> hashcodes = new();

            bool error = false;
            foreach (NetworkObject n in base.Prefabs)
            {
                hashcodes.Add(n.AssetPathHash);
                //If hashcode is 0 something is wrong
                if (n.AssetPathHash == 0)
                {
                    error = true;
                    Debug.LogError($"AssetPathHash is not set for GameObject {n.name}.");
                    
                }
                hashcodesAndNobs.Add(n.AssetPathHash, n);
            }
            //An error occured, no reason to continue.
            if (error)
            {
                Debug.LogError($"One or more NetworkObject prefabs did not have their AssetPathHash set. This usually occurs when a prefab cannot be saved. Check the specified prefabs for missing scripts or serialization errors and correct them, then use Fish-Networking -> Refresh Default Prefabs.");
                return;
            }

            //Once all hashes have been made re-add them to prefabs sorted.
            hashcodes.Sort();
            //Build to a new list using sorted hashcodes.
            List<NetworkObject> sortedNobs = new();
            foreach (ulong hc in hashcodes)
                sortedNobs.Add(hashcodesAndNobs[hc]);

            base.Clear();
            base.AddObjects(sortedNobs, checkForDuplicates: false, initializeAdded: false);
        }


    }

}using FishNet.Documenting;
using FishNet.Object;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Object
{

    //document
    [APIExclude]
    [CreateAssetMenu(fileName = "New DualPrefabObjects", menuName = "FishNet/Spawnable Prefabs/Dual Prefab Objects")]
    public class DualPrefabObjects : PrefabObjects
    {
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Prefabs which may be spawned.")]
        [SerializeField]
        private List<DualPrefab> _prefabs = new();
        /// <summary>
        /// Prefabs which may be spawned.
        /// </summary>
        public IReadOnlyList<DualPrefab> Prefabs => _prefabs;

        public override void Clear()
        {
            _prefabs.Clear();
        }
        public override int GetObjectCount()
        {
            return _prefabs.Count;
        }

        public override NetworkObject GetObject(bool asServer, int id)
        {
            if (id < 0 || id >= _prefabs.Count)
            {
                NetworkManagerExtensions.LogError($"PrefabId {id} is out of range.");
                return null;
            }
            else
            {
                DualPrefab dp = _prefabs[id];
                NetworkObject nob = (asServer) ? dp.Server : dp.Client;
                if (nob == null)
                {
                    string lookupSide = (asServer) ? "server" : "client";
                    NetworkManagerExtensions.LogError($"Prefab for {lookupSide} on id {id} is null ");
                }

                return nob;
            }
        }

        public override void RemoveNull()
        {
            for (int i = 0; i < _prefabs.Count; i++)
            {
                if (_prefabs[i].Server == null || _prefabs[i].Client == null)
                {
                    _prefabs.RemoveAt(i);
                    i--;
                }
            }
        }

        public override void AddObject(DualPrefab dualPrefab, bool checkForDuplicates = false, bool initializeAdded = true)
        {
            AddObjects(new DualPrefab[] { dualPrefab }, checkForDuplicates, initializeAdded);
        }

        public override void AddObjects(List<DualPrefab> dualPrefabs, bool checkForDuplicates = false, bool initializeAdded = true)
        {
            AddObjects(dualPrefabs.ToArray(), checkForDuplicates, initializeAdded);
        }

        public override void AddObjects(DualPrefab[] dualPrefabs, bool checkForDuplicates = false, bool initializeAdded = true)
        {
            if (!checkForDuplicates)
            {
                _prefabs.AddRange(dualPrefabs);
            }
            else
            {
                foreach (DualPrefab dp in dualPrefabs)
                    AddUniqueNetworkObjects(dp);
            }

            if (initializeAdded && Application.isPlaying)
                InitializePrefabRange(0);
        }

        private void AddUniqueNetworkObjects(DualPrefab dp)
        {
            for (int i = 0; i < _prefabs.Count; i++)
            {
                if (_prefabs[i].Server == dp.Server && _prefabs[i].Client == dp.Client)
                    return;
            }

            _prefabs.Add(dp);
        }

        
        public override void InitializePrefabRange(int startIndex)
        {
            for (int i = startIndex; i < _prefabs.Count; i++)
            {
                ManagedObjects.InitializePrefab(_prefabs[i].Server, i, CollectionId);
                ManagedObjects.InitializePrefab(_prefabs[i].Client, i, CollectionId);
            }
        }


        #region Unused.
        public override void AddObject(NetworkObject networkObject, bool checkForDuplicates = false, bool initializeAdded = true)
        {
            NetworkManagerExtensions.LogError($"Single prefabs are not supported with DualPrefabObjects. Make a SinglePrefabObjects asset instead.");
        }

        public override void AddObjects(List<NetworkObject> networkObjects, bool checkForDuplicates = false, bool initializeAdded = true)
        {
            NetworkManagerExtensions.LogError($"Single prefabs are not supported with DualPrefabObjects. Make a SinglePrefabObjects asset instead.");
        }

        public override void AddObjects(NetworkObject[] networkObjects, bool checkForDuplicates = false, bool initializeAdded = true)
        {
            NetworkManagerExtensions.LogError($"Single prefabs are not supported with DualPrefabObjects. Make a SinglePrefabObjects asset instead.");
        }
        #endregion
    }
}using FishNet.Documenting;
using FishNet.Object;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Managing.Object
{
    //document
    [APIExclude]
    public abstract class PrefabObjects : ScriptableObject
    {
        /// <summary>
        /// CollectionId for this PrefabObjects.
        /// </summary>
        public ushort CollectionId { get; private set; }
        /// <summary>
        /// Sets CollectionIdValue.
        /// </summary>
        internal void SetCollectionId(ushort id) => CollectionId = id;

        public abstract void Clear();
        public abstract int GetObjectCount();
        public abstract NetworkObject GetObject(bool asServer, int id);
        public abstract void RemoveNull();
        public abstract void AddObject(NetworkObject networkObject, bool checkForDuplicates = false, bool initializeAdded = true);
        public abstract void AddObjects(List<NetworkObject> networkObjects, bool checkForDuplicates = false, bool initializeAdded = true);
        public abstract void AddObjects(NetworkObject[] networkObjects, bool checkForDuplicates = false, bool initializeAdded = true);
        public abstract void AddObject(DualPrefab dualPrefab, bool checkForDuplicates = false, bool initializeAdded = true);
        public abstract void AddObjects(List<DualPrefab> dualPrefab, bool checkForDuplicates = false, bool initializeAdded = true);
        public abstract void AddObjects(DualPrefab[] dualPrefab, bool checkForDuplicates = false, bool initializeAdded = true);
        public abstract void InitializePrefabRange(int startIndex);



    }
}using FishNet.Documenting;
using FishNet.Object;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Object
{
    //document
    [APIExclude]
    [CreateAssetMenu(fileName = "New SinglePrefabObjects", menuName = "FishNet/Spawnable Prefabs/Single Prefab Objects")]
    public class SinglePrefabObjects : PrefabObjects
    {
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Prefabs which may be spawned.")]
        [SerializeField]
        private List<NetworkObject> _prefabs = new();
        /// <summary>
        /// Prefabs which may be spawned.
        /// </summary>
        public IReadOnlyList<NetworkObject> Prefabs => _prefabs;

        public override void Clear()
        {
            _prefabs.Clear();
        }
        public override int GetObjectCount()
        {
            return _prefabs.Count;
        }
        public override NetworkObject GetObject(bool asServer, int id)
        {
            if (id < 0 || id >= _prefabs.Count)
            {
                NetworkManagerExtensions.LogError($"PrefabId {id} is out of range.");
                return null;
            }
            else
            {
                NetworkObject nob = _prefabs[id];
                if (nob == null)
                    NetworkManagerExtensions.LogError($"Prefab on id {id} is null.");

                return nob;
            }
        }

        public override void RemoveNull()
        {
            for (int i = 0; i < _prefabs.Count; i++)
            {
                if (_prefabs[i] == null)
                {
                    _prefabs.RemoveAt(i);
                    i--;
                }
            }
        }

        public override void AddObject(NetworkObject networkObject, bool checkForDuplicates = false, bool initializeAdded = true)
        {
            if (!checkForDuplicates)
                _prefabs.Add(networkObject);
            else
                AddUniqueNetworkObject(networkObject);

            if (initializeAdded && Application.isPlaying)
                InitializePrefabRange(0);
        }

        public override void AddObjects(List<NetworkObject> networkObjects, bool checkForDuplicates = false, bool initializeAdded = true)
        {
            if (!checkForDuplicates)
            {
                _prefabs.AddRange(networkObjects);
            }
            else
            {
                foreach (NetworkObject nob in networkObjects)
                    AddUniqueNetworkObject(nob);
            }

            if (initializeAdded && Application.isPlaying)
                InitializePrefabRange(0);
        }
        public override void AddObjects(NetworkObject[] networkObjects, bool checkForDuplicates = false, bool initializeAdded = true)
        {
            AddObjects(networkObjects.ToList(), checkForDuplicates, initializeAdded);
        }

        private void AddUniqueNetworkObject(NetworkObject nob)
        {
            if (!_prefabs.Contains(nob))
                _prefabs.Add(nob);
        }

        
        public override void InitializePrefabRange(int startIndex)
        {
            for (int i = startIndex; i < _prefabs.Count; i++)
                ManagedObjects.InitializePrefab(_prefabs[i], i, CollectionId);
        }


        #region Unused.
        public override void AddObject(DualPrefab dualPrefab, bool checkForDuplicates = false, bool initializeAdded = true)
        {
            NetworkManagerExtensions.LogError($"Dual prefabs are not supported with SinglePrefabObjects. Make a DualPrefabObjects asset instead.");
        }

        public override void AddObjects(List<DualPrefab> dualPrefab, bool checkForDuplicates = false, bool initializeAdded = true)
        {
            NetworkManagerExtensions.LogError($"Dual prefabs are not supported with SinglePrefabObjects. Make a DualPrefabObjects asset instead.");
        }

        public override void AddObjects(DualPrefab[] dualPrefab, bool checkForDuplicates = false, bool initializeAdded = true)
        {
            NetworkManagerExtensions.LogError($"Dual prefabs are not supported with SinglePrefabObjects. Make a DualPrefabObjects asset instead.");
        }
        #endregion
    }
}﻿using FishNet.Component.Observing;
using FishNet.Connection;
using FishNet.Object;
using FishNet.Observing;
using FishNet.Utility;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Serialization;

[assembly: InternalsVisibleTo(UtilityConstants.DEMOS_ASSEMBLY_NAME)]
[assembly: InternalsVisibleTo(UtilityConstants.TEST_ASSEMBLY_NAME)]

namespace FishNet.Managing.Observing
{
    /// <summary>
    /// Additional options for managing the observer system.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/ObserverManager")]
    public sealed class ObserverManager : MonoBehaviour
    {
        #region Serialized.
        /// <summary>
        /// True to update visibility for clientHost based on if they are an observer or not.
        /// </summary>
        public bool UpdateHostVisibility
        {
            get => _updateHostVisibility;
            private set => _updateHostVisibility = value;
        }

        [Tooltip("True to update visibility for clientHost based on if they are an observer or not.")]
        [SerializeField]
        private bool _updateHostVisibility = true;

        /// <summary>
        /// Maximum duration the server will take to update timed observer conditions as server load increases. Lower values will result in timed conditions being checked quicker at the cost of performance..
        /// </summary>
        public float MaximumTimedObserversDuration
        {
            get => _maximumTimedObserversDuration;
            private set => _maximumTimedObserversDuration = value;
        }

        [Tooltip("Maximum duration the server will take to update timed observer conditions as server load increases. Lower values will result in timed conditions being checked quicker at the cost of performance.")]
        [SerializeField]
        [Range(MINIMUM_TIMED_OBSERVERS_DURATION, MAXIMUM_TIMED_OBSERVERS_DURATION)]
        private float _maximumTimedObserversDuration = 10f;

        /// <summary>
        /// Sets the MaximumTimedObserversDuration value.
        /// </summary>
        /// <param name="value">New maximum duration to update timed observers over.</param>
        public void SetMaximumTimedObserversDuration(float value) => MaximumTimedObserversDuration = System.Math.Clamp(value, MINIMUM_TIMED_OBSERVERS_DURATION, MAXIMUM_TIMED_OBSERVERS_DURATION);

        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Default observer conditions for networked objects.")]
        [SerializeField]
        private List<ObserverCondition> _defaultConditions = new();

        #endregion

        #region Private.

        /// <summary>
        /// NetworkManager on object.
        /// </summary>
        private NetworkManager _networkManager;
        #endregion

        #region Consts.
        /// <summary>
        /// Minimum time allowed for timed observers to rebuild.
        /// </summary>
        private const float MINIMUM_TIMED_OBSERVERS_DURATION = 0.1f;
        /// <summary>
        /// Maxmimum time allowed for timed observers to rebuild.
        /// </summary>
        private const float MAXIMUM_TIMED_OBSERVERS_DURATION = 20f;
        #endregion

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="manager"></param>
        internal void InitializeOnce_Internal(NetworkManager manager)
        {
            _networkManager = manager;
            //Update the current value to itself so it becomes clamped. This is just to protect against the user manually setting it outside clamp somehow.
            SetMaximumTimedObserversDuration(MaximumTimedObserversDuration);
        }

        /// <summary>
        /// Sets a new value for UpdateHostVisibility.
        /// </summary>
        /// <param name="value">New value.</param>
        /// <param name="updateType">Which objects to update.</param>
        public void SetUpdateHostVisibility(bool value, HostVisibilityUpdateTypes updateType)
        {
            //Unchanged.
            if (value == UpdateHostVisibility)
                return;

            /* Update even if server state is not known.
             * The setting should be updated so when the server
             * does start spawned objects have latest setting. */
            if (HostVisibilityUpdateContains(updateType, HostVisibilityUpdateTypes.Manager))
                UpdateHostVisibility = value;

            /* If to update spawned as well then update all networkobservers
             * with the setting and also update renderers. */
            if (_networkManager.IsServerStarted && HostVisibilityUpdateContains(updateType, HostVisibilityUpdateTypes.Spawned))
            {
                NetworkConnection clientConn = _networkManager.ClientManager.Connection;
                foreach (NetworkObject n in _networkManager.ServerManager.Objects.Spawned.Values)
                {
                    n.NetworkObserver.SetUpdateHostVisibility(value);

                    //Only check to update renderers if clientHost. If not client then clientConn won't be active.
                    if (clientConn.IsActive)
                        n.SetRenderersVisible(n.Observers.Contains(clientConn), true);
                }
            }

            bool HostVisibilityUpdateContains(HostVisibilityUpdateTypes whole, HostVisibilityUpdateTypes part)
            {
                return (whole & part) == part;
            }
        }

        /// <summary>
        /// Adds default observer conditions to nob and returns the NetworkObserver used.
        /// </summary>
        internal NetworkObserver AddDefaultConditions(NetworkObject nob)
        {
            bool isGlobal = (nob.IsGlobal && !nob.IsSceneObject);
            bool obsAdded;

            NetworkObserver result;
            if (!nob.TryGetComponent(out result))
            {
                obsAdded = true;
                result = nob.gameObject.AddComponent<NetworkObserver>();
            }
            else
            {
                //If already setup by this manager then return.
                if (result.ConditionsSetByObserverManager)
                    return result;

                obsAdded = false;
            }

            /* NetworkObserver is null and there are no
             * conditions to add. Nothing will change by adding
             * the NetworkObserver component so exit early. */
            if (!obsAdded && _defaultConditions.Count == 0)
                return result;

            //If the NetworkObserver component was just added.
            if (obsAdded)
            {
                /* Global nobs do not need a NetworkObserver.
                 * Ultimately, a global NetworkObject is one without
                 * any conditions. */
                if (isGlobal)
                    return result;
                //If there are no conditions then there's nothing to add.
                if (_defaultConditions.Count == 0)
                    return result;
                /* If here then there not a global networkobject and there are conditions to use.
                 * Since the NetworkObserver is being added fresh, set OverrideType to UseManager
                 * so that the NetworkObserver is populated with the manager conditions. */
                result.OverrideType = NetworkObserver.ConditionOverrideType.UseManager;
            }
            //NetworkObject has a NetworkObserver already on it.
            else
            {
                //If global the NetworkObserver has to be cleared and set to ignore manager.
                if (isGlobal)
                {
                    result.ObserverConditionsInternal.Clear();
                    result.OverrideType = NetworkObserver.ConditionOverrideType.IgnoreManager;
                }
            }

            //If ignoring manager then use whatever is already configured.
            if (result.OverrideType == NetworkObserver.ConditionOverrideType.IgnoreManager)
            {
                //Do nothing.
            }
            //If using manager then replace all with conditions.
            else if (result.OverrideType == NetworkObserver.ConditionOverrideType.UseManager)
            {
                result.ObserverConditionsInternal.Clear();
                AddMissing(result);
            }
            //Adding only new.
            else if (result.OverrideType == NetworkObserver.ConditionOverrideType.AddMissing)
            {
                AddMissing(result);
            }

            void AddMissing(NetworkObserver networkObserver)
            {
                int count = _defaultConditions.Count;
                for (int i = 0; i < count; i++)
                {
                    ObserverCondition oc = _defaultConditions[i];
                    if (!networkObserver.ObserverConditionsInternal.Contains(oc))
                        networkObserver.ObserverConditionsInternal.Add(oc);
                }
            }

            result.ConditionsSetByObserverManager = true;
            
            return result;
        }


    }
}﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Managing.Observing.Editing
{


    [CustomEditor(typeof(ObserverManager), true)]
    [CanEditMultipleObjects]
    public class ObserverManagerEditor : Editor
    {
        private SerializedProperty _updateHostVisibility;
        private SerializedProperty _maximumTimedObserversDuration;
        private SerializedProperty _defaultConditions;

        protected virtual void OnEnable()
        {
            _updateHostVisibility = serializedObject.FindProperty(nameof(_updateHostVisibility));
            _maximumTimedObserversDuration = serializedObject.FindProperty(nameof(_maximumTimedObserversDuration));
            _defaultConditions = serializedObject.FindProperty(nameof(_defaultConditions));
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour((ObserverManager)target), typeof(ObserverManager), false);
            GUI.enabled = true;

            EditorGUILayout.LabelField("Settings", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            
            EditorGUILayout.PropertyField(_updateHostVisibility);
            if (_maximumTimedObserversDuration.floatValue < 1d)
                EditorGUILayout.HelpBox("Using low values may reduce server performance while under load.", MessageType.Warning);
            EditorGUILayout.PropertyField(_maximumTimedObserversDuration);
            EditorGUILayout.PropertyField(_defaultConditions);

            EditorGUI.indentLevel--;

            serializedObject.ApplyModifiedProperties();
        }

    }
}
#endif﻿using FishNet.Connection;
using FishNet.Managing.Timing;
using FishNet.Managing.Transporting;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Performance;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

namespace FishNet.Managing.Predicting
{
    /// <summary>
    /// Additional options for managing the observer system.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/PredictionManager")]
    public sealed class PredictionManager : MonoBehaviour
    {
        #region Types.
        internal class StatePacketTick
        {
            public uint Client = TimeManager.UNSET_TICK;
            public uint Server = TimeManager.UNSET_TICK;

            /// <summary>
            /// Returns if ticks are unset.
            /// Only client needs to be checked, as they both are set with non default at the same time.
            /// </summary>
            public bool IsUnset => Client == TimeManager.UNSET_TICK;

            public void Update(uint client, uint server)
            {
                Client = client;
                Server = server;
            }

            /// <summary>
            /// Adds ticks onto each field.
            /// </summary>
            public void AddTick(uint quantity)
            {
                Client += quantity;
                Server += quantity;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Called before performing a reconcile. Contains the client and server tick the reconcile is for.
        /// </summary>
        public event PreReconcileDel OnPreReconcile;

        public delegate void PreReconcileDel(uint clientTick, uint serverTick);

        /// <summary>
        /// Called when performing a reconcile.
        /// This is used internally to reconcile objects and does not gaurantee your subscriptions to this event will process before or after internal components.
        /// </summary>
        public event ReconcileDel OnReconcile;

        public delegate void ReconcileDel(uint clientTick, uint serverTick);

        /// <summary>
        /// Called after performing a reconcile. Contains the client and server tick the reconcile is for.
        /// </summary>
        public event PostReconcileDel OnPostReconcile;

        public delegate void PostReconcileDel(uint clientTick, uint serverTick);

        /// <summary>
        /// Called before Physics SyncTransforms are run after a reconcile.
        /// This will only invoke if physics are set to TimeManager, within the TimeManager inspector.
        /// </summary>
        public event PrePhysicsSyncTransformDel OnPrePhysicsTransformSync;

        public delegate void PrePhysicsSyncTransformDel(uint clientTick, uint serverTick);

        /// <summary>
        /// Called after Physics SyncTransforms are run after a reconcile.
        /// This will only invoke if physics are set to TimeManager, within the TimeManager inspector.
        /// </summary>
        public event PostPhysicsSyncTransformDel OnPostPhysicsTransformSync;

        public delegate void PostPhysicsSyncTransformDel(uint clientTick, uint serverTick);

        public event PostPhysicsSyncTransformDel OnPostReconcileSyncTransforms;

        /// <summary>
        /// Called before physics is simulated when replaying a replicate method.
        /// </summary>
        public event PreReplicateReplayDel OnPreReplicateReplay;

        public delegate void PreReplicateReplayDel(uint clientTick, uint serverTick);

        /// <summary>
        /// Called when replaying a replication.
        /// This is called before physics are simulated.
        /// This is used internally to replay objects and does not gaurantee your subscriptions to this event will process before or after internal components.
        /// </summary>
        internal event ReplicateReplayDel OnReplicateReplay;

        public delegate void ReplicateReplayDel(uint clientTick, uint serverTick);

        /// <summary>
        /// Called after physics is simulated when replaying a replicate method.
        /// </summary>
        public event PostReplicateReplayDel OnPostReplicateReplay;

        public delegate void PostReplicateReplayDel(uint clientTick, uint serverTick);

        /// <summary>
        /// True if client timing needs to be reduced. This is fine-tuning of the prediction system.
        /// </summary>
        internal bool ReduceClientTiming;
        /// <summary>
        /// True if prediction is currently reconciling. While reconciling run replicates will be replays.
        /// </summary>
        public bool IsReconciling { get; private set; }
        /// <summary>
        /// When not unset this is the current tick which local client is replaying authoraitive inputs on.
        /// </summary>
        public uint ClientReplayTick { get; private set; } = TimeManager.UNSET_TICK;
        /// <summary>
        /// When not unset this is the current tick which local client is replaying non-authoraitive inputs on.
        /// </summary>
        public uint ServerReplayTick { get; private set; } = TimeManager.UNSET_TICK;
        /// <summary>
        /// Local tick on the most recent performed reconcile.
        /// </summary>
        public uint ClientStateTick { get; private set; } = TimeManager.UNSET_TICK;
        /// <summary>
        /// Server tick on the most recent performed reconcile.
        /// </summary>
        public uint ServerStateTick { get; private set; } = TimeManager.UNSET_TICK;
        #endregion

        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to drop replicates from clients which are being received excessively. This can help with attacks but may cause client to temporarily desynchronize during connectivity issues. When false the server will hold at most up to 3 seconds worth of replicates, consuming multiple per tick to clear out the buffer quicker. This is good to ensure all inputs are executed but potentially could allow speed hacking.")]
        [SerializeField]
        private bool _dropExcessiveReplicates = true;
        /// <summary>
        /// True to drop replicates from clients which are being received excessively. This can help with attacks but may cause client to temporarily desynchronize during connectivity issues.
        /// When false the server will hold at most up to 3 seconds worth of replicates, consuming multiple per tick to clear out the buffer quicker. This is good to ensure all inputs are executed but potentially could allow speed hacking.
        /// </summary>
        internal bool DropExcessiveReplicates => _dropExcessiveReplicates;
        /// <summary>
        /// Sets the maximum number of replicates a server can queue per object.
        /// </summary>
        public void SetMaximumServerReplicates(byte value)
        {
            _maximumServerReplicates = (byte)Mathf.Clamp(value, MINIMUM_REPLICATE_QUEUE_SIZE, MAXIMUM_REPLICATE_QUEUE_SIZE);
        }
        /// <summary>
        /// Maximum number of replicates a server can queue per object. Higher values will reduce the chance of dropped input when the client's connection is unstable, but will potentially add latency to the client's object both on the server and client.
        /// </summary>
        public byte GetMaximumServerReplicates() => _maximumServerReplicates;
        [Tooltip("Maximum number of replicates a server can queue per object. Higher values will reduce the chance of dropped input when the client's connection is unstable, but will potentially add latency to the client's object both on the server and client.")]
        [SerializeField]
        private byte _maximumServerReplicates = 15;

        /// <summary>
        /// No more than this value of replicates should be stored as a buffer.
        /// </summary>
        internal ushort MaximumPastReplicates => (ushort)(_networkManager.TimeManager.TickRate * 5);

        /// <summary>
        /// True for the client to create local reconcile states. Enabling this feature allows reconciles to be sent less frequently and provides data to use for reconciles when packets are lost.
        /// </summary>
        internal bool CreateLocalStates => _createLocalStates;
        [FormerlySerializedAs("_localStates")]
        [Tooltip("True for the client to create local reconcile states. Enabling this feature allows reconciles to be sent less frequently and provides data to use for reconciles when packets are lost.")]
        [SerializeField]
        private bool _createLocalStates = true;
        /// <summary>
        /// How many states to try and hold in a buffer before running them. Larger values add resilience against network issues at the cost of running states later.
        /// </summary> 
        public byte StateInterpolation => _stateInterpolation;
        [Tooltip("How many states to try and hold in a buffer before running them on clients. Larger values add resilience against network issues at the cost of running states later.")]
        [Range(0, MAXIMUM_PAST_INPUTS)]
        [FormerlySerializedAs("_redundancyCount")] //Remove on V5.
        [FormerlySerializedAs("_interpolation")] //Remove on V5.
        [SerializeField]
        private byte _stateInterpolation = 2;
        /// <summary>
        /// The order in which states are run. Future favors performance and does not depend upon reconciles, while Past favors accuracy but clients must reconcile every tick.
        /// </summary>
        public ReplicateStateOrder StateOrder => _stateOrder;
        [Tooltip("The order in which clients run states. Future favors performance and does not depend upon reconciles, while Past favors accuracy but clients must reconcile every tick.")]
        [SerializeField]
        private ReplicateStateOrder _stateOrder = ReplicateStateOrder.Appended;
        /// <summary>
        /// True if StateOrder is set to future.
        /// </summary>
        internal bool IsAppendedStateOrder => (_stateOrder == ReplicateStateOrder.Appended);

        /// <summary>
        /// Sets the current ReplicateStateOrder. This may be changed at runtime.
        /// Changing this value only affects the client which it is changed on.
        /// </summary>
        /// <param name="stateOrder"></param>
        public void SetStateOrder(ReplicateStateOrder stateOrder)
        {
            //Server doesnt use state order, exit early if server.
            if (_networkManager.IsServerStarted)
                return;
            //Same as before, do nothing.
            if (stateOrder == _stateOrder)
                return;

            _stateOrder = stateOrder;
            /* If client is started and if new order is
             * past then tell all spawned objects to
             * clear future queue. */
            if (stateOrder == ReplicateStateOrder.Inserted && _networkManager.IsClientStarted)
            {
                foreach (NetworkObject item in _networkManager.ClientManager.Objects.Spawned.Values)
                    item.EmptyReplicatesQueueIntoHistory();
            }
        }

        /// <summary>
        /// Number of past inputs to send, which is also the number of times to resend final datas.
        /// </summary>
        internal byte RedundancyCount => (byte)(_stateInterpolation + 1);
        ///// <summary>
        ///// 
        ///// </summary>
        //[Tooltip("How many states to try and hold in a buffer before running them on server. Larger values add resilience against network issues at the cost of running states later.")]
        //[Range(0, MAXIMUM_PAST_INPUTS + 30)]
        //[SerializeField]
        //private byte _serverInterpolation = 1;
        ///// <summary>
        ///// How many states to try and hold in a buffer before running them on server. Larger values add resilience against network issues at the cost of running states later.
        ///// </summary>
        //internal byte ServerInterpolation => _serverInterpolation;
        #endregion

        #region Private.
        /// <summary>
        /// Number of reconciles dropped due to high latency.
        /// This is not necessarily needed but can save performance on machines struggling to keep up with simulations when combined with low frame rate.
        /// </summary>
        private byte _droppedReconcilesCount;
        /// <summary>
        /// Ticks for the last state packet to run.
        /// </summary>
        private StatePacketTick _lastStatePacketTick = new();
        /// <summary>
        /// Current reconcile state to use.
        /// </summary>
        //private StatePacket _reconcileState;
        private Queue<StatePacket> _reconcileStates = new();
        /// <summary>
        /// Look up to find states by their tick.
        /// Key: client LocalTick on the state.
        /// Value: StatePacket stored.
        /// </summary>
        private Dictionary<uint, StatePacket> _stateLookups = new();
        /// <summary>
        /// Last ordered tick read for a reconcile state.
        /// </summary>
        private uint _lastOrderedReadReconcileTick;
        /// <summary>
        /// NetworkManager used with this.
        /// </summary>
        private NetworkManager _networkManager;
        #endregion

        #region Const.
        /// <summary>
        /// Minimum number of past inputs which can be sent.
        /// </summary>
        private const byte MINIMUM_PAST_INPUTS = 1;
        /// <summary>
        /// Maximum number of past inputs which can be sent.
        /// </summary>
        internal const byte MAXIMUM_PAST_INPUTS = 5;
        /// <summary>
        /// Minimum amount of replicate queue size.
        /// </summary>
        private const byte MINIMUM_REPLICATE_QUEUE_SIZE = (MINIMUM_PAST_INPUTS + 1);
        /// <summary>
        /// Maxmimum amount of replicate queue size.
        /// </summary>
        private const byte MAXIMUM_REPLICATE_QUEUE_SIZE = byte.MaxValue;
        /// <summary>
        /// Recommended state interpolation value when using appended state order.
        /// </summary>
        internal const int MINIMUM_APPENDED_INTERPOLATION_RECOMMENDATION = 2;
        /// <summary>
        /// Recommended state interpolation value when using inserted state order.
        /// </summary>
        internal const int MINIMUM_INSERTED_INTERPOLATION_RECOMMENDATION = 1;
        /// <summary>
        /// Message when state interpolation is 0.
        /// </summary>
        internal static readonly string ZERO_STATE_INTERPOLATION_MESSAGE = $"When interpolation is 0 the chances of de-synchronizations on non-owned objects is increased drastically.";
        /// <summary>
        /// Message when state interpolation is less than ideal for appended state order.
        /// </summary>
        internal static readonly string LESS_THAN_MINIMUM_APPENDED_MESSAGE = $"When using Appended StateOrder and an interpolation less than {MINIMUM_APPENDED_INTERPOLATION_RECOMMENDATION} the chances of de-synchronizations on non-owned objects is increased.";
        /// <summary>
        /// Message when state interpolation is less than ideal for inserted state order.
        /// </summary>
        internal static readonly string LESS_THAN_MINIMUM_INSERTED_MESSAGE = $"When using Inserted StateOrder and an interpolation less than {MINIMUM_INSERTED_INTERPOLATION_RECOMMENDATION} the chances of de-synchronizations on non-owned objects is increased.";
        #endregion

        internal void InitializeOnce(NetworkManager manager)
        {
            _networkManager = manager;
            ValidateClampInterpolation();
            _networkManager.ClientManager.OnClientConnectionState += ClientManager_OnClientConnectionState;
        }

        /// <summary>
        /// Called after the local client connection state changes.
        /// </summary>
        private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs obj)
        {
            _droppedReconcilesCount = 0;
            _lastOrderedReadReconcileTick = 0;
        }

        /// <summary>
        /// Amount to reserve for the header of a state update.
        /// </summary>
        internal const int STATE_HEADER_RESERVE_LENGTH = (TransportManager.PACKETID_LENGTH + TransportManager.UNPACKED_TICK_LENGTH + TransportManager.UNPACKED_SIZE_LENGTH);

        /// <summary>
        /// Clamps queued inputs to a valid value.
        /// </summary>
        private void ValidateClampInterpolation()
        {
            ushort startingValue = _stateInterpolation;
            //Check for setting if dropping.
            if (_dropExcessiveReplicates && _stateInterpolation > _maximumServerReplicates)
                _stateInterpolation = (byte)(_maximumServerReplicates - 1);

            //If changed.
            if (_stateInterpolation != startingValue)
                _networkManager.Log($"Interpolation has been set to {_stateInterpolation}.");
            
            //Check to warn if low value.
            if (_stateInterpolation == 0)
                _networkManager.LogWarning(ZERO_STATE_INTERPOLATION_MESSAGE);
            else if (_stateOrder == ReplicateStateOrder.Appended && _stateInterpolation < MINIMUM_APPENDED_INTERPOLATION_RECOMMENDATION)
                _networkManager.LogWarning(LESS_THAN_MINIMUM_APPENDED_MESSAGE);
            else if (_stateOrder == ReplicateStateOrder.Inserted && _stateInterpolation < MINIMUM_INSERTED_INTERPOLATION_RECOMMENDATION)
                _networkManager.LogWarning(LESS_THAN_MINIMUM_INSERTED_MESSAGE);
        }

        internal class StatePacket : IResettable
        {
            public struct IncomingData
            {
                public ArraySegment<byte> Data;
                public Channel Channel;

                public IncomingData(ArraySegment<byte> data, Channel channel)
                {
                    Data = data;
                    Channel = channel;
                }
            }

            public List<IncomingData> Datas;
            public uint ClientTick;
            public uint ServerTick;

            public void Update(ArraySegment<byte> data, uint clientTick, uint serverTick, Channel channel)
            {
                AddData(data, channel);
                ServerTick = serverTick;
                ClientTick = clientTick;
            }

            public void AddData(ArraySegment<byte> data, Channel channel)
            {
                if (data.Array != null)
                    Datas.Add(new(data, channel));
            }

            public void ResetState()
            {
                for (int i = 0; i < Datas.Count; i++)
                    ByteArrayPool.Store(Datas[i].Data.Array);

                CollectionCaches<IncomingData>.StoreAndDefault(ref Datas);
            }

            public void InitializeState()
            {
                Datas = CollectionCaches<IncomingData>.RetrieveList();
            }
        }

        /// <summary>
        /// Returns client or server state tick for the current reconcile.
        /// </summary>
        /// <param name="clientTick">True to return client state tick, false for servers.</param>
        /// <returns></returns>
        public uint GetReconcileStateTick(bool clientTick) => (clientTick) ? ClientStateTick : ServerStateTick;

        /// <summary>
        /// Reconciles to received states.
        /// </summary>
        internal void ReconcileToStates()
        {
            if (!_networkManager.IsClientStarted)
                return;

            //Creates a local state update if one is not available in reconcile states.
            //   CreateLocalStateUpdate();

            //If there are no states then guestimate the next state.
            if (_reconcileStates.Count == 0)
                return;

            TimeManager tm = _networkManager.TimeManager;
            uint localTick = tm.LocalTick;
            uint estimatedLastRemoteTick = tm.LastPacketTick.Value();

            /* When there is an excessive amount of states try to consume
             * some.This only happens when the client gets really far behind
             * and has to catch up, such as a latency increase then drop.
             * Limit the number of states consumed per tick so the clients
             * computer doesn't catch fire. */
            int iterations = 0;

            while (_reconcileStates.Count > 0)
            {
                iterations++;
                /* Typically there should only be 'interpolation' amount in queue but
                 * there can be more if the clients network is unstable and they are
                 * arriving in burst.
                 * If there's more than interpolation (+1 for as a leniency buffer) then begin to
                 * consume multiple. */
                byte stateInterpolation = StateInterpolation;
                int maxIterations = (_reconcileStates.Count > (stateInterpolation + 1)) ? 2 : 1;
                //At most 2 iterations.
                if (iterations > maxIterations)
                    return;

                StatePacket sp;
                if (!ConditionsMet(_reconcileStates.Peek()))
                    return;
                else
                    sp = _reconcileStates.Dequeue();

                //Condition met. See if the next one matches condition, if so drop current.
                //Returns if a state has it's conditions met.
                bool ConditionsMet(StatePacket spChecked)
                {
                    if (spChecked == null)
                        return false;

                    /* varianceAllowance gives a few ticks to provide opportunity for late
                     * packets to arrive. This adds on varianceAllowance to replays but greatly
                     * increases the chances of the state being received before skipping past it
                     * in a replay.
                     *
                     * When using Inserted (not AppendedStateOrder) there does not need to be any
                     * additional allowance since there is no extra queue like appended, they rather just
                     * go right into the past. */
                    uint varianceAllowance = (IsAppendedStateOrder) ? (uint)2 : (uint)0;
                    uint serverTickDifferenceRequirement = (varianceAllowance + stateInterpolation);

                    bool serverPass = (spChecked.ServerTick < (estimatedLastRemoteTick - serverTickDifferenceRequirement));
                    bool clientPass = spChecked.ClientTick < (localTick - stateInterpolation);

                    return (serverPass && clientPass);
                }

                bool dropReconcile = false;
                uint clientTick = sp.ClientTick;
                uint serverTick = sp.ServerTick;

                /* If client has a low frame rate
                 * then limit the number of reconciles to prevent further performance loss.
                 * Wait 2 seconds for client to achieve a 'not low framerate'.*/
                if (_networkManager.TimeManager.LowFrameRate && _networkManager.TimeManager.ClientUptime > 2f)
                {
                    /* Limit 3 drops a second. DropValue will be roughly the same
                     * as every 330ms. */
                    int reconcileValue = Mathf.Max(1, (_networkManager.TimeManager.TickRate / 3));
                    //If cannot drop then reset dropcount.
                    if (_droppedReconcilesCount >= reconcileValue)
                    {
                        _droppedReconcilesCount = 0;
                    }
                    //If can drop...
                    else
                    {
                        dropReconcile = true;
                        _droppedReconcilesCount++;
                    }
                }
                //}
                //No reason to believe client is struggling, allow reconcile.
                else
                {
                    _droppedReconcilesCount = 0;
                }

                if (!dropReconcile)
                {
                    IsReconciling = true;
                    _lastStatePacketTick.Update(clientTick, serverTick);

                    ClientStateTick = clientTick;
                    /* This is the tick which the reconcile is for.
                     * Since reconciles are performed after replicate, if
                     * the replicate was on tick 100 then this reconcile is the state
                     * on tick 100, after the replicate is performed. */
                    ServerStateTick = serverTick;

                    //Have the reader get processed.
                    foreach (StatePacket.IncomingData item in sp.Datas)
                    {
                        // //If data isn't set skip it. This can be true if a locally generated state packet.
                        // if (item.Data.Array == null)
                        //     continue;

                        PooledReader reader = ReaderPool.Retrieve(item.Data, _networkManager, Reader.DataSource.Server);
                        _networkManager.ClientManager.ParseReader(reader, item.Channel);
                        ReaderPool.Store(reader);
                    }

                    bool timeManagerPhysics = (tm.PhysicsMode == PhysicsMode.TimeManager);
                    float tickDelta = ((float)tm.TickDelta * _networkManager.TimeManager.GetPhysicsTimeScale());

                    OnPreReconcile?.Invoke(ClientStateTick, ServerStateTick);
                    OnReconcile?.Invoke(ClientStateTick, ServerStateTick);

                    if (timeManagerPhysics)
                    {
                        OnPrePhysicsTransformSync?.Invoke(ClientStateTick, ServerStateTick);
                        Physics.SyncTransforms();
                        Physics2D.SyncTransforms();
                        OnPostPhysicsTransformSync?.Invoke(ClientStateTick, ServerStateTick);
                    }
                    
                    OnPostReconcileSyncTransforms?.Invoke(ClientStateTick, ServerStateTick);
                    /* Set first replicate to be the 1 tick
                     * after reconcile. This is because reconcile calcs
                     * should be performed after replicate has run.
                     * In result object will reconcile to data AFTER
                     * the replicate tick, and then run remaining replicates as replay.
                     *
                     * Replay up to localtick, excluding localtick. There will
                     * be no input for localtick since reconcile runs before
                     * OnTick. */
                    ClientReplayTick = ClientStateTick + 1;
                    ServerReplayTick = ServerStateTick + 1;

                    /* Only replay up to but excluding local tick.
                     * This prevents client from running 1 local tick into the future
                     * since the OnTick has not run yet.
                     *
                     * EG: if localTick is 100 replay will run up to 99, then OnTick
                     * will fire for 100.                     */
                    while (ClientReplayTick < localTick)
                    {
                        OnPreReplicateReplay?.Invoke(ClientReplayTick, ServerReplayTick);
                        OnReplicateReplay?.Invoke(ClientReplayTick, ServerReplayTick);
                        if (timeManagerPhysics && tickDelta > 0f)
                        {
                            Physics.Simulate(tickDelta);
                            Physics2D.Simulate(tickDelta);
                        }
                        OnPostReplicateReplay?.Invoke(ClientReplayTick, ServerReplayTick);
                        ClientReplayTick++;
                        ServerReplayTick++;
                    }

                    OnPostReconcile?.Invoke(ClientStateTick, ServerStateTick);
                    
                    // ClientStateTick = TimeManager.UNSET_TICK;
                    // ServerStateTick = TimeManager.UNSET_TICK;
                    ClientReplayTick = TimeManager.UNSET_TICK;
                    ServerReplayTick = TimeManager.UNSET_TICK;
                    IsReconciling = false;
                }

                DisposeOfStatePacket(sp);
            }
        }

        /// <summary>
        /// Gets the reconcile tick to use when generating a local reconcile.
        /// </summary>
        /// <returns></returns>
        internal uint GetCreateReconcileTick(bool isOwner)
        {
            uint localTick = _networkManager.TimeManager.LocalTick;

            //Client uses current localTick if owner.
            if (isOwner)
                return localTick;

            //ClientStateTick has never been set, might happen when just connecting. Cannot get tick.
            if (ClientStateTick == TimeManager.UNSET_TICK)
                return TimeManager.UNSET_TICK;

            long tickDifference = (long)(localTick - ClientStateTick);

            //Should not be possible given state tick is always behind.
            if (tickDifference < 0)
                tickDifference = 0;

            return (ServerStateTick + (uint)tickDifference);
        }

        /// <summary>
        /// Sends written states for clients.
        /// </summary>
        internal void SendStateUpdate()
        {
            byte stateInterpolation = StateInterpolation;
            TransportManager tm = _networkManager.TransportManager;
            //Must have replicated within two timing intervals.
            uint recentReplicateToTicks = (_networkManager.TimeManager.TimingTickInterval * 2);

            foreach (NetworkConnection nc in _networkManager.ServerManager.Clients.Values)
            {
                uint lastReplicateTick;
                //If client has performed a replicate recently.
                if (!nc.ReplicateTick.IsUnset)
                {
                    lastReplicateTick = nc.ReplicateTick.Value();
                }
                /* If not then use what is estimated to be the clients
                 * current tick along with desired interpolation.
                 * This should be just about the same as if the client used replicate recently. */
                else
                {
                    uint ncLocalTick = nc.LocalTick.Value();
                    uint interpolationDifference = ((uint)stateInterpolation * 2);
                    if (ncLocalTick < interpolationDifference)
                        ncLocalTick = 0;

                    lastReplicateTick = ncLocalTick;
                }

                foreach (PooledWriter writer in nc.PredictionStateWriters)
                {
                    /* Packet is sent as follows...
                     * PacketId.
                     * LastReplicateTick of receiver.
                     * Length of packet.
                     * Data. */
                    ArraySegment<byte> segment = writer.GetArraySegment();
                    writer.Position = 0;
                    writer.WritePacketIdUnpacked(PacketId.StateUpdate);
                    writer.WriteTickUnpacked(lastReplicateTick);

                    /* Send the full length of the writer excluding
                     * the reserve count of the header. The header reserve
                     * count will always be the same so that can be parsed
                     * off immediately upon receiving. */
                    int dataLength = (segment.Count - STATE_HEADER_RESERVE_LENGTH);
                    //Write length.
                    writer.WriteInt32Unpacked(dataLength);
                    //Channel is defaulted to unreliable.
                    Channel channel = Channel.Unreliable;
                    //If a single state exceeds MTU it must be sent on reliable. This is extremely unlikely.
                    _networkManager.TransportManager.CheckSetReliableChannel(segment.Count, ref channel);
                    tm.SendToClient((byte)channel, segment, nc, true);
                }

                nc.StorePredictionStateWriters();
            }
        }

        /// <summary>
        /// Parses a received state update.
        /// </summary>
        internal void ParseStateUpdate(PooledReader reader, Channel channel)
        {
            uint lastRemoteTick = _networkManager.TimeManager.LastPacketTick.LastRemoteTick;
            //If server or state is older than another received state.
            if (_networkManager.IsServerStarted || (lastRemoteTick < _lastOrderedReadReconcileTick))
            {
                /* If the server is receiving a state update it can
                 * simply discard the data since the server will never
                 * need to reset states. This can occur on the clientHost
                 * side. */
                reader.ReadTickUnpacked();
                int length = reader.ReadInt32Unpacked();
                reader.Skip(length);
            }
            else
            {
                _lastOrderedReadReconcileTick = lastRemoteTick;

                RemoveExcessiveStates();

                //LocalTick of this client the state is for.
                uint clientTick = reader.ReadTickUnpacked();
                //Length of packet.
                int length = reader.ReadInt32Unpacked();
                //Read data into array.
                byte[] arr = ByteArrayPool.Retrieve(length);
                reader.ReadUInt8Array(ref arr, length);
                //Make segment and store into states.
                ArraySegment<byte> segment = new(arr, 0, length);

                /* See if an entry was already added for the clientTick. If so then
                 * add onto the datas. Otherwise add a new state packet. */
                if (_stateLookups.TryGetValue(clientTick, out StatePacket sp1))
                {
                    sp1.AddData(segment, channel);
                }
                else
                {
                    StatePacket sp2 = ResettableObjectCaches<StatePacket>.Retrieve();
                    sp2.Update(segment, clientTick, lastRemoteTick, channel);
                    _stateLookups[clientTick] = sp2;
                    _reconcileStates.Enqueue(sp2);
                }
            }
        }
        //
        // /// <summary>
        // /// Creates a local statePacket with no data other than ticks.
        // /// </summary>
        // internal void CreateLocalStateUpdate()
        // {
        //     //Only to be called when there are no reconcile states available.
        //     if (_reconcileStates.Count > 0)
        //         return;
        //     if (_networkManager.IsServerStarted)
        //         return;
        //     //Not yet received first state, cannot apply tick.
        //     if (_lastStatePacketTick.IsUnset)
        //         return;
        //
        //     _lastStatePacketTick.AddTick(1);
        //
        //     /* Update last read as well. If we've made it this far we won't be caring about states before this
        //      * even if they come in late. */
        //     _lastOrderedReadReconcileTick = _lastStatePacketTick.Server;
        //
        //     StatePacket sp = ResettableObjectCaches<StatePacket>.Retrieve();
        //     //Channel does not matter; it's only used to determine how data is parsed, data we don't have.
        //     sp.Update(default, _lastStatePacketTick.Client, _lastStatePacketTick.Server, Channel.Unreliable);
        //     _reconcileStates.Enqueue(sp);
        // }

        /// <summary>
        /// Removes excessively stored state packets.
        /// </summary>
        private void RemoveExcessiveStates()
        {
            /* There should never really be more than queuedInputs so set
             * a limit a little beyond to prevent reconciles from building up.
             * This is more of a last result if something went terribly
             * wrong with the network. */
            int adjustedStateInterpolation = (StateInterpolation * 4) + 2;
            /* If appending allow an additional of stateInterpolation since
             * entries arent added into the past until they are run on the appended
             * queue for each networkObject. */
            if (IsAppendedStateOrder)
                adjustedStateInterpolation += StateInterpolation;
            int maxAllowedStates = Mathf.Max(adjustedStateInterpolation, 4);

            while (_reconcileStates.Count > maxAllowedStates)
            {
                StatePacket oldSp = _reconcileStates.Dequeue();
                DisposeOfStatePacket(oldSp);
            }
        }

        /// <summary>
        /// Disposes of and cleans up everything related to a StatePacket.
        /// </summary>
        private void DisposeOfStatePacket(StatePacket sp)
        {
            uint clientTick = sp.ClientTick;
            _stateLookups.Remove(clientTick);
            ResettableObjectCaches<StatePacket>.Store(sp);
        }

#if UNITY_EDITOR
        private void OnValidate()
        {
            ValidateClampInterpolation();
        }

#endif
    }
}
namespace FishNet.Managing.Predicting
{
    public enum ReplicateStateOrder
    {
        /// <summary>
        /// On clients states are placed in the past and then run when reconciles occur.
        /// This ensures that the local client is running states at the exact same time the server had, resulting in the best possible outcome for prediction accuracy.
        /// To function properly however, clients must reconcile regularly to run past inputs which may cause performance loss on lower-end client devices.
        /// </summary>
        Inserted,
        /// <summary>
        /// On clients states are still placed in the past but rather than wait until a reconcile to run, they are also placed into a queue and run as they are received.
        /// This causes states to initially run out of tick alignment, while correcting during reconciles.
        /// However, due to states no longer depending on reconciles to be run reconciles may be sent less, and clients may run reconciles less, resulting in high performance gain especially among physics-based games.
        /// </summary>
        Appended,
    }
}﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Managing.Predicting.Editing
{
    [CustomEditor(typeof(PredictionManager), true)]
    [CanEditMultipleObjects]
    public class PredictionManagerEditor : Editor
    {
        // private SerializedProperty _queuedInputs;
        private SerializedProperty _dropExcessiveReplicates;
        private SerializedProperty _maximumServerReplicates;
        private SerializedProperty _maximumConsumeCount;
        private SerializedProperty _createLocalStates;
        private SerializedProperty _stateInterpolation;
        private SerializedProperty _stateOrder;

        protected virtual void OnEnable()
        {
            _dropExcessiveReplicates = serializedObject.FindProperty(nameof(_dropExcessiveReplicates));
            _maximumServerReplicates = serializedObject.FindProperty(nameof(_maximumServerReplicates));
            _maximumConsumeCount = serializedObject.FindProperty(nameof(_maximumConsumeCount));
            _createLocalStates = serializedObject.FindProperty(nameof(_createLocalStates));
            _stateInterpolation = serializedObject.FindProperty(nameof(_stateInterpolation));
            _stateOrder = serializedObject.FindProperty(nameof(_stateOrder));
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour((PredictionManager)target), typeof(PredictionManager), false);
            GUI.enabled = true;


            EditorGUILayout.LabelField("Client", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;

            EditorGUILayout.PropertyField(_createLocalStates);

            int interpolationValue = _stateInterpolation.intValue;
            if (interpolationValue == 0)
                EditorGUILayout.HelpBox(PredictionManager.ZERO_STATE_INTERPOLATION_MESSAGE, MessageType.Warning);
            else if (_stateOrder.intValue == (int)ReplicateStateOrder.Appended && interpolationValue < PredictionManager.MINIMUM_APPENDED_INTERPOLATION_RECOMMENDATION)
                EditorGUILayout.HelpBox(PredictionManager.LESS_THAN_MINIMUM_APPENDED_MESSAGE, MessageType.Warning);
            else if (_stateOrder.intValue == (int)ReplicateStateOrder.Inserted && interpolationValue < PredictionManager.MINIMUM_INSERTED_INTERPOLATION_RECOMMENDATION)
                EditorGUILayout.HelpBox(PredictionManager.LESS_THAN_MINIMUM_INSERTED_MESSAGE, MessageType.Warning);
            EditorGUILayout.PropertyField(_stateInterpolation);
            
            EditorGUILayout.PropertyField(_stateOrder);
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            EditorGUILayout.LabelField("Server", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            // EditorGUILayout.PropertyField(_serverInterpolation);
            EditorGUILayout.PropertyField(_dropExcessiveReplicates);
            EditorGUI.indentLevel++;
            if (_dropExcessiveReplicates.boolValue == true)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_maximumServerReplicates);
                EditorGUI.indentLevel--;
            }
            EditorGUI.indentLevel--;


            serializedObject.ApplyModifiedProperties();
        }
    }
}
#endif﻿using System.Collections.Generic;
using UnityEngine;
using UnitySceneManager = UnityEngine.SceneManagement.SceneManager;
using UnityScene = UnityEngine.SceneManagement.Scene;
using System.Collections;
using System;

namespace FishNet.Managing.Scened
{

    public class DefaultSceneProcessor : SceneProcessorBase
    {
        #region Private.
        /// <summary>
        /// Currently active loading AsyncOperations.
        /// </summary>
        protected List<AsyncOperation> LoadingAsyncOperations = new();
        /// <summary>
        /// A collection of scenes used both for loading and unloading.
        /// </summary>
        protected List<UnityScene> Scenes = new();
        /// <summary>
        /// Current AsyncOperation being processed.
        /// </summary>
        protected AsyncOperation CurrentAsyncOperation;
        /// <summary>
        /// Last scene to load or begin loading.
        /// </summary>
        private UnityScene _lastLoadedScene;
        #endregion

        /// <summary>
        /// Called when scene loading has begun.
        /// </summary>
        public override void LoadStart(LoadQueueData queueData)
        {
            base.LoadStart(queueData);
            ResetValues();
        }

        public override void LoadEnd(LoadQueueData queueData)
        {
            base.LoadEnd(queueData);
            ResetValues();
        }

        /// <summary>
        /// Resets values for a fresh load or unload.
        /// </summary>
        private void ResetValues()
        {
            CurrentAsyncOperation = null;
            LoadingAsyncOperations.Clear();
        }

        /// <summary>
        /// Called when scene unloading has begun within an unload operation.
        /// </summary>
        /// <param name="queueData"></param>
        public override void UnloadStart(UnloadQueueData queueData)
        {
            base.UnloadStart(queueData);
            Scenes.Clear();
        }

        /// <summary>
        /// Begin loading a scene using an async method.
        /// </summary>
        /// <param name="sceneName">Scene name to load.</param>
        public override void BeginLoadAsync(string sceneName, UnityEngine.SceneManagement.LoadSceneParameters parameters)
        {
            AsyncOperation ao = UnitySceneManager.LoadSceneAsync(sceneName, parameters);
            LoadingAsyncOperations.Add(ao);
            
            _lastLoadedScene = UnitySceneManager.GetSceneAt(UnitySceneManager.sceneCount - 1); 
            
            CurrentAsyncOperation = ao;
            CurrentAsyncOperation.allowSceneActivation = false;
        }

        /// <summary>
        /// Begin unloading a scene using an async method.
        /// </summary>
        /// <param name="sceneName">Scene name to unload.</param>
        public override void BeginUnloadAsync(UnityScene scene)
        {
            CurrentAsyncOperation = UnitySceneManager.UnloadSceneAsync(scene);
        }

        /// <summary>
        /// Returns if a scene load or unload percent is done.
        /// </summary>
        /// <returns></returns>
        public override bool IsPercentComplete()
        {
            return (GetPercentComplete() >= 0.9f);
        }

        /// <summary>
        /// Returns the progress on the current scene load or unload.
        /// </summary>
        /// <returns></returns>
        public override float GetPercentComplete()
        {
            return (CurrentAsyncOperation == null) ? 1f : CurrentAsyncOperation.progress;
        }

        /// <summary>
        /// Gets the scene last loaded by the processor.
        /// </summary>
        /// <remarks>This is called after IsPercentComplete returns true.</remarks>
        public override UnityScene GetLastLoadedScene() => _lastLoadedScene;


        /// <summary>
        /// Adds a loaded scene.
        /// </summary>
        /// <param name="scene">Scene loaded.</param>
        public override void AddLoadedScene(UnityScene scene)
        {
            base.AddLoadedScene(scene);
            Scenes.Add(scene);
        }

        /// <summary>
        /// Returns scenes which were loaded during a load operation.
        /// </summary>
        public override List<UnityScene> GetLoadedScenes()
        {
            return Scenes;
        }

        /// <summary>
        /// Activates scenes which were loaded.
        /// </summary>
        public override void ActivateLoadedScenes()
        {
            for (int i = 0; i < LoadingAsyncOperations.Count; i++)
            {
                try
                {
                    LoadingAsyncOperations[i].allowSceneActivation = true;
                }
                catch(Exception e)
                {
                    base.SceneManager.NetworkManager.LogError($"An error occured while activating scenes. {e.Message}");
                }
            }
        }

        /// <summary>
        /// Returns if all asynchronized tasks are considered IsDone.
        /// </summary>
        /// <returns></returns>
        public override IEnumerator AsyncsIsDone()
        {
            bool notDone;
            do
            {
                notDone = false;
                foreach (AsyncOperation ao in LoadingAsyncOperations)
                {

                    if (!ao.isDone)
                    {
                        notDone = true;
                        break;
                    }
                }
                yield return null;
            } while (notDone);
            
        }
    }


}﻿using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Extensions for SceneLookupData.
    /// </summary>
    internal static class SceneLookupDataExtensions
    {
        /// <summary>
        /// Returns Names from SceneLookupData.
        /// </summary>
        /// <param name="datas"></param>
        /// <returns></returns>
        public static string[] GetNames(this SceneLookupData[] datas)
        {
            string[] names = new string[datas.Length];
            for (int i = 0; i < datas.Length; i++)
                names[i] = datas[i].Name;

            return names;
        }
        /// <summary>
        /// Returns Names from SceneLookupData.
        /// </summary>
        /// <param name="datas"></param>
        /// <returns></returns>
        public static string[] GetNamesOnly(this SceneLookupData[] datas)
        {
            string[] names = new string[datas.Length];
            for (int i = 0; i < datas.Length; i++)
                names[i] = datas[i].NameOnly;

            return names;
        }
    }

    /// <summary>
    /// Data container for looking up, loading, or unloading a scene.
    /// </summary>
    public class SceneLookupData : IEquatable<SceneLookupData>
    {
        /// <summary>
        /// Handle of the scene. If value is 0, then handle is not used.
        /// </summary>
        public int Handle;
        /// <summary>
        /// Name of the scene.
        /// </summary>
        public string Name = string.Empty;
        /// <summary>
        /// Returns the scene name without a directory path should one exist.
        /// </summary>
        public string NameOnly
        {
            get
            {
                if (string.IsNullOrEmpty(Name))
                    return string.Empty;
                string name = System.IO.Path.GetFileName(Name);
                return RemoveUnityExtension(name);
            }
        }
        /// <summary>
        /// Returns if this data is valid for use.
        /// Being valid does not mean that the scene exist, rather that there is enough data to try and lookup a scene.
        /// </summary>
        public bool IsValid => (Name != string.Empty || Handle != 0);

        #region Const
        /// <summary>
        /// String to display when scene data is invalid.
        /// </summary>
        private const string INVALID_SCENE = "One or more scene information entries contain invalid data and have been skipped.";
        #endregion

        /// <summary>
        /// 
        /// </summary>
        public SceneLookupData() { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scene">Scene to generate from.</param>
        public SceneLookupData(Scene scene)
        {
            Handle = scene.handle;
            Name = scene.name;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="name">Scene name to generate from.</param>
        public SceneLookupData(string name)
        {
            Name = name;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="handle">Scene handle to generate from.</param>
        public SceneLookupData(int handle)
        {
            Handle = handle;
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="handle">Scene handle to generate from.</param>
        /// <param name="name">Name to generate from if handle is 0.</param>
        public SceneLookupData(int handle, string name)
        {
            Handle = handle;
            Name = name;
        }

        #region Comparers.
        public static bool operator ==(SceneLookupData sldA, SceneLookupData sldB)
        {
            //One is null while the other is not.
            if ((sldA is null) != (sldB is null))
                return false;

            /*If here both are either null or have value. */
            if (!(sldA is null))
                return sldA.Equals(sldB);
            else if (!(sldB is null))
                return sldB.Equals(sldA);

            //Fall through indicates both are null.
            return true;
        }

        public static bool operator !=(SceneLookupData sldA, SceneLookupData sldB)
        {
            //One is null while the other is not.
            if ((sldA is null) != (sldB is null))
                return true;

            /*If here both are either null or have value. */
            if (!(sldA is null))
                return !sldA.Equals(sldB);
            else if (!(sldB is null))
                return !sldB.Equals(sldA);

            //Fall through indicates both are null.
            return true;
        }

        public bool Equals(SceneLookupData sld)
        {
            //Comparing instanced against null.
            if (sld is null)
                return false;

            //True if both handles are empty.
            bool bothHandlesEmpty = (
                (this.Handle == 0) &&
                (sld.Handle == 0)
                );

            //If both have handles and they match.
            if (!bothHandlesEmpty && sld.Handle == this.Handle)
                return true;
            //If neither have handles and name matches.
            else if (bothHandlesEmpty && sld.Name == this.Name)
                return true;

            //Fall through.
            return false;
        }

        public override int GetHashCode()
        {
            int hashCode = 2053068273;
            hashCode = hashCode * -1521134295 + Handle.GetHashCode();
            hashCode = hashCode * -1521134295 + EqualityComparer<string>.Default.GetHashCode(Name);
            return hashCode;
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override string ToString()
        {
            return $"Name {Name}, Handle {Handle}";
            //return base.ToString();
        }
        #endregion

        #region CreateData.
        /// <summary>
        /// Returns a new SceneLookupData.
        /// </summary>
        /// <param name="scene">Scene to create from.</param>
        /// <returns></returns>
        public static SceneLookupData CreateData(Scene scene) => new(scene);
        /// <summary>
        /// Returns a new SceneLookupData.
        /// </summary>
        /// <param name="scene">Scene name to create from.</param>
        /// <returns></returns>
        public static SceneLookupData CreateData(string name) => new(name);
        /// <summary>
        /// Returns a new SceneLookupData.
        /// </summary>
        /// <param name="scene">Scene handle to create from.</param>
        /// <returns></returns>
        public static SceneLookupData CreateData(int handle) => new(handle);
        /// <summary>
        /// Returns a SceneLookupData collection.
        /// </summary>
        /// <param name="scenes">Scenes to create from.</param>
        /// <returns></returns>
        public static SceneLookupData[] CreateData(List<Scene> scenes) => CreateData(scenes.ToArray());
        /// <summary>
        /// Returns a SceneLookupData collection.
        /// </summary>
        /// <param name="names">Scene names to create from.</param>
        /// <returns></returns>
        public static SceneLookupData[] CreateData(List<string> names) => CreateData(names.ToArray());
        /// <summary>
        /// Returns a SceneLookupData collection.
        /// </summary>
        /// <param name="handles">Scene handles to create from.</param>
        /// <returns></returns>
        public static SceneLookupData[] CreateData(List<int> handles) => CreateData(handles.ToArray());
        /// <summary>
        /// Returns a SceneLookupData collection.
        /// </summary>
        /// <param name="scenes">Scenes to create from.</param>
        /// <returns></returns>
        public static SceneLookupData[] CreateData(Scene[] scenes)
        {
            bool invalidFound = false;
            List<SceneLookupData> result = new();
            foreach (Scene item in scenes)
            {
                if (!item.IsValid())
                {
                    invalidFound = true;
                    continue;
                }

                result.Add(CreateData(item));
            }

            if (invalidFound)
                NetworkManagerExtensions.LogWarning(INVALID_SCENE);

            return result.ToArray();
        }
        /// <summary>
        /// Returns a SceneLookupData collection.
        /// </summary>
        /// <param name="names">Scene names to create from.</param>
        /// <returns></returns>
        public static SceneLookupData[] CreateData(string[] names)
        {
            SceneLookupData[] result = new SceneLookupData[names.Length];
            for (int i = 0; i < result.Length; i++)
                result[i] = new(names[i]);

            return ValidateData(result);
        }

        /// <summary>
        /// Validates SceneLookupdatas and returns only valid entries.
        /// </summary>
        public static SceneLookupData[] ValidateData(SceneLookupData data) => ValidateData(new SceneLookupData[] { data });
        /// <summary>
        /// Validates SceneLookupdatas and returns only valid entries.
        /// </summary>
        /// <param name="datas">Datas to validate.</param>
        public static SceneLookupData[] ValidateData(SceneLookupData[] datas)
        {
            bool invalidFound = false;
            List<SceneLookupData> result = CollectionCaches<SceneLookupData>.RetrieveList();
            foreach (SceneLookupData item in datas)
            {
                if (item.IsValid)
                {
                    int failingIndex = -1;
                    //Scene name or handle is set, make sure it's not duplicated in datas.
                    for (int i = 0; i < result.Count; i++)
                    {
                        bool nameMatches = (result[i].Name == item.Name);
                        bool handleMatches = (result[i].Handle == item.Handle);
                        //Handle is the same (could be 0 handle).
                        if (handleMatches)
                        {
                            //If handle matches and not default then the same scene was added multiple times.
                            if (item.Handle != 0)
                                failingIndex = i;
                        }
                        //Name is the same.
                        else if (nameMatches)
                        {
                            //If handle and name matches then also fail.
                            if (handleMatches)
                                failingIndex = i;
                        }
                    }

                    if (failingIndex != -1)
                        NetworkManagerExtensions.LogWarning($"Data {item.ToString()} matches {result[failingIndex].ToString()} and has been removed from datas.");
                    else
                        result.Add(item);
                }
                else
                {
                    invalidFound = true;
                }
            }

            SceneLookupData[] returnedValue;
            if (invalidFound)
            {
                NetworkManagerExtensions.LogWarning(INVALID_SCENE);
                returnedValue = result.ToArray();
            }
            else
            {
                returnedValue = datas;
            }

            CollectionCaches<SceneLookupData>.Store(result);
            return returnedValue;
        }

        /// <summary>
        /// Returns a SceneLookupData collection.
        /// </summary>
        /// <param name="handles">Scene handles to create from.</param>
        /// <returns></returns>
        public static SceneLookupData[] CreateData(int[] handles)
        {
            bool invalidFound = false;
            List<SceneLookupData> result = new();
            foreach (int item in handles)
            {
                if (item == 0)
                {
                    invalidFound = true;
                    continue;
                }

                result.Add(CreateData(item));
            }

            if (invalidFound)
                NetworkManagerExtensions.LogWarning(INVALID_SCENE);

            return result.ToArray();
        }
        #endregion

        /// <summary>
        /// Removes .Unity from text.
        /// </summary>
        private static string RemoveUnityExtension(string text)
        {
            string extension = ".unity";
            int extIndex = text.ToLower().IndexOf(extension);
            if (extIndex != -1 && (text.Length - extIndex) == extension.Length)
                text = text.Substring(0, extIndex);

            return text;
        }

        /// <summary>
        /// Returns the first scene found using Handle or Name, preferring Handle.
        /// </summary>
        /// <returns></returns>
        /// <param name="foundByHandle">True if scene was found by handle. Handle is always checked first.</param>
        /// <param name="warn">True to warn if duplicates are found.</param>
        public Scene GetScene(out bool foundByHandle, bool warnIfDuplicates = true)
        {
            foundByHandle = false;

            if (Handle == 0 && string.IsNullOrEmpty(NameOnly))
            {
                NetworkManagerExtensions.LogWarning("Scene handle and name is unset; scene cannot be returned.");
                return default;
            }

            Scene result = default;

            //Lookup my handle.
            if (Handle != 0)
            {
                result = SceneManager.GetScene(Handle);
                if (result.handle != 0)
                    foundByHandle = true;
            }

            //If couldnt find handle try by string.
            if (!foundByHandle)
                result = SceneManager.GetScene(NameOnly, null, warnIfDuplicates);

            return result;
        }

    }
}﻿// #if !STABLE_SCENEMANAGER_DEFINE
// using FishNet.Connection;
// using FishNet.Managing.Client;
// using FishNet.Managing.Logging;
// using FishNet.Managing.Server;
// using FishNet.Object;
// using FishNet.Serializing.Helping;
// using FishNet.Transporting;
// using GameKit.Dependencies.Utilities;
// using GameKit.Dependencies.Utilities.Types;
// using System;
// using System.Collections;
// using System.Collections.Generic;
// using System.Linq;
// using UnityEngine;
// using UnityEngine.SceneManagement;
// using UnitySceneManager = UnityEngine.SceneManagement.SceneManager;
//
// namespace FishNet.Managing.Scened
// {
//     /// <summary>
//     /// Handles loading, unloading, and scene visibility for clients.
//     /// </summary>
//     [DisallowMultipleComponent]
//     [AddComponentMenu("FishNet/Manager/SceneManager")]
//     public sealed class SceneManager : MonoBehaviour
//     {
//         #region Types.
//         internal enum LightProbeUpdateType
//         {
//             Asynchronous = 0,
//             BlockThread = 1,
//             Off = 2,
//         }
//         #endregion
//
//         #region Public.
//         /// <summary>
//         /// Called after the active scene has been set, immediately after scene loads. This will occur before NetworkBehaviour callbacks run for the scene's objects.
//         /// The boolean will indicate if the scene set active was specified by the user.
//         /// </summary>
//         public event Action<bool> OnActiveSceneSet;
//         /// <summary>
//         /// Called when a client loads initial scenes after connecting. Boolean will be true if asServer. This will invoke even if the SceneManager is not used when the client completes fully connecting to the server.
//         /// </summary>
//         public event Action<NetworkConnection, bool> OnClientLoadedStartScenes;
//         /// <summary>
//         /// Called when a scene change queue has begun. This will only call if a scene has succesfully begun to load or unload. The queue may process any number of scene events. For example: if a scene is told to unload while a load is still in progress, then the unload will be placed in the queue.
//         /// </summary>
//         public event Action OnQueueStart;
//         /// <summary>
//         /// Called when the scene queue is emptied.
//         /// </summary>
//         public event Action OnQueueEnd;
//         /// <summary>
//         /// Called when a scene load starts.
//         /// </summary>
//         public event Action<SceneLoadStartEventArgs> OnLoadStart;
//         /// <summary>
//         /// Called when completion percentage changes while loading a scene. Value is between 0f and 1f, while 1f is 100% done. Can be used for custom progress bars when loading scenes.
//         /// </summary>
//         public event Action<SceneLoadPercentEventArgs> OnLoadPercentChange;
//         /// <summary>
//         /// Called when a scene load ends.
//         /// </summary>
//         public event Action<SceneLoadEndEventArgs> OnLoadEnd;
//         /// <summary>
//         /// Called when a scene unload starts.
//         /// </summary>
//         public event Action<SceneUnloadStartEventArgs> OnUnloadStart;
//         /// <summary>
//         /// Called when a scene unload ends.
//         /// </summary>
//         public event Action<SceneUnloadEndEventArgs> OnUnloadEnd;
//         /// <summary>
//         /// Called when a client presence changes within a scene, before the server rebuilds observers.
//         /// </summary>
//         public event Action<ClientPresenceChangeEventArgs> OnClientPresenceChangeStart;
//         /// <summary>
//         /// Called when a client presence changes within a scene, after the server rebuilds observers.
//         /// </summary>
//         public event Action<ClientPresenceChangeEventArgs> OnClientPresenceChangeEnd;
//         /// <summary>
//         /// Connections within each scene.
//         /// </summary>
//         public Dictionary<Scene, HashSet<NetworkConnection>> SceneConnections { get; private set; } = new();
//         /// <summary>
//         /// 
//         /// </summary>
//         [Tooltip("Script to handle addressables loading and unloading. This field may be blank if addressables are not being used.")]
//         [SerializeField]
//         private SceneProcessorBase _sceneProcessor;
//
//         /// <summary>
//         /// Script to handle addressables loading and unloading. This field may be blank if addressables are not being used.
//         /// </summary>
//         /// <returns></returns>
//         public SceneProcessorBase GetSceneProcessor() => _sceneProcessor;
//
//         /// <summary>
//         /// Sets the SceneProcessor to use.
//         /// </summary>
//         /// <param name="value"></param>
//         public void SetSceneProcessor(SceneProcessorBase value) => _sceneProcessor = value;
//
//         /// <summary>
//         /// NetworkManager for this script.
//         /// </summary>
//         public NetworkManager NetworkManager { get; private set; }
//         #endregion
//
//         #region Internal.
//         /// <summary>
//         /// Called after the active scene has been set, immediately after scene loads.
//         /// </summary>
//         internal event Action OnActiveSceneSetInternal;
//         /// <summary>
//         /// True if the SceneManager has items in queue.
//         /// </summary>
//         internal bool IteratingQueue { get; private set; }
//         /// <summary>
//         /// Unscaled time when the SceneManager completed it's last queue.
//         /// </summary>
//         internal float QueueCompleteTime { get; private set; }
//         #endregion
//
//         #region Serialized.
//         /// <summary>
//         /// How to update light probes after loading or unloading scenes.
//         /// </summary>
//         [Tooltip("How to update light probes after loading or unloading scenes.")]
//         [SerializeField]
//         private LightProbeUpdateType _lightProbeUpdating = LightProbeUpdateType.Asynchronous;
//         /// <summary>
//         /// True to move spawned objects visible to the client that are within an unloading scene. This ensures the objects are despawned on the client side rather than when the scene is destroyed.
//         /// </summary>
//         [FormerlySerializedAs("_moveClientHostObjects")]
//         [Tooltip("True to move spawned objects visible to the client that are within an unloading scene. This ensures the objects are despawned on the client side rather than when the scene is destroyed.")]
//         [SerializeField]
//         private bool _moveClientObjects = true;
//         /// <summary>
//         /// Sets a new value for MoveClientObjects.
//         /// </summary>
//         public void SetMoveClientObjects(bool value) => _moveClientObjects = value;
//         /// <summary>
//         /// True to automatically set active scenes when loading and unloading scenes.
//         /// </summary>
//         [Tooltip("True to automatically set active scenes when loading and unloading scenes.")]
//         [SerializeField]
//         private bool _setActiveScene = true;
//         #endregion
//
//         #region Private.
//         /// <summary>
//         /// ServerManager for this script.
//         /// </summary>
//         private ServerManager _serverManager => NetworkManager.ServerManager;
//         /// <summary>
//         /// ClientManager for this script.
//         /// </summary>
//         private ClientManager _clientManager => NetworkManager.ClientManager;
//         /// <summary>
//         /// Scenes which are currently loaded as networked scenes. All players should have networked scenes loaded.
//         /// </summary>
//         private string[] _globalScenes = new string[0];
//         /// <summary>
//         /// Lastest SceneLoadData for a global load.
//         /// </summary>
//         private SceneLoadData _globalSceneLoadData = new();
//         /// <summary>
//         /// Scenes to load or unload, in order.
//         /// </summary>
//         private List<object> _queuedOperations = new();
//         /// <summary>
//         /// Scenes which must be manually unloaded, even when emptied.
//         /// </summary>
//         private HashSet<Scene> _manualUnloadScenes = new();
//         /// <summary>
//         /// Scene containing moved objects when changing single scene. On client this will contain all objects moved until the server destroys them.
//         /// The network only sends spawn messages once per-client, per server side scene load. If a scene load is performed only for specific connections
//         /// then the server is not resetting their single scene, but rather the single scene for those connections only. Because of this, any objects
//         /// which are to be moved will not receive a second respawn message, as they are never destroyed on server, only on client.
//         /// While on server only this scene contains objects being moved temporarily, before being moved to the new scene.
//         /// </summary>
//         private Scene _movedObjectsScene;
//         /// <summary>
//         /// Scene containing objects awaiting to be destroyed by the client-host.
//         /// This is required when unloading scenes where the client-host has visibility.
//         /// Otherwise the objects would become destroyed when the scene unloads on the server
//         /// which would cause missing networkobjects on clients when receiving despawn messages.
//         /// </summary>
//         private Scene _delayedDestroyScene;
//         /// <summary>
//         /// A scene to be set as the active scene where there are no global scenes.
//         /// This is used to prevent connection scenes and MovedObjectsScene from becoming the active scene.
//         /// </summary>
//         private Scene _fallbackActiveScene;
//         /// <summary>
//         /// Becomes true when when a scene first successfully begins to load or unload. Value is reset to false when the scene queue is emptied.
//         /// </summary>
//         private bool _sceneQueueStartInvoked;
//         /// <summary>
//         /// Objects being moved from MovedObjects scene to another. 
//         /// </summary>
//         private List<GameObject> _movingObjects = new();
//         /// <summary>
//         /// How many scene load confirmations the server is expecting from a client.
//         /// Unloads do not need to be checked because server does not require confirmation for those.
//         /// This is used to prevent attacks.
//         /// </summary>
//         private Dictionary<NetworkConnection, HashSet<Scene>> _pendingClientSceneChanges = new();
//         ///// <summary>
//         ///// Cache of SceneLookupData.
//         ///// </summary>
//         //private SceneLookupData _sceneLookupDataCache = new SceneLookupData();
//         /// <summary>
//         /// GlobalScenes currently loading on the server.
//         /// </summary>
//         private HashSet<string> _serverGlobalScenesLoading = new();
//         #endregion
//
//         #region Consts.
//         /// <summary>
//         /// String to use when scene data used to load is invalid.
//         /// </summary>
//         private const string INVALID_SCENELOADDATA = "One or more datas in SceneLoadData are invalid.This generally occurs when calling this method without specifying any scenes or when data fields are null.";
//         /// <summary>
//         /// String to use when scene data used to unload is invalid.
//         /// </summary>
//         private const string INVALID_SCENEUNLOADDATA = "One or more datas in SceneLoadData are invalid.This generally occurs when calling this method without specifying any scenes or when data fields are null.";
//         #endregion
//
//         #region Unity callbacks and initialization.
//         private void Awake()
//         {
//             UnitySceneManager.sceneUnloaded += SceneManager_SceneUnloaded;
//             if (_sceneProcessor == null)
//                 _sceneProcessor = gameObject.AddComponent<DefaultSceneProcessor>();
//             _sceneProcessor.Initialize(this);
//         }
//
//         private void Start()
//         {
//             //No need to unregister since managers are on the same object.
//             NetworkManager.ServerManager.OnRemoteConnectionState += ServerManager_OnRemoteConnectionState;
//             NetworkManager.ServerManager.OnServerConnectionState += ServerManager_OnServerConnectionState;
//             _clientManager.RegisterBroadcast<LoadScenesBroadcast>(OnLoadScenes);
//             _clientManager.RegisterBroadcast<UnloadScenesBroadcast>(OnUnloadScenes);
//             _serverManager.RegisterBroadcast<ClientScenesLoadedBroadcast>(OnClientLoadedScenes);
//             _serverManager.RegisterBroadcast<EmptyStartScenesBroadcast>(OnServerEmptyStartScenes);
//             _clientManager.RegisterBroadcast<EmptyStartScenesBroadcast>(OnClientEmptyStartScenes);
//         }
//
//         private void OnDestroy()
//         {
//             UnitySceneManager.sceneUnloaded -= SceneManager_SceneUnloaded;
//         }
//
//         /// <summary>
//         /// Called when the server connection state changes.
//         /// </summary>
//         private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs obj)
//         {
//             //If no servers are started.
//             if (!NetworkManager.ServerManager.AnyServerStarted())
//                 ResetValues();
//         }
//
//         /// <summary>
//         /// Resets as if first use.
//         /// </summary>
//         private void ResetValues()
//         {
//             SceneConnections.Clear();
//             _globalScenes = new string[0];
//             _globalSceneLoadData = new();
//             _queuedOperations.Clear();
//             _manualUnloadScenes.Clear();
//             _sceneQueueStartInvoked = false;
//             _movingObjects.Clear();
//         }
//
//         /// <summary>
//         /// Called when a connection state changes for a remote client.
//         /// </summary>
//         private void ServerManager_OnRemoteConnectionState(NetworkConnection arg1, RemoteConnectionStateArgs arg2)
//         {
//             if (arg2.ConnectionState == RemoteConnectionState.Stopped)
//                 ClientDisconnected(arg1);
//         }
//
//         /// <summary>
//         /// Initializes this script for use.
//         /// </summary>
//         /// <param name="manager"></param>
//         internal void InitializeOnce_Internal(NetworkManager manager)
//         {
//             NetworkManager = manager;
//         }
//
//         /// <summary>
//         /// Received when a scene is unloaded.
//         /// </summary>
//         /// <param name="arg0"></param>
//         private void SceneManager_SceneUnloaded(Scene scene)
//         {
//             if (!NetworkManager.IsServerStarted)
//                 return;
//
//             /* Remove any unloaded scenes from local variables. This shouldn't
//              * be needed if the user properly utilizes this scene manager,
//              * but just incase, we don't want a memory leak. */
//             SceneConnections.Remove(scene);
//             _manualUnloadScenes.Remove(scene);
//             RemoveFromGlobalScenes(scene);
//         }
//         #endregion
//
//         #region Initial synchronizing.
//         /// <summary>
//         /// Invokes OnClientLoadedStartScenes if connection just loaded start scenes.
//         /// </summary>
//         /// <param name="connection"></param>
//         private void TryInvokeLoadedStartScenes(NetworkConnection connection, bool asServer)
//         {
//             if (connection.SetLoadedStartScenes(asServer))
//                 OnClientLoadedStartScenes?.Invoke(connection, asServer);
//         }
//
//         /// <summary>
//         /// Called when authenitcator has concluded a result for a connection. Boolean is true if authentication passed, false if failed. This invokes before OnClientAuthenticated so FishNet may run operations on authenticated clients before user code does.
//         /// </summary>
//         /// <param name="obj"></param>
//         internal void OnClientAuthenticated(NetworkConnection connection)
//         {
//             //No global scenes to load.
//             if (_globalScenes.Length == 0)
//             {
//                 /* Invoke that client had loaded the default scenes immediately,
//                  * since there are no scenes to load. */
//                 //OnClientLoadedScenes(connection, new ClientScenesLoadedBroadcast());
//                 //Tell the client there are no scenes to load.
//                 EmptyStartScenesBroadcast msg = new();
//                 connection.Broadcast(msg);
//             }
//             else
//             {
//                 string[] globalsNotLoading = GlobalScenesExcludingLoading();
//                 //If there are globals that can be sent now.
//                 if (globalsNotLoading != null)
//                 {
//                     SceneLoadData sld = new(globalsNotLoading);
//                     sld.Params = _globalSceneLoadData.Params;
//                     sld.Options = _globalSceneLoadData.Options;
//                     sld.ReplaceScenes = _globalSceneLoadData.ReplaceScenes;
//                     sld.PreferredActiveScene = _globalSceneLoadData.PreferredActiveScene;
//
//                     List<Scene> loadingScenes = CollectionCaches<Scene>.RetrieveList();
//                     foreach (SceneLookupData lSld in sld.SceneLookupDatas)
//                         loadingScenes.Add(lSld.GetScene(out _));
//
//                     AddPendingLoad(connection, loadingScenes);
//                     CollectionCaches<Scene>.StoreAndDefault(ref loadingScenes);
//
//                     LoadQueueData qd = new(SceneScopeType.Global, Array.Empty<NetworkConnection>(), sld, _globalScenes, false);
//                     //Send message to load the networked scenes.
//                     LoadScenesBroadcast msg = new()
//                     {
//                         QueueData = qd
//                     };
//
//                     connection.Broadcast(msg, true);
//                 }
//             }
//         }
//
//         /// <summary>
//         /// Received on client when the server has no start scenes.
//         /// </summary>
//         private void OnClientEmptyStartScenes(EmptyStartScenesBroadcast msg, Channel channel)
//         {
//             TryInvokeLoadedStartScenes(_clientManager.Connection, asServer: false);
//             _clientManager.Broadcast(msg);
//         }
//
//         /// <summary>
//         /// Received on server when client confirms there are no start scenes.
//         /// </summary>
//         private void OnServerEmptyStartScenes(NetworkConnection conn, EmptyStartScenesBroadcast msg, Channel channel)
//         {
//             //Already received, shouldn't be happening again.
//             if (conn.LoadedStartScenes(true))
//                 conn.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Received multiple EmptyStartSceneBroadcast from connectionId {conn.ClientId}. Connection will be kicked immediately.");
//             else
//                 TryInvokeLoadedStartScenes(conn, asServer: true);
//         }
//         #endregion
//
//         #region Player disconnect.
//         /// <summary>
//         /// Received when a player disconnects from the server.
//         /// </summary>
//         /// <param name="conn"></param> //finish.
//         private void ClientDisconnected(NetworkConnection conn)
//         {
//             List<Scene> connScenes = CollectionCaches<Scene>.RetrieveList();
//
//             //Remove the disconnecting clients pending loads.
//             if (_pendingClientSceneChanges.TryGetValueIL2CPP(conn, out HashSet<Scene> pendingLoads))
//             {
//                 //Add pending to connsScenes.
//                 foreach (Scene s in pendingLoads)
//                     connScenes.AddUnique(s);
//
//                 //The pending collection is no longer needed, cache it.
//                 CollectionCaches<Scene>.Store(pendingLoads);
//                 _pendingClientSceneChanges.Remove(conn);
//             }
//
//             //Now add scenes the connection is confirmed to be in.
//             foreach (Scene s in conn.Scenes)
//             {
//                 connScenes.AddUnique(s);
//                 
//                 /* If scene is in SceneConnections, which it should be, then
//                  * remove the disconnecting player from the connections in that scene.
//                  * If there are no connections left in that scene then cache the collection. */
//                 if (SceneConnections.TryGetValueIL2CPP(s, out HashSet<NetworkConnection> connsInScene))
//                 {
//                     connsInScene.Remove(conn);
//                     if (connsInScene.Count == 0)
//                     {
//                         CollectionCaches<NetworkConnection>.Store(connsInScene);
//                         SceneConnections.Remove(s);
//                     }
//                 }
//             }
//
//             /* Now remove occupied scenes from scenes the disconnecting
//              * client was in. This will remove any scenes that are pending
//              * or confirmed load for other clients. */
//             RemoveOccupiedScenes(connScenes);
//             //Globals should not be unloaded either.
//             RemoveGlobalScenes(connScenes);
//
//             List<Scene> scenesToUnload = CollectionCaches<Scene>.RetrieveList();
//             //Current active scene.
//             Scene activeScene = UnitySceneManager.GetActiveScene();
//
//             foreach (Scene s in connScenes)
//             {
//                 /* Run some additional checks to make sure the scene can be
//                  * unloaded. If possible, add to scenes to unload. */
//                 if (!_manualUnloadScenes.Contains(s) && (s != activeScene))
//                     scenesToUnload.Add(s);
//             }
//             
//             //If scenes should be unloaded.
//             if (scenesToUnload.Count > 0)
//             {
//                 SceneUnloadData sud = new(SceneLookupData.CreateData(scenesToUnload));
//                 UnloadConnectionScenes(Array.Empty<NetworkConnection>(), sud);
//             }
//             
//             CollectionCaches<Scene>.Store(connScenes);
//             CollectionCaches<Scene>.Store(scenesToUnload);
//         }
//         #endregion
//
//         #region Server received messages.
//         /// <summary>
//         /// Received on server when a client loads scenes.
//         /// </summary>
//         /// <param name="conn"></param>
//         /// <param name="msg"></param>
//         private void OnClientLoadedScenes(NetworkConnection conn, ClientScenesLoadedBroadcast msg, Channel channel)
//         {
//             HashSet<Scene> pendingLoads;
//             //There's no loads or unloads pending, kick client.
//             if (!_pendingClientSceneChanges.TryGetValueIL2CPP(conn, out pendingLoads) || pendingLoads.Count == 0)
//             {
//                 conn.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Received excessive ClientScenesLoadedBroadcast from connectionId {conn.ClientId}. Connection will be kicked immediately.");
//                 return;
//             }
//
//             //If there is a load pending then update pending count.
//             foreach (SceneLookupData item in msg.SceneLookupDatas)
//             {
//                 Scene s = item.GetScene(out _);
//                 pendingLoads.Remove(s);
//             }
//
//             //If there are no more pending loads for the connection then cache the collections and remove client from pending.
//             if (pendingLoads.Count == 0)
//             {
//                 CollectionCaches<Scene>.Store(pendingLoads);
//                 _pendingClientSceneChanges.Remove(conn);
//             }
//
//             if (!Comparers.IsDefault(msg))
//             {
//                 foreach (SceneLookupData item in msg.SceneLookupDatas)
//                 {
//                     Scene s = item.GetScene(out _);
//                     if (s.IsValid())
//                         AddConnectionToScene(conn, s);
//                 }
//             }
//         }
//         #endregion
//
//         #region Events.
//         /// <summary>
//         /// Checks if OnQueueStart should invoke, and if so invokes.
//         /// </summary>
//         private void TryInvokeOnQueueStart()
//         {
//             if (_sceneQueueStartInvoked)
//                 return;
//
//             _sceneQueueStartInvoked = true;
//             IteratingQueue = true;
//             OnQueueStart?.Invoke();
//         }
//
//         /// <summary>
//         /// Checks if OnQueueEnd should invoke, and if so invokes.
//         /// </summary>
//         private void TryInvokeOnQueueEnd()
//         {
//             if (!_sceneQueueStartInvoked)
//                 return;
//
//             _sceneQueueStartInvoked = false;
//             IteratingQueue = false;
//             QueueCompleteTime = Time.unscaledTime;
//             OnQueueEnd?.Invoke();
//         }
//
//         /// <summary>
//         /// Invokes that a scene load has started. Only called when valid scenes will be loaded.
//         /// </summary>
//         /// <param name="qd"></param>
//         private void InvokeOnSceneLoadStart(LoadQueueData qd)
//         {
//             TryInvokeOnQueueStart();
//             OnLoadStart?.Invoke(new(qd));
//         }
//
//         /// <summary>
//         /// Invokes that a scene load has ended. Only called after a valid scene has loaded.
//         /// </summary>
//         /// <param name="qd"></param>
//         private void InvokeOnSceneLoadEnd(LoadQueueData qd, List<string> requestedLoadScenes, List<Scene> loadedScenes, string[] unloadedSceneNames)
//         {
//             //Make new list to not destroy original data.
//             List<string> skippedScenes = requestedLoadScenes.ToList();
//             //Remove loaded scenes from requested scenes.
//             for (int i = 0; i < loadedScenes.Count; i++)
//                 skippedScenes.Remove(loadedScenes[i].name);
//
//             SceneLoadEndEventArgs args = new(qd, skippedScenes.ToArray(), loadedScenes.ToArray(), unloadedSceneNames);
//             OnLoadEnd?.Invoke(args);
//         }
//
//         /// <summary>
//         /// Invokes that a scene unload has started. Only called when valid scenes will be unloaded.
//         /// </summary>
//         /// <param name="sqd"></param>
//         private void InvokeOnSceneUnloadStart(UnloadQueueData sqd)
//         {
//             TryInvokeOnQueueStart();
//             OnUnloadStart?.Invoke(new(sqd));
//         }
//
//         /// <summary>
//         /// Invokes that a scene unload has ended. Only called after a valid scene has unloaded.
//         /// </summary>
//         /// <param name="sqd"></param>
//         private void InvokeOnSceneUnloadEnd(UnloadQueueData sqd, List<Scene> unloadedScenes, List<UnloadedScene> newUnloadedScenes)
//         {
//             SceneUnloadEndEventArgs args = new(sqd, unloadedScenes, newUnloadedScenes);
//             OnUnloadEnd?.Invoke(args);
//         }
//
//         /// <summary>
//         /// Invokes when completion percentage changes while unloading or unloading a scene. Value is between 0f and 1f, while 1f is 100% done.
//         /// </summary>
//         /// <param name="value"></param>
//         private void InvokeOnScenePercentChange(LoadQueueData qd, float value)
//         {
//             value = Mathf.Clamp(value, 0f, 1f);
//             SceneLoadPercentEventArgs slp = new(qd, value);
//             OnLoadPercentChange?.Invoke(slp);
//         }
//         #endregion
//
//         #region Scene queue processing.
//         /// <summary>
//         /// Queues a load or unload operation and starts queue if needed.
//         /// </summary>
//         /// <param name="data"></param>
//         private void QueueOperation(object data)
//         {
//             //Add to scene queue data.        
//             _queuedOperations.Add(data);
//             /* If only one entry then scene operations are not currently in progress.
//              * Should there be more than one entry then scene operations are already
//              * occuring. The coroutine will automatically load in order. */
//
//             if (_queuedOperations.Count == 1)
//                 StartCoroutine(__ProcessSceneQueue());
//         }
//
//         /// <summary>
//         /// Processes queued scene operations.
//         /// </summary>
//         /// <param name="asServer"></param>
//         /// <returns></returns>
//         private IEnumerator __ProcessSceneQueue()
//         {
//             /* Queue start won't invoke unless a scene load or unload actually occurs.
//              * For example: if a scene is already loaded, and nothing needs to be loaded,
//              * queue start will not invoke. */
//
//             while (_queuedOperations.Count > 0)
//             {
//                 //If a load scene.
//                 if (_queuedOperations[0] is LoadQueueData)
//                     yield return StartCoroutine(__LoadScenes());
//                 //If an unload scene.
//                 else if (_queuedOperations[0] is UnloadQueueData)
//                     yield return StartCoroutine(__UnloadScenes());
//
//                 if (_queuedOperations.Count > 0)
//                     _queuedOperations.RemoveAt(0);
//             }
//
//             TryInvokeOnQueueEnd();
//         }
//         #endregion
//
//         /// <summary>
//         /// Returns global scenes which are not currently being loaded by the server.
//         /// </summary>
//         /// <returns></returns>
//         private string[] GlobalScenesExcludingLoading()
//         {
//             HashSet<string> excludedScenes = null;
//             foreach (string gs in _globalScenes)
//             {
//                 if (_serverGlobalScenesLoading.Contains(gs))
//                 {
//                     if (excludedScenes == null)
//                         excludedScenes = new();
//
//                     excludedScenes.Add(gs);
//                 }
//             }
//
//             //Some scenes are excluded.
//             if (excludedScenes != null)
//             {
//                 //All are excluded, quick exit to save perf.
//                 int remaining = (_globalScenes.Length - excludedScenes.Count);
//                 if (remaining <= 0)
//                     return null;
//                 //Some are excluded.
//                 List<string> results = new();
//                 foreach (string globalScene in _globalScenes)
//                 {
//                     if (!excludedScenes.Contains(globalScene))
//                         results.Add(globalScene);
//                 }
//
//                 return results.ToArray();
//             }
//             //No scenes are excluded.
//             else
//             {
//                 return _globalScenes;
//             }
//         }
//
//         //#region IsQueuedScene.
//         ///// <summary>
//         ///// Returns if this SceneManager has a scene load or unload in queue for server or client.
//         ///// </summary>
//         ///// <param name="loading">True to check loading scenes, false to check unloading.</param>
//         ///// <param name="asServer">True to check if data in queue is for server, false if for client.
//         ///// <returns></returns>
//         //public bool IsQueuedScene(string sceneName, bool loading, bool asServer)
//         //{
//         //    _sceneLookupDataCache.Update(sceneName, 0);
//         //    return IsQueuedScene(_sceneLookupDataCache, loading, asServer);
//         //}
//         ///// <summary>
//         ///// Returns if this SceneManager has a scene load or unload in queue for server or client.
//         ///// </summary>
//         ///// <param name="loading">True to check loading scenes, false to check unloading.</param>
//         ///// <param name="asServer">True to check if data in queue is for server, false if for client.
//         ///// <returns></returns>
//         //public bool IsQueuedScene(int handle, bool loading, bool asServer)
//         //{
//         //    _sceneLookupDataCache.Update(string.Empty, handle);
//         //    return IsQueuedScene(_sceneLookupDataCache, loading, asServer);
//         //}
//         ///// <summary>
//         ///// Returns if this SceneManager has a scene load or unload in queue for server or client.
//         ///// </summary>
//         ///// <param name="loading">True to check loading scenes, false to check unloading.</param>
//         ///// <param name="asServer">True to check if data in queue is for server, false if for client.
//         ///// <returns></returns>
//         //public bool IsQueuedScene(Scene scene, bool loading, bool asServer)
//         //{
//         //    _sceneLookupDataCache.Update(scene.name, scene.handle);
//         //    return IsQueuedScene(_sceneLookupDataCache, loading, asServer);
//         //}
//         ///// <summary>
//         ///// Returns if this SceneManager has a scene load or unload in queue for server or client.
//         ///// </summary>
//         ///// <param name="loading">True to check loading scenes, false to check unloading.</param>
//         ///// <param name="asServer">True to check if data in queue is for server, false if for client.
//         ///// <returns></returns>
//         //public bool IsQueuedScene(SceneLookupData sld, bool loading, bool asServer)
//         //{
//         //    foreach (object item in _queuedOperations)
//         //    {
//         //        SceneLookupData[] lookupDatas = null;
//         //        //Loading check.
//         //        if (loading && item is SceneLoadData loadData)
//         //            lookupDatas = loadData.SceneLookupDatas;
//         //        else if (!loading && item is SceneUnloadData unloadData)
//         //            lookupDatas = unloadData.SceneLookupDatas;
//
//         //        if (lookupDatas != null)
//         //        {
//         //            foreach (SceneLookupData operationSld in lookupDatas)
//         //            {
//         //                if (operationSld == sld)
//         //                    return true;
//         //            }
//         //        }
//         //    }
//
//         //    //Fall through, not found in any queue operations.
//         //    return false;
//         //}
//         //#endregion
//
//         #region LoadScenes
//         /// <summary>
//         /// Loads scenes on the server and for all clients. Future clients will automatically load these scenes.
//         /// </summary>
//         /// <param name="sceneLoadData">Data about which scenes to load.</param>
//         public void LoadGlobalScenes(SceneLoadData sceneLoadData)
//         {
//             LoadGlobalScenes_Internal(sceneLoadData, _globalScenes, true);
//         }
//
//         private void LoadGlobalScenes_Internal(SceneLoadData sceneLoadData, string[] globalScenes, bool asServer)
//         {
//             if (!CanExecute(asServer, true))
//                 return;
//             if (SceneDataInvalid(sceneLoadData, true))
//                 return;
//             if (sceneLoadData.Options.AllowStacking)
//             {
//                 NetworkManager.LogError($"Stacking scenes is not allowed with Global scenes.");
//                 return;
//             }
//
//             LoadQueueData lqd = new(SceneScopeType.Global, Array.Empty<NetworkConnection>(), sceneLoadData, globalScenes, asServer);
//             QueueOperation(lqd);
//         }
//
//         /// <summary>
//         /// Loads scenes on server and tells connections to load them as well. Other connections will not load this scene.
//         /// </summary>
//         /// <param name="conn">Connections to load scenes for.</param>
//         /// <param name="sceneLoadData">Data about which scenes to load.</param>
//         public void LoadConnectionScenes(NetworkConnection conn, SceneLoadData sceneLoadData)
//         {
//             //This cannot use cache because the array will persist for many frames after this method completion.
//             LoadConnectionScenes(new NetworkConnection[] { conn }, sceneLoadData);
//         }
//
//         /// <summary>
//         /// Loads scenes on server and tells connections to load them as well. Other connections will not load this scene.
//         /// </summary>
//         /// <param name="conns">Connections to load scenes for.</param>
//         /// <param name="sceneLoadData">Data about which scenes to load.</param>
//         public void LoadConnectionScenes(NetworkConnection[] conns, SceneLoadData sceneLoadData)
//         {
//             LoadConnectionScenes_Internal(conns, sceneLoadData, _globalScenes, true);
//         }
//
//         /// <summary>
//         /// Loads scenes on server without telling clients to load the scenes.
//         /// </summary>
//         /// <param name="sceneLoadData">Data about which scenes to load.</param>
//         public void LoadConnectionScenes(SceneLoadData sceneLoadData)
//         {
//             LoadConnectionScenes_Internal(Array.Empty<NetworkConnection>(), sceneLoadData, _globalScenes, true);
//         }
//
//         private void LoadConnectionScenes_Internal(NetworkConnection[] conns, SceneLoadData sceneLoadData, string[] globalScenes, bool asServer)
//         {
//             if (!CanExecute(asServer, true))
//                 return;
//             if (SceneDataInvalid(sceneLoadData, true))
//                 return;
//
//             LoadQueueData lqd = new(SceneScopeType.Connections, conns, sceneLoadData, globalScenes, asServer);
//             QueueOperation(lqd);
//         }
//
//         /// <summary>
//         /// Returns if a NetworkObject can be moved.
//         /// </summary>
//         /// <param name="warn"></param>
//         /// <returns></returns>
//         private bool CanMoveNetworkObject(NetworkObject nob, bool warn)
//         {
//             //Null.
//             if (nob == null)
//                 return WarnAndReturnFalse($"NetworkObject is null.");
//             //Not networked.
//             if (!nob.GetIsNetworked())
//                 return WarnAndReturnFalse($"NetworkObject {nob.name} cannot be moved as it is not networked.");
//             //Not spawned.
//             if (!nob.IsSpawned)
//                 return WarnAndReturnFalse($"NetworkObject {nob.name} canot be moved as it is not spawned.");
//             //SceneObject.
//             if (nob.IsSceneObject)
//                 return WarnAndReturnFalse($"NetworkObject {nob.name} cannot be moved as it is a scene object.");
//             //Not root.
//             if (nob.transform.parent != null)
//                 return WarnAndReturnFalse($"NetworkObject {nob.name} cannot be moved because it is not the root object. Unity can only move root objects between scenes.");
//             //In DDOL and IsGlobal.
//             if (nob.IsGlobal && (nob.gameObject.scene.name == DDOL.GetDDOL().gameObject.scene.name))
//                 return WarnAndReturnFalse($"NetworkObject {nob.name} cannot be moved because it is global. Global objects must remain in the DontDestroyOnLoad scene.");
//
//             //Fall through success.
//             return true;
//
//             bool WarnAndReturnFalse(string msg)
//             {
//                 if (warn)
//                     NetworkManager.LogWarning(msg);
//                 return false;
//             }
//         }
//
//         /// <summary>
//         /// Loads a connection scene queue data. This behaves just like a networked scene load except it sends only to the specified connections, and it always loads as an additive scene on server.
//         /// </summary>
//         /// <returns></returns>
//         private IEnumerator __LoadScenes()
//         {
//             try
//             {
//                 LoadQueueData data = _queuedOperations[0] as LoadQueueData;
//                 SceneLoadData sceneLoadData = data.SceneLoadData;
//                 //True if running as server.
//                 bool asServer = data.AsServer;
//                 //True if running as client, while network server is active.
//                 bool asHost = (!asServer && NetworkManager.IsServerStarted);
//
//                 //If connection went inactive.
//                 if (!ConnectionActive(asServer))
//                     yield break;
//
//                 /* Scene sanity checks. */
//                 if (sceneLoadData.SceneLookupDatas.Length == 0)
//                 {
//                     NetworkManager.LogWarning($"No scenes specified to load.");
//                     yield break;
//                 }
//
//                 //True if replacing scenes with specified ones.
//                 ReplaceOption replaceScenes = sceneLoadData.ReplaceScenes;
//
//                 //May be unset if on server, this is fine.
//                 NetworkConnection localConnection = NetworkManager.ClientManager.Connection;
//                 /* Immediately set new global scenes. If on client this is whatever
//                  * server passes in. This should be set even if scope type
//                  * is not global because clients might get a connection scene first.
//                  */
//                 if (!asServer)
//                 {
//                     if (!asHost)
//                         _globalScenes = data.GlobalScenes;
//                 }
//                 /* However, if server, then only update global scenes if scope
//                  * is global. */
//                 else if (asServer && data.ScopeType == SceneScopeType.Global)
//                 {
//                     _globalSceneLoadData = sceneLoadData;
//                     string[] names = sceneLoadData.SceneLookupDatas.GetNames();
//                     //Add to server global scenes which are currently loading.
//                     foreach (string item in names)
//                         _serverGlobalScenesLoading.Add(item);
//                     //If replacing.
//                     if (replaceScenes != ReplaceOption.None)
//                     {
//                         _globalScenes = names;
//                     }
//                     //Add onto.
//                     else
//                     {
//                         int index = _globalScenes.Length;
//                         Array.Resize(ref _globalScenes, _globalScenes.Length + names.Length);
//                         Array.Copy(names, 0, _globalScenes, index, names.Length);
//                     }
//                     CheckForDuplicateGlobalSceneNames();
//                     data.GlobalScenes = _globalScenes;
//                 }
//
//
//                 /* Scene queue data scenes.
//                  * All scenes in the scene queue data whether they will be loaded or not. */
//                 List<string> requestedLoadSceneNames = new();
//                 List<int> requestedLoadSceneHandles = new();
//
//                 /* Make a null filled array. This will be populated
//                  * using loaded scenes, or already loaded (eg cannot be loaded) scenes. */
//                 SceneLookupData[] broadcastLookupDatas = new SceneLookupData[sceneLoadData.SceneLookupDatas.Length];
//
//                 /* LoadableScenes and SceneReferenceDatas.
//                 /* Will contain scenes which may be loaded.
//                  * Scenes might not be added to loadableScenes
//                  * if for example loadOnlyUnloaded is true and
//                  * the scene is already loaded. */
//                 List<SceneLookupData> loadableScenes = new();
//                 for (int i = 0; i < sceneLoadData.SceneLookupDatas.Length; i++)
//                 {
//                     SceneLookupData lookupData = sceneLoadData.SceneLookupDatas[i];
//                     //Scene to load.
//                     bool byHandle;
//                     Scene s = lookupData.GetScene(out byHandle);
//                     //If found then add it to requestedLoadScenes.
//                     if (s.IsValid())
//                     {
//                         requestedLoadSceneNames.Add(s.name);
//                         if (byHandle)
//                             requestedLoadSceneHandles.Add(s.handle);
//                     }
//
//                     if (CanLoadScene(data, lookupData))
//                     {
//                         //Don't load if as host, server side would have loaded already.
//                         if (!asHost)
//                             loadableScenes.Add(lookupData);
//                     }
//                     //Only the server needs to find scene handles to send to client. Client will send these back to the server.
//                     else if (asServer)
//                     {
//                         /* If here then scene cannot be loaded, which
//                          * can only happen if the scene already exists.
//                          * Find the scene using sld and set to datas. */
//                         /* Set at the index of i. This way should the current
//                          * SLD not be the first scene it won't fill the
//                          * first slot in broadcastLookupDatas. This is important
//                          * because the first slot is used for the single scene
//                          * when using replace scenes. */
//                         broadcastLookupDatas[i] = new(s);
//                     }
//                 }
//
//                 /* Move identities
//                  * to holder scene to preserve them.
//                  * Required if a single scene is specified. Cannot rely on
//                  * loadSingleScene since it is only true if the single scene
//                  * must be loaded, which may be false if it's already loaded on
//                  * the server. */
//                 //Do not run if running as client, and server is active. This would have already run as server.
//                 if (!asHost)
//                 {
//                     foreach (NetworkObject nob in sceneLoadData.MovedNetworkObjects)
//                     {
//                         //NetworkObject might be null if client lost observation of it.
//                         if (nob != null && CanMoveNetworkObject(nob, true))
//                             UnitySceneManager.MoveGameObjectToScene(nob.gameObject, GetMovedObjectsScene());
//                     }
//                 }
//
//                 //Connection scenes handles prior to ConnectionScenes being modified.
//                 List<int> connectionScenesHandlesCached = new();
//                 //If replacing scenes.
//                 if (replaceScenes != ReplaceOption.None)
//                 {
//                     /* Resetting SceneConnections. */
//                     /* If server and replacing scenes.
//                      * It's important to run this AFTER moving MovedNetworkObjects
//                      * so that they are no longer in the scenes they are leaving. Otherwise
//                      * the scene condition would pick them up as still in the leaving scene. */
//                     if (asServer)
//                     {
//                         Scene[] sceneConnectionsKeys = SceneConnections.Keys.ToArray();
//                         for (int i = 0; i < sceneConnectionsKeys.Length; i++)
//                             connectionScenesHandlesCached.Add(sceneConnectionsKeys[i].handle);
//
//                         //If global then remove all connections from all scenes.
//                         if (data.ScopeType == SceneScopeType.Global)
//                         {
//                             foreach (Scene s in sceneConnectionsKeys)
//                                 RemoveAllConnectionsFromScene(s);
//                         }
//                         //Connections.
//                         else if (data.ScopeType == SceneScopeType.Connections)
//                         {
//                             RemoveConnectionsFromNonGlobalScenes(data.Connections);
//                         }
//                     }
//                     //As client set scenes id cache to local connection scenes.
//                     else
//                     {
//                         foreach (Scene s in NetworkManager.ClientManager.Connection.Scenes)
//                             connectionScenesHandlesCached.Add(s.handle);
//                     }
//                 }
//
//
//                 /* Scene unloading if replacing scenes.
//                  *
//                  * Unload all scenes except MovedObjectsHolder. Also don't
//                  * unload GlobalScenes if loading as connection. */
//                 List<Scene> unloadableScenes = new();
//                 //Do not run if running as client, and server is active. This would have already run as server.
//                 if ((replaceScenes != ReplaceOption.None) && !asHost)
//                 {
//                     //See what scenes can be unloaded based on replace options.
//                     for (int i = 0; i < UnitySceneManager.sceneCount; i++)
//                     {
//                         Scene s = UnitySceneManager.GetSceneAt(i);
//                         //MovedObjectsScene will never be unloaded.
//                         if (s == GetMovedObjectsScene())
//                             continue;
//                         /* Scene is in one of the scenes being loaded.
//                          * This can occur when trying to load additional clients
//                          * into an existing scene. */
//                         if (requestedLoadSceneNames.Contains(s.name))
//                             continue;
//                         //Same as above but using handles.
//                         if (requestedLoadSceneHandles.Contains(s.handle))
//                             continue;
//                         /* Cannot unload global scenes. If
//                          * replace scenes was used for a global
//                          * load then global scenes would have been reset
//                          * before this. */
//                         if (IsGlobalScene(s))
//                             continue;
//                         //If scene must be manually unloaded then it cannot be unloaded here.
//                         if (_manualUnloadScenes.Contains(s))
//                             continue;
//
//                         bool inScenesCache = connectionScenesHandlesCached.Contains(s.handle);
//                         HashSet<NetworkConnection> conns;
//                         bool inScenesCurrent = SceneConnections.ContainsKey(s);
//                         //If was in scenes previously but isnt now then no connections reside in the scene.
//                         if (inScenesCache && !inScenesCurrent)
//                         {
//                             //Intentionally left blank.
//                         }
//                         //If still in cache see if any connections exist.
//                         else if (SceneConnections.TryGetValueIL2CPP(s, out conns))
//                         {
//                             //Still has clients in scene.
//                             if (conns != null && conns.Count > 0)
//                                 continue;
//                         }
//                         //An offline scene.
//                         else
//                         {
//                             //If not replacing all scenes then skip offline scenes.
//                             if (replaceScenes != ReplaceOption.All)
//                                 continue;
//                         }
//
//                         unloadableScenes.Add(s);
//                     }
//                 }
//
//                 /* Start event. */
//                 InvokeOnSceneLoadStart(data);
//                 if (unloadableScenes.Count > 0 || loadableScenes.Count > 0)
//                     _sceneProcessor.LoadStart(data);
//                 //Unloaded scenes by name. Only used for information within callbacks.
//                 string[] unloadedNames = new string[unloadableScenes.Count];
//                 for (int i = 0; i < unloadableScenes.Count; i++)
//                     unloadedNames[i] = unloadableScenes[i].name;
//                 /* Before unloading if !asServer and !asHost and replacing scenes
//                  * then move all non scene networked objects to the moved
//                  * objects holder. Otherwise network objects would get destroyed
//                  * on the scene change and never respawned if server doesn't
//                  * have a reason to update visibility. */
//                 if (!data.AsServer && !asHost && (replaceScenes != ReplaceOption.None))
//                 {
//                     Scene s = GetMovedObjectsScene();
//                     foreach (NetworkObject nob in NetworkManager.ClientManager.Objects.Spawned.Values)
//                     {
//                         if (CanMoveNetworkObject(nob, false))
//                             UnitySceneManager.MoveGameObjectToScene(nob.gameObject, s);
//                     }
//                 }
//                 /* Unloading scenes. */
//                 _sceneProcessor.UnloadStart(data);
//                 for (int i = 0; i < unloadableScenes.Count; i++)
//                 {
//                     MoveClientHostObjects(unloadableScenes[i], asServer);
//                     //Unload one at a time.
//                     _sceneProcessor.BeginUnloadAsync(unloadableScenes[i]);
//                     while (!_sceneProcessor.IsPercentComplete())
//                         yield return null;
//                 }
//                 _sceneProcessor.UnloadEnd(data);
//
//                 //Scenes loaded.
//                 List<Scene> loadedScenes = new();
//                 /* Scene loading.
//                 /* Use additive to not thread lock server. */
//                 for (int i = 0; i < loadableScenes.Count; i++)
//                 {
//                     //Start load async and wait for it to finish.
//                     LoadSceneParameters loadSceneParameters = new()
//                     {
//                         loadSceneMode = LoadSceneMode.Additive,
//                         localPhysicsMode = sceneLoadData.Options.LocalPhysics
//                     };
//
//                     /* How much percentage each scene load can be worth
//                      * at maximum completion. EG: if there are two scenes
//                      * 1f / 2f is 0.5f. */
//                     float maximumIndexWorth = (1f / (float)loadableScenes.Count);
//
//                     _sceneProcessor.BeginLoadAsync(loadableScenes[i].Name, loadSceneParameters);
//                     while (!_sceneProcessor.IsPercentComplete())
//                     {
//                         float percent = _sceneProcessor.GetPercentComplete();
//                         InvokePercentageChange(i, maximumIndexWorth, percent);
//                         yield return null;
//                     }
//
//                     //Invokes OnScenePercentChange with progress.
//                     void InvokePercentageChange(int index, float maximumWorth, float currentScenePercent)
//                     {
//                         /* Total percent will be how much percentage is complete
//                          * in total. Initialize it with a value based on how many
//                          * scenes are already fully loaded. */
//                         float totalPercent = (index * maximumWorth);
//                         //Add this scenes progress onto total percent.
//                         totalPercent += Mathf.Lerp(0f, maximumWorth, currentScenePercent);
//                         //Dispatch with total percent.
//                         InvokeOnScenePercentChange(data, totalPercent);
//                     }
// 
//                     Scene lastLoadedScene = _sceneProcessor.GetLastLoadedScene();
//                     /* If the lastLoadedScene returns default
//                      * then the user is overriding the sceneprocessor
//                      * and has not setup use for this particular API. */
//                     if (lastLoadedScene == default)
//                         lastLoadedScene = UnitySceneManager.GetSceneAt(UnitySceneManager.sceneCount - 1);
//                                             
//                     loadedScenes.Add(lastLoadedScene);
//                     _sceneProcessor.AddLoadedScene(lastLoadedScene);
//                 }

//                 //When all scenes are loaded invoke with 100% done.
//                 InvokeOnScenePercentChange(data, 1f);
//
//                 /* Add to ManuallyUnloadScenes. */
//                 if (data.AsServer && !sceneLoadData.Options.AutomaticallyUnload)
//                 {
//                     foreach (Scene s in loadedScenes)
//                         _manualUnloadScenes.Add(s);
//                 }
//                 /* Move identities to first scene. */
//                 if (!asHost)
//                 {
//                     //Find the first valid scene to move objects to.
//                     Scene firstValidScene = default;
//                     //If to stack scenes.
//                     if (sceneLoadData.Options.AllowStacking)
//                     {
//                         Scene firstScene = sceneLoadData.GetFirstLookupScene();
//                         /* If the first lookup data contains a handle and the scene
//                          * is found for that handle then use that as the moved to scene.
//                          * Nobs always move to the first specified scene. */
//                         if (sceneLoadData.SceneLookupDatas[0].Handle != 0 && !string.IsNullOrEmpty(firstScene.name))
//                         {
//                             firstValidScene = firstScene;
//                         }
//                         //If handle is not specified then used the last scene that has the same name as the first lookupData.
//                         else
//                         {
//                             Scene lastSameSceneName = default;
//                             for (int i = 0; i < UnitySceneManager.sceneCount; i++)
//                             {
//                                 Scene s = UnitySceneManager.GetSceneAt(i);
//                                 if (s.name == firstScene.name)
//                                     lastSameSceneName = s;
//                             }
//
//                             /* Shouldn't be possible since the scene will always exist either by
//                              * just being loaded or already loaded. */
//                             if (string.IsNullOrEmpty(lastSameSceneName.name))
//                                 NetworkManager.LogError($"Scene {sceneLoadData.SceneLookupDatas[0].Name} could not be found in loaded scenes.");
//                             else
//                                 firstValidScene = lastSameSceneName;
//                         }
//                     }
//                     //Not stacking.
//                     else
//                     {
//                         firstValidScene = sceneLoadData.GetFirstLookupScene();
//                         //If not found by look then try firstloaded.
//                         if (string.IsNullOrEmpty(firstValidScene.name))
//                             firstValidScene = GetFirstLoadedScene();
//                     }
//
//                     //Gets first scene loaded this method call.
//                     Scene GetFirstLoadedScene()
//                     {
//                         if (loadedScenes.Count > 0)
//                             return loadedScenes[0];
//                         else
//                             return default;
//                     }
//
//                     //If firstValidScene is still invalid then throw.
//                     if (string.IsNullOrEmpty(firstValidScene.name))
//                     {
//                         NetworkManager.LogError($"Unable to move objects to a new scene because new scene lookup has failed.");
//                     }
//                     //Move objects from movedobejctsscene to first valid scene.
//                     else
//                     {
//                         Scene s = GetMovedObjectsScene();
//                         s.GetRootGameObjects(_movingObjects);
//
//                         foreach (GameObject go in _movingObjects)
//                             UnitySceneManager.MoveGameObjectToScene(go, firstValidScene);
//                     }
//                 }
//
//                 _sceneProcessor.ActivateLoadedScenes();
//                 //Wait until everything is loaded (done).
//                 yield return _sceneProcessor.AsyncsIsDone();
//                 _sceneProcessor.LoadEnd(data);
//
//                 /* Wait until loadedScenes are all marked as done.
//                  * This is an extra precautionary step because on some devices
//                  * the AsyncIsDone returns true before scenes are actually loaded. */
//                 bool allScenesLoaded;
//                 do
//                 {
//                     //Reset state for iteration https://github.com/FirstGearGames/FishNet/issues/322
//                     allScenesLoaded = true;
//                     foreach (Scene s in loadedScenes)
//                     {
//                         if (!s.isLoaded)
//                         {
//                             allScenesLoaded = false;
//                             break;
//                         }
//                     }
//                     yield return null;
//                 } while (!allScenesLoaded);
//
//                 SetActiveScene_Local();
//
//                 void SetActiveScene_Local()
//                 {
//                     bool byUser;
//                     Scene preferredActiveScene = GetUserPreferredActiveScene(sceneLoadData.PreferredActiveScene, asServer, out byUser);
//                     //If preferred still is not set then try to figure it out.
//                     if (!preferredActiveScene.IsValid())
//                     {
//                         bool setToFirstLookup = false;
//                         //If any scenes are being replaced see if active needs to be updated.
//                         if (sceneLoadData.ReplaceScenes != ReplaceOption.None)
//                         {
//                             //If load is for a connection and server isnt started.
//                             setToFirstLookup |= (data.ScopeType == SceneScopeType.Connections && !NetworkManager.IsServerStarted);
//                             /* If current active is the movedObjectsHolder, such as moved objects.
//                              * This can happen when replacing a scene that was active and the next in line is
//                              * set by unity as one of the temp scenes. */
//                             Scene activeScene = UnitySceneManager.GetActiveScene();
//                             setToFirstLookup |= (activeScene == GetMovedObjectsScene());
//                         }
//
//                         if (setToFirstLookup)
//                             preferredActiveScene = sceneLoadData.GetFirstLookupScene();
//                     }
//
//                     SetActiveScene(preferredActiveScene, byUser);
//                 }
//
//                 //Only the server needs to find scene handles to send to client. Client will send these back to the server.
//                 if (asServer)
//                 {
//                     //Populate broadcastLookupDatas with any loaded scenes.
//                     foreach (Scene s in loadedScenes)
//                     {
//                         SetInFirstNullIndex(s);
//
//                         //Sets scene in the first null index of broadcastLookupDatas.
//                         void SetInFirstNullIndex(Scene scene)
//                         {
//                             for (int i = 0; i < broadcastLookupDatas.Length; i++)
//                             {
//                                 if (broadcastLookupDatas[i] == null)
//                                 {
//                                     broadcastLookupDatas[i] = new(scene);
//                                     return;
//                                 }
//                             }
//
//                             //If here there are no null entries.
//                             NetworkManager.LogError($"Cannot add scene to broadcastLookupDatas, collection is full.");
//                         }
//                     }
//                 }
//
//                 /* If running as server and server is
//                  * active then send scene changes to client.
//                  * Making sure server is still active should it maybe
//                  * have dropped during scene loading. */
//                 if (data.AsServer && NetworkManager.IsServerStarted)
//                 {
//                     //Tell clients to load same scenes.
//                     LoadScenesBroadcast msg = new()
//                     {
//                         QueueData = data
//                     };
//
//                     //Replace scene lookup datas with ones intended to broadcast to client.
//                     msg.QueueData.SceneLoadData.SceneLookupDatas = broadcastLookupDatas;
//
//                     /* Build scenes the client will be loading. This is used to
//                      * add the client to pending loading for these scenes.*/
//                     List<Scene> scenes = CollectionCaches<Scene>.RetrieveList();
//                     foreach (SceneLookupData sud in msg.QueueData.SceneLoadData.SceneLookupDatas)
//                         scenes.Add(sud.GetScene(out _));
//
//                     //If networked scope then send to all.
//                     if (data.ScopeType == SceneScopeType.Global)
//                     {
//                         NetworkConnection[] conns = _serverManager.Clients.Values.ToArray();
//                         AddPendingLoad(conns, scenes);
//                         _serverManager.Broadcast(msg, true);
//                     }
//                     //If connections scope then only send to connections.
//                     else if (data.ScopeType == SceneScopeType.Connections)
//                     {
//                         AddPendingLoad(data.Connections, scenes);
//                         for (int i = 0; i < data.Connections.Length; i++)
//                         {
//                             NetworkConnection c = data.Connections[i];
//                             if (c.IsValid() && c.IsAuthenticated)
//                                 data.Connections[i].Broadcast(msg, true);
//                         }
//                     }
//
//                     CollectionCaches<Scene>.Store(scenes);
//                 }
//                 /* If running as client then send a message
//                  * to the server to tell them the scene was loaded.
//                  * This allows the server to add the client
//                  * to the scene for checkers. */
//                 else if (!data.AsServer && NetworkManager.IsClientStarted)
//                 {
//                     //Remove from old scenes.
//                     foreach (Scene item in unloadableScenes)
//                     {
//                         if (item.IsValid())
//                             localConnection.RemoveFromScene(item);
//                     }
//                     //Add local client to scenes.
//                     foreach (Scene item in loadedScenes)
//                         localConnection.AddToScene(item);
//
//                     TryInvokeLoadedStartScenes(_clientManager.Connection, asServer: false);
//
//                     ClientScenesLoadedBroadcast msg = new()
//                     {
//                         SceneLookupDatas = sceneLoadData.SceneLookupDatas
//                     };
//                     _clientManager.Broadcast(msg);
//                 }
//
//                 InvokeOnSceneLoadEnd(data, requestedLoadSceneNames, loadedScenes, unloadedNames);
//             }
//             finally
//             {
//                 _serverGlobalScenesLoading.Clear();
//             }
//         }
//
//         /// <summary>
//         /// Received on client when connection scenes must be loaded.
//         /// </summary>
//         /// <param name="conn"></param>
//         /// <param name="msg"></param>
//         private void OnLoadScenes(LoadScenesBroadcast msg, Channel channel)
//         {
//             //Null data is sent by the server when there are no start scenes to load.
//             if (msg.QueueData == null)
//             {
//                 TryInvokeLoadedStartScenes(_clientManager.Connection, false);
//             }
//             else
//             {
//                 LoadQueueData qd = msg.QueueData;
//                 if (qd.ScopeType == SceneScopeType.Global)
//                     LoadGlobalScenes_Internal(qd.SceneLoadData, qd.GlobalScenes, false);
//                 else
//                     LoadConnectionScenes_Internal(Array.Empty<NetworkConnection>(), qd.SceneLoadData, qd.GlobalScenes, false);
//             }
//         }
//         #endregion
//
//         #region UnloadScenes.
//         /// <summary>
//         /// Unloads scenes on the server and for all clients.
//         /// </summary>
//         /// <param name="sceneUnloadData">Data about which scenes to unload.</param>
//         public void UnloadGlobalScenes(SceneUnloadData sceneUnloadData)
//         {
//             if (!CanExecute(true, true))
//                 return;
//
//             UnloadGlobalScenes_Internal(sceneUnloadData, _globalScenes, true);
//         }
//
//         private void UnloadGlobalScenes_Internal(SceneUnloadData sceneUnloadData, string[] globalScenes, bool asServer)
//         {
//             UnloadQueueData uqd = new(SceneScopeType.Global, Array.Empty<NetworkConnection>(), sceneUnloadData, globalScenes, asServer);
//             QueueOperation(uqd);
//         }
//
//         /// <summary>
//         /// Unloads scenes on server and tells a connection to unload them as well. Other connections will not unload this scene.
//         /// </summary>
//         /// <param name="connection">Connection to unload scenes for.</param>
//         /// <param name="sceneUnloadData">Data about which scenes to unload.</param>
//         public void UnloadConnectionScenes(NetworkConnection connection, SceneUnloadData sceneUnloadData)
//         {
//             //This cannot use cache because the array will persist for many frames after this method completion.
//             UnloadConnectionScenes(new NetworkConnection[] { connection }, sceneUnloadData);
//         }
//
//         /// <summary>
//         /// Unloads scenes on server and tells connections to unload them as well. Other connections will not unload this scene.
//         /// </summary>
//         /// <param name="connections">Connections to unload scenes for.</param>
//         /// <param name="sceneUnloadData">Data about which scenes to unload.</param>
//         public void UnloadConnectionScenes(NetworkConnection[] connections, SceneUnloadData sceneUnloadData)
//         {
//             UnloadConnectionScenes_Internal(connections, sceneUnloadData, _globalScenes, true);
//         }
//
//         /// <summary>
//         /// Unloads scenes on server without telling any connections to unload them.
//         /// </summary>
//         /// <param name="sceneUnloadData">Data about which scenes to unload.</param>
//         public void UnloadConnectionScenes(SceneUnloadData sceneUnloadData)
//         {
//             UnloadConnectionScenes_Internal(Array.Empty<NetworkConnection>(), sceneUnloadData, _globalScenes, true);
//         }
//
//         private void UnloadConnectionScenes_Internal(NetworkConnection[] connections, SceneUnloadData sceneUnloadData, string[] globalScenes, bool asServer)
//         {
//             if (!CanExecute(asServer, true))
//                 return;
//             if (SceneDataInvalid(sceneUnloadData, true))
//                 return;
//
//             UnloadQueueData uqd = new(SceneScopeType.Connections, connections, sceneUnloadData, globalScenes, asServer);
//             QueueOperation(uqd);
//         }
//
//         /// <summary>
//         /// Loads scenes within QueuedSceneLoads.
//         /// </summary>
//         /// <returns></returns>
//         private IEnumerator __UnloadScenes()
//         {
//             UnloadQueueData data = _queuedOperations[0] as UnloadQueueData;
//             SceneUnloadData sceneUnloadData = data.SceneUnloadData;
//
//             //If connection went inactive.
//             if (!ConnectionActive(data.AsServer))
//                 yield break;
//
//             /* Some actions should not run as client if server is also active.
//              * This is to keep things from running twice. */
//             bool asClientHost = (!data.AsServer && NetworkManager.IsServerStarted);
//             ///True if running asServer.
//             bool asServer = data.AsServer;
//
//             //Get scenes to unload.
//             Scene[] scenes = GetScenes(sceneUnloadData.SceneLookupDatas);
//             /* No scenes found. Only run this if not asHost.
//              * While asHost scenes will possibly not exist because
//              * server side has already unloaded them. But rest of
//              * the unload should continue. */
//             if (scenes.Length == 0 && !asClientHost)
//             {
//                 NetworkManager.LogWarning($"Scene lookup data of length {sceneUnloadData.SceneLookupDatas.Length} could not find any scenes to unload. This may occur when trying to unload a scene only by handle. Consider using the scene reference or handle and name while creating SceneLookupData.");
//                 yield break;
//             }
//
//             /* Remove from global scenes
//              * if server and scope is global.
//              * All passed in scenes should be removed from global
//              * regardless of if they're valid or not. If they are invalid,
//              * then they shouldn't be in global to begin with. */
//             if (asServer && data.ScopeType == SceneScopeType.Global)
//             {
//                 RemoveFromGlobalScenes(sceneUnloadData.SceneLookupDatas);
//                 //Update queue data.
//                 data.GlobalScenes = _globalScenes;
//             }
//
//             /* Remove connections. */
//             if (asServer)
//             {
//                 foreach (Scene s in scenes)
//                 {
//                     //If global then remove all connections.
//                     if (data.ScopeType == SceneScopeType.Global)
//                         RemoveAllConnectionsFromScene(s);
//                     //Connections.
//                     else if (data.ScopeType == SceneScopeType.Connections)
//                         RemoveConnectionsFromScene(data.Connections, s);
//                 }
//             }
//
//
//             /* This will contain all scenes which can be unloaded.
//              * The collection will be modified through various checks. */
//             List<Scene> unloadableScenes = scenes.ToList();
//             /* Unloaded scenes manually created to overcome
//              * the empty names in Scene structs after Unity unloads
//              * a scene. */
//             List<UnloadedScene> unloadedScenes = new();
//             /* If asServer and KeepUnused then clear all unloadables.
//              * The clients will still unload the scenes. */
//             if ((asServer || asClientHost) && sceneUnloadData.Options.Mode == UnloadOptions.ServerUnloadMode.KeepUnused)
//                 unloadableScenes.Clear();
//             //If clientOnly then force mode to unloadUnused.
//             else if (!asServer && !asClientHost)
//                 sceneUnloadData.Options.Mode = UnloadOptions.ServerUnloadMode.UnloadUnused;
//             /* Check to remove global scenes unloadableScenes.
//              * This will need to be done if scenes are being unloaded
//              * for connections. Global scenes cannot be unloaded as
//              * connection. */
//             if (data.ScopeType == SceneScopeType.Connections)
//                 RemoveGlobalScenes(unloadableScenes);
//             //If set to unload unused only.
//             if (sceneUnloadData.Options.Mode == UnloadOptions.ServerUnloadMode.UnloadUnused)
//                 RemoveOccupiedScenes(unloadableScenes);
//
//             //If there are scenes to unload.
//             if (unloadableScenes.Count > 0)
//             {
//                 InvokeOnSceneUnloadStart(data);
//                 _sceneProcessor.UnloadStart(data);
//
//                 //Begin unloading.
//                 foreach (Scene s in unloadableScenes)
//                 {
//                     if (!s.IsValid())
//                     {
//                         NetworkManager.LogWarning($"A scene was expected to be unloaded but could not due to it's referening going missing. This usually occurs when the same scene has been queued for unloading multiple times.");
//                         continue;
//                     }
//
//                     unloadedScenes.Add(new(s));
//                     MoveClientHostObjects(s, asServer);
//                     /* Remove from manualUnloadedScenes.
//                      * Scene may not be in this collection
//                      * but removing is one call vs checking
//                      * then removing. */
//                     _manualUnloadScenes.Remove(s);
//
//                     _sceneProcessor.BeginUnloadAsync(s);
//                     while (!_sceneProcessor.IsPercentComplete())
//                         yield return null;
//                 }
//
//                 _sceneProcessor.UnloadEnd(data);
//             }
//
//             /* Must yield after sceneProcessor handles things.
//              * This is a Unity bug of sorts. I'm not entirely sure what
//              * is happening, but without the yield it seems as though
//              * the processor logic doesn't complete. This doesn't make much
//              * sense given unity is supposed to be single threaded. Must be
//              * something to do with the coroutine. */
//             yield return null;
//
//             bool byUser;
//             Scene preferredActiveScene = GetUserPreferredActiveScene(sceneUnloadData.PreferredActiveScene, asServer, out byUser);
//             SetActiveScene(preferredActiveScene, byUser);
//
//             /* If running as server then make sure server
//              * is still active after the unloads. If so
//              * send out unloads to clients. */
//             if (asServer && ConnectionActive(true))
//             {
//                 //Tell clients to unload same scenes.
//                 UnloadScenesBroadcast msg = new()
//                 {
//                     QueueData = data
//                 };
//                 //Global.
//                 if (data.ScopeType == SceneScopeType.Global)
//                 {
//                     _serverManager.Broadcast(msg, true);
//                 }
//                 //Connections.
//                 else if (data.ScopeType == SceneScopeType.Connections)
//                 {
//                     if (data.Connections != null)
//                     {
//                         for (int i = 0; i < data.Connections.Length; i++)
//                         {
//                             NetworkConnection conn = data.Connections[i];
//                             //Would not be null from internals, but users might incorrectly pass null in.
//                             if (conn.IsValid())
//                                 data.Connections[i].Broadcast(msg, true);
//                         }
//                     }
//                 }
//             }
//             else if (!asServer)
//             {
//                 NetworkConnection localConnection = NetworkManager.ClientManager.Connection;
//                 //Remove from old scenes.
//                 foreach (Scene item in unloadableScenes)
//                 {
//                     if (item.IsValid())
//                         localConnection.RemoveFromScene(item);
//                 }
//             }
//
//             InvokeOnSceneUnloadEnd(data, unloadableScenes, unloadedScenes);
//         }
//
//         /// <summary>
//         /// Received on clients when networked scenes must be unloaded.
//         /// </summary>
//         /// <param name="conn"></param>
//         /// <param name="msg"></param>
//         private void OnUnloadScenes(UnloadScenesBroadcast msg, Channel channel)
//         {
//             UnloadQueueData qd = msg.QueueData;
//             if (qd.ScopeType == SceneScopeType.Global)
//                 UnloadGlobalScenes_Internal(qd.SceneUnloadData, qd.GlobalScenes, false);
//             else
//                 UnloadConnectionScenes_Internal(Array.Empty<NetworkConnection>(), qd.SceneUnloadData, qd.GlobalScenes, false);
//         }
//         #endregion
//
//         /// <summary>
//         /// Move objects visible to clientHost that are within an unloading scene.This ensures the objects are despawned on the client side rather than when the scene is destroyed.
//         /// </summary>
//         /// <param name="scene"></param>
//         private void MoveClientHostObjects(Scene scene, bool asServer)
//         {
//             if (!_moveClientObjects)
//                 return;
//             /* The asServer isn't really needed. I could only call
//              * this method when asServer is true. But for the sake
//              * of preventing user-error (me being the user this time)
//              * I've included it into the parameters. */
//             if (!asServer)
//                 return;
//             //Don't need to perform if not host.
//             if (!NetworkManager.IsClientStarted)
//                 return;
//
//             NetworkConnection clientConn = NetworkManager.ClientManager.Connection;
//             /* It would be nice to see if the client wasn't even in the scene
//              * here using SceneConnections but it's possible that the scene had been
//              * wiped from SceneConnections earlier depending on how scenes are
//              * loaded or unloaded. Instead we must iterate through spawned objects. */
//
//             List<NetworkObject> movingNobs = CollectionCaches<NetworkObject>.RetrieveList();
//             /* Rather than a get all networkobjects in scene
//              * let's iterate the spawned objects instead. I imagine
//              * in most scenarios iterating spawned would be faster.
//              * That's a long one! */
//             foreach (NetworkObject nob in NetworkManager.ServerManager.Objects.Spawned.Values)
//             {
//                 //Not in the scene being destroyed.
//                 if (nob.gameObject.scene != scene)
//                     continue;
//                 //ClientHost doesn't have visibility.
//                 if (!nob.Observers.Contains(clientConn))
//                     continue;
//                 //Cannot move if not root.
//                 if (nob.transform.root != null)
//                     continue;
//
//                 /* If here nob is in the same being
//                  * destroyed and clientHost has visiblity. */
//                 movingNobs.Add(nob);
//             }
//
//             int count = movingNobs.Count;
//             if (count > 0)
//             {
//                 Scene moveScene = GetDelayedDestroyScene();
//                 for (int i = 0; i < count; i++)
//                 {
//                     NetworkObject nob = movingNobs[i];
//                     /* Force as not a scene object
//                      * so that it becomes destroyed
//                      * rather than disabled. */
//                     nob.ClearRuntimeSceneObject();
//                     /* If the object is already being despawned then
//                      *just disable and move it. Otherwise despawn it
//                      * on the server then move it. */
//                     //Not deinitializing, despawn it then.
//                     if (!nob.IsDeinitializing)
//                         nob.Despawn();
//                     else
//                         nob.gameObject.SetActive(false);
//
//                     UnitySceneManager.MoveGameObjectToScene(nob.gameObject, moveScene);
//                 }
//             }
//             CollectionCaches<NetworkObject>.Store(movingNobs);
//         }
//
//         /// <summary>
//         /// Returns if a connection is in a scene using SceneConnections.
//         /// </summary>
//         /// <param name="conn"></param>
//         /// <param name="scene"></param>
//         /// <returns></returns>
//         internal bool InSceneConnections(NetworkConnection conn, Scene scene)
//         {
//             if (!SceneConnections.TryGetValueIL2CPP(scene, out HashSet<NetworkConnection> hs))
//                 return false;
//             else
//                 return hs.Contains(conn);
//         }
//
//         /// <summary>
//         /// Adds the owner of nob to the gameObjects scene if there are no global scenes.
//         /// </summary>
//         public void AddOwnerToDefaultScene(NetworkObject nob)
//         {
//             //No owner.
//             if (!nob.Owner.IsValid)
//             {
//                 NetworkManager.LogWarning($"NetworkObject {nob.name} does not have an owner.");
//                 return;
//             }
//             //Won't add to default if there are globals.
//             if (_globalScenes.Length > 0)
//                 return;
//
//             AddConnectionToScene(nob.Owner, nob.gameObject.scene);
//         }
//
//         /// <summary>
//         /// Adds a connection to a scene. This will always be called one connection at a time because connections are only added after they invidually validate loading the scene.
//         /// Exposed for power users, use caution.
//         /// </summary>
//         /// <param name="conn">Connection to add.</param>
//         /// <param name="scene">Scene to add the connection to.</param>
//         public void AddConnectionToScene(NetworkConnection conn, Scene scene)
//         {
//             if (!conn.IsValid())
//                 return;
//             if (!scene.isLoaded || !scene.IsValid())
//             {
//                 NetworkManager.LogError($"Only valid, loaded scenes may be used.");
//                 return;
//             }
//
//             HashSet<NetworkConnection> hs;
//             //Scene doesn't have any connections yet.
//             bool inSceneConnections = SceneConnections.TryGetValueIL2CPP(scene, out hs);
//             if (!inSceneConnections)
//                 hs = new();
//
//             bool added = hs.Add(conn);
//             if (added)
//             {
//                 conn.AddToScene(scene);
//
//                 //If not yet added to scene connections.
//                 if (!inSceneConnections)
//                     SceneConnections[scene] = hs;
//
//                 NetworkConnection[] arrayConn = new NetworkConnection[] { conn };
//                 InvokeClientPresenceChange(scene, arrayConn, true, true);
//                 RebuildObservers(arrayConn);
//                 InvokeClientPresenceChange(scene, arrayConn, true, false);
//
//                 /* Also need to rebuild all networkobjects
//                  * for connection so other players can
//                  * see them. */
//                 RebuildObservers(conn.Objects.ToArray());
//             }
//         }
//
//         /// <summary>
//         /// Removes connections from any scene which is not global.
//         /// Exposed for power users, use caution.
//         /// </summary>
//         /// <param name="conns"></param>
//         public void RemoveConnectionsFromNonGlobalScenes(NetworkConnection[] conns)
//         {
//             List<Scene> removedScenes = new();
//
//             foreach (KeyValuePair<Scene, HashSet<NetworkConnection>> item in SceneConnections)
//             {
//                 Scene scene = item.Key;
//                 //Cannot remove from globla scenes.
//                 if (IsGlobalScene(scene))
//                     continue;
//
//                 HashSet<NetworkConnection> hs = item.Value;
//                 List<NetworkConnection> connectionsRemoved = new();
//                 //Remove every connection from the scene.
//                 foreach (NetworkConnection c in conns)
//                 {
//                     if (!c.IsValid())
//                         continue;
//
//                     bool removed = hs.Remove(c);
//                     if (removed)
//                     {
//                         c.RemoveFromScene(scene);
//                         connectionsRemoved.Add(c);
//                     }
//                 }
//
//                 //If hashset is empty then remove scene from SceneConnections.
//                 if (hs.Count == 0)
//                     removedScenes.Add(scene);
//
//                 if (connectionsRemoved.Count > 0)
//                 {
//                     InvokeClientPresenceChange(scene, connectionsRemoved, false, true);
//                     RebuildObservers(connectionsRemoved);
//                     InvokeClientPresenceChange(scene, connectionsRemoved, false, false);
//                 }
//             }
//
//             foreach (Scene s in removedScenes)
//                 SceneConnections.Remove(s);
//
//             /* Also rebuild observers for objects owned by connection.
//              * This ensures other connections will lose visibility if
//              * they no longer share a scene. */
//             foreach (NetworkConnection c in conns)
//                 RebuildObservers(c.Objects.ToArray());
//         }
//
//         /// <summary>
//         /// Removes connections from specified scenes.
//         /// Exposed for power users, use caution.
//         /// </summary>
//         /// <param name="conns">Connections to remove.</param>
//         /// <param name="scene">Scene to remove from.</param>
//         public void RemoveConnectionsFromScene(NetworkConnection[] conns, Scene scene)
//         {
//             HashSet<NetworkConnection> hs;
//             //No hashset for scene, so no connections are in scene.
//             if (!SceneConnections.TryGetValueIL2CPP(scene, out hs))
//                 return;
//
//             List<NetworkConnection> connectionsRemoved = new();
//             //Remove every connection from the scene.
//             foreach (NetworkConnection c in conns)
//             {
//                 if (!c.IsValid())
//                     continue;
//
//                 bool removed = hs.Remove(c);
//                 if (removed)
//                 {
//                     c.RemoveFromScene(scene);
//                     connectionsRemoved.Add(c);
//                 }
//             }
//
//             //If hashset is empty then remove scene from SceneConnections.
//             if (hs.Count == 0)
//                 SceneConnections.Remove(scene);
//
//             if (connectionsRemoved.Count > 0)
//             {
//                 NetworkConnection[] connectionsRemovedArray = connectionsRemoved.ToArray();
//                 InvokeClientPresenceChange(scene, connectionsRemovedArray, false, true);
//                 RebuildObservers(connectionsRemovedArray);
//                 InvokeClientPresenceChange(scene, connectionsRemovedArray, false, false);
//             }
//
//             /* Also rebuild observers for objects owned by connection.
//              * This ensures other connections will lose visibility if
//              * they no longer share a scene. */
//             foreach (NetworkConnection c in conns)
//                 RebuildObservers(c.Objects.ToArray());
//         }
//
//         /// <summary>
//         /// Removes all connections from a scene.
//         /// </summary>
//         /// <param name="scene">Scene to remove connections from.</param>
//         public void RemoveAllConnectionsFromScene(Scene scene)
//         {
//             HashSet<NetworkConnection> hs;
//             //No hashset for scene, so no connections are in scene.
//             if (!SceneConnections.TryGetValueIL2CPP(scene, out hs))
//                 return;
//
//             //On each connection remove them from specified scene.
//             foreach (NetworkConnection c in hs)
//                 c.RemoveFromScene(scene);
//             //Make hashset into list for presence change.
//             NetworkConnection[] connectionsRemoved = hs.ToArray();
//
//             //Clear hashset and remove entry from sceneconnections.
//             hs.Clear();
//             SceneConnections.Remove(scene);
//
//             if (connectionsRemoved.Length > 0)
//             {
//                 InvokeClientPresenceChange(scene, connectionsRemoved, false, true);
//                 RebuildObservers(connectionsRemoved);
//                 InvokeClientPresenceChange(scene, connectionsRemoved, false, false);
//             }
//
//             /* Also rebuild observers for objects owned by connection.
//              * This ensures other connections will lose visibility if
//              * they no longer share a scene. */
//             foreach (NetworkConnection c in connectionsRemoved)
//                 RebuildObservers(c.Objects.ToArray());
//         }
//
//         #region Can Load/Unload Scene.
//         /// <summary>
//         /// Returns if a scene can be loaded locally.
//         /// </summary>
//         /// <returns></returns>
//         private bool CanLoadScene(LoadQueueData qd, SceneLookupData sld)
//         {
//             bool foundByHandle;
//             Scene s = sld.GetScene(out foundByHandle);
//             //Try to find if scene is already loaded.
//             bool alreadyLoaded = !string.IsNullOrEmpty(s.name);
//
//             if (alreadyLoaded)
//             {
//                 //Only servers can load the same scene multiple times for stacking.
//                 if (!qd.AsServer)
//                     return false;
//                 //If can only load scenes which aren't loaded yet and scene is already loaded.
//                 if (!qd.SceneLoadData.Options.AllowStacking)
//                     return false;
//                 /* Found by handle, this means the user is trying to specify
//                  * exactly which scene to load into. When a handle is specified
//                  * new instances will not be created, so a new scene cannot
//                  * be loaded. */
//                 if (alreadyLoaded && foundByHandle)
//                     return false;
//             }
//
//             //Fall through.
//             return true;
//         }
//         #endregion
//
//         #region Helpers.
//         /// <summary>
//         /// Rebuilds observers for networkObjects.
//         /// </summary>
//         /// <param name="networkObjects"></param>
//         private void RebuildObservers(IList<NetworkObject> networkObjects)
//         {
//             NetworkObject nob;
//             int count = networkObjects.Count;
//             for (int i = 0; i < count; i++)
//             {
//                 nob = networkObjects[i];
//                 if (nob != null && nob.IsSpawned)
//                     _serverManager.Objects.RebuildObservers(nob);
//             }
//         }
//
//         /// <summary>
//         /// Rebuilds all NetworkObjects for connection.
//         /// </summary>
//         internal void RebuildObservers(NetworkConnection connection)
//         {
//             List<NetworkConnection> connCache = CollectionCaches<NetworkConnection>.RetrieveList(connection);
//             RebuildObservers(connCache);
//             CollectionCaches<NetworkConnection>.Store(connCache);
//         }
//
//         /// <summary>
//         /// Rebuilds all NetworkObjects for connections.
//         /// </summary>
//         internal void RebuildObservers(IList<NetworkConnection> connections)
//         {
//             int count = connections.Count;
//             for (int i = 0; i < count; i++)
//                 _serverManager.Objects.RebuildObservers(connections[i]);
//         }
//
//         /// <summary>
//         /// Invokes OnClientPresenceChange start or end.
//         /// </summary>
//         private void InvokeClientPresenceChange(Scene scene, IList<NetworkConnection> conns, bool added, bool start)
//         {
//             NetworkConnection c;
//             int count = conns.Count;
//             for (int i = 0; i < count; i++)
//             {
//                 c = conns[i];
//                 ClientPresenceChangeEventArgs cpc = new(scene, c, added);
//                 if (start)
//                     OnClientPresenceChangeStart?.Invoke(cpc);
//                 else
//                     OnClientPresenceChangeEnd?.Invoke(cpc);
//             }
//         }
//         #endregion
//
//         #region GetScene.
//         /// <summary>
//         /// Gets scenes from SceneLookupData.
//         /// </summary>
//         /// <param name="datas"></param>
//         /// <returns></returns>
//         private Scene[] GetScenes(SceneLookupData[] datas)
//         {
//             List<Scene> result = new();
//             foreach (SceneLookupData sld in datas)
//             {
//                 Scene s = sld.GetScene(out _);
//                 if (!string.IsNullOrEmpty(s.name))
//                 {
//                     result.Add(s);
//                 }
//             }
//
//             return result.ToArray();
//         }
//
//         /// <summary>
//         /// Returns a scene by name.
//         /// </summary>
//         /// <param name="sceneName">Name of scene to retrieve.</param>
//         /// <param name="nm">NetworkManager to use for debug print. This value may be left null.</param>
//         /// <param name="warnIfDuplicates">True to warn if scene name is found loaded multiple times.</param>
//         /// <returns></returns>
//         public static Scene GetScene(string sceneName, NetworkManager nm = null, bool warnIfDuplicates = true)
//         {
//             Scene result = default;
//             sceneName = sceneName.ToLower();
//
//             int count = UnitySceneManager.sceneCount;
//             for (int i = 0; i < count; i++)
//             {
//                 Scene s = UnitySceneManager.GetSceneAt(i);
//                 //Matches.
//                 if (s.name.ToLower() == sceneName)
//                 {
//                     //If result is already set.
//                     if (result.IsValid())
//                     {
//                         if (warnIfDuplicates)
//                         {
//                             string msg = $"Scene name {s.name} is loaded multiple times. The first scene found will be returned. If you wish to unload multiple instances of a scene with the same name create {nameof(SceneLookupData)} using scene handles instead of name.";
//                             nm.LogWarning(msg);
//                             //No need to spam the message, break on first duplicate.
//                             break;
//                         }
//                     }
//                     else
//                     {
//                         result = s;
//                     }
//                 }
//             }
//
//             return result;
//         }
//
//         /// <summary>
//         /// Returns a scene by handle.
//         /// </summary>
//         /// <param name="sceneHandle"></param>
//         /// <returns></returns>
//         public static Scene GetScene(int sceneHandle)
//         {
//             int count = UnitySceneManager.sceneCount;
//             for (int i = 0; i < count; i++)
//             {
//                 Scene s = UnitySceneManager.GetSceneAt(i);
//                 if (s.handle == sceneHandle)
//                     return s;
//             }
//
//             return new();
//         }
//         #endregion
//
//         /// <summary>
//         /// Returns if GlobalScenes contains scene.
//         /// </summary>
//         /// <param name="s"></param>
//         /// <returns></returns>
//         private bool IsGlobalScene(Scene scene)
//         {
//             foreach (string item in _globalScenes)
//             {
//                 string nameOnly = System.IO.Path.GetFileNameWithoutExtension(item);
//                 if (item == scene.name || nameOnly == scene.name)
//                     return true;
//             }
//             return false;
//         }
//
//         /// <summary>
//         /// Warns if any scene names in GlobalScenes are unsupported.
//         /// This only applies to FishNet version 3.
//         /// </summary>
//         private void CheckForDuplicateGlobalSceneNames()
//         {
//             /* This is being removed between version 4.0.0 to 4.1.0 */
//             HashSet<string> namesOnly = CollectionCaches<string>.RetrieveHashSet();
//             foreach (string item in _globalScenes)
//             {
//                 string name = System.IO.Path.GetFileNameWithoutExtension(item);
//                 if (namesOnly.Contains(name))
//                 {
//                     NetworkManager.LogWarning($"There are multiple global scenes loaded with the same NameOnly. This occurs when a global scene has the same name as another but resides in a different folder path. Each global scene name must be unique.");
//                     break;
//                 }
//                 else
//                 {
//                     namesOnly.Add(name);
//                 }
//             }
//         }
//
//         /// <summary>
//         /// Removes datas from GlobalScenes.
//         /// </summary>
//         /// <param name="scenes"></param>
//         private void RemoveFromGlobalScenes(Scene scene)
//         {
//             RemoveFromGlobalScenes(new SceneLookupData[] { SceneLookupData.CreateData(scene) });
//         }
//
//         /// <summary>
//         /// Removes datas from GlobalScenes.
//         /// </summary>
//         /// <param name="scenes"></param>
//         private void RemoveFromGlobalScenes(SceneLookupData[] datas)
//         {
//             List<string> newGlobalScenes = _globalScenes.ToList();
//             int startCount = newGlobalScenes.Count;
//             //Remove scenes.
//             for (int i = 0; i < datas.Length; i++)
//                 newGlobalScenes.Remove(datas[i].Name);
//
//             //If any were removed remake globalscenes.
//             if (startCount != newGlobalScenes.Count)
//                 _globalScenes = newGlobalScenes.ToArray();
//         }
//
//         /// <summary>
//         /// Removes GlobalScenes from scenes.
//         /// </summary>
//         /// <param name="scenes"></param>
//         /// <returns></returns>
//         private void RemoveGlobalScenes(List<Scene> scenes)
//         {
//             for (int i = 0; i < scenes.Count; i++)
//             {
//                 foreach (string gs in _globalScenes)
//                 {
//                     if (gs == scenes[i].name)
//                     {
//                         scenes.RemoveAt(i);
//                         i--;
//                     }
//                 }
//             }
//         }
//
//         /// <summary>
//         /// Removes occupied scenes from scenes.
//         /// </summary>
//         /// <param name="scenes"></param>
//         private void RemoveOccupiedScenes(List<Scene> scenes)
//         {
//             for (int i = 0; i < scenes.Count; i++)
//             {
//                 Scene currentScene = scenes[i];
//                 /* If any connections are in the scene being checked
//                  * then remove from scenes. */
//                 if (SceneConnections.TryGetValueIL2CPP(currentScene, out _))
//                 {
//                     RemoveAndSubtractIndex(ref i);
//                 }
//                 /* Not in scene connections, see if any connection has
//                  * the scene pending load. */
//                 else
//                 {
//                     foreach (HashSet<Scene> pendingScenes in _pendingClientSceneChanges.Values)
//                     {
//                         if (pendingScenes.Contains(currentScene))
//                         {
//                             RemoveAndSubtractIndex(ref i);
//                             /* No need to keep checking pending for currentScene
//                              * since it was removed from scenes. */
//                             break;
//                         }
//                     }
//                 }
//             }
//
//             void RemoveAndSubtractIndex(ref int index)
//             {
//                 scenes.RemoveAt(index--);
//             }
//         }
//
//         /// <summary>
//         /// Adds a pending load for a connection.
//         /// </summary>
//         private void AddPendingLoad(NetworkConnection conn, List<Scene> scenes)
//         {
//             NetworkConnection[] conns = CollectionCaches<NetworkConnection>.RetrieveArray();
//             if (conns.Length == 0)
//                 conns = new NetworkConnection[1];
//             conns[0] = conn;
//
//             AddPendingLoad(conns, scenes);
//             CollectionCaches<NetworkConnection>.Store(conns, 1);
//         }
//
//         /// <summary>
//         /// Adds a pending load for a connection.
//         /// </summary>
//         private void AddPendingLoad(NetworkConnection[] conns, List<Scene> scenes)
//         {
//             foreach (NetworkConnection c in conns)
//             {
//                 /* Make sure connection is active. This should always be true
//                  * but perhaps disconnect happened as scene was loading on server
//                  * therefor it cannot be sent to the client.
//                  * Also only authenticated clients can load scenes. */
//                 if (!c.IsActive || !c.IsAuthenticated)
//                     continue;
//
//                 HashSet<Scene> pendingScenes;
//                 if (!_pendingClientSceneChanges.TryGetValueIL2CPP(c, out pendingScenes))
//                 {
//                     pendingScenes = CollectionCaches<Scene>.RetrieveHashSet();
//                     _pendingClientSceneChanges[c] = pendingScenes;
//                 }
//
//                 foreach (Scene scene in scenes)
//                     pendingScenes.Add(scene);
//             }
//         }
//
//         /// <summary>
//         /// Sets the first global scene as the active scene.
//         /// If a global scene is not available then FallbackActiveScene is used.
//         /// </summary>
//         private void SetActiveScene(Scene preferredScene = default, bool byUser = false)
//         {
//             //If user specified then skip figuring it out checks.
//             if (byUser && preferredScene.IsValid())
//             {
//                 CompleteSetActive(preferredScene);
//             }
//             //Setting active scene is not used.
//             else if (!_setActiveScene)
//             {
//                 //Still invoke event with current scene.
//                 Scene s = UnitySceneManager.GetActiveScene();
//                 CompleteSetActive(s);
//                 return;
//             }
//             //Need to figure out which scene to use.
//             else
//             {
//                 Scene s = default;
//
//                 if (_globalScenes.Length > 0)
//                     s = GetScene(_globalScenes[0], NetworkManager, false);
//                 else if (preferredScene.IsValid())
//                     s = preferredScene;
//
//                 /* If scene isn't set from global then make
//                  * sure currently active isn't the movedobjectscene.
//                  * If it is, then use the fallback scene. */
//                 if (string.IsNullOrEmpty(s.name) && UnitySceneManager.GetActiveScene() == _movedObjectsScene)
//                     s = GetFallbackActiveScene();
//
//                 CompleteSetActive(s);
//             }
//
//             //Completes setting the active scene with specified value.
//             void CompleteSetActive(Scene scene)
//             {
//                 bool sceneValid = scene.IsValid();
//                 if (sceneValid)
//                     UnitySceneManager.SetActiveScene(scene);
//
//                 OnActiveSceneSet?.Invoke(byUser);
//                 OnActiveSceneSetInternal?.Invoke();
//
//                 if (sceneValid)
//                 {
//                     //Also update light probes.
//                     if (_lightProbeUpdating == LightProbeUpdateType.Asynchronous)
//                         LightProbes.TetrahedralizeAsync();
//                     else if (_lightProbeUpdating == LightProbeUpdateType.BlockThread)
//                         LightProbes.Tetrahedralize();
//                 }
//             }
//         }
//
//         /// <summary>
//         /// Returns the FallbackActiveScene.
//         /// </summary>
//         /// <returns></returns>
//         private Scene GetFallbackActiveScene() => _sceneProcessor.GetFallbackActiveScene();
//
//         /// <summary>
//         /// Returns the MovedObjectsScene.
//         /// </summary>
//         /// <returns></returns>
//         private Scene GetMovedObjectsScene() => _sceneProcessor.GetMovedObjectsScene();
//
//         /// <summary>
//         /// Returns the DelayedDestroyScene.
//         /// </summary>
//         /// <returns></returns>
//         private Scene GetDelayedDestroyScene() => _sceneProcessor.GetDelayedDestroyScene();
//
//         /// <summary>
//         /// Returns a preferred active scene to use.
//         /// </summary>
//         private Scene GetUserPreferredActiveScene(PreferredScene ps, bool asServer, out bool byUser)
//         {
//             byUser = false;
//             SceneLookupData sld = (asServer) ? ps.Server : ps.Client;
//             //Not specified.
//             if (sld == null)
//                 return default;
//
//             Scene s = sld.GetScene(out _);
//             if (s.IsValid())
//                 byUser = true;
//             return s;
//         }
//
//         #region Sanity checks.
//         /// <summary>
//         /// Returns if iterating queue.
//         /// True will be returned even if not iterating queue if the iteration had completed with the time requirement.
//         internal bool IsIteratingQueue(float completionTimeRequirement = 0f)
//         {
//             return (IteratingQueue || (Time.unscaledTime - QueueCompleteTime) < completionTimeRequirement);
//         }
//
//         /// <summary>
//         /// Returns if a SceneLoadData is valid.
//         /// </summary>
//         /// <param name="data"></param>
//         /// <param name="error"></param>
//         /// <returns></returns>
//         private bool SceneDataInvalid(SceneLoadData data, bool error)
//         {
//             bool result = data.DataInvalid();
//             if (result && error)
//                 NetworkManager.LogError(INVALID_SCENELOADDATA);
//
//             return result;
//         }
//
//         /// <summary>
//         /// Returns if a SceneLoadData is valid.
//         /// </summary>
//         /// <param name="data"></param>
//         /// <param name="error"></param>
//         /// <returns></returns>
//         private bool SceneDataInvalid(SceneUnloadData data, bool error)
//         {
//             bool result = data.DataInvalid();
//             if (result && error)
//                 NetworkManager.LogError(INVALID_SCENEUNLOADDATA);
//
//
//             return result;
//         }
//
//         /// <summary>
//         /// Returns if connection is active for server or client in association with AsServer.
//         /// </summary>
//         /// <param name="asServer"></param>
//         /// <returns></returns>
//         private bool ConnectionActive(bool asServer)
//         {
//             return (asServer) ? NetworkManager.IsServerStarted : NetworkManager.IsClientStarted;
//         }
//
//         /// <summary>
//         /// Returns if a method can execute.
//         /// </summary>
//         /// <param name="asServer"></param>
//         /// <param name="warn"></param>
//         /// <returns></returns>
//         private bool CanExecute(bool asServer, bool warn)
//         {
//             bool result;
//             if (asServer)
//             {
//                 result = NetworkManager.IsServerStarted;
//                 if (!result && warn)
//                     NetworkManager.LogWarning($"Method cannot be called as the server is not active.");
//             }
//             else
//             {
//                 result = NetworkManager.IsClientStarted;
//                 if (!result && warn)
//                     NetworkManager.LogWarning($"Method cannot be called as the client is not active.");
//             }
//
//             return result;
//         }
//         #endregion
//     }
// }
//
// #else

using FishNet.Connection;
using FishNet.Managing.Client;
using FishNet.Managing.Logging;
using FishNet.Managing.Server;
using FishNet.Object;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using GameKit.Dependencies.Utilities.Types;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.Serialization;
using UnitySceneManager = UnityEngine.SceneManagement.SceneManager;

namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Handles loading, unloading, and scene visibility for clients.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/SceneManager")]
    public sealed class SceneManager : MonoBehaviour
    {
        #region Types.
        internal enum LightProbeUpdateType
        {
            Asynchronous = 0,
            BlockThread = 1,
            Off = 2,
        }
        #endregion

        #region Public.
        /// <summary>
        /// Called after the active scene has been set, immediately after scene loads. This will occur before NetworkBehaviour callbacks run for the scene's objects.
        /// The boolean will indicate if the scene set active was specified by the user.
        /// </summary>
        public event Action<bool> OnActiveSceneSet;
        /// <summary>
        /// Called when a client loads initial scenes after connecting. Boolean will be true if asServer. This will invoke even if the SceneManager is not used when the client completes fully connecting to the server.
        /// </summary>
        public event Action<NetworkConnection, bool> OnClientLoadedStartScenes;
        /// <summary>
        /// Called when a scene change queue has begun. This will only call if a scene has succesfully begun to load or unload. The queue may process any number of scene events. For example: if a scene is told to unload while a load is still in progress, then the unload will be placed in the queue.
        /// </summary>
        public event Action OnQueueStart;
        /// <summary>
        /// Called when the scene queue is emptied.
        /// </summary>
        public event Action OnQueueEnd;
        /// <summary>
        /// Called when a scene load starts.
        /// </summary>
        public event Action<SceneLoadStartEventArgs> OnLoadStart;
        /// <summary>
        /// Called when completion percentage changes while loading a scene. Value is between 0f and 1f, while 1f is 100% done. Can be used for custom progress bars when loading scenes.
        /// </summary>
        public event Action<SceneLoadPercentEventArgs> OnLoadPercentChange;
        /// <summary>
        /// Called when a scene load ends.
        /// </summary>
        public event Action<SceneLoadEndEventArgs> OnLoadEnd;
        /// <summary>
        /// Called when a scene unload starts.
        /// </summary>
        public event Action<SceneUnloadStartEventArgs> OnUnloadStart;
        /// <summary>
        /// Called when a scene unload ends.
        /// </summary>
        public event Action<SceneUnloadEndEventArgs> OnUnloadEnd;
        /// <summary>
        /// Called when a client presence changes within a scene, before the server rebuilds observers.
        /// </summary>
        public event Action<ClientPresenceChangeEventArgs> OnClientPresenceChangeStart;
        /// <summary>
        /// Called when a client presence changes within a scene, after the server rebuilds observers.
        /// </summary>
        public event Action<ClientPresenceChangeEventArgs> OnClientPresenceChangeEnd;
        /// <summary>
        /// Connections within each scene.
        /// </summary>
        public Dictionary<Scene, HashSet<NetworkConnection>> SceneConnections { get; private set; } = new();
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Script to handle addressables loading and unloading. This field may be blank if addressables are not being used.")]
        [SerializeField]
        private SceneProcessorBase _sceneProcessor;

        /// <summary>
        /// Script to handle addressables loading and unloading. This field may be blank if addressables are not being used.
        /// </summary>
        /// <returns></returns>
        public SceneProcessorBase GetSceneProcessor() => _sceneProcessor;

        /// <summary>
        /// Sets the SceneProcessor to use.
        /// </summary>
        /// <param name="value"></param>
        public void SetSceneProcessor(SceneProcessorBase value) => _sceneProcessor = value;

        /// <summary>
        /// NetworkManager for this script.
        /// </summary>
        public NetworkManager NetworkManager { get; private set; }
        #endregion

        #region Internal.
        /// <summary>
        /// Called after the active scene has been set, immediately after scene loads.
        /// </summary>
        internal event Action<bool> OnActiveSceneSetInternal;
        /// <summary>
        /// True if the SceneManager has items in queue.
        /// </summary>
        internal bool IteratingQueue { get; private set; }
        /// <summary>
        /// Unscaled time when the SceneManager completed it's last queue.
        /// </summary>
        internal float QueueCompleteTime { get; private set; }
        #endregion

        #region Serialized.
        /// <summary>
        /// How to update light probes after loading or unloading scenes.
        /// </summary>
        [Tooltip("How to update light probes after loading or unloading scenes.")]
        [SerializeField]
        private LightProbeUpdateType _lightProbeUpdating = LightProbeUpdateType.Asynchronous;
        /// <summary>
        /// True to move spawned objects visible to the client that are within an unloading scene. This ensures the objects are despawned on the client side rather than when the scene is destroyed.
        /// </summary>
        [FormerlySerializedAs("_moveClientHostObjects")]
        [Tooltip("True to move spawned objects visible to the client that are within an unloading scene. This ensures the objects are despawned on the client side rather than when the scene is destroyed.")]
        [SerializeField]
        private bool _moveClientObjects = true;

        /// <summary>
        /// Sets a new value for MoveClientObjects.
        /// </summary>
        public void SetMoveClientObjects(bool value) => _moveClientObjects = value;

        /// <summary>
        /// True to automatically set active scenes when loading and unloading scenes.
        /// </summary>
        [Tooltip("True to automatically set active scenes when loading and unloading scenes.")]
        [SerializeField]
        private bool _setActiveScene = true;
        #endregion

        #region Private.
        /// <summary>
        /// ServerManager for this script.
        /// </summary>
        private ServerManager _serverManager => NetworkManager.ServerManager;
        /// <summary>
        /// ClientManager for this script.
        /// </summary>
        private ClientManager _clientManager => NetworkManager.ClientManager;
        /// <summary>
        /// Scenes which are currently loaded as networked scenes. All players should have networked scenes loaded.
        /// </summary>
        private string[] _globalScenes = new string[0];
        /// <summary>
        /// Lastest SceneLoadData for a global load.
        /// </summary>
        private SceneLoadData _globalSceneLoadData = new();
        /// <summary>
        /// Scenes to load or unload, in order.
        /// </summary>
        private List<object> _queuedOperations = new();
        /// <summary>
        /// Scenes which must be manually unloaded, even when emptied.
        /// </summary>
        private HashSet<Scene> _manualUnloadScenes = new();
        /// <summary>
        /// Scene containing moved objects when changing single scene. On client this will contain all objects moved until the server destroys them.
        /// The network only sends spawn messages once per-client, per server side scene load. If a scene load is performed only for specific connections
        /// then the server is not resetting their single scene, but rather the single scene for those connections only. Because of this, any objects
        /// which are to be moved will not receive a second respawn message, as they are never destroyed on server, only on client.
        /// While on server only this scene contains objects being moved temporarily, before being moved to the new scene.
        /// </summary>
        private Scene _movedObjectsScene;
        /// <summary>
        /// Scene containing objects awaiting to be destroyed by the client-host.
        /// This is required when unloading scenes where the client-host has visibility.
        /// Otherwise the objects would become destroyed when the scene unloads on the server
        /// which would cause missing networkobjects on clients when receiving despawn messages.
        /// </summary>
        private Scene _delayedDestroyScene;
        /// <summary>
        /// A scene to be set as the active scene where there are no global scenes.
        /// This is used to prevent connection scenes and MovedObjectsScene from becoming the active scene.
        /// </summary>
        private Scene _fallbackActiveScene;
        /// <summary>
        /// Becomes true when when a scene first successfully begins to load or unload. Value is reset to false when the scene queue is emptied.
        /// </summary>
        private bool _sceneQueueStartInvoked;
        /// <summary>
        /// Objects being moved from MovedObjects scene to another. 
        /// </summary>
        private List<GameObject> _movingObjects = new();
        /// <summary>
        /// How many scene load confirmations the server is expecting from a client.
        /// Unloads do not need to be checked because server does not require confirmation for those.
        /// This is used to prevent attacks.
        /// </summary>
        private Dictionary<NetworkConnection, int> _pendingClientSceneChanges = new();
        ///// <summary>
        ///// Cache of SceneLookupData.
        ///// </summary>
        //private SceneLookupData _sceneLookupDataCache = new SceneLookupData();
        /// <summary>
        /// GlobalScenes currently loading on the server.
        /// </summary>
        private HashSet<string> _serverGlobalScenesLoading = new();
        #endregion

        #region Consts.
        /// <summary>
        /// String to use when scene data used to load is invalid.
        /// </summary>
        private const string INVALID_SCENELOADDATA = "One or more datas in SceneLoadData are invalid.This generally occurs when calling this method without specifying any scenes or when data fields are null.";
        /// <summary>
        /// String to use when scene data used to unload is invalid.
        /// </summary>
        private const string INVALID_SCENEUNLOADDATA = "One or more datas in SceneLoadData are invalid.This generally occurs when calling this method without specifying any scenes or when data fields are null.";
        #endregion

        #region Unity callbacks and initialization.
        private void Awake()
        {
            UnitySceneManager.sceneUnloaded += SceneManager_SceneUnloaded;
            if (_sceneProcessor == null)
                _sceneProcessor = gameObject.AddComponent<DefaultSceneProcessor>();
            _sceneProcessor.Initialize(this);
        }
        
        private void OnDestroy()
        {
            UnitySceneManager.sceneUnloaded -= SceneManager_SceneUnloaded;
        }

        /// <summary>
        /// Called when the server connection state changes.
        /// </summary>
        private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs obj)
        {
            //If no servers are started.
            if (!NetworkManager.ServerManager.IsAnyServerStarted())
                ResetValues();
        }

        /// <summary>
        /// Resets as if first use.
        /// </summary>
        private void ResetValues()
        {
            SceneConnections.Clear();
            _globalScenes = new string[0];
            _globalSceneLoadData = new();
            _queuedOperations.Clear();
            _manualUnloadScenes.Clear();
            _sceneQueueStartInvoked = false;
            _movingObjects.Clear();
        }

        /// <summary>
        /// Called when a connection state changes for a remote client.
        /// </summary>
        private void ServerManager_OnRemoteConnectionState(NetworkConnection arg1, RemoteConnectionStateArgs arg2)
        {
            if (arg2.ConnectionState == RemoteConnectionState.Stopped)
                ClientDisconnected(arg1);
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="manager"></param>
        internal void InitializeOnce_Internal(NetworkManager manager)
        {
            NetworkManager = manager;
            //No need to unregister since managers are on the same object.
            NetworkManager.ServerManager.OnRemoteConnectionState += ServerManager_OnRemoteConnectionState;
            NetworkManager.ServerManager.OnServerConnectionState += ServerManager_OnServerConnectionState;
            _clientManager.RegisterBroadcast<LoadScenesBroadcast>(OnServerLoadedScenes);
            _clientManager.RegisterBroadcast<UnloadScenesBroadcast>(OnServerUnloadedScenes);
            _serverManager.RegisterBroadcast<ClientScenesLoadedBroadcast>(OnClientLoadedScenes);
            _serverManager.RegisterBroadcast<EmptyStartScenesBroadcast>(OnClientSentEmptyStartScenes);
            _clientManager.RegisterBroadcast<EmptyStartScenesBroadcast>(OnServerSentEmptyStartScenes);
        }

        /// <summary>
        /// Received when a scene is unloaded.
        /// </summary>
        /// <param name="arg0"></param>
        private void SceneManager_SceneUnloaded(Scene scene)
        {
            if (!NetworkManager.IsServerStarted)
                return;

            /* Remove any unloaded scenes from local variables. This shouldn't
             * be needed if the user properly utilizes this scene manager,
             * but just incase, we don't want a memory leak. */
            SceneConnections.Remove(scene);
            _manualUnloadScenes.Remove(scene);
            RemoveFromGlobalScenes(scene);
        }
        #endregion

        #region Initial synchronizing.
        /// <summary>
        /// Invokes OnClientLoadedStartScenes if connection just loaded start scenes.
        /// </summary>
        /// <param name="connection"></param>
        private void TryInvokeLoadedStartScenes(NetworkConnection connection, bool asServer)
        {
            if (connection.SetLoadedStartScenes(asServer))
                OnClientLoadedStartScenes?.Invoke(connection, asServer);
        }

        /// <summary>
        /// Called when authenitcator has concluded a result for a connection. Boolean is true if authentication passed, false if failed. This invokes before OnClientAuthenticated so FishNet may run operations on authenticated clients before user code does.
        /// </summary>
        /// <param name="obj"></param>
        internal void OnClientAuthenticated(NetworkConnection connection)
        {
            AddPendingLoad(connection);

            //No global scenes to load.
            if (_globalScenes.Length == 0)
            {
                /* Invoke that client had loaded the default scenes immediately,
                 * since there are no scenes to load. */
                //OnClientLoadedScenes(connection, new ClientScenesLoadedBroadcast());
                //Tell the client there are no scenes to load.
                EmptyStartScenesBroadcast msg = new();
                connection.Broadcast(msg);
            }
            else
            {
                string[] globalsNotLoading = GlobalScenesExcludingLoading();
                //If there are globals that can be sent now.
                if (globalsNotLoading != null)
                {
                    SceneLoadData sld = new(globalsNotLoading);
                    sld.Params = _globalSceneLoadData.Params;
                    sld.Options = _globalSceneLoadData.Options;
                    sld.ReplaceScenes = _globalSceneLoadData.ReplaceScenes;
                    sld.PreferredActiveScene = _globalSceneLoadData.PreferredActiveScene;

                    LoadQueueData qd = new(SceneScopeType.Global, Array.Empty<NetworkConnection>(), sld, _globalScenes, false);
                    //Send message to load the networked scenes.
                    LoadScenesBroadcast msg = new()
                    {
                        QueueData = qd
                    };

                    connection.Broadcast(msg, true);
                }
            }
        }

        /// <summary>
        /// Received on client when the server has no start scenes.
        /// </summary>
        private void OnServerSentEmptyStartScenes(EmptyStartScenesBroadcast msg, Channel channel)
        {
            TryInvokeLoadedStartScenes(_clientManager.Connection, false);
            _clientManager.Broadcast(msg);
        }

        /// <summary>
        /// Received on server when client confirms there are no start scenes.
        /// </summary>
        private void OnClientSentEmptyStartScenes(NetworkConnection conn, EmptyStartScenesBroadcast msg, Channel channel)
        {
            if (!conn.IsActive)
                return;

            //Already received, shouldn't be happening again.
            if (conn.LoadedStartScenes(true))
                conn.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Received multiple EmptyStartSceneBroadcast from connectionId {conn.ClientId}. Connection will be kicked immediately.");
            else
                OnClientLoadedScenes(conn, new(), channel);
        }
        #endregion

        #region Player disconnect.
        /// <summary>
        /// Received when a player disconnects from the server.
        /// </summary>
        /// <param name="conn"></param> //finish.
        private void ClientDisconnected(NetworkConnection conn)
        {
            _pendingClientSceneChanges.Remove(conn);
            /* Remove connection from all scenes. While doing so check
             * if scene should be unloaded provided there are no more clients
             * in the scene, and it's set to automatically unload. This situation is a bit
             * unique since a client disconnect happens outside the manager, so there
             * isn't much code we can re-use to perform this operation. */
            List<Scene> scenesToUnload = new();
            //Current active scene.
            Scene activeScene = UnitySceneManager.GetActiveScene();
            foreach (KeyValuePair<Scene, HashSet<NetworkConnection>> item in SceneConnections)
            {
                Scene scene = item.Key;
                HashSet<NetworkConnection> hs = item.Value;

                bool removed = hs.Remove(conn);
                /* If no more observers for scene, not a global scene, and not to be manually unloaded
                 * then remove scene from SceneConnections and unload it. */
                if (removed && hs.Count == 0 && !IsGlobalScene(scene) && !_manualUnloadScenes.Contains(scene) && (scene != activeScene))
                    scenesToUnload.Add(scene);
            }

            //If scenes should be unloaded.
            if (scenesToUnload.Count > 0)
            {
                foreach (Scene s in scenesToUnload)
                    SceneConnections.Remove(s);
                SceneUnloadData sud = new(SceneLookupData.CreateData(scenesToUnload));
                UnloadConnectionScenes(Array.Empty<NetworkConnection>(), sud);
            }
        }
        #endregion

        #region Server received messages.
        /// <summary>
        /// Received on server when a client loads scenes.
        /// </summary>
        /// <param name="conn"></param>
        /// <param name="msg"></param>
        private void OnClientLoadedScenes(NetworkConnection conn, ClientScenesLoadedBroadcast msg, Channel channel)
        {
            if (!conn.IsActive)
                return;
            
            int pendingLoads;
            _pendingClientSceneChanges.TryGetValueIL2CPP(conn, out pendingLoads);

            //There's no loads or unloads pending, kick client.
            if (pendingLoads == 0)
            {
                conn.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Received excessive ClientScenesLoadedBroadcast from connectionId {conn.ClientId}. Connection will be kicked immediately.");
                return;
            }
            //If there is a load pending then update pending count.
            else
            {
                pendingLoads--;
                if (pendingLoads == 0)
                    _pendingClientSceneChanges.Remove(conn);
                else
                    _pendingClientSceneChanges[conn] = pendingLoads;
            }

            if (!Comparers.IsDefault(msg))
            {
                foreach (SceneLookupData item in msg.SceneLookupDatas)
                {
                    Scene s = item.GetScene(out _);
                    if (s.IsValid())
                        AddConnectionToScene(conn, s);
                }
            }

            TryInvokeLoadedStartScenes(conn, true);
        }
        #endregion

        #region Events.
        /// <summary>
        /// Checks if OnQueueStart should invoke, and if so invokes.
        /// </summary>
        private void TryInvokeOnQueueStart()
        {
            if (_sceneQueueStartInvoked)
                return;

            _sceneQueueStartInvoked = true;
            IteratingQueue = true;
            OnQueueStart?.Invoke();
        }

        /// <summary>
        /// Checks if OnQueueEnd should invoke, and if so invokes.
        /// </summary>
        private void TryInvokeOnQueueEnd()
        {
            if (!_sceneQueueStartInvoked)
                return;

            _sceneQueueStartInvoked = false;
            IteratingQueue = false;
            QueueCompleteTime = Time.unscaledTime;
            OnQueueEnd?.Invoke();
        }

        /// <summary>
        /// Invokes that a scene load has started. Only called when valid scenes will be loaded.
        /// </summary>
        /// <param name="qd"></param>
        private void InvokeOnSceneLoadStart(LoadQueueData qd)
        {
            TryInvokeOnQueueStart();
            OnLoadStart?.Invoke(new(qd));
        }

        /// <summary>
        /// Invokes that a scene load has ended. Only called after a valid scene has loaded.
        /// </summary>
        /// <param name="qd"></param>
        private void InvokeOnSceneLoadEnd(LoadQueueData qd, List<string> requestedLoadScenes, List<Scene> loadedScenes, string[] unloadedSceneNames)
        {
            //Make new list to not destroy original data.
            List<string> skippedScenes = requestedLoadScenes.ToList();
            //Remove loaded scenes from requested scenes.
            for (int i = 0; i < loadedScenes.Count; i++)
                skippedScenes.Remove(loadedScenes[i].name);

            SceneLoadEndEventArgs args = new(qd, skippedScenes.ToArray(), loadedScenes.ToArray(), unloadedSceneNames);
            OnLoadEnd?.Invoke(args);
        }

        /// <summary>
        /// Invokes that a scene unload has started. Only called when valid scenes will be unloaded.
        /// </summary>
        /// <param name="sqd"></param>
        private void InvokeOnSceneUnloadStart(UnloadQueueData sqd)
        {
            TryInvokeOnQueueStart();
            OnUnloadStart?.Invoke(new(sqd));
        }

        /// <summary>
        /// Invokes that a scene unload has ended. Only called after a valid scene has unloaded.
        /// </summary>
        /// <param name="sqd"></param>
        private void InvokeOnSceneUnloadEnd(UnloadQueueData sqd, List<Scene> unloadedScenes, List<UnloadedScene> newUnloadedScenes)
        {
            SceneUnloadEndEventArgs args = new(sqd, unloadedScenes, newUnloadedScenes);
            OnUnloadEnd?.Invoke(args);
        }

        /// <summary>
        /// Invokes when completion percentage changes while unloading or unloading a scene. Value is between 0f and 1f, while 1f is 100% done.
        /// </summary>
        /// <param name="value"></param>
        private void InvokeOnScenePercentChange(LoadQueueData qd, float value)
        {
            value = Mathf.Clamp(value, 0f, 1f);
            SceneLoadPercentEventArgs slp = new(qd, value);
            OnLoadPercentChange?.Invoke(slp);
        }
        #endregion

        #region Scene queue processing.
        /// <summary>
        /// Queues a load or unload operation and starts queue if needed.
        /// </summary>
        /// <param name="data"></param>
        private void QueueOperation(object data)
        {
            //Add to scene queue data.        
            _queuedOperations.Add(data);
            /* If only one entry then scene operations are not currently in progress.
             * Should there be more than one entry then scene operations are already
             * occuring. The coroutine will automatically load in order. */

            if (_queuedOperations.Count == 1)
                StartCoroutine(__ProcessSceneQueue());
        }

        /// <summary>
        /// Processes queued scene operations.
        /// </summary>
        /// <param name="asServer"></param>
        /// <returns></returns>
        private IEnumerator __ProcessSceneQueue()
        {
            /* Queue start won't invoke unless a scene load or unload actually occurs.
             * For example: if a scene is already loaded, and nothing needs to be loaded,
             * queue start will not invoke. */

            while (_queuedOperations.Count > 0)
            {
                //If a load scene.
                if (_queuedOperations[0] is LoadQueueData)
                    yield return StartCoroutine(__LoadScenes());
                //If an unload scene.
                else if (_queuedOperations[0] is UnloadQueueData)
                    yield return StartCoroutine(__UnloadScenes());

                if (_queuedOperations.Count > 0)
                    _queuedOperations.RemoveAt(0);
            }

            TryInvokeOnQueueEnd();
        }
        #endregion

        /// <summary>
        /// Returns global scenes which are not currently being loaded by the server.
        /// </summary>
        /// <returns></returns>
        private string[] GlobalScenesExcludingLoading()
        {
            HashSet<string> excludedScenes = null;
            foreach (string gs in _globalScenes)
            {
                if (_serverGlobalScenesLoading.Contains(gs))
                {
                    if (excludedScenes == null)
                        excludedScenes = new();

                    excludedScenes.Add(gs);
                }
            }

            //Some scenes are excluded.
            if (excludedScenes != null)
            {
                //All are excluded, quick exit to save perf.
                int remaining = (_globalScenes.Length - excludedScenes.Count);
                if (remaining <= 0)
                    return null;
                //Some are excluded.
                List<string> results = new();
                foreach (string globalScene in _globalScenes)
                {
                    if (!excludedScenes.Contains(globalScene))
                        results.Add(globalScene);
                }

                return results.ToArray();
            }
            //No scenes are excluded.
            else
            {
                return _globalScenes;
            }
        }

        //#region IsQueuedScene.
        ///// <summary>
        ///// Returns if this SceneManager has a scene load or unload in queue for server or client.
        ///// </summary>
        ///// <param name="loading">True to check loading scenes, false to check unloading.</param>
        ///// <param name="asServer">True to check if data in queue is for server, false if for client.
        ///// <returns></returns>
        //public bool IsQueuedScene(string sceneName, bool loading, bool asServer)
        //{
        //    _sceneLookupDataCache.Update(sceneName, 0);
        //    return IsQueuedScene(_sceneLookupDataCache, loading, asServer);
        //}
        ///// <summary>
        ///// Returns if this SceneManager has a scene load or unload in queue for server or client.
        ///// </summary>
        ///// <param name="loading">True to check loading scenes, false to check unloading.</param>
        ///// <param name="asServer">True to check if data in queue is for server, false if for client.
        ///// <returns></returns>
        //public bool IsQueuedScene(int handle, bool loading, bool asServer)
        //{
        //    _sceneLookupDataCache.Update(string.Empty, handle);
        //    return IsQueuedScene(_sceneLookupDataCache, loading, asServer);
        //}
        ///// <summary>
        ///// Returns if this SceneManager has a scene load or unload in queue for server or client.
        ///// </summary>
        ///// <param name="loading">True to check loading scenes, false to check unloading.</param>
        ///// <param name="asServer">True to check if data in queue is for server, false if for client.
        ///// <returns></returns>
        //public bool IsQueuedScene(Scene scene, bool loading, bool asServer)
        //{
        //    _sceneLookupDataCache.Update(scene.name, scene.handle);
        //    return IsQueuedScene(_sceneLookupDataCache, loading, asServer);
        //}
        ///// <summary>
        ///// Returns if this SceneManager has a scene load or unload in queue for server or client.
        ///// </summary>
        ///// <param name="loading">True to check loading scenes, false to check unloading.</param>
        ///// <param name="asServer">True to check if data in queue is for server, false if for client.
        ///// <returns></returns>
        //public bool IsQueuedScene(SceneLookupData sld, bool loading, bool asServer)
        //{
        //    foreach (object item in _queuedOperations)
        //    {
        //        SceneLookupData[] lookupDatas = null;
        //        //Loading check.
        //        if (loading && item is SceneLoadData loadData)
        //            lookupDatas = loadData.SceneLookupDatas;
        //        else if (!loading && item is SceneUnloadData unloadData)
        //            lookupDatas = unloadData.SceneLookupDatas;

        //        if (lookupDatas != null)
        //        {
        //            foreach (SceneLookupData operationSld in lookupDatas)
        //            {
        //                if (operationSld == sld)
        //                    return true;
        //            }
        //        }
        //    }

        //    //Fall through, not found in any queue operations.
        //    return false;
        //}
        //#endregion

        #region LoadScenes
        /// <summary>
        /// Loads scenes on the server and for all clients. Future clients will automatically load these scenes.
        /// </summary>
        /// <param name="sceneLoadData">Data about which scenes to load.</param>
        public void LoadGlobalScenes(SceneLoadData sceneLoadData)
        {
            LoadGlobalScenes_Internal(sceneLoadData, _globalScenes, true);
        }

        private void LoadGlobalScenes_Internal(SceneLoadData sceneLoadData, string[] globalScenes, bool asServer)
        {
            if (!CanExecute(asServer, true))
                return;
            if (SceneDataInvalid(sceneLoadData, true))
                return;
            if (sceneLoadData.Options.AllowStacking)
            {
                NetworkManager.LogError($"Stacking scenes is not allowed with Global scenes.");
                return;
            }

            LoadQueueData lqd = new(SceneScopeType.Global, Array.Empty<NetworkConnection>(), sceneLoadData, globalScenes, asServer);
            QueueOperation(lqd);
        }

        /// <summary>
        /// Loads scenes on server and tells connections to load them as well. Other connections will not load this scene.
        /// </summary>
        /// <param name="conn">Connections to load scenes for.</param>
        /// <param name="sceneLoadData">Data about which scenes to load.</param>
        public void LoadConnectionScenes(NetworkConnection conn, SceneLoadData sceneLoadData)
        {
            //This cannot use cache because the array will persist for many frames after this method completion.
            LoadConnectionScenes(new NetworkConnection[] { conn }, sceneLoadData);
        }

        /// <summary>
        /// Loads scenes on server and tells connections to load them as well. Other connections will not load this scene.
        /// </summary>
        /// <param name="conns">Connections to load scenes for.</param>
        /// <param name="sceneLoadData">Data about which scenes to load.</param>
        public void LoadConnectionScenes(NetworkConnection[] conns, SceneLoadData sceneLoadData)
        {
            LoadConnectionScenes_Internal(conns, sceneLoadData, _globalScenes, true);
        }

        /// <summary>
        /// Loads scenes on server without telling clients to load the scenes.
        /// </summary>
        /// <param name="sceneLoadData">Data about which scenes to load.</param>
        public void LoadConnectionScenes(SceneLoadData sceneLoadData)
        {
            LoadConnectionScenes_Internal(Array.Empty<NetworkConnection>(), sceneLoadData, _globalScenes, true);
        }

        private void LoadConnectionScenes_Internal(NetworkConnection[] conns, SceneLoadData sceneLoadData, string[] globalScenes, bool asServer)
        {
            if (!CanExecute(asServer, true))
                return;
            if (SceneDataInvalid(sceneLoadData, true))
                return;

            LoadQueueData lqd = new(SceneScopeType.Connections, conns, sceneLoadData, globalScenes, asServer);
            QueueOperation(lqd);
        }

        /// <summary>
        /// Returns if a NetworkObject can be moved.
        /// </summary>
        /// <param name="warn"></param>
        /// <returns></returns>
        private bool CanMoveNetworkObject(NetworkObject nob, bool warn)
        {
            //Null.
            if (nob == null)
                return WarnAndReturnFalse($"NetworkObject is null.");
            //Not networked.
            if (!nob.GetIsNetworked())
                return WarnAndReturnFalse($"NetworkObject {nob.name} cannot be moved as it is not networked.");
            //Not spawned.
            if (!nob.IsSpawned)
                return WarnAndReturnFalse($"NetworkObject {nob.name} canot be moved as it is not spawned.");
            //SceneObject.
            if (nob.IsSceneObject)
                return WarnAndReturnFalse($"NetworkObject {nob.name} cannot be moved as it is a scene object.");
            //Not root.
            if (nob.transform.parent != null)
                return WarnAndReturnFalse($"NetworkObject {nob.name} cannot be moved because it is not the root object. Unity can only move root objects between scenes.");
            //In DDOL and IsGlobal.
            if (nob.IsGlobal && (nob.gameObject.scene.name == DDOL.GetDDOL().gameObject.scene.name))
                return WarnAndReturnFalse($"NetworkObject {nob.name} cannot be moved because it is global. Global objects must remain in the DontDestroyOnLoad scene.");

            //Fall through success.
            return true;

            bool WarnAndReturnFalse(string msg)
            {
                if (warn)
                    NetworkManager.LogWarning(msg);
                return false;
            }
        }

        /// <summary>
        /// Loads a connection scene queue data. This behaves just like a networked scene load except it sends only to the specified connections, and it always loads as an additive scene on server.
        /// </summary>
        /// <returns></returns>
        private IEnumerator __LoadScenes()
        {
            try
            {
                LoadQueueData data = _queuedOperations[0] as LoadQueueData;
                SceneLoadData sceneLoadData = data.SceneLoadData;
                //True if running as server.
                bool asServer = data.AsServer;
                //True if running as client, while network server is active.
                bool asHost = (!asServer && NetworkManager.IsServerStarted);

                //If connection went inactive.
                if (!ConnectionActive(asServer))
                    yield break;

                /* Scene sanity checks. */
                if (sceneLoadData.SceneLookupDatas.Length == 0)
                {
                    NetworkManager.LogWarning($"No scenes specified to load.");
                    yield break;
                }

                //True if replacing scenes with specified ones.
                ReplaceOption replaceScenes = sceneLoadData.ReplaceScenes;

                //May be unset if on server, this is fine.
                NetworkConnection localConnection = NetworkManager.ClientManager.Connection;
                /* Immediately set new global scenes. If on client this is whatever
                 * server passes in. This should be set even if scope type
                 * is not global because clients might get a connection scene first.
                 */
                if (!asServer)
                {
                    if (!asHost)
                        _globalScenes = data.GlobalScenes;
                }
                /* However, if server, then only update global scenes if scope
                 * is global. */
                else if (asServer && data.ScopeType == SceneScopeType.Global)
                {
                    _globalSceneLoadData = sceneLoadData;
                    string[] names = sceneLoadData.SceneLookupDatas.GetNames();
                    //Add to server global scenes which are currently loading.
                    foreach (string item in names)
                        _serverGlobalScenesLoading.Add(item);
                    //If replacing.
                    if (replaceScenes != ReplaceOption.None)
                    {
                        _globalScenes = names;
                    }
                    //Add onto.
                    else
                    {
                        int index = _globalScenes.Length;
                        Array.Resize(ref _globalScenes, _globalScenes.Length + names.Length);
                        Array.Copy(names, 0, _globalScenes, index, names.Length);
                    }
                    CheckForDuplicateGlobalSceneNames();
                    data.GlobalScenes = _globalScenes;
                }


                /* Scene queue data scenes.
                 * All scenes in the scene queue data whether they will be loaded or not. */
                List<string> requestedLoadSceneNames = new();
                List<int> requestedLoadSceneHandles = new();

                /* Make a null filled array. This will be populated
                 * using loaded scenes, or already loaded (eg cannot be loaded) scenes. */
                SceneLookupData[] broadcastLookupDatas = new SceneLookupData[sceneLoadData.SceneLookupDatas.Length];

                /* LoadableScenes and SceneReferenceDatas.
                /* Will contain scenes which may be loaded.
                 * Scenes might not be added to loadableScenes
                 * if for example loadOnlyUnloaded is true and
                 * the scene is already loaded. */
                List<SceneLookupData> loadableScenes = new();
                for (int i = 0; i < sceneLoadData.SceneLookupDatas.Length; i++)
                {
                    SceneLookupData lookupData = sceneLoadData.SceneLookupDatas[i];
                    //Scene to load.
                    bool byHandle;
                    Scene s = lookupData.GetScene(out byHandle);
                    //If found then add it to requestedLoadScenes.
                    if (s.IsValid())
                    {
                        requestedLoadSceneNames.Add(s.name);
                        if (byHandle)
                            requestedLoadSceneHandles.Add(s.handle);
                    }

                    if (CanLoadScene(data, lookupData))
                    {
                        //Don't load if as host, server side would have loaded already.
                        if (!asHost)
                            loadableScenes.Add(lookupData);
                    }
                    //Only the server needs to find scene handles to send to client. Client will send these back to the server.
                    else if (asServer)
                    {
                        /* If here then scene cannot be loaded, which
                         * can only happen if the scene already exists.
                         * Find the scene using sld and set to datas. */
                        /* Set at the index of i. This way should the current
                         * SLD not be the first scene it won't fill the
                         * first slot in broadcastLookupDatas. This is important
                         * because the first slot is used for the single scene
                         * when using replace scenes. */
                        broadcastLookupDatas[i] = new(s);
                    }
                }

                /* Move identities
                 * to holder scene to preserve them.
                 * Required if a single scene is specified. Cannot rely on
                 * loadSingleScene since it is only true if the single scene
                 * must be loaded, which may be false if it's already loaded on
                 * the server. */
                //Do not run if running as client, and server is active. This would have already run as server.
                if (!asHost)
                {
                    Scene moveScene = GetMovedObjectsScene();
                    foreach (NetworkObject nob in sceneLoadData.MovedNetworkObjects)
                    {
                        //NetworkObject might be null if client lost observation of it.
                        if (nob != null && CanMoveNetworkObject(nob, true))
                            UnitySceneManager.MoveGameObjectToScene(nob.gameObject, moveScene);
                    }
                }

                //Connection scenes handles prior to ConnectionScenes being modified.
                List<int> connectionScenesHandlesCached = new();
                //If replacing scenes.
                if (replaceScenes != ReplaceOption.None)
                {
                    /* Resetting SceneConnections. */
                    /* If server and replacing scenes.
                     * It's important to run this AFTER moving MovedNetworkObjects
                     * so that they are no longer in the scenes they are leaving. Otherwise
                     * the scene condition would pick them up as still in the leaving scene. */
                    if (asServer)
                    {
                        Scene[] sceneConnectionsKeys = SceneConnections.Keys.ToArray();
                        for (int i = 0; i < sceneConnectionsKeys.Length; i++)
                            connectionScenesHandlesCached.Add(sceneConnectionsKeys[i].handle);

                        //If global then remove all connections from all scenes.
                        if (data.ScopeType == SceneScopeType.Global)
                        {
                            foreach (Scene s in sceneConnectionsKeys)
                                RemoveAllConnectionsFromScene(s);
                        }
                        //Connections.
                        else if (data.ScopeType == SceneScopeType.Connections)
                        {
                            RemoveConnectionsFromNonGlobalScenes(data.Connections);
                        }
                    }
                    //As client set scenes id cache to local connection scenes.
                    else
                    {
                        foreach (Scene s in NetworkManager.ClientManager.Connection.Scenes)
                            connectionScenesHandlesCached.Add(s.handle);
                    }
                }


                /* Scene unloading if replacing scenes.
                 *
                 * Unload all scenes except MovedObjectsHolder. Also don't
                 * unload GlobalScenes if loading as connection. */
                List<Scene> unloadableScenes = new();
                //Do not run if running as client, and server is active. This would have already run as server.
                if ((replaceScenes != ReplaceOption.None) && !asHost)
                {
                    //See what scenes can be unloaded based on replace options.
                    for (int i = 0; i < UnitySceneManager.sceneCount; i++)
                    {
                        Scene s = UnitySceneManager.GetSceneAt(i);
                        //MovedObjectsScene will never be unloaded.
                        if (s == GetMovedObjectsScene())
                            continue;
                        /* Scene is in one of the scenes being loaded.
                         * This can occur when trying to load additional clients
                         * into an existing scene. */
                        if (requestedLoadSceneNames.Contains(s.name))
                            continue;
                        //Same as above but using handles.
                        if (requestedLoadSceneHandles.Contains(s.handle))
                            continue;
                        /* Cannot unload global scenes. If
                         * replace scenes was used for a global
                         * load then global scenes would have been reset
                         * before this. */
                        if (IsGlobalScene(s))
                            continue;
                        //If scene must be manually unloaded then it cannot be unloaded here.
                        if (_manualUnloadScenes.Contains(s))
                            continue;

                        bool inScenesCache = connectionScenesHandlesCached.Contains(s.handle);
                        HashSet<NetworkConnection> conns;
                        bool inScenesCurrent = SceneConnections.ContainsKey(s);
                        //If was in scenes previously but isnt now then no connections reside in the scene.
                        if (inScenesCache && !inScenesCurrent)
                        {
                            //Intentionally left blank.
                        }
                        //If still in cache see if any connections exist.
                        else if (SceneConnections.TryGetValueIL2CPP(s, out conns))
                        {
                            //Still has clients in scene.
                            if (conns != null && conns.Count > 0)
                                continue;
                        }
                        //An offline scene.
                        else
                        {
                            //If not replacing all scenes then skip offline scenes.
                            if (replaceScenes != ReplaceOption.All)
                                continue;
                        }

                        unloadableScenes.Add(s);
                    }
                }

                /* Start event. */
                InvokeOnSceneLoadStart(data);
                if (unloadableScenes.Count > 0 || loadableScenes.Count > 0)
                    _sceneProcessor.LoadStart(data);
                //Unloaded scenes by name. Only used for information within callbacks.
                string[] unloadedNames = new string[unloadableScenes.Count];
                for (int i = 0; i < unloadableScenes.Count; i++)
                    unloadedNames[i] = unloadableScenes[i].name;
                /* Before unloading if !asServer and !asHost and replacing scenes
                 * then move all non scene networked objects to the moved
                 * objects holder. Otherwise network objects would get destroyed
                 * on the scene change and never respawned if server doesn't
                 * have a reason to update visibility. */
                if (!data.AsServer && !asHost && (replaceScenes != ReplaceOption.None))
                {
                    //Only proceed if moving is disabled. This statement is nested for readability.
                    if (_moveClientObjects)
                    {
                        Scene s = GetMovedObjectsScene();
                        foreach (NetworkObject nob in NetworkManager.ClientManager.Objects.Spawned.Values)
                        {
                            if (CanMoveNetworkObject(nob, false))
                                UnitySceneManager.MoveGameObjectToScene(nob.gameObject, s);
                        }
                    }
                }
                /* Unloading scenes. */
                _sceneProcessor.UnloadStart(data);
                for (int i = 0; i < unloadableScenes.Count; i++)
                {
                    MoveClientHostObjects(unloadableScenes[i], asServer);
                    //Unload one at a time.
                    _sceneProcessor.BeginUnloadAsync(unloadableScenes[i]);
                    while (!_sceneProcessor.IsPercentComplete())
                        yield return null;
                }
                _sceneProcessor.UnloadEnd(data);

                //Scenes loaded.
                List<Scene> loadedScenes = new();
                /* Scene loading.
                /* Use additive to not thread lock server. */
                for (int i = 0; i < loadableScenes.Count; i++)
                {
                    //Start load async and wait for it to finish.
                    LoadSceneParameters loadSceneParameters = new()
                    {
                        loadSceneMode = LoadSceneMode.Additive,
                        localPhysicsMode = sceneLoadData.Options.LocalPhysics
                    };

                    /* How much percentage each scene load can be worth
                     * at maximum completion. EG: if there are two scenes
                     * 1f / 2f is 0.5f. */
                    float maximumIndexWorth = (1f / (float)loadableScenes.Count);

                    _sceneProcessor.BeginLoadAsync(loadableScenes[i].Name, loadSceneParameters);
                    while (!_sceneProcessor.IsPercentComplete())
                    {
                        float percent = _sceneProcessor.GetPercentComplete();
                        InvokePercentageChange(i, maximumIndexWorth, percent);
                        yield return null;
                    }

                    //Invokes OnScenePercentChange with progress.
                    void InvokePercentageChange(int index, float maximumWorth, float currentScenePercent)
                    {
                        /* Total percent will be how much percentage is complete
                         * in total. Initialize it with a value based on how many
                         * scenes are already fully loaded. */
                        float totalPercent = (index * maximumWorth);
                        //Add this scenes progress onto total percent.
                        totalPercent += Mathf.Lerp(0f, maximumWorth, currentScenePercent);
                        //Dispatch with total percent.
                        InvokeOnScenePercentChange(data, totalPercent);
                    }

                    Scene lastLoadedScene = _sceneProcessor.GetLastLoadedScene();
                    /* If the lastLoadedScene returns default
                     * then the user is overriding the sceneprocessor
                     * and has not setup use for this particular API. */
                    if (lastLoadedScene == default)
                        lastLoadedScene = UnitySceneManager.GetSceneAt(UnitySceneManager.sceneCount - 1);
                    
                    loadedScenes.Add(lastLoadedScene);
                    _sceneProcessor.AddLoadedScene(lastLoadedScene);
                }
                //When all scenes are loaded invoke with 100% done.
                InvokeOnScenePercentChange(data, 1f);

                /* Add to ManuallyUnloadScenes. */
                if (data.AsServer && !sceneLoadData.Options.AutomaticallyUnload)
                {
                    foreach (Scene s in loadedScenes)
                        _manualUnloadScenes.Add(s);
                }
                /* Move identities to first scene. */
                if (!asHost)
                {
                    //Find the first valid scene to move objects to.
                    Scene firstValidScene = default;
                    //If to stack scenes.
                    if (sceneLoadData.Options.AllowStacking)
                    {
                        Scene firstScene = sceneLoadData.GetFirstLookupScene();
                        /* If the first lookup data contains a handle and the scene
                         * is found for that handle then use that as the moved to scene.
                         * Nobs always move to the first specified scene. */
                        if (sceneLoadData.SceneLookupDatas[0].Handle != 0 && !string.IsNullOrEmpty(firstScene.name))
                        {
                            firstValidScene = firstScene;
                        }
                        //If handle is not specified then used the last scene that has the same name as the first lookupData.
                        else
                        {
                            Scene lastSameSceneName = default;
                            for (int i = 0; i < UnitySceneManager.sceneCount; i++)
                            {
                                Scene s = UnitySceneManager.GetSceneAt(i);
                                if (s.name == firstScene.name)
                                    lastSameSceneName = s;
                            }

                            /* Shouldn't be possible since the scene will always exist either by
                             * just being loaded or already loaded. */
                            if (string.IsNullOrEmpty(lastSameSceneName.name))
                                NetworkManager.LogError($"Scene {sceneLoadData.SceneLookupDatas[0].Name} could not be found in loaded scenes.");
                            else
                                firstValidScene = lastSameSceneName;
                        }
                    }
                    //Not stacking.
                    else
                    {
                        firstValidScene = sceneLoadData.GetFirstLookupScene();
                        //If not found by look then try firstloaded.
                        if (string.IsNullOrEmpty(firstValidScene.name))
                            firstValidScene = GetFirstLoadedScene();
                    }

                    //Gets first scene loaded this method call.
                    Scene GetFirstLoadedScene()
                    {
                        if (loadedScenes.Count > 0)
                            return loadedScenes[0];
                        else
                            return default;
                    }

                    //If firstValidScene is still invalid then throw.
                    if (string.IsNullOrEmpty(firstValidScene.name))
                    {
                        NetworkManager.LogError($"Unable to move objects to a new scene because new scene lookup has failed.");
                    }
                    //Move objects from movedobejctsscene to first valid scene.
                    else
                    {
                        Scene s = GetMovedObjectsScene();
                        s.GetRootGameObjects(_movingObjects);

                        foreach (GameObject go in _movingObjects)
                            UnitySceneManager.MoveGameObjectToScene(go, firstValidScene);
                    }
                }

                _sceneProcessor.ActivateLoadedScenes();
                //Wait until everything is loaded (done).
                yield return _sceneProcessor.AsyncsIsDone();
                _sceneProcessor.LoadEnd(data);

                /* Wait until loadedScenes are all marked as done.
                 * This is an extra precautionary step because on some devices
                 * the AsyncIsDone returns true before scenes are actually loaded. */
                bool allScenesLoaded;
                do
                {
                    //Reset state for iteration https://github.com/FirstGearGames/FishNet/issues/322
                    allScenesLoaded = true;
                    foreach (Scene s in loadedScenes)
                    {
                        if (!s.isLoaded)
                        {
                            allScenesLoaded = false;
                            break;
                        }
                    }
                    yield return null;
                } while (!allScenesLoaded);

                SetActiveScene_Local();

                void SetActiveScene_Local()
                {
                    bool byUser;
                    Scene preferredActiveScene = GetUserPreferredActiveScene(sceneLoadData.PreferredActiveScene, asServer, out byUser);
                    //If preferred still is not set then try to figure it out.
                    if (!preferredActiveScene.IsValid())
                    {
                        bool setToFirstLookup = false;
                        //If any scenes are being replaced see if active needs to be updated.
                        if (sceneLoadData.ReplaceScenes != ReplaceOption.None)
                        {
                            //If load is for a connection and server isnt started.
                            setToFirstLookup |= (data.ScopeType == SceneScopeType.Connections && !NetworkManager.IsServerStarted);
                            /* If current active is the movedObjectsHolder, such as moved objects.
                             * This can happen when replacing a scene that was active and the next in line is
                             * set by unity as one of the temp scenes. */
                            Scene activeScene = UnitySceneManager.GetActiveScene();
                            setToFirstLookup |= (activeScene == GetMovedObjectsScene());
                        }

                        if (setToFirstLookup)
                            preferredActiveScene = sceneLoadData.GetFirstLookupScene();
                    }

                    SetActiveScene(preferredActiveScene, asServer, byUser);
                }

                //Only the server needs to find scene handles to send to client. Client will send these back to the server.
                if (asServer)
                {
                    //Populate broadcastLookupDatas with any loaded scenes.
                    foreach (Scene s in loadedScenes)
                    {
                        SetInFirstNullIndex(s);

                        //Sets scene in the first null index of broadcastLookupDatas.
                        void SetInFirstNullIndex(Scene scene)
                        {
                            for (int i = 0; i < broadcastLookupDatas.Length; i++)
                            {
                                if (broadcastLookupDatas[i] == null)
                                {
                                    broadcastLookupDatas[i] = new(scene);
                                    return;
                                }
                            }

                            //If here there are no null entries.
                            NetworkManager.LogError($"Cannot add scene to broadcastLookupDatas, collection is full.");
                        }
                    }
                }

                /* If running as server and server is
                 * active then send scene changes to client.
                 * Making sure server is still active should it maybe
                 * have dropped during scene loading. */
                if (data.AsServer && NetworkManager.IsServerStarted)
                {
                    //Tell clients to load same scenes.
                    LoadScenesBroadcast msg = new()
                    {
                        QueueData = data
                    };
                    //Replace scene lookup datas with ones intended to broadcast to client.
                    msg.QueueData.SceneLoadData.SceneLookupDatas = broadcastLookupDatas;
                    //If networked scope then send to all.
                    if (data.ScopeType == SceneScopeType.Global)
                    {
                        NetworkConnection[] conns = _serverManager.Clients.Values.ToArray();
                        AddPendingLoad(conns, conns.Length);
                        _serverManager.Broadcast(msg, true);
                    }
                    //If connections scope then only send to connections.
                    else if (data.ScopeType == SceneScopeType.Connections)
                    {
                        AddPendingLoad(data.Connections, data.Connections.Length);
                        for (int i = 0; i < data.Connections.Length; i++)
                        {
                            NetworkConnection c = data.Connections[i];
                            if (c.IsValid() && c.IsAuthenticated)
                                data.Connections[i].Broadcast(msg, true);
                        }
                    }
                }
                /* If running as client then send a message
                 * to the server to tell them the scene was loaded.
                 * This allows the server to add the client
                 * to the scene for checkers. */
                else if (!data.AsServer && NetworkManager.IsClientStarted)
                {
                    //Remove from old scenes.
                    foreach (Scene item in unloadableScenes)
                    {
                        if (item.IsValid())
                            localConnection.RemoveFromScene(item);
                    }
                    //Add local client to scenes.
                    foreach (Scene item in loadedScenes)
                        localConnection.AddToScene(item);

                    TryInvokeLoadedStartScenes(_clientManager.Connection, false);

                    ClientScenesLoadedBroadcast msg = new()
                    {
                        SceneLookupDatas = sceneLoadData.SceneLookupDatas
                    };
                    _clientManager.Broadcast(msg);
                }

                InvokeOnSceneLoadEnd(data, requestedLoadSceneNames, loadedScenes, unloadedNames);
            }
            finally
            {
                _serverGlobalScenesLoading.Clear();
            }
        }

        /// <summary>
        /// Received on client when connection scenes must be loaded.
        /// </summary>
        /// <param name="conn"></param>
        /// <param name="msg"></param>
        private void OnServerLoadedScenes(LoadScenesBroadcast msg, Channel channel)
        {
            //Null data is sent by the server when there are no start scenes to load.
            if (msg.QueueData == null)
            {
                TryInvokeLoadedStartScenes(_clientManager.Connection, false);
            }
            else
            {
                LoadQueueData qd = msg.QueueData;
                if (qd.ScopeType == SceneScopeType.Global)
                    LoadGlobalScenes_Internal(qd.SceneLoadData, qd.GlobalScenes, false);
                else
                    LoadConnectionScenes_Internal(Array.Empty<NetworkConnection>(), qd.SceneLoadData, qd.GlobalScenes, false);
            }
        }
        #endregion

        #region UnloadScenes.
        /// <summary>
        /// Unloads scenes on the server and for all clients.
        /// </summary>
        /// <param name="sceneUnloadData">Data about which scenes to unload.</param>
        public void UnloadGlobalScenes(SceneUnloadData sceneUnloadData)
        {
            if (!CanExecute(true, true))
                return;

            UnloadGlobalScenes_Internal(sceneUnloadData, _globalScenes, true);
        }

        private void UnloadGlobalScenes_Internal(SceneUnloadData sceneUnloadData, string[] globalScenes, bool asServer)
        {
            UnloadQueueData uqd = new(SceneScopeType.Global, Array.Empty<NetworkConnection>(), sceneUnloadData, globalScenes, asServer);
            QueueOperation(uqd);
        }

        /// <summary>
        /// Unloads scenes on server and tells a connection to unload them as well. Other connections will not unload this scene.
        /// </summary>
        /// <param name="connection">Connection to unload scenes for.</param>
        /// <param name="sceneUnloadData">Data about which scenes to unload.</param>
        public void UnloadConnectionScenes(NetworkConnection connection, SceneUnloadData sceneUnloadData)
        {
            //This cannot use cache because the array will persist for many frames after this method completion.
            UnloadConnectionScenes(new NetworkConnection[] { connection }, sceneUnloadData);
        }

        /// <summary>
        /// Unloads scenes on server and tells connections to unload them as well. Other connections will not unload this scene.
        /// </summary>
        /// <param name="connections">Connections to unload scenes for.</param>
        /// <param name="sceneUnloadData">Data about which scenes to unload.</param>
        public void UnloadConnectionScenes(NetworkConnection[] connections, SceneUnloadData sceneUnloadData)
        {
            UnloadConnectionScenes_Internal(connections, sceneUnloadData, _globalScenes, true);
        }

        /// <summary>
        /// Unloads scenes on server without telling any connections to unload them.
        /// </summary>
        /// <param name="sceneUnloadData">Data about which scenes to unload.</param>
        public void UnloadConnectionScenes(SceneUnloadData sceneUnloadData)
        {
            UnloadConnectionScenes_Internal(Array.Empty<NetworkConnection>(), sceneUnloadData, _globalScenes, true);
        }

        private void UnloadConnectionScenes_Internal(NetworkConnection[] connections, SceneUnloadData sceneUnloadData, string[] globalScenes, bool asServer)
        {
            if (!CanExecute(asServer, true))
                return;
            if (SceneDataInvalid(sceneUnloadData, true))
                return;

            UnloadQueueData uqd = new(SceneScopeType.Connections, connections, sceneUnloadData, globalScenes, asServer);
            QueueOperation(uqd);
        }

        /// <summary>
        /// Loads scenes within QueuedSceneLoads.
        /// </summary>
        /// <returns></returns>
        private IEnumerator __UnloadScenes()
        {
            UnloadQueueData data = _queuedOperations[0] as UnloadQueueData;
            SceneUnloadData sceneUnloadData = data.SceneUnloadData;

            //If connection went inactive.
            if (!ConnectionActive(data.AsServer))
                yield break;

            /* Some actions should not run as client if server is also active.
             * This is to keep things from running twice. */
            bool asClientHost = (!data.AsServer && NetworkManager.IsServerStarted);
            ///True if running asServer.
            bool asServer = data.AsServer;

            //Get scenes to unload.
            Scene[] scenes = GetScenes(sceneUnloadData.SceneLookupDatas);
            /* No scenes found. Only run this if not asHost.
             * While asHost scenes will possibly not exist because
             * server side has already unloaded them. But rest of
             * the unload should continue. */
            if (scenes.Length == 0 && !asClientHost)
            {
                NetworkManager.LogWarning($"Scene lookup data of length {sceneUnloadData.SceneLookupDatas.Length} could not find any scenes to unload. This may occur when trying to unload a scene only by handle. Consider using the scene reference or handle and name while creating SceneLookupData.");
                yield break;
            }

            /* Remove from global scenes
             * if server and scope is global.
             * All passed in scenes should be removed from global
             * regardless of if they're valid or not. If they are invalid,
             * then they shouldn't be in global to begin with. */
            if (asServer && data.ScopeType == SceneScopeType.Global)
            {
                RemoveFromGlobalScenes(sceneUnloadData.SceneLookupDatas);
                //Update queue data.
                data.GlobalScenes = _globalScenes;
            }

            /* Remove connections. */
            if (asServer)
            {
                foreach (Scene s in scenes)
                {
                    //If global then remove all connections.
                    if (data.ScopeType == SceneScopeType.Global)
                        RemoveAllConnectionsFromScene(s);
                    //Connections.
                    else if (data.ScopeType == SceneScopeType.Connections)
                        RemoveConnectionsFromScene(data.Connections, s);
                }
            }


            /* This will contain all scenes which can be unloaded.
             * The collection will be modified through various checks. */
            List<Scene> unloadableScenes = scenes.ToList();
            /* Unloaded scenes manually created to overcome
             * the empty names in Scene structs after Unity unloads
             * a scene. */
            List<UnloadedScene> unloadedScenes = new();
            /* If asServer and KeepUnused then clear all unloadables.
             * The clients will still unload the scenes. */
            if ((asServer || asClientHost) && sceneUnloadData.Options.Mode == UnloadOptions.ServerUnloadMode.KeepUnused)
                unloadableScenes.Clear();
            //If clientOnly then force mode to unloadUnused.
            else if (!asServer && !asClientHost)
                sceneUnloadData.Options.Mode = UnloadOptions.ServerUnloadMode.UnloadUnused;
            /* Check to remove global scenes unloadableScenes.
             * This will need to be done if scenes are being unloaded
             * for connections. Global scenes cannot be unloaded as
             * connection. */
            if (data.ScopeType == SceneScopeType.Connections)
                RemoveGlobalScenes(unloadableScenes);
            //If set to unload unused only.
            if (sceneUnloadData.Options.Mode == UnloadOptions.ServerUnloadMode.UnloadUnused)
                RemoveOccupiedScenes(unloadableScenes);

            //If there are scenes to unload.
            if (unloadableScenes.Count > 0)
            {
                InvokeOnSceneUnloadStart(data);
                _sceneProcessor.UnloadStart(data);

                //Begin unloading.
                foreach (Scene s in unloadableScenes)
                {
                    if (!s.IsValid())
                    {
                        NetworkManager.LogWarning($"A scene was expected to be unloaded but could not due to it's referening going missing. This usually occurs when the same scene has been queued for unloading multiple times.");
                        continue;
                    }

                    unloadedScenes.Add(new(s));
                    MoveClientHostObjects(s, asServer);
                    /* Remove from manualUnloadedScenes.
                     * Scene may not be in this collection
                     * but removing is one call vs checking
                     * then removing. */
                    _manualUnloadScenes.Remove(s);

                    _sceneProcessor.BeginUnloadAsync(s);
                    while (!_sceneProcessor.IsPercentComplete())
                        yield return null;
                }

                _sceneProcessor.UnloadEnd(data);
            }

            /* Must yield after sceneProcessor handles things.
             * This is a Unity bug of sorts. I'm not entirely sure what
             * is happening, but without the yield it seems as though
             * the processor logic doesn't complete. This doesn't make much
             * sense given unity is supposed to be single threaded. Must be
             * something to do with the coroutine. */
            yield return null;

            bool byUser;
            Scene preferredActiveScene = GetUserPreferredActiveScene(sceneUnloadData.PreferredActiveScene, asServer, out byUser);
            SetActiveScene(preferredActiveScene, asServer, byUser);

            /* If running as server then make sure server
             * is still active after the unloads. If so
             * send out unloads to clients. */
            if (asServer && ConnectionActive(true))
            {
                //Tell clients to unload same scenes.
                UnloadScenesBroadcast msg = new()
                {
                    QueueData = data
                };
                //Global.
                if (data.ScopeType == SceneScopeType.Global)
                {
                    _serverManager.Broadcast(msg, true);
                }
                //Connections.
                else if (data.ScopeType == SceneScopeType.Connections)
                {
                    if (data.Connections != null)
                    {
                        for (int i = 0; i < data.Connections.Length; i++)
                        {
                            NetworkConnection conn = data.Connections[i];
                            //Would not be null from internals, but users might incorrectly pass null in.
                            if (conn.IsValid())
                                data.Connections[i].Broadcast(msg, true);
                        }
                    }
                }
            }
            else if (!asServer)
            {
                NetworkConnection localConnection = NetworkManager.ClientManager.Connection;
                //Remove from old scenes.
                foreach (Scene item in unloadableScenes)
                {
                    if (item.IsValid())
                        localConnection.RemoveFromScene(item);
                }
            }

            InvokeOnSceneUnloadEnd(data, unloadableScenes, unloadedScenes);
        }

        /// <summary>
        /// Received on clients when networked scenes must be unloaded.
        /// </summary>
        /// <param name="conn"></param>
        /// <param name="msg"></param>
        private void OnServerUnloadedScenes(UnloadScenesBroadcast msg, Channel channel)
        {
            UnloadQueueData qd = msg.QueueData;
            if (qd.ScopeType == SceneScopeType.Global)
                UnloadGlobalScenes_Internal(qd.SceneUnloadData, qd.GlobalScenes, false);
            else
                UnloadConnectionScenes_Internal(Array.Empty<NetworkConnection>(), qd.SceneUnloadData, qd.GlobalScenes, false);
        }
        #endregion

        /// <summary>
        /// Move objects visible to clientHost that are within an unloading scene.This ensures the objects are despawned on the client side rather than when the scene is destroyed.
        /// </summary>
        /// <param name="scene"></param>
        private void MoveClientHostObjects(Scene scene, bool asServer)
        {
            if (!_moveClientObjects)
                return;
            /* The asServer isn't really needed. I could only call
             * this method when asServer is true. But for the sake
             * of preventing user-error (me being the user this time)
             * I've included it into the parameters. */
            if (!asServer)
                return;
            //Don't need to perform if not host.
            if (!NetworkManager.IsClientStarted)
                return;

            NetworkConnection clientConn = NetworkManager.ClientManager.Connection;
            /* It would be nice to see if the client wasn't even in the scene
             * here using SceneConnections but it's possible that the scene had been
             * wiped from SceneConnections earlier depending on how scenes are
             * loaded or unloaded. Instead we must iterate through spawned objects. */

            List<NetworkObject> movingNobs = CollectionCaches<NetworkObject>.RetrieveList();
            /* Rather than a get all networkobjects in scene
             * let's iterate the spawned objects instead. I imagine
             * in most scenarios iterating spawned would be faster.
             * That's a long one! */
            foreach (NetworkObject nob in NetworkManager.ServerManager.Objects.Spawned.Values)
            {
                //Not in the scene being destroyed.
                if (nob.gameObject.scene != scene)
                    continue;
                //ClientHost doesn't have visibility.
                if (!nob.Observers.Contains(clientConn))
                    continue;
                //Cannot move if not root.
                if (nob.transform.root != null)
                    continue;

                /* If here nob is in the same being
                 * destroyed and clientHost has visiblity. */
                movingNobs.Add(nob);
            }

            int count = movingNobs.Count;
            if (count > 0)
            {
                Scene moveScene = GetDelayedDestroyScene();
                for (int i = 0; i < count; i++)
                {
                    NetworkObject nob = movingNobs[i];
                    /* Force as not a scene object
                     * so that it becomes destroyed
                     * rather than disabled. */
                    nob.ClearRuntimeSceneObject();
                    /* If the object is already being despawned then
                     *just disable and move it. Otherwise despawn it
                     * on the server then move it. */
                    //Not deinitializing, despawn it then.
                    if (!nob.IsDeinitializing)
                        nob.Despawn();
                    else
                        nob.gameObject.SetActive(false);

                    UnitySceneManager.MoveGameObjectToScene(nob.gameObject, moveScene);
                }
            }
            CollectionCaches<NetworkObject>.Store(movingNobs);
        }

        /// <summary>
        /// Returns if a connection is in a scene using SceneConnections.
        /// </summary>
        /// <param name="conn"></param>
        /// <param name="scene"></param>
        /// <returns></returns>
        internal bool InSceneConnections(NetworkConnection conn, Scene scene)
        {
            if (!SceneConnections.TryGetValueIL2CPP(scene, out HashSet<NetworkConnection> hs))
                return false;
            else
                return hs.Contains(conn);
        }

        /// <summary>
        /// Adds the owner of nob to the gameObjects scene if there are no global scenes.
        /// </summary>
        public void AddOwnerToDefaultScene(NetworkObject nob)
        {
            //No owner.
            if (!nob.Owner.IsValid)
            {
                NetworkManager.LogWarning($"NetworkObject {nob.name} does not have an owner.");
                return;
            }
            //Won't add to default if there are globals.
            if (_globalScenes.Length > 0)
                return;

            AddConnectionToScene(nob.Owner, nob.gameObject.scene);
        }

        /// <summary>
        /// Adds a connection to a scene. This will always be called one connection at a time because connections are only added after they invidually validate loading the scene.
        /// Exposed for power users, use caution.
        /// </summary>
        /// <param name="conn">Connection to add.</param>
        /// <param name="scene">Scene to add the connection to.</param>
        public void AddConnectionToScene(NetworkConnection conn, Scene scene)
        {
            if (!conn.IsValid())
                return;
            if (!scene.isLoaded || !scene.IsValid())
            {
                NetworkManager.LogError($"Only valid, loaded scenes may be used.");
                return;
            }

            HashSet<NetworkConnection> hs;
            //Scene doesn't have any connections yet.
            bool inSceneConnections = SceneConnections.TryGetValueIL2CPP(scene, out hs);
            if (!inSceneConnections)
                hs = new();

            bool added = hs.Add(conn);
            if (added)
            {
                conn.AddToScene(scene);

                //If not yet added to scene connections.
                if (!inSceneConnections)
                    SceneConnections[scene] = hs;

                NetworkConnection[] arrayConn = new NetworkConnection[] { conn };
                InvokeClientPresenceChange(scene, arrayConn, true, true);
                RebuildObservers(arrayConn);
                InvokeClientPresenceChange(scene, arrayConn, true, false);

                /* Also need to rebuild all networkobjects
                 * for connection so other players can
                 * see them. */
                RebuildObservers(conn.Objects.ToArray());
            }
        }

        /// <summary>
        /// Removes connections from any scene which is not global.
        /// Exposed for power users, use caution.
        /// </summary>
        /// <param name="conns"></param>
        public void RemoveConnectionsFromNonGlobalScenes(NetworkConnection[] conns)
        {
            List<Scene> removedScenes = new();

            foreach (KeyValuePair<Scene, HashSet<NetworkConnection>> item in SceneConnections)
            {
                Scene scene = item.Key;
                //Cannot remove from globla scenes.
                if (IsGlobalScene(scene))
                    continue;

                HashSet<NetworkConnection> hs = item.Value;
                List<NetworkConnection> connectionsRemoved = new();
                //Remove every connection from the scene.
                foreach (NetworkConnection c in conns)
                {
                    if (!c.IsValid())
                        continue;

                    bool removed = hs.Remove(c);
                    if (removed)
                    {
                        c.RemoveFromScene(scene);
                        connectionsRemoved.Add(c);
                    }
                }

                //If hashset is empty then remove scene from SceneConnections.
                if (hs.Count == 0)
                    removedScenes.Add(scene);

                if (connectionsRemoved.Count > 0)
                {
                    InvokeClientPresenceChange(scene, connectionsRemoved, false, true);
                    RebuildObservers(connectionsRemoved);
                    InvokeClientPresenceChange(scene, connectionsRemoved, false, false);
                }
            }

            foreach (Scene s in removedScenes)
                SceneConnections.Remove(s);

            /* Also rebuild observers for objects owned by connection.
             * This ensures other connections will lose visibility if
             * they no longer share a scene. */
            foreach (NetworkConnection c in conns)
                RebuildObservers(c.Objects.ToArray());
        }

        /// <summary>
        /// Removes connections from specified scenes.
        /// Exposed for power users, use caution.
        /// </summary>
        /// <param name="conns">Connections to remove.</param>
        /// <param name="scene">Scene to remove from.</param>
        public void RemoveConnectionsFromScene(NetworkConnection[] conns, Scene scene)
        {
            HashSet<NetworkConnection> hs;
            //No hashset for scene, so no connections are in scene.
            if (!SceneConnections.TryGetValueIL2CPP(scene, out hs))
                return;

            List<NetworkConnection> connectionsRemoved = new();
            //Remove every connection from the scene.
            foreach (NetworkConnection c in conns)
            {
                if (!c.IsValid())
                    continue;

                bool removed = hs.Remove(c);
                if (removed)
                {
                    c.RemoveFromScene(scene);
                    connectionsRemoved.Add(c);
                }
            }

            //If hashset is empty then remove scene from SceneConnections.
            if (hs.Count == 0)
                SceneConnections.Remove(scene);

            if (connectionsRemoved.Count > 0)
            {
                NetworkConnection[] connectionsRemovedArray = connectionsRemoved.ToArray();
                InvokeClientPresenceChange(scene, connectionsRemovedArray, false, true);
                RebuildObservers(connectionsRemovedArray);
                InvokeClientPresenceChange(scene, connectionsRemovedArray, false, false);
            }

            /* Also rebuild observers for objects owned by connection.
             * This ensures other connections will lose visibility if
             * they no longer share a scene. */
            foreach (NetworkConnection c in conns)
                RebuildObservers(c.Objects.ToArray());
        }

        /// <summary>
        /// Removes all connections from a scene.
        /// </summary>
        /// <param name="scene">Scene to remove connections from.</param>
        public void RemoveAllConnectionsFromScene(Scene scene)
        {
            HashSet<NetworkConnection> hs;
            //No hashset for scene, so no connections are in scene.
            if (!SceneConnections.TryGetValueIL2CPP(scene, out hs))
                return;

            //On each connection remove them from specified scene.
            foreach (NetworkConnection c in hs)
                c.RemoveFromScene(scene);
            //Make hashset into list for presence change.
            NetworkConnection[] connectionsRemoved = hs.ToArray();

            //Clear hashset and remove entry from sceneconnections.
            hs.Clear();
            SceneConnections.Remove(scene);

            if (connectionsRemoved.Length > 0)
            {
                InvokeClientPresenceChange(scene, connectionsRemoved, false, true);
                RebuildObservers(connectionsRemoved);
                InvokeClientPresenceChange(scene, connectionsRemoved, false, false);
            }

            /* Also rebuild observers for objects owned by connection.
             * This ensures other connections will lose visibility if
             * they no longer share a scene. */
            foreach (NetworkConnection c in connectionsRemoved)
                RebuildObservers(c.Objects.ToArray());
        }

        #region Can Load/Unload Scene.
        /// <summary>
        /// Returns if a scene can be loaded locally.
        /// </summary>
        /// <returns></returns>
        private bool CanLoadScene(LoadQueueData qd, SceneLookupData sld)
        {
            bool foundByHandle;
            Scene s = sld.GetScene(out foundByHandle);
            //Try to find if scene is already loaded.
            bool alreadyLoaded = !string.IsNullOrEmpty(s.name);

            if (alreadyLoaded)
            {
                //Only servers can load the same scene multiple times for stacking.
                if (!qd.AsServer)
                    return false;
                //If can only load scenes which aren't loaded yet and scene is already loaded.
                if (!qd.SceneLoadData.Options.AllowStacking)
                    return false;
                /* Found by handle, this means the user is trying to specify
                 * exactly which scene to load into. When a handle is specified
                 * new instances will not be created, so a new scene cannot
                 * be loaded. */
                if (alreadyLoaded && foundByHandle)
                    return false;
            }

            //Fall through.
            return true;
        }
        #endregion

        #region Helpers.
        /// <summary>
        /// Rebuilds observers for networkObjects.
        /// </summary>
        /// <param name="networkObjects"></param>
        private void RebuildObservers(IList<NetworkObject> networkObjects)
        {
            NetworkObject nob;
            int count = networkObjects.Count;
            for (int i = 0; i < count; i++)
            {
                nob = networkObjects[i];
                if (nob != null && nob.IsSpawned)
                    _serverManager.Objects.RebuildObservers(nob);
            }
        }

        /// <summary>
        /// Rebuilds all NetworkObjects for connection.
        /// </summary>
        internal void RebuildObservers(NetworkConnection connection)
        {
            List<NetworkConnection> connCache = CollectionCaches<NetworkConnection>.RetrieveList(connection);
            RebuildObservers(connCache);
            CollectionCaches<NetworkConnection>.Store(connCache);
        }

        /// <summary>
        /// Rebuilds all NetworkObjects for connections.
        /// </summary>
        internal void RebuildObservers(IList<NetworkConnection> connections)
        {
            int count = connections.Count;
            for (int i = 0; i < count; i++)
                _serverManager.Objects.RebuildObservers(connections[i]);
        }

        /// <summary>
        /// Invokes OnClientPresenceChange start or end.
        /// </summary>
        private void InvokeClientPresenceChange(Scene scene, IList<NetworkConnection> conns, bool added, bool start)
        {
            NetworkConnection c;
            int count = conns.Count;
            for (int i = 0; i < count; i++)
            {
                c = conns[i];
                ClientPresenceChangeEventArgs cpc = new(scene, c, added);
                if (start)
                    OnClientPresenceChangeStart?.Invoke(cpc);
                else
                    OnClientPresenceChangeEnd?.Invoke(cpc);
            }
        }
        #endregion

        #region GetScene.
        /// <summary>
        /// Gets scenes from SceneLookupData.
        /// </summary>
        /// <param name="datas"></param>
        /// <returns></returns>
        private Scene[] GetScenes(SceneLookupData[] datas)
        {
            List<Scene> result = new();
            foreach (SceneLookupData sld in datas)
            {
                Scene s = sld.GetScene(out _);
                if (!string.IsNullOrEmpty(s.name))
                {
                    result.Add(s);
                }
            }

            return result.ToArray();
        }

        /// <summary>
        /// Returns a scene by name.
        /// </summary>
        /// <param name="sceneName">Name of scene to retrieve.</param>
        /// <param name="nm">NetworkManager to use for debug print. This value may be left null.</param>
        /// <param name="warnIfDuplicates">True to warn if scene name is found loaded multiple times.</param>
        /// <returns></returns>
        public static Scene GetScene(string sceneName, NetworkManager nm = null, bool warnIfDuplicates = true)
        {
            Scene result = default;
            sceneName = sceneName.ToLower();

            int count = UnitySceneManager.sceneCount;
            for (int i = 0; i < count; i++)
            {
                Scene s = UnitySceneManager.GetSceneAt(i);
                //Matches.
                if (s.name.ToLower() == sceneName)
                {
                    //If result is already set.
                    if (result.IsValid())
                    {
                        if (warnIfDuplicates)
                        {
                            string msg = $"Scene name {s.name} is loaded multiple times. The first scene found will be returned. If you wish to unload multiple instances of a scene with the same name create {nameof(SceneLookupData)} using scene handles instead of name.";
                            nm.LogWarning(msg);
                            //No need to spam the message, break on first duplicate.
                            break;
                        }
                    }
                    else
                    {
                        result = s;
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Returns a scene by handle.
        /// </summary>
        /// <param name="sceneHandle"></param>
        /// <returns></returns>
        public static Scene GetScene(int sceneHandle)
        {
            int count = UnitySceneManager.sceneCount;
            for (int i = 0; i < count; i++)
            {
                Scene s = UnitySceneManager.GetSceneAt(i);
                if (s.handle == sceneHandle)
                    return s;
            }

            return new();
        }
        #endregion

        /// <summary>
        /// Returns if GlobalScenes contains scene.
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        private bool IsGlobalScene(Scene scene)
        {
            foreach (string item in _globalScenes)
            {
                string nameOnly = System.IO.Path.GetFileNameWithoutExtension(item);
                if (item == scene.name || nameOnly == scene.name)
                    return true;
            }
            return false;
        }

        /// <summary>
        /// Warns if any scene names in GlobalScenes are unsupported.
        /// This only applies to FishNet version 3.
        /// </summary>
        private void CheckForDuplicateGlobalSceneNames()
        {
            /* This is being removed between version 4.0.0 to 4.1.0 */
            HashSet<string> namesOnly = CollectionCaches<string>.RetrieveHashSet();
            foreach (string item in _globalScenes)
            {
                string name = System.IO.Path.GetFileNameWithoutExtension(item);
                if (namesOnly.Contains(name))
                {
                    NetworkManager.LogWarning($"There are multiple global scenes loaded with the same NameOnly. This occurs when a global scene has the same name as another but resides in a different folder path. Each global scene name must be unique.");
                    break;
                }
                else
                {
                    namesOnly.Add(name);
                }
            }
        }

        /// <summary>
        /// Removes datas from GlobalScenes.
        /// </summary>
        /// <param name="scenes"></param>
        private void RemoveFromGlobalScenes(Scene scene)
        {
            RemoveFromGlobalScenes(new SceneLookupData[] { SceneLookupData.CreateData(scene) });
        }

        /// <summary>
        /// Removes datas from GlobalScenes.
        /// </summary>
        /// <param name="scenes"></param>
        private void RemoveFromGlobalScenes(SceneLookupData[] datas)
        {
            List<string> newGlobalScenes = _globalScenes.ToList();
            int startCount = newGlobalScenes.Count;
            //Remove scenes.
            for (int i = 0; i < datas.Length; i++)
                newGlobalScenes.Remove(datas[i].Name);

            //If any were removed remake globalscenes.
            if (startCount != newGlobalScenes.Count)
                _globalScenes = newGlobalScenes.ToArray();
        }

        /// <summary>
        /// Removes GlobalScenes from scenes.
        /// </summary>
        /// <param name="scenes"></param>
        /// <returns></returns>
        private void RemoveGlobalScenes(List<Scene> scenes)
        {
            for (int i = 0; i < scenes.Count; i++)
            {
                foreach (string gs in _globalScenes)
                {
                    if (gs == scenes[i].name)
                    {
                        scenes.RemoveAt(i);
                        i--;
                    }
                }
            }
        }

        /// <summary>
        /// Removes occupied scenes from scenes.
        /// </summary>
        /// <param name="scenes"></param>
        private void RemoveOccupiedScenes(List<Scene> scenes)
        {
            for (int i = 0; i < scenes.Count; i++)
            {
                if (SceneConnections.TryGetValueIL2CPP(scenes[i], out _))
                {
                    scenes.RemoveAt(i);
                    i--;
                }
            }
        }

        /// <summary>
        /// Adds a pending load for a connection.
        /// </summary>
        private void AddPendingLoad(NetworkConnection conn)
        {
            NetworkConnection[] conns = CollectionCaches<NetworkConnection>.RetrieveArray();
            if (conns.Length == 0)
                conns = new NetworkConnection[1];
            conns[0] = conn;

            AddPendingLoad(conns, 1);
            CollectionCaches<NetworkConnection>.Store(conns, 1);
        }

        /// <summary>
        /// Adds a pending load for a connection.
        /// </summary>
        private void AddPendingLoad(NetworkConnection[] conns, int count)
        {
            foreach (NetworkConnection c in conns)
            {
                /* Make sure connection is active. This should always be true
                 * but perhaps disconnect happened as scene was loading on server
                 * therefor it cannot be sent to the client.
                 * Also only authenticated clients can load scenes. */
                if (!c.IsActive || !c.IsAuthenticated)
                    continue;

                if (_pendingClientSceneChanges.TryGetValue(c, out int result))
                    _pendingClientSceneChanges[c] = (result + 1);
                else
                    _pendingClientSceneChanges[c] = 1;
            }
        }

        /// <summary>
        /// Sets the first global scene as the active scene.
        /// If a global scene is not available then FallbackActiveScene is used.
        /// </summary>
        private void SetActiveScene(Scene preferredScene, bool asServer, bool byUser)
        {
            //If user specified then skip figuring it out checks.
            if (byUser && preferredScene.IsValid())
            {
                CompleteSetActive(preferredScene);
            }
            //Setting active scene is not used.
            else if (!_setActiveScene)
            {
                //Still invoke event with current scene.
                Scene s = UnitySceneManager.GetActiveScene();
                CompleteSetActive(s);
            }
            //Need to figure out which scene to use.
            else
            {
                Scene s = default;

                if (_globalScenes.Length > 0)
                    s = GetScene(_globalScenes[0], NetworkManager, false);
                else if (preferredScene.IsValid())
                    s = preferredScene;

                /* If scene isn't set from global then make
                 * sure currently active isn't the movedobjectscene.
                 * If it is, then use the fallback scene. */
                if (string.IsNullOrEmpty(s.name) && UnitySceneManager.GetActiveScene() == _movedObjectsScene)
                    s = GetFallbackActiveScene();

                CompleteSetActive(s);
            }

            //Completes setting the active scene with specified value.
            void CompleteSetActive(Scene scene)
            {
                bool sceneValid = scene.IsValid();
                if (sceneValid)
                    UnitySceneManager.SetActiveScene(scene);

                OnActiveSceneSet?.Invoke(byUser);
                OnActiveSceneSetInternal?.Invoke(asServer);

                if (sceneValid)
                {
                    //Also update light probes.
                    if (_lightProbeUpdating == LightProbeUpdateType.Asynchronous)
                        LightProbes.TetrahedralizeAsync();
                    else if (_lightProbeUpdating == LightProbeUpdateType.BlockThread)
                        LightProbes.Tetrahedralize();
                }
            }
        }

        /// <summary>
        /// Returns the FallbackActiveScene.
        /// </summary>
        /// <returns></returns>
        private Scene GetFallbackActiveScene() => _sceneProcessor.GetFallbackActiveScene();

        /// <summary>
        /// Returns the MovedObjectsScene.
        /// </summary>
        /// <returns></returns>
        private Scene GetMovedObjectsScene() => _sceneProcessor.GetMovedObjectsScene();

        /// <summary>
        /// Returns the DelayedDestroyScene.
        /// </summary>
        /// <returns></returns>
        private Scene GetDelayedDestroyScene() => _sceneProcessor.GetDelayedDestroyScene();

        /// <summary>
        /// Returns a preferred active scene to use.
        /// </summary>
        private Scene GetUserPreferredActiveScene(PreferredScene ps, bool asServer, out bool byUser)
        {
            byUser = false;
            SceneLookupData sld = (asServer) ? ps.Server : ps.Client;
            //Not specified.
            if (sld == null)
                return default;

            Scene s = sld.GetScene(out _);
            if (s.IsValid())
                byUser = true;
            return s;
        }

        #region Sanity checks.
        /// <summary>
        /// Returns if iterating queue.
        /// True will be returned even if not iterating queue if the iteration had completed with the time requirement.
        internal bool IsIteratingQueue(float completionTimeRequirement = 0f)
        {
            return (IteratingQueue || (Time.unscaledTime - QueueCompleteTime) < completionTimeRequirement);
        }

        /// <summary>
        /// Returns if a SceneLoadData is valid.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="error"></param>
        /// <returns></returns>
        private bool SceneDataInvalid(SceneLoadData data, bool error)
        {
            bool result = data.DataInvalid();
            if (result && error)
                NetworkManager.LogError(INVALID_SCENELOADDATA);

            return result;
        }

        /// <summary>
        /// Returns if a SceneLoadData is valid.
        /// </summary>
        /// <param name="data"></param>
        /// <param name="error"></param>
        /// <returns></returns>
        private bool SceneDataInvalid(SceneUnloadData data, bool error)
        {
            bool result = data.DataInvalid();
            if (result && error)
                NetworkManager.LogError(INVALID_SCENEUNLOADDATA);


            return result;
        }

        /// <summary>
        /// Returns if connection is active for server or client in association with AsServer.
        /// </summary>
        /// <param name="asServer"></param>
        /// <returns></returns>
        private bool ConnectionActive(bool asServer)
        {
            return (asServer) ? NetworkManager.IsServerStarted : NetworkManager.IsClientStarted;
        }

        /// <summary>
        /// Returns if a method can execute.
        /// </summary>
        /// <param name="asServer"></param>
        /// <param name="warn"></param>
        /// <returns></returns>
        private bool CanExecute(bool asServer, bool warn)
        {
            bool result;
            if (asServer)
            {
                result = NetworkManager.IsServerStarted;
                if (!result && warn)
                    NetworkManager.LogWarning($"Method cannot be called as the server is not active.");
            }
            else
            {
                result = NetworkManager.IsClientStarted;
                if (!result && warn)
                    NetworkManager.LogWarning($"Method cannot be called as the client is not active.");
            }

            return result;
        }
        #endregion
    }
}

//#endif﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityScene = UnityEngine.SceneManagement.Scene;
using UnitySceneManager = UnityEngine.SceneManagement.SceneManager;

namespace FishNet.Managing.Scened
{

    public abstract class SceneProcessorBase : MonoBehaviour
    {
        #region Protected.
        /// <summary>
        /// SceneManager for this processor.
        /// </summary>
        protected SceneManager SceneManager;
        /// <summary>
        /// Scene used to store objects while they are being moved from one scene to another.
        /// </summary>
        protected Scene MovedObjectsScene;
        /// <summary>
        /// Scene used to store objects queued for destruction but cannot be destroyed until the clientHost gets the despawn packet.
        /// </summary>
        protected Scene DelayedDestroyScene;
        /// <summary>
        /// Scene used as the active scene when the user does not specify which scene to set active and the scenemanager cannot determine one without error.
        /// This is primarily used so scenes with incorrect or unexpected lighting are not set as the active scene given this may disrupt visuals.
        /// </summary>
        protected Scene FallbackActiveScene;
        #endregion

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="manager">SceneManager which will be utilizing this class.</param>
        public virtual void Initialize(SceneManager manager)
        {
            SceneManager = manager;
        }
        /// <summary>
        /// Called when scene loading has begun.
        /// </summary>
        public virtual void LoadStart(LoadQueueData queueData) { }
        /// <summary>
        /// Called when scene loading has ended.
        /// </summary>
        public virtual void LoadEnd(LoadQueueData queueData) { }
        /// <summary>
        /// Called when scene unloading has begun within a load operation.
        /// </summary>
        public virtual void UnloadStart(LoadQueueData queueData) { }
        /// <summary>
        /// Called when scene unloading has ended within a load operation.
        /// </summary>
        public virtual void UnloadEnd(LoadQueueData queueData) { }
        /// <summary>
        /// Called when scene unloading has begun within an unload operation.
        /// </summary>
        public virtual void UnloadStart(UnloadQueueData queueData) { }
        /// <summary>
        /// Called when scene unloading has ended within an unload operation.
        /// </summary>
        public virtual void UnloadEnd(UnloadQueueData queueData) { }
        /// <summary>
        /// Begin loading a scene using an async method.
        /// </summary>
        /// <param name="sceneName">Scene name to load.</param>
        public abstract void BeginLoadAsync(string sceneName, LoadSceneParameters parameters);
        /// <summary>
        /// Begin unloading a scene using an async method.
        /// </summary>
        /// <param name="sceneName">Scene name to unload.</param>
        public abstract void BeginUnloadAsync(Scene scene);
        /// <summary>
        /// Returns if a scene load or unload percent is done.
        /// </summary>
        /// <returns></returns>
        public abstract bool IsPercentComplete();
        /// <summary>
        /// Returns the progress on the current scene load or unload.
        /// </summary>
        /// <returns></returns>
        public abstract float GetPercentComplete();
        /// <summary>
        /// Gets the scene last loaded by the processor.
        /// </summary>
        /// <remarks>This is called after IsPercentComplete returns true.</remarks>
        public virtual Scene GetLastLoadedScene() => default;
        /// <summary>
        /// Adds a scene to loaded scenes.
        /// </summary>
        /// <param name="scene">Scene loaded.</param>
        public virtual void AddLoadedScene(Scene scene) { }
        /// <summary>
        /// Returns scenes which were loaded during a load operation.
        /// </summary>
        public abstract List<Scene> GetLoadedScenes();
        /// <summary>
        /// Activates scenes which were loaded.
        /// </summary>
        public abstract void ActivateLoadedScenes();
        /// <summary>
        /// Returns if all asynchronized tasks are considered IsDone.
        /// </summary>
        /// <returns></returns>
        public abstract IEnumerator AsyncsIsDone();

        /// <summary>
        /// Returns the MovedObjectsScene.
        /// </summary>
        /// <returns></returns>
        public virtual Scene GetMovedObjectsScene()
        {
            //Create moved objects scene. It will probably be used eventually. If not, no harm either way.
            if (string.IsNullOrEmpty(MovedObjectsScene.name))
                MovedObjectsScene = FindOrCreateScene("MovedObjectsHolder");

            return MovedObjectsScene;
        }

        /// <summary>
        /// Returns the DelayedDestroyScene.
        /// </summary>
        /// <returns></returns>
        public virtual Scene GetDelayedDestroyScene()
        {
            //Create moved objects scene. It will probably be used eventually. If not, no harm either way.
            if (string.IsNullOrEmpty(DelayedDestroyScene.name))
                DelayedDestroyScene = FindOrCreateScene("DelayedDestroy");

            return DelayedDestroyScene;
        }

        /// <summary>
        /// Returns the FallbackActiveScene.
        /// </summary>
        /// <returns></returns>
        public virtual Scene GetFallbackActiveScene()
        {
            if (string.IsNullOrEmpty(FallbackActiveScene.name))
                FallbackActiveScene = FindOrCreateScene("FallbackActiveScene");

            return FallbackActiveScene;
        }

        /// <summary>
        /// Tries to find a scene by name and if it does not exist creates an empty scene of name.
        /// </summary>
        /// <param name="name">Name of the scene to find or create.</param>
        /// <returns></returns>
        public virtual Scene FindOrCreateScene(string name)
        {
            Scene result = UnitySceneManager.GetSceneByName(name);
            if (!result.IsValid())
                result = UnitySceneManager.CreateScene(name);

            return result;
        }
    }


}﻿
//using FishNet.Managing.Scened.Data;
//using System;
//using UnityEngine;
//using UnityEngine.SceneManagement;

//namespace FishNet.Managing.Scened
//{

//    public static class SceneSpawner
//    {

//        #region Prefab.
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(Scene scene, GameObject prefab)
//        {
//            return Instantiate<GameObject>(scene, prefab);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(Scene scene, GameObject prefab)
//        {
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, null, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(SceneReferenceData sceneReferenceData, GameObject prefab)
//        {
//            return Instantiate<GameObject>(sceneReferenceData, prefab);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(SceneReferenceData sceneReferenceData, GameObject prefab)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneReferenceData);
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, null, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(int sceneHandle, GameObject prefab)
//        {
//            return Instantiate<GameObject>(sceneHandle, prefab, prefab.transform.position, prefab.transform.rotation, null);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(int sceneHandle, GameObject prefab)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneHandle);
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, null, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(string sceneName, GameObject prefab)
//        {
//            return Instantiate<GameObject>(sceneName, prefab);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(string sceneName, GameObject prefab)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneName);
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, null, true);
//        }
//        #endregion




//        #region Prefab, Parent, WorldSpace
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(Scene scene, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            return Instantiate<GameObject>(scene, prefab, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(Scene scene, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(SceneReferenceData sceneReferenceData, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            return Instantiate<GameObject>(sceneReferenceData, prefab, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(SceneReferenceData sceneReferenceData, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneReferenceData);
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(int sceneHandle, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            return Instantiate<GameObject>(sceneHandle, prefab, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(int sceneHandle, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneHandle);
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(string sceneName, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            return Instantiate<GameObject>(sceneName, prefab, parent, instantiateInWorldSpace);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(string sceneName, GameObject prefab, Transform parent, bool instantiateInWorldSpace = true)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneName);
//            return Instantiate<T>(scene, prefab, prefab.transform.position, prefab.transform.rotation, parent, instantiateInWorldSpace);
//        }
//        #endregion




//        #region Prefab, Position, Rotation.
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(Scene scene, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            return Instantiate<GameObject>(scene, prefab, position, rotation);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(Scene scene, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            return Instantiate<T>(scene, prefab, position, rotation, null, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(SceneReferenceData sceneReferenceData, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            return Instantiate<GameObject>(sceneReferenceData, prefab, position, rotation);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(SceneReferenceData sceneReferenceData, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneReferenceData);
//            return Instantiate<T>(scene, prefab, position, rotation, null, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(int sceneHandle, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            return Instantiate<GameObject>(sceneHandle, prefab, position, rotation);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(int sceneHandle, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneHandle);
//            return Instantiate<T>(scene, prefab, position, rotation, null, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(string sceneName, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            return Instantiate<GameObject>(sceneName, prefab, position, rotation);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(string sceneName, GameObject prefab, Vector3 position, Quaternion rotation)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneName);
//            return Instantiate<T>(scene, prefab, position, rotation, null, true);
//        }
//        #endregion




//        #region Prefab, Position, Rotation, Parent.
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns> 
//        public static GameObject Instantiate(Scene scene, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            return Instantiate<GameObject>(scene, prefab, position, rotation, parent);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(Scene scene, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            return Instantiate<T>(scene, prefab, position, rotation, parent, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(SceneReferenceData sceneReferenceData, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            return Instantiate<GameObject>(sceneReferenceData, prefab, position, rotation, parent);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(SceneReferenceData sceneReferenceData, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneReferenceData);
//            return Instantiate<T>(scene, prefab, position, rotation, parent, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(int sceneHandle, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            return Instantiate<GameObject>(sceneHandle, prefab, position, rotation, parent);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(int sceneHandle, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneHandle);
//            return Instantiate<T>(scene, prefab, position, rotation, parent, true);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static GameObject Instantiate(string sceneName, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            return Instantiate<GameObject>(sceneName, prefab, position, rotation, parent);
//        }
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        public static T Instantiate<T>(string sceneName, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent)
//        {
//            Scene scene = SceneManager.ReturnScene(sceneName);
//            return Instantiate<T>(scene, prefab, position, rotation, parent, true);
//        }
//        #endregion


//        #region Instantiator.
//        /// <summary>
//        /// Instantiates a prefab and moves it to a scene.
//        /// </summary>
//        /// <returns>Instantiated prefab or script.</returns>
//        private static T Instantiate<T>(Scene scene, GameObject prefab, Vector3 position, Quaternion rotation, Transform parent, bool instantiateInWorldSpace)
//        {
//            if (string.IsNullOrEmpty(scene.name))
//            {
//                Debug.LogWarning("Scene does not exist. Prefab cannot be instantiated.");
//                return default(T);
//            }

//            GameObject result = MonoBehaviour.Instantiate(prefab, position, rotation);
//            if (result != null)
//            {
//                //Move to new scene first.
//                UnityEngine.SceneManagement.SceneManager.MoveGameObjectToScene(result, scene);

//                //Set parent and spaces.
//                if (parent != null)
//                {
//                    result.transform.SetParent(parent);
//                    //If to not instantiate in world space then update pos/rot to localspace.
//                    if (!instantiateInWorldSpace)
//                    {
//                        result.transform.localPosition = position;
//                        result.transform.localRotation = rotation;
//                    }
//                }

//                //If was a gameobject then return as GO.
//                if (typeof(T) == typeof(GameObject))
//                    return (T)Convert.ChangeType(result, typeof(GameObject));
//                //Otherwise use getcomponent on the type.
//                else
//                    return result.GetComponent<T>();
//            }
//            //Couldn't be instantiated, return default of T.
//            else
//            {
//                return default(T);
//            }

//        }
//        #endregion


//    }




//}﻿using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{
    public struct UnloadedScene
    {
        public readonly string Name;
        public readonly int Handle;

        public UnloadedScene(Scene s)
        {
            Name = s.name;
            Handle = s.handle;
        }
        public UnloadedScene(string name, int handle)
        {
            Name = name;
            Handle = handle;
        }

        /// <summary>
        /// Returns a scene based on handle.
        /// Result may not be valid as some Unity versions discard of the scene information after unloading.
        /// </summary>
        /// <returns></returns>
        public Scene GetScene()
        {
            int loadedScenes = UnityEngine.SceneManagement.SceneManager.sceneCount;
            for (int i = 0; i < loadedScenes; i++)
            {
                Scene s = UnityEngine.SceneManagement.SceneManager.GetSceneAt(i);
                if (s.IsValid() && s.handle == Handle)
                    return s;
            }

            return default;
        }
    }
}
﻿using FishNet.Broadcast;
using FishNet.Documenting;

namespace FishNet.Managing.Scened
{

    /// <summary>
    /// Sent when there are starting scenes for the client to load.
    /// </summary>
    public struct EmptyStartScenesBroadcast : IBroadcast { }
    /// <summary>
    /// Sent to clients to load networked scenes.
    /// </summary>
    [APIExclude]
    public struct LoadScenesBroadcast : IBroadcast
    {
        public LoadQueueData QueueData;
    }

    /// <summary>       
    /// Sent to clients to unload networked scenes.
    /// </summary>     
    [APIExclude]
    public struct UnloadScenesBroadcast : IBroadcast
    {
        public UnloadQueueData QueueData;
    }

    /// <summary> 
    /// Sent to server to indicate which scenes a client has loaded.
    /// </summary>
    [APIExclude]
    public struct ClientScenesLoadedBroadcast : IBroadcast
    {
        public SceneLookupData[] SceneLookupDatas;
    }

}﻿using FishNet.Connection;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Data container about a scene presence change for a client.
    /// </summary>
    public struct ClientPresenceChangeEventArgs
    {

        /// <summary>
        /// Scene on the server which the client's presence has changed.
        /// </summary>
        public Scene Scene;
        /// <summary>
        /// Connection to client.
        /// </summary>
        public NetworkConnection Connection;
        /// <summary>
        /// True if the client was added to the scene, false is removed.
        /// </summary>
        public bool Added;

        internal ClientPresenceChangeEventArgs(Scene scene, NetworkConnection conn, bool added)
        {
            Scene = scene;
            Connection = conn;
            Added = added;
        }
    }


}﻿using System.Collections.Generic;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Data container about a scene load start.
    /// </summary>
    public struct SceneLoadStartEventArgs
    {
        /// <summary>
        /// Queue data used by the current scene action.
        /// </summary>
        public readonly LoadQueueData QueueData;

        internal SceneLoadStartEventArgs(LoadQueueData lqd)
        {
            QueueData = lqd;
        }
    }


    /// <summary>
    /// Data container about a scene load percent change.
    /// </summary>
    public struct SceneLoadPercentEventArgs
    {
        /// <summary>
        /// Queue data used by the current scene action.
        /// </summary>
        public readonly LoadQueueData QueueData;
        /// <summary>
        /// Percentage of change completion. 1f is equal to 100% complete.
        /// </summary>
        public readonly float Percent;

        internal SceneLoadPercentEventArgs(LoadQueueData lqd, float percent)
        {
            QueueData = lqd;
            Percent = percent;
        }
    }


    /// <summary>
    /// Data container about a scene load end.
    /// </summary>
    public struct SceneLoadEndEventArgs
    {
        /// <summary>
        /// Queue data used by the current scene action.
        /// </summary>
        public readonly LoadQueueData QueueData;
        /// <summary>
        /// Scenes which were loaded.
        /// </summary>
        public readonly Scene[] LoadedScenes;
        /// <summary>
        /// Scenes which were skipped because they were already loaded.
        /// </summary>
        public readonly string[] SkippedSceneNames;
        /// <summary>
        /// Scenes which were unloaded.
        /// </summary>
        public readonly string[] UnloadedSceneNames;

        internal SceneLoadEndEventArgs(LoadQueueData lqd, string[] skipped, Scene[] loaded, string[] unloadedSceneNames)
        {
            QueueData = lqd;
            SkippedSceneNames = skipped;
            LoadedScenes = loaded;
            UnloadedSceneNames = unloadedSceneNames;
        }


    }

}
﻿using System;
using System.Collections.Generic;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{

    /// <summary>
    /// Data container about a scene unload start.
    /// </summary>
    public struct SceneUnloadStartEventArgs
    {
        /// <summary>
        /// Queue data used by the current scene action.
        /// </summary>
        public readonly UnloadQueueData QueueData;

        internal SceneUnloadStartEventArgs(UnloadQueueData sqd)
        {
            QueueData = sqd;
        }
    }

    /// <summary>
    /// Data container about a scene unload end.
    /// </summary>
    public struct SceneUnloadEndEventArgs
    {
        /// <summary>
        /// Queue data used by the current scene action.
        /// </summary>
        public readonly UnloadQueueData QueueData;
        /// <summary>
        /// Scenes which were successfully unloaded.
        /// This collection may be populated with empty scenes depending on engine version.
        /// </summary>
        [Obsolete("Use UnloadedScenesV2.")] //Remove on V5. Rename UnloadedScenesV2 to UnloadedScenes.
        public List<Scene> UnloadedScenes;
        /// <summary>
        /// Scenes which were successfully unloaded.
        /// This contains information of the scene unloaded but may not contain scene references as some Unity versions discard that information after a scene is unloaded.
        /// </summary>
        public List<UnloadedScene> UnloadedScenesV2;
        
        internal SceneUnloadEndEventArgs(UnloadQueueData sqd, List<Scene> unloadedScenes, List<UnloadedScene> newUnloadedScenes)
        {
            QueueData = sqd;
#pragma warning disable CS0618 // Type or member is obsolete
            UnloadedScenes = unloadedScenes;
#pragma warning restore CS0618 // Type or member is obsolete
            UnloadedScenesV2 = newUnloadedScenes;
        }
    }


}﻿using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Settings to apply when loading a scene.
    /// </summary>
    public class LoadOptions
    {
        /// <summary>
        /// True if to automatically unload the loaded scenes when they are no longer being used by clients. This field only applies to scenes loaded for connections, not globally loaded scenes.
        /// </summary>
        [System.NonSerialized]
        public bool AutomaticallyUnload = true;
        /// <summary>
        /// False if to only load scenes which are not yet loaded. When true a scene may load multiple times; this is known as scene stacking. Only the server is able to stack scenes; clients will load a single instance. Global scenes cannot be stacked.
        /// </summary>
        [System.NonSerialized]
        public bool AllowStacking;
        /// <summary>
        /// LocalPhysics mode to use when loading this scene. Generally this will only be used when applying scene stacking. Only used by the server.
        /// https://docs.unity3d.com/ScriptReference/SceneManagement.LocalPhysicsMode.html
        /// </summary>
        [System.NonSerialized]
        public LocalPhysicsMode LocalPhysics = LocalPhysicsMode.None;
        /// <summary>
        /// True to reload a scene if it's already loaded.
        /// This does not function yet.
        /// </summary>
        [System.Obsolete("This feature is not functional yet but will be at a later release.")]
        public bool ReloadScenes;
        /// <summary>
        /// True if scenes should be loaded using addressables. This field only exists for optional use so the user may know if their queue data is using addressables.
        /// </summary>
        public bool Addressables;
    }


}﻿namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Additional user-crafted data which can be included in scene load callbacks.
    /// </summary>
    public class LoadParams
    {
        /// <summary>
        /// Objects which are included in callbacks on the server when loading a scene. Can be useful for including unique information about the scene, such as match id. These are not sent to clients; use ClientParams for this.
        /// </summary>
        [System.NonSerialized]
        public object[] ServerParams = new object[0];
        /// <summary>
        /// Bytes which are sent to clients during scene loads. Can contain any information.
        /// </summary>
        public byte[] ClientParams = new byte[0];
    }

}﻿using FishNet.Connection;
using FishNet.Utility;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.GENERATED_ASSEMBLY_NAME)]
namespace FishNet.Managing.Scened
{


    /// <summary>
    /// Data generated when loading a scene.
    /// </summary>
    public class LoadQueueData
    {
        /// <summary>
        /// Clients which receive this SceneQueueData. If Networked, all clients do. If Connections, only the specified Connections do.
        /// </summary>
        [System.NonSerialized]
        public SceneScopeType ScopeType;
        /// <summary>
        /// Connections to load scenes for. Only valid on the server and when ScopeType is Connections.
        /// </summary>
        [System.NonSerialized]
        public NetworkConnection[] Connections = new NetworkConnection[0];
        /// <summary>
        /// SceneLoadData to use.
        /// </summary>
        public SceneLoadData SceneLoadData = null;
        /// <summary>
        /// Current global scenes.
        /// </summary>
        public string[] GlobalScenes = new string[0];
        /// <summary>
        /// True if to iterate this queue data as server.
        /// </summary>
        [System.NonSerialized]
        public readonly bool AsServer;

        public LoadQueueData() { }
        internal LoadQueueData(SceneScopeType scopeType, NetworkConnection[] conns, SceneLoadData sceneLoadData, string[] globalScenes, bool asServer)
        {
            ScopeType = scopeType;
            Connections = conns;
            SceneLoadData = sceneLoadData;
            GlobalScenes = globalScenes;
            AsServer = asServer;
        }
    }


}﻿
namespace FishNet.Managing.Scened
{
    public struct PreferredScene
    {
        /// <summary>
        /// Preferred scene for the client.
        /// </summary>
        public SceneLookupData Client;
        /// <summary>
        /// Preferred scene for the server.
        /// </summary>
        public SceneLookupData Server;

        /// <summary>
        /// Sets an individual preferred scene for client and server.
        /// </summary>
        public PreferredScene(SceneLookupData client, SceneLookupData server)
        {
            Client = client;
            Server = server;
        }

        /// <summary>
        /// Sets the same preferred scene for client and server.
        /// </summary>
        /// <param name="sld"></param>
        public PreferredScene(SceneLookupData sld)
        {
            Client = sld;
            Server = sld;
        }
    }


}﻿
namespace FishNet.Managing.Scened
{
    /// <summary>
    /// How to replace scenes when loading.
    /// </summary>
    public enum ReplaceOption : byte
    { 
        /// <summary>
        /// Replace all scenes, online and offline.
        /// </summary>
        All,
        /// <summary>
        /// Only replace scenes loaded using the SceneManager.
        /// </summary>
        OnlineOnly,
        /// <summary>
        /// Do not replace any scenes, additional scenes will be loaded as additive.
        /// </summary>
        None
    }



}﻿using FishNet.Object;
using FishNet.Serializing.Helping;
using System.Collections.Generic;
using System.IO;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Data about which scenes to load.
    /// </summary>
    public class SceneLoadData
    {
        /// <summary>
        /// When specified these scenes will be set as the active scene after loading occurs.
        /// </summary>
        public PreferredScene PreferredActiveScene;
        /// <summary>
        /// SceneLookupData for each scene to load.
        /// </summary>
        public SceneLookupData[] SceneLookupDatas = new SceneLookupData[0];
        /// <summary>
        /// NetworkObjects to move to the new scenes. Objects will be moved to the first scene.
        /// </summary>
        public NetworkObject[] MovedNetworkObjects = new NetworkObject[0];
        /// <summary>
        /// How to replace current scenes with new ones. When replacing scenes the first scene loaded will be set as the active scene, and the rest additive.
        /// </summary>
        public ReplaceOption ReplaceScenes = ReplaceOption.None;
        /// <summary>
        /// Parameters which may be set and will be included in load callbacks.
        /// </summary>
        public LoadParams Params = new();
        /// <summary>
        /// Additional options to use for loaded scenes.
        /// </summary>
        public LoadOptions Options = new();

        public SceneLoadData() { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scene">Scene to load.</param>
        public SceneLoadData(Scene scene) : this(new Scene[] { scene }, null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneName">Scene to load by name.</param>
        public SceneLoadData(string sceneName) : this(new string[] { sceneName }, null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandle">Scene to load by handle.</param>
        public SceneLoadData(int sceneHandle) : this(new int[] { sceneHandle }, null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandle">Scene to load by handle.</param>
        /// <param name="sceneName">Scene to load by name.</param>
        public SceneLoadData(int sceneHandle, string sceneName) : this(new SceneLookupData(sceneHandle, sceneName)) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneLookupData">Scene to load by SceneLookupData.</param>
        public SceneLoadData(SceneLookupData sceneLookupData) : this(new SceneLookupData[] { sceneLookupData }) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scenes">Scenes to load.</param>
        public SceneLoadData(List<Scene> scenes) : this(scenes.ToArray(), null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneNames">Scenes to load by name.</param>
        public SceneLoadData(List<string> sceneNames) : this(sceneNames.ToArray(), null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandles">Scenes to load by handle.</param>
        public SceneLoadData(List<int> sceneHandles) : this(sceneHandles.ToArray(), null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scenes">Scenes to load.</param>
        public SceneLoadData(Scene[] scenes) : this(scenes, null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneNames">Scenes to load by name.</param>
        public SceneLoadData(string[] sceneNames) : this(sceneNames, null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandles">Scenes to load by handle.</param>
        public SceneLoadData(int[] sceneHandles) : this(sceneHandles, null) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneLookupDatas">Scenes to load by SceneLookupDatas.</param>
        public SceneLoadData(SceneLookupData[] sceneLookupDatas) : this(sceneLookupDatas, null) { }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="scene">Scene to load.</param>
        /// <param name="movedNetworkObjects">NetworkObjects to move to the first specified scene.</param>
        public SceneLoadData(Scene scene, NetworkObject[] movedNetworkObjects)
        {
            SceneLookupData data = SceneLookupData.CreateData(scene);
            Construct(new SceneLookupData[] { data }, movedNetworkObjects);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scenes">Scenes to load.</param>
        /// <param name="movedNetworkObjects">NetworkObjects to move to the first specified scene.</param>
        public SceneLoadData(Scene[] scenes, NetworkObject[] movedNetworkObjects)
        {
            SceneLookupData[] datas = SceneLookupData.CreateData(scenes);
            Construct(datas, movedNetworkObjects);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneNames">Scenes to load by Name.</param>
        /// <param name="movedNetworkObjects">NetworkObjects to move to the first specified scene.</param>
        public SceneLoadData(string[] sceneNames, NetworkObject[] movedNetworkObjects)
        {
            SceneLookupData[] datas = SceneLookupData.CreateData(sceneNames);
            Construct(datas, movedNetworkObjects);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandles">Scenes to load by handle.</param>
        /// <param name="movedNetworkObjects">NetworkObjects to move to the first specified scene.</param>
        public SceneLoadData(int[] sceneHandles, NetworkObject[] movedNetworkObjects)
        {
            SceneLookupData[] datas = SceneLookupData.CreateData(sceneHandles);
            Construct(datas, movedNetworkObjects);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneLookupDatas">Scenes to load by SceneLookupDatas.</param>
        /// <param name="movedNetworkObjects">NetworkObjects to move to the first specified scene.</param>
        public SceneLoadData(SceneLookupData[] sceneLookupDatas, NetworkObject[] movedNetworkObjects)
        {
            sceneLookupDatas = SceneLookupData.ValidateData(sceneLookupDatas);
            Construct(sceneLookupDatas, movedNetworkObjects);
        }

        /// <summary>
        /// Called at the end of every constructor.
        /// </summary>
        private void Construct(SceneLookupData[] datas, NetworkObject[] movedNetworkObjects)
        {
            SceneLookupDatas = datas;
            if (movedNetworkObjects == null)
                movedNetworkObjects = new NetworkObject[0];
            MovedNetworkObjects = movedNetworkObjects;
        }

        /// <summary>
        /// Gets the first Scene in SceneLookupDatas.
        /// </summary>
        /// <returns></returns>
        public Scene GetFirstLookupScene()
        {
            foreach (SceneLookupData sld in SceneLookupDatas)
            {
                Scene result = sld.GetScene(out _, false);
                if (!string.IsNullOrEmpty(result.name))
                    return result;
            }

            return default;
        }


        /// <summary>
        /// Returns if any data is invalid, such as null entries.
        /// </summary>
        /// <returns></returns>
        internal bool DataInvalid()
        {
            //Null values.
            if (Params == null || MovedNetworkObjects == null || SceneLookupDatas == null ||
                Options == null)
                return true;
            //No lookups.
            if (SceneLookupDatas.Length == 0)
                return true;

            return false;
        }


    }


}﻿namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Type of scopes for a scene load or unload.
    /// </summary> 
    public enum SceneScopeType : byte
    {
        /// <summary>
        /// Scene action occured for all clients.
        /// </summary>
        Global = 0,
        /// <summary>
        /// Scene action occurred for specified clients.
        /// </summary>
        Connections = 1
    }

}﻿using System.Collections.Generic;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Scened
{

    /// <summary>
    /// Data about which scenes to unload.
    /// </summary>    
    public class SceneUnloadData
    {
        /// <summary>
        /// When specified these scenes will be set as the active scene after loading occurs.
        /// </summary>
        public PreferredScene PreferredActiveScene;
        /// <summary>
        /// SceneLookupData for each scene to load.
        /// </summary>
        public SceneLookupData[] SceneLookupDatas = new SceneLookupData[0];
        /// <summary>
        /// Parameters which may be set and will be included in load callbacks.
        /// </summary>
        public UnloadParams Params = new();
        /// <summary>
        /// Additional options to use for loaded scenes.
        /// </summary>
        public UnloadOptions Options = new();

        /// <summary>
        /// 
        /// </summary>
        public SceneUnloadData() { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scene">Scene to unload.</param>
        public SceneUnloadData(Scene scene) : this(new Scene[] { scene }) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneName">Scene to unload by name.</param>
        public SceneUnloadData(string sceneName) : this(new string[] { sceneName }) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandle">Scene to unload by handle.</param>
        public SceneUnloadData(int sceneHandle) : this(new int[] { sceneHandle }) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneLookupData">Scene to unload by SceneLookupData.</param>
        public SceneUnloadData(SceneLookupData sceneLookupData)
        {
            SceneLookupDatas = new SceneLookupData[] { sceneLookupData };
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scenes">Scenes to unload.</param>
        public SceneUnloadData(List<Scene> scenes) : this(scenes.ToArray()) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneNames">Scenes to unload by names.</param>
        public SceneUnloadData(List<string> sceneNames) : this(sceneNames.ToArray()) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandles">Scenes to unload by handles.</param>
        public SceneUnloadData(List<int> sceneHandles) : this(sceneHandles.ToArray()) { }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="scenes">Scenes to unload.</param>
        public SceneUnloadData(Scene[] scenes)
        {
            SceneLookupDatas = SceneLookupData.CreateData(scenes);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneNames">Scenes to unload by names.</param>
        public SceneUnloadData(string[] sceneNames)
        {
            SceneLookupDatas = SceneLookupData.CreateData(sceneNames);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneHandles">Scenes to unload by handles.</param>
        public SceneUnloadData(int[] sceneHandles)
        {
            SceneLookupDatas = SceneLookupData.CreateData(sceneHandles);
        }
        /// <summary>
        /// 
        /// </summary>
        /// <param name="sceneLookupDatas">Scenes to unload by SceneLookupDatas.</param>
        public SceneUnloadData(SceneLookupData[] sceneLookupDatas)
        {
            SceneLookupDatas = sceneLookupDatas;
        }


        /// <summary>
        /// Returns if any data is invalid, such as null entries.
        /// </summary>
        /// <returns></returns>
        internal bool DataInvalid()
        {
            //Null values.
            if (Params == null || SceneLookupDatas == null ||
                Options == null)
                return true;
            //No lookups.
            if (SceneLookupDatas.Length == 0)
                return true;

            return false;
        }
    }


}﻿
namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Settings to apply when loading a scene.
    /// </summary>
    public class UnloadOptions
    {
        /// <summary>
        /// Conditions to unloading a scene on the server.
        /// </summary>
        public enum ServerUnloadMode
        {
            /// <summary>
            /// Unloads the scene if no more connections are within it.
            /// </summary>
            UnloadUnused = 0,
            /// <summary>
            /// Unloads scenes for connections but keeps scene loaded on server even if no connections are within it.
            /// </summary>
            KeepUnused = 1,
        }

        /// <summary>
        /// How to unload scenes on the server. UnloadUnused will unload scenes which have no more clients in them. KeepUnused will not unload a scene even when empty. ForceUnload will unload a scene regardless of if clients are still connected to it.
        /// </summary>
        public ServerUnloadMode Mode = ServerUnloadMode.UnloadUnused;
        /// <summary>
        /// True if scenes should be loaded using addressables. This field only exists for optional use so the user may know if their queue data is using addressables.
        /// </summary>
        public bool Addressables;
    }


}﻿namespace FishNet.Managing.Scened
{
    /// <summary>
    /// Additional user-crafted data which can be included in scene unload callbacks.
    /// </summary>
    public class UnloadParams
    {
        /// <summary>
        /// Objects which are included in callbacks on the server when unloading a scene. Can be useful for including unique information about the scene, such as match id. These are not sent to clients; use ClientParams for this.
        /// </summary>
        [System.NonSerialized]
        public object[] ServerParams = new object[0];
        /// <summary>
        /// Bytes which are sent to clients during scene unloads. Can contain any information.
        /// </summary>
        public byte[] ClientParams = new byte[0];
    }

}﻿using FishNet.Connection;
using FishNet.Utility;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.GENERATED_ASSEMBLY_NAME)]
namespace FishNet.Managing.Scened
{

    /// <summary>
    /// Data generated when unloading a scene.
    /// </summary>
    public class UnloadQueueData
    {
        /// <summary>
        /// Clients which receive this SceneQueueData. If Networked, all clients do. If Connections, only the specified Connections do.
        /// </summary>
        [System.NonSerialized]
        public readonly SceneScopeType ScopeType;
        /// <summary>
        /// Connections to unload scenes for. Only valid on the server and when ScopeType is Connections.
        /// </summary>
        [System.NonSerialized]
        public NetworkConnection[] Connections;
        /// <summary>
        /// SceneUnloadData to use.
        /// </summary>
        public SceneUnloadData SceneUnloadData = null;
        /// <summary>
        /// Current global scenes.
        /// </summary>
        public string[] GlobalScenes = new string[0];
        /// <summary>
        /// True if to iterate this queue data as server.
        /// </summary>
        [System.NonSerialized]
        public readonly bool AsServer;

        public UnloadQueueData() { }
        internal UnloadQueueData(SceneScopeType scopeType, NetworkConnection[] conns, SceneUnloadData sceneUnloadData, string[] globalScenes, bool asServer)
        {
            ScopeType = scopeType;
            Connections = conns;
            SceneUnloadData = sceneUnloadData;
            GlobalScenes = globalScenes;
            AsServer = asServer;
        }


    }



}﻿using FishNet.Broadcast;
using FishNet.CodeGenerating;
using FishNet.Serializing;
using FishNet.Utility.Performance;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;

namespace FishNet.Managing.Server
{
    public struct ClientConnectionChangeBroadcast : IBroadcast
    {
        public bool Connected;
        public int Id;
    }

    [UseGlobalCustomSerializer]
    public struct ConnectedClientsBroadcast : IBroadcast
    {
        public List<int> Values;
    }

    
    internal static class ConnectedClientsBroadcastSerializers
    {
        public static void WriteConnectedClientsBroadcast(this Writer writer, ConnectedClientsBroadcast value)
        {
            writer.WriteList(value.Values);
        }

        public static ConnectedClientsBroadcast ReadConnectedClientsBroadcast(this Reader reader)
        {
            List<int> cache = CollectionCaches<int>.RetrieveList();
            reader.ReadList(ref cache);
            return new()
            {
                Values = cache
            };
        }

    }
}

﻿namespace FishNet.Managing.Server
{

    public enum KickReason : short
    {
        /// <summary>
        /// No reason was specified.
        /// </summary>
        Unset = 0,
        /// <summary>
        /// Client performed an action which could only be done if trying to exploit the server.
        /// </summary>
        ExploitAttempt = 1,
        /// <summary>
        /// Data received from the client could not be parsed. This rarely indicates an attack.
        /// </summary>
        MalformedData = 2,
        /// <summary>
        /// Client sent more data than should be able to.
        /// </summary>
        ExploitExcessiveData = 3,
        /// <summary>
        /// Client has sent a large amount of data several times in a row. This may not be an attack but there is no way to know with certainty.
        /// </summary>
        ExcessiveData = 4,
        /// <summary>
        /// A problem occurred with the server where the only option was to kick the client. This rarely indicates an exploit attempt.
        /// </summary>
        UnexpectedProblem = 5,
        /// <summary>
        /// Client is behaving unusually, such as providing multiple invalid states. This may not be an attack but there is no way to know with certainty.
        /// </summary>
        UnusualActivity = 6,
    }

}﻿using FishNet.Broadcast;
using FishNet.Broadcast.Helping;
using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Managing.Utility;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Server
{
    public sealed partial class ServerManager : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// Handler for registered broadcasts.
        /// </summary>
        private readonly Dictionary<ushort, BroadcastHandlerBase> _broadcastHandlers = new();
        /// <summary>
        /// Connections which can be broadcasted to after having excluded removed.
        /// </summary>
        private HashSet<NetworkConnection> _connectionsWithoutExclusionsCache = new();
        #endregion

        /// <summary>
        /// Registers a method to call when a Broadcast arrives.
        /// </summary>
        /// <typeparam name="T">Type of broadcast being registered.</typeparam>
        /// <param name="handler">Method to call.</param>
        /// <param name="requireAuthentication">True if the client must be authenticated for the method to call.</param>
        public void RegisterBroadcast<T>(Action<NetworkConnection, T, Channel> handler, bool requireAuthentication = true) where T : struct, IBroadcast
        {
            if (handler == null)
            {
                NetworkManager.LogError($"Broadcast cannot be registered because handler is null. This may occur when trying to register to objects which require initialization, such as events.");
                return;
            }

            ushort key = BroadcastExtensions.GetKey<T>();
            //Create new IBroadcastHandler if needed.
            BroadcastHandlerBase bhs;
            if (!_broadcastHandlers.TryGetValueIL2CPP(key, out bhs))
            {
                bhs = new ClientBroadcastHandler<T>(requireAuthentication);
                _broadcastHandlers.Add(key, bhs);
            }
            //Register handler to IBroadcastHandler.
            bhs.RegisterHandler(handler);
        }

        /// <summary>
        /// Unregisters a method call from a Broadcast type.
        /// </summary>
        /// <typeparam name="T">Type of broadcast being unregistered.</typeparam>
        /// <param name="handler">Method to unregister.</param>
        public void UnregisterBroadcast<T>(Action<NetworkConnection, T, Channel> handler) where T : struct, IBroadcast
        {
            ushort key = BroadcastExtensions.GetKey<T>();
            if (_broadcastHandlers.TryGetValueIL2CPP(key, out BroadcastHandlerBase bhs))
                bhs.UnregisterHandler(handler);
        }


        /// <summary>
        /// Parses a received broadcast.
        /// </summary>
        
        private void ParseBroadcast(PooledReader reader, NetworkConnection conn, Channel channel)
        {
            ushort key = reader.ReadUInt16();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.Broadcast, reader, channel);

            // try to invoke the handler for that message
            if (_broadcastHandlers.TryGetValueIL2CPP(key, out BroadcastHandlerBase bhs))
            {
                if (bhs.RequireAuthentication && !conn.IsAuthenticated)
                    conn.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"ConnectionId {conn.ClientId} sent a broadcast which requires authentication, but client was not authenticated. Client has been disconnected.");
                else
                    bhs.InvokeHandlers(conn, reader, channel);
            }
            else
            {
                reader.Skip(dataLength);
            }
        }

        /// <summary>
        /// Sends a broadcast to a connection.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="connection">Connection to send to.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the client must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void Broadcast<T>(NetworkConnection connection, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                NetworkManager.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }
            if (requireAuthenticated && !connection.IsAuthenticated)
            {
                NetworkManager.LogWarning($"Cannot send broadcast to client because they are not authenticated.");
                return;
            }

            PooledWriter writer = WriterPool.Retrieve();
            BroadcastsSerializers.WriteBroadcast(NetworkManager, writer, message, ref channel);
            ArraySegment<byte> segment = writer.GetArraySegment();
            NetworkManager.TransportManager.SendToClient((byte)channel, segment, connection);
            writer.Store();
        }


        /// <summary>
        /// Sends a broadcast to connections.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="connections">Connections to send to.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void Broadcast<T>(HashSet<NetworkConnection> connections, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                NetworkManager.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }

            bool failedAuthentication = false;
            PooledWriter writer = WriterPool.Retrieve();
            BroadcastsSerializers.WriteBroadcast(NetworkManager, writer, message, ref channel);
            ArraySegment<byte> segment = writer.GetArraySegment();

            foreach (NetworkConnection conn in connections)
            {
                if (requireAuthenticated && !conn.IsAuthenticated)
                    failedAuthentication = true;
                else
                    NetworkManager.TransportManager.SendToClient((byte)channel, segment, conn);
            }
            writer.Store();

            if (failedAuthentication)
            {
                NetworkManager.LogWarning($"One or more broadcast did not send to a client because they were not authenticated.");
                return;
            }
        }


        /// <summary>
        /// Sends a broadcast to connections except excluded.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="connections">Connections to send to.</param>
        /// <param name="excludedConnection">Connection to exclude.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void BroadcastExcept<T>(HashSet<NetworkConnection> connections, NetworkConnection excludedConnection, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                NetworkManager.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }

            //Fast exit if no exclusions.
            if (excludedConnection == null || !excludedConnection.IsValid)
            {
                Broadcast(connections, message, requireAuthenticated, channel);
                return;
            }

            connections.Remove(excludedConnection);
            Broadcast(connections, message, requireAuthenticated, channel);
        }


        /// <summary>
        /// Sends a broadcast to connections except excluded.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="connections">Connections to send to.</param>
        /// <param name="excludedConnections">Connections to exclude.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void BroadcastExcept<T>(HashSet<NetworkConnection> connections, HashSet<NetworkConnection> excludedConnections, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                NetworkManager.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }

            //Fast exit if no exclusions.
            if (excludedConnections == null || excludedConnections.Count == 0)
            {
                Broadcast(connections, message, requireAuthenticated, channel);
                return;
            }

            /* I'm not sure if the hashset API such as intersect generates
             * GC or not but I'm betting doing remove locally is faster, or
             * just as fast. */
            foreach (NetworkConnection ec in excludedConnections)
                connections.Remove(ec);

            Broadcast(connections, message, requireAuthenticated, channel);
        }

        /// <summary>
        /// Sends a broadcast to all connections except excluded.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="excludedConnection">Connection to exclude.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void BroadcastExcept<T>(NetworkConnection excludedConnection, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                NetworkManager.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }

            //Fast exit if there are no excluded.
            if (excludedConnection == null || !excludedConnection.IsValid)
            {
                Broadcast(message, requireAuthenticated, channel);
                return;
            }

            _connectionsWithoutExclusionsCache.Clear();
            /* It will be faster to fill the entire list then
             * remove vs checking if each connection is contained within excluded. */
            foreach (NetworkConnection c in Clients.Values)
                _connectionsWithoutExclusionsCache.Add(c);
            //Remove
            _connectionsWithoutExclusionsCache.Remove(excludedConnection);

            Broadcast(_connectionsWithoutExclusionsCache, message, requireAuthenticated, channel);
        }

        /// <summary>
        /// Sends a broadcast to all connections except excluded.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="excludedConnections">Connections to send to.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void BroadcastExcept<T>(HashSet<NetworkConnection> excludedConnections, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                NetworkManager.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }

            //Fast exit if there are no excluded.
            if (excludedConnections == null || excludedConnections.Count == 0)
            {
                Broadcast(message, requireAuthenticated, channel);
                return;
            }

            _connectionsWithoutExclusionsCache.Clear();
            /* It will be faster to fill the entire list then
             * remove vs checking if each connection is contained within excluded. */
            foreach (NetworkConnection c in Clients.Values)
                _connectionsWithoutExclusionsCache.Add(c);
            //Remove
            foreach (NetworkConnection c in excludedConnections)
                _connectionsWithoutExclusionsCache.Remove(c);

            Broadcast(_connectionsWithoutExclusionsCache, message, requireAuthenticated, channel);
        }

        /// <summary>
        /// Sends a broadcast to observers.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="networkObject">NetworkObject to use Observers from.</param>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        
        public void Broadcast<T>(NetworkObject networkObject, T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (networkObject == null)
            {
                NetworkManager.LogWarning($"Cannot send broadcast because networkObject is null.");
                return;
            }

            Broadcast(networkObject.Observers, message, requireAuthenticated, channel);
        }


        /// <summary>
        /// Sends a broadcast to all clients.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the clients must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void Broadcast<T>(T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (!Started)
            {
                NetworkManager.LogWarning($"Cannot send broadcast to client because server is not active.");
                return;
            }

            bool failedAuthentication = false;
            PooledWriter writer = WriterPool.Retrieve();
            BroadcastsSerializers.WriteBroadcast(NetworkManager, writer, message, ref channel);
            ArraySegment<byte> segment = writer.GetArraySegment();

            foreach (NetworkConnection conn in Clients.Values)
            {
                //
                if (requireAuthenticated && !conn.IsAuthenticated)
                    failedAuthentication = true;
                else
                    NetworkManager.TransportManager.SendToClient((byte)channel, segment, conn);
            }
            writer.Store();

            if (failedAuthentication)
            {
                NetworkManager.LogWarning($"One or more broadcast did not send to a client because they were not authenticated.");
                return;
            }
        }

    }


}
﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.Authenticating;
using FishNet.Component.Observing;
using FishNet.Connection;
using FishNet.Managing.Debugging;
using FishNet.Managing.Logging;
using FishNet.Managing.Predicting;
using FishNet.Managing.Timing;
using FishNet.Managing.Transporting;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using FishNet.Utility.Performance;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace FishNet.Managing.Server
{
    /// <summary>
    /// A container for server data and actions.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/ServerManager")]
    public sealed partial class ServerManager : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Called after the local server connection state changes.
        /// </summary>
        public event Action<ServerConnectionStateArgs> OnServerConnectionState;
        /// <summary>
        /// Called when authenticator has concluded a result for a connection. Boolean is true if authentication passed, false if failed.
        /// </summary>
        public event Action<NetworkConnection, bool> OnAuthenticationResult;
        /// <summary>
        /// Called when a remote client state changes with the server.
        /// </summary>
        public event Action<NetworkConnection, RemoteConnectionStateArgs> OnRemoteConnectionState;
        /// <summary>
        /// True if the server connection has started.
        /// </summary>
        public bool Started { get; private set; }
        /// <summary>
        /// Handling and information for objects on the server.
        /// </summary>
        public ServerObjects Objects { get; private set; }
        /// <summary>
        /// Authenticated and non-authenticated connected clients.
        /// </summary>
        [HideInInspector]
        public Dictionary<int, NetworkConnection> Clients = new();
        /// <summary>
        /// Clients dictionary as a list, containing only values.
        /// </summary>        
        private List<NetworkConnection> _clientsList = new();
        /// <summary>
        /// NetworkManager for server.
        /// </summary>
        [HideInInspector]
        public NetworkManager NetworkManager { get; private set; }
        #endregion

        #region Serialized.
        /// <summary>
        /// Gets the Authenticator for this manager.
        /// </summary>
        /// <returns></returns>
        public Authenticator GetAuthenticator() => _authenticator;

        /// <summary>
        /// Gets the Authenticator for this manager, and initializes it.
        /// </summary>
        /// <returns></returns>
        public void SetAuthenticator(Authenticator value)
        {
            _authenticator = value;
            InitializeAuthenticator();
        }

        [Tooltip("Authenticator for this ServerManager. May be null if not using authentication.")]
        [SerializeField]
        private Authenticator _authenticator;
        /// <summary>
        /// What platforms to enable remote client timeout.
        /// </summary>
        [Tooltip("What platforms to enable remote client timeout.")]
        [SerializeField]
        private RemoteTimeoutType _remoteClientTimeout = RemoteTimeoutType.Development;
        /// <summary>
        /// How long in seconds client must go without sending any packets before getting disconnected. This is independent of any transport settings.
        /// </summary>
        [Tooltip("How long in seconds a client must go without sending any packets before getting disconnected. This is independent of any transport settings.")]
        [Range(1, MAXIMUM_REMOTE_CLIENT_TIMEOUT_DURATION)]
        [SerializeField]
        private ushort _remoteClientTimeoutDuration = 60;

        /// <summary>
        /// Sets timeout settings. Can be used at runtime.
        /// </summary>
        /// <returns></returns>
        public void SetRemoteClientTimeout(RemoteTimeoutType timeoutType, ushort duration)
        {
            _remoteClientTimeout = timeoutType;
            duration = (ushort)Mathf.Clamp(duration, 1, MAXIMUM_REMOTE_CLIENT_TIMEOUT_DURATION);
            _remoteClientTimeoutDuration = duration;
        }

        /// <summary>
        /// True to allow clients to use predicted spawning. While true, each NetworkObject you wish this feature to apply towards must have a PredictedSpawn component.
        /// Predicted spawns can have custom validation on the server.
        /// </summary>
        internal bool GetAllowPredictedSpawning() => _allowPredictedSpawning;

        [Tooltip("True to allow clients to use predicted spawning. While true, each NetworkObject you wish this feature to apply towards must have a PredictedSpawn component. Predicted spawns can have custom validation on the server.")]
        [SerializeField]
        private bool _allowPredictedSpawning = false;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Maximum number of Ids to reserve on clients for predicted spawning. Higher values will allow clients to send more predicted spawns per second but may reduce availability of ObjectIds with high player counts.")]
        [Range(1, MAXIMUM_RESERVED_OBJECT_IDS)]
        [SerializeField]
        private ushort _reservedObjectIds = 15;

        /// <summary>
        /// Maximum number of Ids to reserve on clients for predicted spawning. Higher values will allow clients to send more predicted spawns per second but may reduce availability of ObjectIds with high player counts.
        /// </summary>
        /// <returns></returns>
        internal ushort GetReservedObjectIds() => _reservedObjectIds;

        /// <summary>
        /// Default send rate for SyncTypes. A value of 0f will send changed values every tick.
        /// </summary>
        /// <returns></returns>
        internal float GetSyncTypeRate() => _syncTypeRate;

        [Tooltip("Default send rate for SyncTypes. A value of 0f will send changed values every tick.")]
        [Range(0f, 60f)]
        [SerializeField]
        private float _syncTypeRate = 0.1f;
        /// <summary>
        /// How to pack object spawns.
        /// </summary>
        [Tooltip("How to pack object spawns.")]
        [SerializeField]
        internal TransformPackingData SpawnPacking = new()
        {
            Position = AutoPackType.Unpacked,
            Rotation = AutoPackType.PackedLess,
            Scale = AutoPackType.PackedLess
        };
        /// <summary>
        /// True to automatically set the frame rate when the client connects.
        /// </summary>
        [Tooltip("True to automatically set the frame rate when the client connects.")]
        [SerializeField]
        private bool _changeFrameRate = true;
        /// <summary>
        /// Maximum frame rate the server may run at. When as host this value runs at whichever is higher between client and server.
        /// </summary>
        internal ushort FrameRate => (_changeFrameRate) ? _frameRate : (ushort)0;
        [Tooltip("Maximum frame rate the server may run at. When as host this value runs at whichever is higher between client and server.")]
        [Range(1, NetworkManager.MAXIMUM_FRAMERATE)]
        [SerializeField]
        private ushort _frameRate = NetworkManager.MAXIMUM_FRAMERATE;

        /// Sets the maximum frame rate the client may run at. Calling this method will enable ChangeFrameRate.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetFrameRate(ushort value)
        {
            _frameRate = (ushort)Mathf.Clamp(value, 0, NetworkManager.MAXIMUM_FRAMERATE);
            _changeFrameRate = true;
            if (NetworkManager != null)
                NetworkManager.UpdateFramerate();
        }

        /// <summary>
        /// True to share the Ids of clients and the objects they own with other clients. No sensitive information is shared.
        /// </summary>
        public bool ShareIds => _shareIds;
        [Tooltip("True to share the Ids of clients and the objects they own with other clients. No sensitive information is shared.")]
        [SerializeField]
        private bool _shareIds = true;

        /// <summary>
        /// Gets StartOnHeadless value.
        /// </summary>
        public bool GetStartOnHeadless() => _startOnHeadless;

        /// <summary>
        /// Sets StartOnHeadless value.
        /// </summary>
        /// <param name="value">New value to use.</param>
        public void SetStartOnHeadless(bool value) => _startOnHeadless = value;

        [Tooltip("True to automatically start the server connection when running as headless.")]
        [SerializeField]
        private bool _startOnHeadless = true;
        #endregion

        #region Private.
        /// <summary>
        /// The last index checked to see if a client has not sent a packet in awhile.
        /// </summary>
        private int _nextClientTimeoutCheckIndex;
        /// <summary>
        /// Next time a timeout check can be performed.
        /// </summary>
        private float _nextTimeoutCheckTime;
        /// <summary>
        /// Used to read splits.
        /// </summary>
        private SplitReader _splitReader = new();
#if DEVELOPMENT
        /// <summary>
        /// Logs data about parser to help debug.
        /// </summary>
        private PacketIdHistory _packetIdHistory = new();
#endif
        #endregion

        #region Const.
        /// <summary>
        /// Maximum value the remote client timeout can be set to.
        /// </summary>
        public const ushort MAXIMUM_REMOTE_CLIENT_TIMEOUT_DURATION = 1500;
        /// <summary>
        /// Maximum number of reserved object Ids allowed for predicted spawning.
        /// </summary>
        private const int MAXIMUM_RESERVED_OBJECT_IDS = 100;  //QUICK-TEST Increase this to 5000, save, within ServerManager set maximum reserved Ids to max.
        #endregion

        private void OnDestroy()
        {
            Objects?.SubscribeToSceneLoaded(false);
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="manager"></param>
        internal void InitializeOnce_Internal(NetworkManager manager)
        {
            NetworkManager = manager;
            Objects = new(manager);
            Objects.SubscribeToSceneLoaded(true);
            InitializeRpcLinks();
            //Unsubscribe first incase already subscribed.
            SubscribeToTransport(false);
            SubscribeToTransport(true);
            NetworkManager.ClientManager.OnClientConnectionState += ClientManager_OnClientConnectionState;
            NetworkManager.SceneManager.OnClientLoadedStartScenes += SceneManager_OnClientLoadedStartScenes;
            NetworkManager.TimeManager.OnPostTick += TimeManager_OnPostTick;

            if (_authenticator == null)
                _authenticator = GetComponent<Authenticator>();
            if (_authenticator != null)
                InitializeAuthenticator();
        }

        /// <summary>
        /// Initializes the authenticator to this manager.
        /// </summary>
        private void InitializeAuthenticator()
        {
            Authenticator auth = GetAuthenticator();
            if (auth == null || auth.Initialized)
                return;
            if (NetworkManager == null)
                return;

            auth.InitializeOnce(NetworkManager);
            auth.OnAuthenticationResult += _authenticator_OnAuthenticationResult;
        }

        /// <summary>
        /// Starts the server if configured to for headless.
        /// </summary>
        internal void StartForHeadless()
        {
            if (GetStartOnHeadless())
            {
                //Wrapping logic in check instead of everything so _startOnHeadless doesnt warn as unused in editor.
#if UNITY_SERVER
                StartConnection();
#endif
            }
        }

        /// <summary>
        /// Stops the local server connection.
        /// </summary>
        /// <param name="sendDisconnectMessage">True to send a disconnect message to all clients first.</param>
        public bool StopConnection(bool sendDisconnectMessage)
        {
            if (sendDisconnectMessage)
                SendDisconnectMessages(Clients.Values.ToList(), true);

            //Return stop connection result.
            return NetworkManager.TransportManager.Transport.StopConnection(true);
        }

        /// <summary>
        /// Sends a disconnect messge to connectionIds.
        /// This does not iterate outgoing automatically.
        /// </summary>
        /// <param name="connectionIds"></param>
        public void SendDisconnectMessages(int[] connectionIds)
        {
            List<NetworkConnection> conns = new();
            foreach (int item in connectionIds)
            {
                if (Clients.TryGetValueIL2CPP(item, out NetworkConnection c))
                    conns.Add(c);
            }

            if (conns.Count > 0)
                SendDisconnectMessages(conns, false);
        }

        /// <summary>
        /// Sends a disconnect message to all clients and optionally immediately iterates outgoing.
        /// </summary>
        public void SendDisconnectMessages(List<NetworkConnection> conns, bool iterate)
        {
            PooledWriter writer = WriterPool.Retrieve();
            writer.WritePacketIdUnpacked(PacketId.Disconnect);
            ArraySegment<byte> segment = writer.GetArraySegment();
            //Send segment to each client, authenticated or not.
            foreach (NetworkConnection c in conns)
                c.SendToClient((byte)Channel.Reliable, segment);
            //Recycle writer.
            writer.Store();

            if (iterate)
                NetworkManager.TransportManager.IterateOutgoing(asServer: true);
        }

        /// <summary>
        /// Starts the local server connection.
        /// </summary>
        public bool StartConnection()
        {
            return NetworkManager.TransportManager.Transport.StartConnection(true);
        }

        /// <summary>
        /// Starts the local server using port.
        /// </summary>
        /// <param name="port">Port to start on.</param>
        /// <returns></returns>
        public bool StartConnection(ushort port)
        {
            Transport t = NetworkManager.TransportManager.Transport;
            t.SetPort(port);
            return t.StartConnection(true);
        }

        /// <summary>
        /// Checks to timeout client connections.
        /// </summary>
        private void CheckClientTimeout()
        {
            if (_remoteClientTimeout == RemoteTimeoutType.Disabled)
                return;
#if DEVELOPMENT
            //If development but not set to development return.
            if (_remoteClientTimeout != RemoteTimeoutType.Development)
                return;
#endif
            //Wait two timing intervals to give packets a chance to come through.
            if (NetworkManager.SceneManager.IsIteratingQueue(2f))
                return;

            float unscaledTime = Time.unscaledTime;
            if (unscaledTime < _nextTimeoutCheckTime)
                return;
            //Check for timeouts every 200ms.
            const float TIMEOUT_CHECK_FREQUENCY = 0.2f;
            _nextTimeoutCheckTime = (unscaledTime + TIMEOUT_CHECK_FREQUENCY);
            //No clients.
            int clientsCount = Clients.Count;
            if (clientsCount == 0)
                return;

            /* If here can do checks. */
            //If to reset index.
            if (_nextClientTimeoutCheckIndex >= clientsCount)
                _nextClientTimeoutCheckIndex = 0;

            //Number of ticks passed for client to be timed out.
            uint requiredTicks = NetworkManager.TimeManager.TimeToTicks((double)_remoteClientTimeoutDuration, TickRounding.RoundUp);

            const float FULL_CHECK_TIME = 2f;
            /* Number of times this is expected to run every 2 seconds.
             * Iterations will try to complete the entire client collection
             * over these 2 seconds. */
            int checkCount = Mathf.CeilToInt(FULL_CHECK_TIME / TIMEOUT_CHECK_FREQUENCY);
            int targetIterations = Mathf.Max(clientsCount / checkCount, 1);

            uint localTick = NetworkManager.TimeManager.LocalTick;
            for (int i = 0; i < targetIterations; i++)
            {
                if (_nextClientTimeoutCheckIndex >= _clientsList.Count)
                    _nextClientTimeoutCheckIndex = 0;

                NetworkConnection item = _clientsList[_nextClientTimeoutCheckIndex];
                uint clientLocalTick = item.PacketTick.LocalTick;
                /* If client tick has not been set yet then use the tick
                 * when they connected to the server. */
                if (clientLocalTick == 0)
                    clientLocalTick = item.ServerConnectionTick;

                uint difference = (localTick - clientLocalTick);
                //Client has timed out.
                if (difference >= requiredTicks)
                    item.Kick(KickReason.UnexpectedProblem, LoggingType.Common, $"{item.ToString()} has timed out. You can modify this feature on the ServerManager component.");

                _nextClientTimeoutCheckIndex++;
            }
        }

        /// <summary>
        /// Called when the TimeManager calls OnPostTick.
        /// </summary>
        private void TimeManager_OnPostTick()
        {
            CheckClientTimeout();
        }

        /// <summary>
        /// Called after the local client connection state changes.
        /// </summary>
        private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs obj)
        {
            /* If client is doing anything but started destroy pending.
             * Pending is only used for host mode. */
            if (obj.ConnectionState != LocalConnectionState.Started)
                Objects.DestroyPending();
        }

        /// <summary>
        /// Called when a client loads initial scenes after connecting.
        /// </summary>
        private void SceneManager_OnClientLoadedStartScenes(NetworkConnection conn, bool asServer)
        {
            if (asServer)
            {
                Objects.RebuildObservers(conn);
                /* If connection is host then renderers must be hidden
                 * for all objects not visible to the host. The observer system
                 * does handle this but only after an initial state is set.
                 * If the clientHost joins without observation of an object
                 * then the initial state will never be set. */
                if (conn.IsLocalClient)
                {
                    foreach (NetworkObject nob in Objects.Spawned.Values)
                    {
                        if (!nob.Observers.Contains(conn))
                            nob.SetRenderersVisible(false);
                    }
                }
            }
        }

        /// <summary>
        /// Changes subscription status to transport.
        /// </summary>
        /// <param name="subscribe"></param>
        private void SubscribeToTransport(bool subscribe)
        {
            if (NetworkManager == null || NetworkManager.TransportManager == null || NetworkManager.TransportManager.Transport == null)
                return;

            if (subscribe)
            {
                NetworkManager.TransportManager.Transport.OnServerReceivedData += Transport_OnServerReceivedData;
                NetworkManager.TransportManager.Transport.OnServerConnectionState += Transport_OnServerConnectionState;
                NetworkManager.TransportManager.Transport.OnRemoteConnectionState += Transport_OnRemoteConnectionState;
            }
            else
            {
                NetworkManager.TransportManager.Transport.OnServerReceivedData -= Transport_OnServerReceivedData;
                NetworkManager.TransportManager.Transport.OnServerConnectionState -= Transport_OnServerConnectionState;
                NetworkManager.TransportManager.Transport.OnRemoteConnectionState -= Transport_OnRemoteConnectionState;
            }
        }

        /// <summary>
        /// Called when authenticator has concluded a result for a connection. Boolean is true if authentication passed, false if failed.
        /// Server listens for this event automatically.
        /// </summary>
        private void _authenticator_OnAuthenticationResult(NetworkConnection conn, bool authenticated)
        {
            if (!authenticated)
                conn.Disconnect(false);
            else
                ClientAuthenticated(conn);
        }

        /// <summary>
        /// Called when a connection state changes for the local server.
        /// </summary>
        private void Transport_OnServerConnectionState(ServerConnectionStateArgs args)
        {
            /* Let the client manager know the server state is changing first.
             * This gives the client an opportunity to clean-up or prepare
             * before the server completes it's actions. */
            Started = IsAnyServerStarted();
            NetworkManager.ClientManager.Objects.OnServerConnectionState(args);
            //If no servers are started then reset data.
            if (!Started)
            {
                MatchCondition.StoreCollections(NetworkManager);
                //Despawn without synchronizing network objects.
                Objects.DespawnWithoutSynchronization(recursive: true, asServer: true);
                //Clear all clients.
                Clients.Clear();
                //Clients as list.
                _clientsList.Clear();
            }
            Objects.OnServerConnectionState(args);

            LocalConnectionState state = args.ConnectionState;

            if (NetworkManager.CanLog(LoggingType.Common))
            {
                Transport t = NetworkManager.TransportManager.GetTransport(args.TransportIndex);
                string tName = (t == null) ? "Unknown" : t.GetType().Name;
                string socketInformation = string.Empty;
                if (state == LocalConnectionState.Starting)
                    socketInformation = $" Listening on port {t.GetPort()}.";
                NetworkManagerExtensions.Log($"Local server is {state.ToString().ToLower()} for {tName}.{socketInformation}");
            }

            NetworkManager.UpdateFramerate();
            OnServerConnectionState?.Invoke(args);
        }

        /// <summary>
        /// Checks to make sure the client is on the same version.
        /// This is to help developers make sure their builds are on the same FishNet version.
        /// </summary>
        private void ParseVersion(PooledReader reader, NetworkConnection conn, int transportId)
        {
            //Cannot be authenticated if havent sent version yet. This is a duplicate version send, likely exploit attempt.
            if (conn.HasSentVersion)
            {
                conn.Kick(reader, KickReason.ExploitAttempt, LoggingType.Common, $"Connection {conn.ToString()} has sent their FishNet version after being authenticated; this is not possible under normal conditions.");
                return;
            }

            conn.HasSentVersion = true;
            string version = reader.ReadStringAllocated();
            //Version match.
            if (version == NetworkManager.FISHNET_VERSION)
            {
                /* Send to client if server is in development build or not.
                 * This is to allow the client to utilize some features/information
                 * received from the server only when it's in dev mode. */
                bool isDevelopmentBuild;
#if DEVELOPMENT
                isDevelopmentBuild = true;
#else
                isDevelopmentBuild = false;
#endif
                PooledWriter writer = WriterPool.Retrieve();
                writer.WritePacketIdUnpacked(PacketId.Version);
                writer.WriteBoolean(isDevelopmentBuild);
                conn.SendToClient((byte)Channel.Reliable, writer.GetArraySegment());
                WriterPool.Store(writer);

                /* If there is an authenticator
                 * and the transport is not a local transport. */
                Authenticator auth = GetAuthenticator();
                if (auth != null && !NetworkManager.TransportManager.IsLocalTransport(transportId))
                    auth.OnRemoteConnection(conn);
                else
                    ClientAuthenticated(conn);
            }
            else
            {
                conn.Kick(reader, KickReason.UnexpectedProblem, LoggingType.Warning, $"Connection {conn.ToString()} has been kicked for being on FishNet version {version}. Server version is {NetworkManager.FISHNET_VERSION}.");
            }
        }

        /// <summary>
        /// Called when a connection state changes for a remote client.
        /// </summary>
        private void Transport_OnRemoteConnectionState(RemoteConnectionStateArgs args)
        {
            //Sanity check to make sure transports are following proper types/ranges.
            int id = args.ConnectionId;
            if (id < 0 || id > NetworkConnection.MAXIMUM_CLIENTID_VALUE)
            {
                Kick(args.ConnectionId, KickReason.UnexpectedProblem, LoggingType.Error, $"The transport you are using supplied an invalid connection Id of {id}. Connection Id values must range between 0 and {NetworkConnection.MAXIMUM_CLIENTID_VALUE}. The client has been disconnected.");
                return;
            }
            //Valid Id.
            else
            {
                //If started then add to authenticated clients.
                if (args.ConnectionState == RemoteConnectionState.Started)
                {
                    NetworkManager.Log($"Remote connection started for Id {id}.");
                    NetworkConnection conn = new(NetworkManager, id, args.TransportIndex, true);
                    Clients.Add(args.ConnectionId, conn);
                    _clientsList.Add(conn);
                    OnRemoteConnectionState?.Invoke(conn, args);

                    //Do nothing else until the client sends it's version.
                }
                //If stopping.
                else if (args.ConnectionState == RemoteConnectionState.Stopped)
                {
                    /* If client's connection is found then clean
                     * them up from server. */
                    if (Clients.TryGetValueIL2CPP(id, out NetworkConnection conn))
                    {
                        conn.SetDisconnecting(true);
                        OnRemoteConnectionState?.Invoke(conn, args);
                        Clients.Remove(id);
                        _clientsList.Remove(conn);
                        Objects.ClientDisconnected(conn);
                        BroadcastClientConnectionChange(false, conn);
                        //Return predictedObjectIds.
                        Queue<int> pqId = conn.PredictedObjectIds;
                        while (pqId.Count > 0)
                            Objects.CacheObjectId(pqId.Dequeue());

                        conn.ResetState();
                        NetworkManager.Log($"Remote connection stopped for Id {id}.");
                    }
                }
            }
        }

        /// <summary>
        /// Sends client their connectionId.
        /// </summary>
        /// <param name="connectionid"></param>
        private void SendAuthenticated(NetworkConnection conn)
        {
            PooledWriter writer = WriterPool.Retrieve();
            writer.WritePacketIdUnpacked(PacketId.Authenticated);
            writer.WriteNetworkConnection(conn);
            /* If predicted spawning is enabled then also send
             * reserved objectIds. */
            ;
            PredictionManager pm = NetworkManager.PredictionManager;
            if (GetAllowPredictedSpawning())
            {
                int count = Mathf.Min(Objects.GetObjectIdCache().Count, GetReservedObjectIds());
                if (count > MAXIMUM_RESERVED_OBJECT_IDS)
                    count = MAXIMUM_RESERVED_OBJECT_IDS;
                
                List<int> ids = CollectionCaches<int>.RetrieveList();
                for (int i = 0; i < count; i++)
                {
                    if (Objects.GetNextNetworkObjectId(out int nId))
                        ids.Add(nId);
                }

                writer.WriteSignedPackedWhole(ids.Count);
                foreach (int id in ids) 
                {
                    writer.WriteNetworkObjectId(id);
                    conn.PredictedObjectIds.Enqueue(id);
                }
           
                CollectionCaches<int>.Store(ids);
            }

            NetworkManager.TransportManager.SendToClient((byte)Channel.Reliable, writer.GetArraySegment(), conn);
            writer.Store();
        }

        /// <summary>
        /// Called when the server socket receives data.
        /// </summary>
        private void Transport_OnServerReceivedData(ServerReceivedDataArgs args)
        {
            ParseReceived(args);
        }

        /// <summary>
        /// Called when the server receives data.
        /// </summary>
        /// <param name="args"></param>
        private void ParseReceived(ServerReceivedDataArgs args)
        {
            //Not from a valid connection.
            if (args.ConnectionId < 0)
                return;

            ArraySegment<byte> segment;
            if (NetworkManager.TransportManager.HasIntermediateLayer)
                segment = NetworkManager.TransportManager.ProcessIntermediateIncoming(args.Data, false);
            else
                segment = args.Data;

            NetworkManager.StatisticsManager.NetworkTraffic.LocalServerReceivedData((ulong)segment.Count);
            if (segment.Count <= TransportManager.UNPACKED_TICK_LENGTH)
                return;

            //FishNet internally splits packets so nothing should ever arrive over MTU.
            int channelMtu = NetworkManager.TransportManager.GetMTU(args.TransportIndex, (byte)args.Channel);
            //If over MTU kick client immediately.
            if (segment.Count > channelMtu)
            {
                ExceededMTUKick();
                return;
            }

            TimeManager timeManager = NetworkManager.TimeManager;

            bool hasIntermediateLayer = NetworkManager.TransportManager.HasIntermediateLayer;
            PacketId packetId = PacketId.Unset;
            PooledReader reader = null;
#if !DEVELOPMENT
            try
            {
#endif
            Reader.DataSource dataSource = Reader.DataSource.Client;
            reader = ReaderPool.Retrieve(segment, NetworkManager, dataSource);
            uint tick = reader.ReadTickUnpacked();
            timeManager.LastPacketTick.Update(tick);
            /* This is a special condition where a message may arrive split.
             * When this occurs buffer each packet until all packets are
             * received. */
            if (reader.PeekPacketId() == PacketId.Split)
            {
#if DEVELOPMENT
                NetworkManager.PacketIdHistory.ReceivedPacket(PacketId.Split, packetFromServer: false);
#endif
                //Skip packetId.
                reader.ReadPacketId();

                int expectedMessages;
                _splitReader.GetHeader(reader, out expectedMessages);
                //If here split message is to be read into splitReader.
                _splitReader.Write(tick, reader, expectedMessages);

                /* If fullMessage returns 0 count then the split
                 * has not written fully yet. Otherwise, if there is
                 * data within then reinitialize reader with the
                 * full message. */
                ArraySegment<byte> fullMessage = _splitReader.GetFullMessage();
                if (fullMessage.Count == 0)
                    return;

                /* If here then all data has been received.
                 * It's possible the client could have exceeded
                 * maximum MTU but not the maximum number of splits.
                 * This is because the length of each split
                 * is not written, so we don't know how much data of the
                 * final message actually belonged to the split vs
                 * unrelated data added afterwards. We're going to cut
                 * the client some slack in this situation for the sake
                 * of keeping things simple. */
                reader.Initialize(fullMessage, NetworkManager, dataSource);
            }

            //Parse reader.
            while (reader.Remaining > 0)
            {
                packetId = reader.ReadPacketId();
#if DEVELOPMENT
                NetworkManager.PacketIdHistory.ReceivedPacket(packetId, packetFromServer: false);
#endif
                NetworkConnection conn;

                /* Connection isn't available. This should never happen.
                 * Force an immediate disconnect. */
                if (!Clients.TryGetValueIL2CPP(args.ConnectionId, out conn))
                {
                    Kick(args.ConnectionId, KickReason.UnexpectedProblem, LoggingType.Error, $"ConnectionId {args.ConnectionId} not found within Clients. Connection will be kicked immediately.");
                    return;
                }
                conn.LocalTick.Update(timeManager, tick, EstimatedTick.OldTickOption.Discard);
                conn.PacketTick.Update(timeManager, tick, EstimatedTick.OldTickOption.SetLastRemoteTick);
                /* If connection isn't authenticated and isn't a broadcast
                 * then disconnect client. If a broadcast then process
                 * normally; client may still become disconnected if the broadcast
                 * does not allow to be called while not authenticated. */
                if (!conn.IsAuthenticated && packetId != PacketId.Version && packetId != PacketId.Broadcast)
                {
                    conn.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"ConnectionId {conn.ClientId} sent packetId {packetId} without being authenticated. Connection will be kicked immediately.");
                    return;
                }

                if (packetId == PacketId.Replicate)
                {
                    Objects.ParseReplicateRpc(reader, conn, args.Channel);
                }
                else if (packetId == PacketId.ServerRpc)
                {
                    Objects.ParseServerRpc(reader, conn, args.Channel);
                }
                else if (packetId == PacketId.ObjectSpawn)
                {
                    if (!GetAllowPredictedSpawning())
                    {
                        conn.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"ConnectionId {conn.ClientId} sent a predicted spawn while predicted spawning is not enabled. Connection will be kicked immediately.");
                        return;
                    }
                    Objects.ReadSpawn(reader, conn);
                }
                else if (packetId == PacketId.ObjectDespawn)
                {
                    if (!GetAllowPredictedSpawning())
                    {
                        conn.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"ConnectionId {conn.ClientId} sent a predicted spawn while predicted spawning is not enabled. Connection will be kicked immediately.");
                        return;
                    }
                    Objects.ReadDespawn(reader, conn);
                }
                else if (packetId == PacketId.Broadcast)
                {
                    ParseBroadcast(reader, conn, args.Channel);
                }
                else if (packetId == PacketId.PingPong)
                {
                    ParsePingPong(reader, conn);
                }
                else if (packetId == PacketId.Version)
                {
                    ParseVersion(reader, conn, args.TransportIndex);
                }
                else
                {
#if DEVELOPMENT
                    NetworkManager.LogError($"Server received an unhandled PacketId of {(ushort)packetId} on channel {args.Channel} from connectionId {args.ConnectionId}. Remaining data has been purged.");
                    NetworkManager.LogError(NetworkManager.PacketIdHistory.GetReceivedPacketIds(packetsFromServer: false));
#else
                        NetworkManager.LogError($"Server received an unhandled PacketId of {(ushort)packetId} on channel {args.Channel} from connectionId {args.ConnectionId}. Connection will be kicked immediately.");
                        NetworkManager.TransportManager.Transport.StopConnection(args.ConnectionId, true);
#endif
                    return;
                }
            }
#if !DEVELOPMENT
            }
            catch (Exception e)
            {
                Kick(args.ConnectionId, KickReason.MalformedData, LoggingType.Error, $"Server encountered an error while parsing data for packetId {packetId} from connectionId {args.ConnectionId}. Connection will be kicked immediately. Message: {e.Message}.");
            }
            finally
            {
                reader?.Store();
            }
#else
            reader?.Store();
#endif

            //Kicks connection for exceeding MTU.
            void ExceededMTUKick()
            {
                Kick(args.ConnectionId, KickReason.ExploitExcessiveData, LoggingType.Common, $"ConnectionId {args.ConnectionId} sent a message larger than allowed amount. Connection will be kicked immediately.");
            }
        }

        /// <summary>
        /// Parses a received PingPong.
        /// </summary>
        /// <param name="reader"></param>
        /// <param name="conn"></param>
        private void ParsePingPong(PooledReader reader, NetworkConnection conn)
        {
            /* //security limit how often clients can send pings.
             * have clients use a stopwatch rather than frame time
             * for checks to ensure it's not possible to send
             * excessively should their game stutter then catch back up. */
            uint clientTick = reader.ReadTickUnpacked();
            if (conn.CanPingPong())
                NetworkManager.TimeManager.SendPong(conn, clientTick);
        }

        /// <summary>
        /// Called when a remote client authenticates with the server.
        /// </summary>
        /// <param name="connectionId"></param>
        private void ClientAuthenticated(NetworkConnection connection)
        {
            /* Immediately send connectionId to client. Some transports
             * don't give clients their remoteId, therefor it has to be sent
             * by the ServerManager. This packet is very simple and can be built
             * on the spot. */
            connection.ConnectionAuthenticated();
            /* Send client Ids before telling the client
             * they are authenticated. This is important because when the client becomes
             * authenticated they set their LocalConnection using Clients field in ClientManager,
             * which is set after getting Ids. */
            BroadcastClientConnectionChange(true, connection);
            SendAuthenticated(connection);

            OnAuthenticationResult?.Invoke(connection, true);
            NetworkManager.SceneManager.OnClientAuthenticated(connection);
        }

        /// <summary>
        /// Sends a client connection state change to owner and other clients if applicable.
        /// </summary>
        private void BroadcastClientConnectionChange(bool connected, NetworkConnection conn)
        {
            //Only send if the connection was authenticated.
            if (!conn.IsAuthenticated)
                return;
            //If sharing Ids then send all connected client Ids first if is a connected state.
            if (ShareIds)
            {
                /* Send a broadcast to all authenticated clients with the clientId
                 * that just connected. The conn client will also get this. */
                ClientConnectionChangeBroadcast changeMsg = new()
                {
                    Connected = connected,
                    Id = conn.ClientId
                };
                foreach (NetworkConnection c in Clients.Values)
                {
                    if (c.IsAuthenticated)
                        Broadcast(c, changeMsg);
                }

                /* If state is connected then the conn client
                 * must also receive all currently connected client ids. */
                if (connected)
                {
                    //Send already connected clients to the connection that just joined.
                    List<int> cache = CollectionCaches<int>.RetrieveList();
                    foreach (int key in Clients.Keys)
                        cache.Add(key);

                    ConnectedClientsBroadcast allMsg = new()
                    {
                        Values = cache
                    };
                    conn.Broadcast(allMsg);
                    CollectionCaches<int>.Store(cache);
                }
            }
            //If not sharing Ids then only send ConnectionChange to conn.
            else
            {
                if (connected)
                {
                    /* Send broadcast only to the client which just disconnected.
                     * Only send if connecting. If the client is disconnected there's no reason
                     * to send them a disconnect msg. */
                    ClientConnectionChangeBroadcast changeMsg = new()
                    {
                        Connected = connected,
                        Id = conn.ClientId
                    };
                    Broadcast(conn, changeMsg, true, Channel.Reliable);
                }
            }
        }
    }
}﻿using FishNet.Connection;
using FishNet.Managing.Logging;
using FishNet.Managing.Transporting;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Transporting.Multipass;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Managing.Server
{
    public sealed partial class ServerManager : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Called when a client is removed from the server using Kick. This is invoked before the client is disconnected.
        /// NetworkConnection when available, clientId, and KickReason are provided.
        /// </summary>
        public event Action<NetworkConnection, int, KickReason> OnClientKick;
        #endregion

        /// <summary>
        /// Stores a cache and returns a boolean result.
        /// </summary>
        /// <returns></returns>
        private bool StoreTransportCacheAndReturn(List<Transport> cache, bool returnedValue)
        {
            CollectionCaches<Transport>.Store(cache);
            return returnedValue;
        }
        
        /// <summary>
        /// Returns true if all server sockets have a local connection state of stopped.
        /// </summary>
        public bool AreAllServersStopped()
        {
            List<Transport> transports = NetworkManager.TransportManager.GetAllTransports(includeMultipass: false);

            foreach (Transport t in transports)
            {
                if (t.GetConnectionState(server: true) != LocalConnectionState.Stopped)
                    return StoreTransportCacheAndReturn(transports, returnedValue: false);
            }

            return StoreTransportCacheAndReturn(transports, returnedValue: true);
        }

        /// <summary>
        /// Returns true if only one server is started.
        /// </summary>
        /// <returns></returns>
        public bool IsOnlyOneServerStarted()
        {
            List<Transport> transports = NetworkManager.TransportManager.GetAllTransports(includeMultipass: false);

            int startedCount = 0;

            foreach (Transport t in transports)
            {
                if (t.GetConnectionState(true) == LocalConnectionState.Started)
                    startedCount++;
            }

            return StoreTransportCacheAndReturn(transports, (startedCount == 1));
        }

        [Obsolete("Use IsOnlyOneServerStarted().")]
        public bool OneServerStarted() => IsOnlyOneServerStarted();


        /// <summary>
        /// Returns true if any server socket is in the started state.
        /// </summary>
        /// <param name="excludedTransport">When set the transport will be ignored. This value is only used with Multipass.</param>
        public bool IsAnyServerStarted(Transport excludedTransport)
        {
            List<Transport> transports = NetworkManager.TransportManager.GetAllTransports(includeMultipass: false);

            foreach (Transport t in transports)
            {
                if (t == excludedTransport)
                    continue;
                //Another transport is started, no need to load start scenes again.
                if (t.GetConnectionState(true) == LocalConnectionState.Started)
                    return StoreTransportCacheAndReturn(transports, returnedValue: true);
            }

            return StoreTransportCacheAndReturn(transports, returnedValue: false);
        }

        /// <summary>
        /// Returns true if any server socket is in the started state.
        /// </summary>
        /// <param name="excludedIndex">When set the transport on this index will be ignored. This value is only used with Multipass.</param>
        public bool IsAnyServerStarted(int excludedIndex = TransportConsts.UNSET_TRANSPORT_INDEX)
        {
            Transport excludedTransport = null;
            if (excludedIndex != TransportConsts.UNSET_TRANSPORT_INDEX)
            {
                if (NetworkManager.TransportManager.Transport is Multipass mp)
                    excludedTransport = mp.GetTransport(excludedIndex);
            }
            
            return IsAnyServerStarted(excludedTransport);
        }

        [Obsolete("Use IsAnyServerStarted.")]
        public bool AnyServerStarted(int excludedIndex = TransportConsts.UNSET_TRANSPORT_INDEX) => IsAnyServerStarted(excludedIndex);

        /// <summary>
        /// Spawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="go">GameObject instance to spawn.</param>
        /// <param name="ownerConnection">Connection to give ownership to.</param>
        public void Spawn(GameObject go, NetworkConnection ownerConnection = null, UnityEngine.SceneManagement.Scene scene = default)
        {
            if (go == null)
            {
                NetworkManager.LogWarning($"GameObject cannot be spawned because it is null.");
                return;
            }

            NetworkObject nob = go.GetComponent<NetworkObject>();
            Spawn(nob, ownerConnection, scene);
        }

        /// <summary>
        /// Spawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="nob">MetworkObject instance to spawn.</param>
        /// <param name="ownerConnection">Connection to give ownership to.</param>
        public void Spawn(NetworkObject nob, NetworkConnection ownerConnection = null, UnityEngine.SceneManagement.Scene scene = default)
        {
            if (!nob.GetIsSpawnable())
            {
                NetworkManager.LogWarning($"NetworkObject {nob} cannot be spawned because it is not marked as spawnable.");
                return;
            }
            Objects.Spawn(nob, ownerConnection, scene);
        }

        /// <summary>
        /// Despawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="go">GameObject instance to despawn.</param>
        /// <param name="cacheOnDespawnOverride">Overrides the default DisableOnDespawn value for this single despawn. Scene objects will never be destroyed.</param>
        public void Despawn(GameObject go, DespawnType? despawnType = null)
        {
            if (go == null)
            {
                NetworkManager.LogWarning($"GameObject cannot be despawned because it is null.");
                return;
            }

            NetworkObject nob = go.GetComponent<NetworkObject>();
            Despawn(nob, despawnType);
        }

        /// <summary>
        /// Despawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="networkObject">NetworkObject instance to despawn.</param>
        /// <param name="despawnType">Despawn override type.</param>
        public void Despawn(NetworkObject networkObject, DespawnType? despawnType = null)
        {
            DespawnType resolvedDespawnType = (!despawnType.HasValue) ? networkObject.GetDefaultDespawnType() : despawnType.Value;

            Objects.Despawn(networkObject, resolvedDespawnType, asServer: true);
        }

        /// <summary>
        /// Kicks a connection immediately while invoking OnClientKick.
        /// </summary>
        /// <param name="conn">Client to kick.</param>
        /// <param name="kickReason">Reason client is being kicked.</param>
        /// <param name="loggingType">How to print logging as.</param>
        /// <param name="log">Optional message to be debug logged.</param>
        public void Kick(NetworkConnection conn, KickReason kickReason, LoggingType loggingType = LoggingType.Common, string log = "")
        {
            if (!conn.IsValid)
                return;

            OnClientKick?.Invoke(conn, conn.ClientId, kickReason);
            if (conn.IsActive)
                conn.Disconnect(true);

            if (!string.IsNullOrEmpty(log))
                NetworkManager.Log(loggingType, log);
        }

        /// <summary>
        /// Kicks a connection immediately while invoking OnClientKick.
        /// </summary>
        /// <param name="clientId">ClientId to kick.</param>
        /// <param name="kickReason">Reason client is being kicked.</param>
        /// <param name="loggingType">How to print logging as.</param>
        /// <param name="log">Optional message to be debug logged.</param>
        public void Kick(int clientId, KickReason kickReason, LoggingType loggingType = LoggingType.Common, string log = "")
        {
            OnClientKick?.Invoke(null, clientId, kickReason);
            NetworkManager.TransportManager.Transport.StopConnection(clientId, true);
            if (!string.IsNullOrEmpty(log))
                NetworkManager.Log(loggingType, log);
        }

        /// <summary>
        /// Kicks a connection immediately while invoking OnClientKick.
        /// </summary>
        /// <param name="conn">Client to kick.</param>
        /// <param name="reader">Reader to clear before kicking.</param>
        /// <param name="kickReason">Reason client is being kicked.</param>
        /// <param name="loggingType">How to print logging as.</param>
        /// <param name="log">Optional message to be debug logged.</param>
        public void Kick(NetworkConnection conn, Reader reader, KickReason kickReason, LoggingType loggingType = LoggingType.Common, string log = "")
        {
            reader.Clear();
            Kick(conn, kickReason, loggingType, log);
        }
    }
}﻿using FishNet.Object;
using FishNet.Transporting;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Managing.Server
{

    public sealed partial class ServerManager : MonoBehaviour
    {


        #region Internal
        /// <summary>
        /// Current RPCLinks.
        /// </summary>
        internal Dictionary<ushort, RpcLink> RpcLinks = new();
        /// <summary>
        /// RPCLink indexes which can be used.
        /// </summary>
        private Queue<ushort> _availableRpcLinkIndexes = new();
        #endregion

        /// <summary>
        /// Initializes RPC Links for NetworkBehaviours.
        /// </summary>
        private void InitializeRpcLinks()
        {
            ushort startingLink = NetworkManager.StartingRpcLinkIndex;
            for (ushort i = ushort.MaxValue; i >= startingLink; i--)
                _availableRpcLinkIndexes.Enqueue(i);
        }

        /// <summary>
        /// Sets the next RPC Link to use.
        /// </summary>
        /// <returns>True if a link was available and set.</returns>
        internal bool GetRpcLink(out ushort value)
        {
            if (_availableRpcLinkIndexes.Count > 0)
            {
                value = _availableRpcLinkIndexes.Dequeue();
                return true;
            }
            else
            {
                value = 0;
                return false;
            }
        }

        /// <summary>
        /// Sets data to RpcLinks for linkIndex.
        /// </summary>
        internal void SetRpcLink(ushort linkIndex, RpcLink data)
        {
            RpcLinks[linkIndex] = data;
        }

        /// <summary>
        /// Returns RPCLinks to availableRpcLinkIndexes.
        /// </summary>
        internal void StoreRpcLinks(Dictionary<uint, RpcLinkType> links)
        {
            foreach (RpcLinkType rlt in links.Values) 
                _availableRpcLinkIndexes.Enqueue(rlt.LinkPacketId);
        }
    }

}﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Managing.Server.Editing
{


    [CustomEditor(typeof(ServerManager), true)]
    [CanEditMultipleObjects]
    public class ServerManagerEditor : Editor
    {
        private SerializedProperty _authenticator;
        private SerializedProperty _remoteClientTimeout;
        private SerializedProperty _remoteClientTimeoutDuration;
        private SerializedProperty _syncTypeRate;
        private SerializedProperty SpawnPacking;
        private SerializedProperty _changeFrameRate;
        private SerializedProperty _frameRate;
        private SerializedProperty _shareIds;
        private SerializedProperty _startOnHeadless;
        private SerializedProperty _allowPredictedSpawning;
        private SerializedProperty _reservedObjectIds;

        protected virtual void OnEnable()
        {
            _authenticator = serializedObject.FindProperty(nameof(_authenticator));
            _remoteClientTimeout = serializedObject.FindProperty(nameof(_remoteClientTimeout));           
            _remoteClientTimeoutDuration = serializedObject.FindProperty(nameof(_remoteClientTimeoutDuration));
            _syncTypeRate = serializedObject.FindProperty(nameof(_syncTypeRate));
            SpawnPacking = serializedObject.FindProperty(nameof(SpawnPacking));
            _changeFrameRate = serializedObject.FindProperty(nameof(_changeFrameRate));
            _frameRate = serializedObject.FindProperty(nameof(_frameRate));
            _shareIds = serializedObject.FindProperty(nameof(_shareIds));
            _startOnHeadless = serializedObject.FindProperty(nameof(_startOnHeadless));
            _allowPredictedSpawning = serializedObject.FindProperty(nameof(_allowPredictedSpawning));
            _reservedObjectIds = serializedObject.FindProperty(nameof(_reservedObjectIds));

        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour((ServerManager)target), typeof(ServerManager), false);
            GUI.enabled = true;

            EditorGUILayout.LabelField("Settings", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_syncTypeRate);
            EditorGUILayout.PropertyField(SpawnPacking);
            EditorGUILayout.PropertyField(_changeFrameRate);
            if (_changeFrameRate.boolValue)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_frameRate);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.PropertyField(_startOnHeadless);
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            EditorGUILayout.LabelField("Connections", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_remoteClientTimeout);
            if ((RemoteTimeoutType)_remoteClientTimeout.intValue != RemoteTimeoutType.Disabled)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_remoteClientTimeoutDuration,new GUIContent("Timeout"));
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.PropertyField(_shareIds);
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            EditorGUILayout.LabelField("Security", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_authenticator);

            EditorGUILayout.PropertyField(_allowPredictedSpawning);
            if (_allowPredictedSpawning.boolValue == true)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_reservedObjectIds);
                EditorGUI.indentLevel--;
            }
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            serializedObject.ApplyModifiedProperties();
        }

    }
}
#endif﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.Connection;
using FishNet.Managing.Object;
using FishNet.Managing.Timing;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility.Extension;
using GameKit.Dependencies.Utilities;
using GameKit.Dependencies.Utilities.Types;
using System;
using System.Collections.Generic;
using FishNet.Managing.Logging;
using FishNet.Object.Synchronizing;
using FishNet.Serializing.Helping;
using FishNet.Utility.Performance;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Managing.Server
{
    /// <summary>
    /// Handles objects and information about objects for the server. See ManagedObjects for inherited options.
    /// </summary>
    public partial class ServerObjects : ManagedObjects
    {
        #region Public.
        /// <summary>
        /// Called right before client objects are destroyed when a client disconnects.
        /// </summary>
        public event Action<NetworkConnection> OnPreDestroyClientObjects;
        #endregion

        #region Internal.
        /// <summary>
        /// Collection of NetworkObjects recently despawned.
        /// Key: objectId.
        /// Value: despawn tick.
        /// This is used primarily to track if client is sending messages for recently despawned objects.
        /// Objects are automatically removed after RECENTLY_DESPAWNED_DURATION seconds.
        /// </summary>
        internal Dictionary<int, uint> RecentlyDespawnedIds = new();
        #endregion

        #region Private.
        /// <summary>
        /// Cached ObjectIds which may be used when exceeding available ObjectIds.
        /// </summary>
        private Queue<int> _objectIdCache = new();

        /// <summary>
        /// Returns the ObjectId cache.
        /// </summary>
        /// <returns></returns>
        internal Queue<int> GetObjectIdCache() => _objectIdCache;

        /// <summary>
        /// NetworkBehaviours which have dirty SyncObjects.
        /// </summary>
        private List<NetworkBehaviour> _dirtySyncTypeBehaviours = new(20);
        /// <summary>
        /// Objects which need to be destroyed next tick.
        /// This is needed when running as host so host client will get any final messages for the object before they're destroyed.
        /// </summary>
        private HashSet<NetworkObject> _pendingDestroy = new();
        /// <summary>
        /// NetworkObjects in a recently loaded scene.
        /// </summary>
        private List<(int, List<NetworkObject>)> _loadedSceneNetworkObjects = new List<(int frame, List<NetworkObject> nobs)>();
        /// <summary>
        /// Cache of spawning objects, used for recursively spawning nested NetworkObjects.
        /// </summary>
        private List<NetworkObject> _spawnCache = new();
        /// <summary>
        /// True if one or more scenes are currently loading through the SceneManager.
        /// </summary>
        private bool _scenesLoading;

        /// <summary>
        /// Number of ticks which must pass to clear a recently despawned.
        /// </summary>
        private uint _cleanRecentlyDespawnedMaxTicks => base.NetworkManager.TimeManager.TimeToTicks(30d, TickRounding.RoundUp);
        #endregion

        internal ServerObjects(NetworkManager networkManager)
        {
            base.Initialize(networkManager);
            networkManager.SceneManager.OnLoadStart += SceneManager_OnLoadStart;
            networkManager.SceneManager.OnActiveSceneSetInternal += SceneManager_OnActiveSceneSet;
            networkManager.TimeManager.OnUpdate += TimeManager_OnUpdate;
        }

        /// <summary>
        /// Called when MonoBehaviours call Update.
        /// </summary>
        private void TimeManager_OnUpdate()
        {
            if (!base.NetworkManager.IsServerStarted)
            {
                _scenesLoading = false;
                ClearSceneLoadedNetworkObjects();
                return;
            }

            CleanRecentlyDespawned();

            if (!_scenesLoading)
                IterateLoadedScenes(false);

            Observers_OnUpdate();
        }

        /// <summary>
        /// Clears NetworkObjects pending initialization from a recently loaded scene.
        /// </summary>
        private void ClearSceneLoadedNetworkObjects()
        {
            for (int i = 0; i < _loadedSceneNetworkObjects.Count; i++)
            {
                (int frame, List<NetworkObject> nobs) value = _loadedSceneNetworkObjects[i];
                CollectionCaches<NetworkObject>.Store(value.nobs);
            }

            _loadedSceneNetworkObjects.Clear();
        }

        #region Checking dirty SyncTypes.
        /// <summary>
        /// Iterates NetworkBehaviours with dirty SyncTypes.
        /// </summary>
        internal void WriteDirtySyncTypes()
        {
            List<NetworkBehaviour> collection = _dirtySyncTypeBehaviours;
            int colStart = collection.Count;
            if (colStart == 0)
                return;

            /* Tells networkbehaviours to check their
             * dirty synctypes. */
            for (int i = 0; i < collection.Count; i++)
            {
                bool dirtyCleared = collection[i].WriteDirtySyncTypes(SyncTypeWriteFlag.Unset);
                if (dirtyCleared)
                {
                    collection.RemoveAt(i);
                    i--;
                }
            }
        }

        /// <summary>
        /// Sets that a NetworkBehaviour has a dirty syncVars.
        /// </summary>
        internal void SetDirtySyncType(NetworkBehaviour nb)
        {
            _dirtySyncTypeBehaviours.Add(nb);
        }
        #endregion

        #region Connection Handling.
        /// <summary>
        /// Called when the connection state changes for the local server.
        /// </summary>
        /// <param name="args"></param>
        internal void OnServerConnectionState(ServerConnectionStateArgs args)
        {
            //If server just connected.
            if (args.ConnectionState == LocalConnectionState.Started)
            {
                /* If there's no servers started besides the one
                 * that just started then build Ids and setup scene objects. */
                if (base.NetworkManager.ServerManager.IsOnlyOneServerStarted())
                {
                    BuildObjectIdCache();
                    SetupSceneObjects();
                }
            }
            //Server in anything but started state.
            else
            {
                //If no servers are started then reset.
                if (!base.NetworkManager.ServerManager.IsAnyServerStarted())
                {
                    base.DespawnWithoutSynchronization(recursive: true, asServer: true);
                    base.SceneObjects_Internal.Clear();
                    _objectIdCache.Clear();
                    base.NetworkManager.ClearClientsCollection(base.NetworkManager.ServerManager.Clients);
                }
                //If at least one server is started then only clear for disconnecting server.
                else
                {
                    int transportIndex = args.TransportIndex;
                    //Remove connection from all NetworkObjects to ensure they are not stuck in observers.
                    foreach (NetworkConnection c in base.NetworkManager.ServerManager.Clients.Values)
                    {
                        if (c.TransportIndex == transportIndex)
                            RemoveFromObserversWithoutSynchronization(c);
                    }

                    //Remove connections only for transportIndex.
                    base.NetworkManager.ClearClientsCollection(base.NetworkManager.ServerManager.Clients, transportIndex);
                }
            }
        }

        /// <summary>
        /// Called when a client disconnects.
        /// </summary>
        /// <param name="connection"></param>
        internal void ClientDisconnected(NetworkConnection connection)
        {
            RemoveFromObserversWithoutSynchronization(connection);

            if (OnPreDestroyClientObjects != null)
                OnPreDestroyClientObjects.Invoke(connection);

            /* A cache is made because the Objects
             * collection would end up modified during
             * iteration from removing ownership and despawning. */
            List<NetworkObject> nobs = CollectionCaches<NetworkObject>.RetrieveList();
            foreach (NetworkObject nob in connection.Objects)
                nobs.Add(nob);

            int nobsCount = nobs.Count;
            for (int i = 0; i < nobsCount; i++)
            {
                NetworkObject n = nobs[i];
                /* Objects may already be deinitializing when a client disconnects
                 * because the root object could have been despawned first, and in result
                 * all child objects would have been recursively despawned.
                 *
                 * EG: object is:
                 *      A (nob)
                 *          B (nob)
                 *
                 * Both A and B are owned by the client so they will both be
                 * in collection. Should A despawn first B will recursively despawn
                 * from it. Then once that finishes and the next index of collection
                 * is run, which would B, the object B would have already been deinitialized. */
                if (!n.IsDeinitializing && !n.PreventDespawnOnDisconnect)
                    base.NetworkManager.ServerManager.Despawn(nobs[i]);
            }

            CollectionCaches<NetworkObject>.Store(nobs);
        }
        #endregion

        #region ObjectIds.
        /// <summary>
        /// Builds the ObjectId cache with all possible Ids.
        /// </summary>
        private void BuildObjectIdCache()
        {
            _objectIdCache.Clear();

            /* Shuffle Ids to make it more difficult
             * for clients to track spawned object
             * count. */
            List<int> shuffledCache = new();
            //Ignore ushort.maxvalue as that indicates null.
            for (int i = 0; i < (ushort.MaxValue - 1); i++)
            //for (int i = 0; i < (2200); i++) //QUICK-TEST Uncomment this, and comment the line above.
                shuffledCache.Add(i);
            /* Only shuffle when NOT in editor and not
             * development build.
             * Debugging could be easier when Ids are ordered. */
#if !DEVELOPMENT
            shuffledCache.Shuffle();
#endif
            //Add shuffled to objectIdCache.
            //Build Id cache.
            int cacheCount = shuffledCache.Count;
            for (int i = 0; i < cacheCount; i++)
                _objectIdCache.Enqueue(shuffledCache[i]);
        }

        /// <summary>
        /// Caches a NetworkObject ObjectId.
        /// </summary>
        private void CacheObjectId(NetworkObject nob)
        {
            if (nob.ObjectId != NetworkObject.UNSET_OBJECTID_VALUE)
                CacheObjectId(nob.ObjectId);
        }

        /// <summary>
        /// Adds an ObjectId to objectId cache.
        /// </summary>
        /// <param name="id"></param>
        internal void CacheObjectId(int id)
        {
            if (!_objectIdCache.Contains(id))
                _objectIdCache.Enqueue(id);
            else
                NetworkManager.LogError($"Object Id [{id}] already exists within ObjectId Cache. Please report this error.");
        }

        /// <summary>
        /// Gets the next ObjectId to use for NetworkObjects.
        /// </summary>
        /// <returns></returns>
        protected internal override bool GetNextNetworkObjectId(out int nextNetworkObjectId)
        {
            if (!_objectIdCache.TryDequeue(out nextNetworkObjectId))
            {
                nextNetworkObjectId = NetworkObject.UNSET_OBJECTID_VALUE;
                base.NetworkManager.LogError($"No more available ObjectIds. How the heck did you manage to have {ushort.MaxValue} objects spawned at once?");
            }

            return (nextNetworkObjectId != NetworkObject.UNSET_OBJECTID_VALUE);
        }
        #endregion

        #region Initializing Objects In Scenes.
        /// <summary>
        /// Called when a scene load starts.
        /// </summary>
        private void SceneManager_OnLoadStart(Scened.SceneLoadStartEventArgs obj)
        {
            _scenesLoading = true;
        }

        /// <summary>
        /// Called after the active scene has been scene, immediately after scene loads.
        /// </summary>
        private void SceneManager_OnActiveSceneSet(bool asServer)
        {
            _scenesLoading = false;
            IterateLoadedScenes(true);
        }

        /// <summary>
        /// Iterates loaded scenes and sets them up.
        /// </summary>
        /// <param name="ignoreFrameRestriction">True to ignore the frame restriction when iterating.</param>
        internal void IterateLoadedScenes(bool ignoreFrameRestriction)
        {
            //Not started, clear loaded scenes.
            if (!NetworkManager.ServerManager.Started)
            {
                ClearSceneLoadedNetworkObjects();
                return;
            }

            for (int i = 0; i < _loadedSceneNetworkObjects.Count; i++)
            {
                (int frame, List<NetworkObject> networkObjects) value = _loadedSceneNetworkObjects[i];
                if (ignoreFrameRestriction || (Time.frameCount > value.frame))
                {
                    SetupSceneObjects(value.networkObjects);
                    CollectionCaches<NetworkObject>.Store(value.networkObjects);
                    _loadedSceneNetworkObjects.RemoveAt(i);
                    i--;
                }
            }
        }

        /// <summary>
        /// Called when a scene loads on the server.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="arg1"></param>
        protected internal override void SceneManager_sceneLoaded(Scene s, LoadSceneMode arg1)
        {
            base.SceneManager_sceneLoaded(s, arg1);

            if (!NetworkManager.ServerManager.Started)
                return;

            List<NetworkObject> sceneNobs = CollectionCaches<NetworkObject>.RetrieveList();
            Scenes.GetSceneNetworkObjects(s, firstOnly: false, errorOnDuplicates: true, ignoreUnsetSceneIds: true, ref sceneNobs);
            _loadedSceneNetworkObjects.Add((Time.frameCount, sceneNobs));

            InitializeRootNetworkObjects(sceneNobs);
        }

        /// <summary>
        /// Sets initial values for NetworkObjects.
        /// </summary>
        /// <param name="nobs"></param>
        private void InitializeRootNetworkObjects(List<NetworkObject> nobs)
        {
            /* First update the nested status on all nobs, as well
             * set them as not initialized. This is done as some scene objets might be prefabs
             * that were changed in scene but have not had the prefab settings updated to those
             * changes. */
            foreach (NetworkObject nob in nobs)
            {
                nob.SetIsNestedThroughTraversal();
                nob.UnsetInitializedValuesSet();
            }

            //Initialize sceneNobs cache, but do not invoke callbacks till next frame.
            foreach (NetworkObject nob in nobs)
            {
                if (nob.IsSceneObject && !nob.IsNested)
                    nob.SetInitializedValues(parentNob: null, force: false);
            }
        }

        /// <summary>
        /// Setup all NetworkObjects in scenes. Should only be called when server is active.
        /// </summary>
        protected internal void SetupSceneObjects()
        {
            Scene ddolScene = DDOL.GetDDOL().gameObject.scene;
            bool ddolLoaded = ddolScene.isLoaded;

            /* Becomes false if setup in GetSceenAt.
             * This is a safety check for if Unity ever changes
             * the behavior where DDOL scenes appear in the sceneCount. */
            bool trySetupDdol = true;

            for (int i = 0; i < SceneManager.sceneCount; i++)
            {
                Scene s = SceneManager.GetSceneAt(i);
                if (ddolLoaded && s.handle == ddolScene.handle)
                    trySetupDdol = false;

                SetupSceneObjects(s);
            }

            if (trySetupDdol)
                SetupSceneObjects(ddolScene);
        }

        /// <summary>
        /// Setup NetworkObjects in a scene. Should only be called when server is active.
        /// </summary>
        /// <param name="s"></param>
        private void SetupSceneObjects(Scene s)
        {
            if (!s.IsValid())
                return;

            List<NetworkObject> sceneNobs = CollectionCaches<NetworkObject>.RetrieveList();
            Scenes.GetSceneNetworkObjects(s, firstOnly: false, errorOnDuplicates: true, ignoreUnsetSceneIds: true, ref sceneNobs);

            SetupSceneObjects(sceneNobs);

            CollectionCaches<NetworkObject>.Store(sceneNobs);
        }

        /// <summary>
        /// Setup NetworkObjects in a scene. Should only be called when server is active.
        /// </summary>
        /// <param name="s"></param>
        private void SetupSceneObjects(List<NetworkObject> sceneNobs)
        {
            InitializeRootNetworkObjects(sceneNobs);

            List<NetworkObject> cache = SortRootAndNestedByInitializeOrder(sceneNobs);

            bool isHost = base.NetworkManager.IsHostStarted;
            int nobsCount = cache.Count;
            for (int i = 0; i < nobsCount; i++)
            {
                NetworkObject nob = cache[i];
                //Only setup if a scene object and not initialzied.
                if (nob.GetIsNetworked() && nob.IsSceneObject && nob.IsDeinitializing)
                {
                    if (!nob.WasActiveDuringEdit_Set1)
                    {
                        NetworkManager.LogError($"NetworkObject {nob.name} in scene {nob.gameObject.scene.name} needs to be reserialized. Please use the Fish-Networking menu -> Utility -> Reserialize NetworkObjects.");
                        continue;
                    }

                    base.AddToSceneObjects(nob);
                    /* If was active in the editor (before hitting play), or currently active
                     * then PreInitialize without synchronizing to clients. There is no reason
                     * to synchronize to clients because the scene just loaded on server,
                     * which means clients are not yet in the scene. */
                    if (nob.WasActiveDuringEdit || nob.gameObject.activeInHierarchy)
                    {
                        //If not host then object doesn't need to be spawned until a client joins.
                        if (!isHost)
                            SetupWithoutSynchronization(nob);
                        //Otherwise spawn object so observers update for clientHost.
                        else
                            SpawnWithoutChecks(nob);
                    }
                }
            }

            CollectionCaches<NetworkObject>.Store(cache);
        }

        /// <summary>
        /// Performs setup on a NetworkObject without synchronizing the actions to clients.
        /// </summary>
        /// <param name="objectId">Override ObjectId to use.</param>
        private bool SetupWithoutSynchronization(NetworkObject nob, NetworkConnection ownerConnection = null, int? objectId = null, bool initializeEarly = true)
        {
            if (nob.GetIsNetworked())
            {
                int objectIdValue;

                if (objectId != null)
                {
                    objectIdValue = objectId.Value;
                }
                else
                {
                    if (!GetNextNetworkObjectId(out objectIdValue))
                        return false;
                }

                if (initializeEarly)
                    nob.InitializeEarly(NetworkManager, objectIdValue, ownerConnection, true);

                base.AddToSpawned(nob, true);
                nob.gameObject.SetActive(true);
                nob.Initialize(true, true);

                return true;
            }

            return false;
        }
        #endregion

        #region Spawning.
        /// <summary>
        /// Spawns an object over the network.
        /// </summary>
        internal void Spawn(NetworkObject networkObject, NetworkConnection ownerConnection = null, UnityEngine.SceneManagement.Scene scene = default)
        {
            //Default as false, will change if needed.
            bool predictedSpawn = false;

            if (networkObject == null)
            {
                base.NetworkManager.LogError($"Specified networkObject is null.");
                return;
            }

            if (!NetworkManager.ServerManager.Started)
            {
                //Neither server nor client are started.
                if (!NetworkManager.ClientManager.Started)
                {
                    base.NetworkManager.LogWarning("Cannot spawn object because server nor client are active.");
                    return;
                }

                //Server has predicted spawning disabled.
                if (!NetworkManager.ServerManager.GetAllowPredictedSpawning())
                {
                    base.NetworkManager.LogWarning("Cannot spawn object because server is not active and predicted spawning is not enabled.");
                    return;
                }

                //Various predicted spawn checks.
                if (!base.CanPredictedSpawn(networkObject, NetworkManager.ClientManager.Connection, false))
                    return;

                //Since server is not started then run TrySpawn for client, given this is a client trying to predicted spawn.
                if (!networkObject.PredictedSpawn.OnTrySpawnClient())
                    return;

                predictedSpawn = true;
            }

            if (!networkObject.gameObject.scene.IsValid())
            {
                base.NetworkManager.LogError($"{networkObject.name} is a prefab. You must instantiate the prefab first, then use Spawn on the instantiated copy.");
                return;
            }

            if (ownerConnection != null && ownerConnection.IsActive && !ownerConnection.LoadedStartScenes(!predictedSpawn))
            {
                base.NetworkManager.LogWarning($"{networkObject.name} was spawned but it's recommended to not spawn objects for connections until they have loaded start scenes. You can be notified when a connection loads start scenes by using connection.OnLoadedStartScenes on the connection, or SceneManager.OnClientLoadStartScenes.");
            }

            if (networkObject.IsSpawned)
            {
                base.NetworkManager.LogWarning($"{networkObject.name} is already spawned.");
                return;
            }

            NetworkBehaviour networkBehaviourParent = networkObject.CurrentParentNetworkBehaviour;
            if (networkBehaviourParent != null && !networkBehaviourParent.IsSpawned)
            {
                base.NetworkManager.LogError($"{networkObject.name} cannot be spawned because it has a parent NetworkObject {networkBehaviourParent} which is not spawned.");
                return;
            }

            /* If scene is specified make sure the object is root,
             * and if not move it before network spawning. */
            if (scene.IsValid())
            {
                if (networkObject.transform.parent != null)
                {
                    base.NetworkManager.LogError($"{networkObject.name} cannot be moved to scene name {scene.name}, handle {scene.handle} because {networkObject.name} is not root and only root objects may be moved.");
                    return;
                }
                else
                {
                    UnityEngine.SceneManagement.SceneManager.MoveGameObjectToScene(networkObject.gameObject, scene);
                }
            }

            if (predictedSpawn)
                base.NetworkManager.ClientManager.Objects.PredictedSpawn(networkObject, ownerConnection);
            else
                SpawnWithoutChecks(networkObject, recursiveSpawnCache: null, ownerConnection);
        }

        /// <summary>
        /// Spawns networkObject without any checks.
        /// </summary>
        private void SpawnWithoutChecks(NetworkObject networkObject, List<NetworkObject> recursiveSpawnCache = null, NetworkConnection ownerConnection = null, int? objectId = null, bool rebuildObservers = true, bool initializeEarly = true, bool isRecursiveIteration = false)
        {
            /* Setup locally without sending to clients.
             * When observers are built for the network object
             * during initialization spawn messages will
             * be sent. */
            networkObject.SetIsNetworked(true);

            /* Grab the nested before spawning the networkObject. This prevents double initialization
             * if one of the OnStart callbacks adds nested to networkObject.
             *
             * EG: called on NetworkObject during 'SetupWithoutSynchronization'
             * private void OnStartNetwork()
             * {
             *       NetworkObject n = Instantiate(xyz);
             *       n.SetParent(this); //this being NetworkObject
             *       base.Spawn(n);
             * }
             *
             * If nested was fetched after SetupWithout Synchronize just below then it would
             * include the newly nested object, and try to initialize it twice.
             */
            List<NetworkObject> nestedNetworkObjects = (isRecursiveIteration) ? null : networkObject.GetNetworkObjects(GetNetworkObjectOption.AllNestedRecursive);

            if (SetupWithoutSynchronization(networkObject, ownerConnection, objectId, initializeEarly))
                _spawnCache.Add(networkObject);

            if (nestedNetworkObjects != null)
            {
                foreach (NetworkObject item in nestedNetworkObjects)
                {
                    /* Only spawn recursively if the nob state is unset.
                     * Unset indicates that the nob has not been manually spawned or despawned. */
                    if (item.gameObject.activeInHierarchy || item.State == NetworkObjectState.Spawned)
                        SpawnWithoutChecks(item, recursiveSpawnCache: null, ownerConnection, isRecursiveIteration: true);
                }
            }

            /* Copy to a new cache then reset _spawnCache
             * just incase rebuilding observers would lead to
             * more additions into _spawnCache. EG: rebuilding
             * may result in additional objects being spawned
             * for clients and if _spawnCache were not reset
             * the same objects would be rebuilt again. This likely
             * would not affect anything other than perf but who
             * wants that. */
            bool recursiveCacheWasNull = (recursiveSpawnCache == null);
            if (recursiveCacheWasNull)
                recursiveSpawnCache = CollectionCaches<NetworkObject>.RetrieveList();
            recursiveSpawnCache.AddRange(_spawnCache);
            _spawnCache.Clear();

            //Also rebuild observers for the object so it spawns for others.
            if (rebuildObservers)
                RebuildObservers(recursiveSpawnCache);

            int spawnCacheCopyCount = recursiveSpawnCache.Count;
            /* If also client then we need to make sure the object renderers have correct visibility.
             * Set visibility based on if the observers contains the clientHost connection. */
            if (NetworkManager.IsClientStarted)
            {
                int count = spawnCacheCopyCount;
                NetworkConnection localConnection = NetworkManager.ClientManager.Connection;
                for (int i = 0; i < count; i++)
                {
                    NetworkObject nob = recursiveSpawnCache[i];
                    nob.SetRenderersVisible(nob.Observers.Contains(localConnection));
                }
            }

            CollectionCaches<NetworkObject>.StoreAndDefault(ref nestedNetworkObjects);

            /* If collection was null then store the one retrieved.
             * Otherwise, let the calling method handle the provided
             * cache. */
            if (recursiveCacheWasNull)
                CollectionCaches<NetworkObject>.Store(recursiveSpawnCache);
        }

        /// <summary>
        /// Reads a predicted spawn.
        /// </summary>
        internal void ReadSpawn(PooledReader reader, NetworkConnection conn)
        {
            ushort spawnLength = reader.ReadUInt16Unpacked();

            int readStartPosition = reader.Position;

            SpawnType st = (SpawnType)reader.ReadUInt8Unpacked();
            bool sceneObject = st.FastContains(SpawnType.Scene);
            bool isGlobal = st.FastContains(SpawnType.InstantiatedGlobal);

            ReadNestedSpawnIds(reader, st, out byte? nobComponentId, out int? parentObjectId, out byte? parentComponentId, readSpawningObjects: null);

            int objectId = reader.ReadNetworkObjectForSpawn(out _, out ushort collectionId);

            //No predicted spawn ids left. Should not be possible as client would have stopped this locally.
            if (conn.PredictedObjectIds.Count == 0 || !conn.PredictedObjectIds.TryDequeue(out int serverPredictedObjectId))
            {
                reader.Clear();
                conn.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Connection {conn.ClientId} used predicting spawning without any Ids in queue.");
                return;
            }

            //Ids should match. Client cannot send predicted spawn Ids out of order, so they should always match the server in order.
            if (objectId != serverPredictedObjectId)
            {
                reader.Clear();
                conn.Kick(KickReason.ExploitAttempt, LoggingType.Common, $"Connection {conn.ClientId} used predicted Id of {objectId} while the server Id is {serverPredictedObjectId}.");
                return;
            }

            NetworkObject nob = null;
            NetworkConnection owner = null;

            /* See if the parent exists. If not, then do not
             * continue and send failed response to client. */
            if (parentObjectId.HasValue && !Spawned.TryGetValueIL2CPP(parentObjectId.Value, out NetworkObject _))
            {
                NetworkManager.Log($"Predicted spawn failed due to the NetworkObject's parent not being found. Scene object: {sceneObject}, ObjectId {objectId}, CollectionId {collectionId}.");
                SendFailedResponse(objectId);
                return;
            }
            owner = reader.ReadNetworkConnection();

            //Read transform values which differ from serialized values.
            base.ReadTransformProperties(reader, out Vector3? nullablePosition, out Quaternion? nullableRotation, out Vector3? nullableScale);

            int prefabId;
            ulong sceneId = 0;
            string sceneName = string.Empty;
            string objectName = string.Empty;

            if (sceneObject)
            {
                base.ReadSceneObjectId(reader, out sceneId);
#if DEVELOPMENT
                if (NetworkManager.ClientManager.IsServerDevelopment)
                    base.CheckReadSceneObjectDetails(reader, ref sceneName, ref objectName);
#endif
                nob = base.GetSceneNetworkObject(sceneId, sceneName, objectName);
            }
            else
            {
                prefabId = reader.ReadNetworkObjectId();
                ObjectPoolRetrieveOption retrieveOptions = (ObjectPoolRetrieveOption.MakeActive | ObjectPoolRetrieveOption.LocalSpace);
                nob = NetworkManager.GetPooledInstantiated(prefabId, collectionId, retrieveOptions, null, nullablePosition, nullableRotation, nullableScale, false);
            }

            /* NetworkObject could not be found. User could be sending an invalid Id,
             * or perhaps it was a scene object and the scene had unloaded prior to getting
             * this spawn message. */
            if (nob == null)
            {
                NetworkManager.Log($"Predicted spawn failed due to the NetworkObject not being found. Scene object: {sceneObject}, ObjectId {objectId}, CollectionId {collectionId}.");
                SendFailedResponse(objectId);
                return;
            }

            if (!nob.WasActiveDuringEdit_Set1)
            {
                string sceneOrPrefabText = (sceneObject) ? $"in scene {nob.gameObject.scene.name}" : "prefab";
                NetworkManager.LogError($"NetworkObject {nob.name} {sceneOrPrefabText}. Please use the Fish-Networking menu -> Utility -> Reserialize NetworkObjects.");
            }


            /* Update sceneObject position.
             * There is no need to do this on instantiate since the position is set
             * during the instantiation. */
            if (sceneObject)
            {
                nob.transform.SetLocalPositionRotationAndScale(nullablePosition, nullableRotation, nullableScale);
            }

            //Check if nob allows predicted spawning.
            if (!base.CanPredictedSpawn(nob, conn, true, reader))
                return;

            nob.SetIsGlobal(isGlobal);
            nob.SetIsNetworked(true);
            nob.InitializeEarly(NetworkManager, objectId, owner, true);
            //Initialize for prediction.
            nob.InitializePredictedObject_Server(conn);

            base.ReadPayload(conn, nob, reader);
            base.ReadRpcLinks(reader);
            base.ReadSyncTypesForSpawn(reader);

            //Check user implementation of trySpawn.
            if (!nob.PredictedSpawn.OnTrySpawnServer(conn, owner))
            {
                //Inform client of failure.
                SendFailedResponse(objectId);
                return;
            }

            //Once here everything is good.

            //Get connections to send spawn to.
            List<NetworkConnection> conns = RetrieveAuthenticatedConnections();

            SendSuccessResponse(objectId);
            //Store caches used.
            CollectionCaches<NetworkConnection>.Store(conns);

            //Sends a failed response.
            void SendFailedResponse(int lObjectId)
            {
                SkipRemainingSpawnLength();
                if (nob != null)
                {
                    //TODO support pooling. This first requires a rework of the initialization / clientHost message system.
                    UnityEngine.Object.Destroy(nob.gameObject);
                    //base.NetworkManager.StorePooledInstantiated(nob, true);
                }

                PooledWriter writer = WriteResponseHeader(success: false, lObjectId);

                conn.SendToClient((byte)Channel.Reliable, writer.GetArraySegment());
                WriterPool.Store(writer);
            }

            //Sends a success spawn result and returns nobs recursively spawned, including original.
            void SendSuccessResponse(int lObjectId)
            {
                PooledWriter writer = WriteResponseHeader(success: true, lObjectId);

                SpawnWithoutChecks(nob, recursiveSpawnCache: null, owner, lObjectId, rebuildObservers: true, initializeEarly: false);
                conn.SendToClient((byte)Channel.Reliable, writer.GetArraySegment());

                WriterPool.Store(writer);
            }

            //Writes response header and returns writer used.
            PooledWriter WriteResponseHeader(bool success, int lObjectId)
            {
                PooledWriter writer = WriterPool.Retrieve();
                writer.WritePacketIdUnpacked(PacketId.PredictedSpawnResult);
                writer.WriteBoolean(success);

                //Id of object which was predicted spawned.
                writer.WriteNetworkObjectId(lObjectId);

                //Write the next Id even if not succesful.
                int nextId;
                if (NetworkManager.ServerManager.Objects.GetObjectIdCache().TryDequeue(out nextId))
                    conn.PredictedObjectIds.Enqueue(nextId);
                else
                    nextId = NetworkObject.UNSET_OBJECTID_VALUE;

                //Write nextId even if invalid. Client will not add invalid Ids.
                writer.WriteNetworkObjectId(nextId);

                return writer;
            }

            //Skips remaining data for the spawn.
            void SkipRemainingSpawnLength()
            {
                /* Simply setting the position to readStart + spawnLength works
                 * too but when possible use supplied API. */
                int skipLength = spawnLength - (reader.Position - readStartPosition);
                reader.Skip(skipLength);
            }
        }
        #endregion

        #region Despawning.
        /// <summary>
        /// Cleans recently despawned objects.
        /// </summary>
        private void CleanRecentlyDespawned()
        {
            //Only iterate if frame ticked to save perf.
            if (!base.NetworkManager.TimeManager.FrameTicked)
                return;

            List<int> intCache = CollectionCaches<int>.RetrieveList();

            uint requiredTicks = _cleanRecentlyDespawnedMaxTicks;
            uint currentTick = base.NetworkManager.TimeManager.LocalTick;
            //Iterate 20, or 5% of the collection, whichever is higher.
            int iterations = Mathf.Max(20, (int)(RecentlyDespawnedIds.Count * 0.05f));
            /* Given this is a dictionary there is no gaurantee which order objects are
             * added. Because of this it's possible some objects may take much longer to
             * be removed. This is okay so long as a consistent chunk of objects are removed
             * at a time; eventually all objects will be iterated. */
            int count = 0;
            foreach (KeyValuePair<int, uint> kvp in RecentlyDespawnedIds)
            {
                long result = (currentTick - kvp.Value);
                //If enough ticks have passed to remove.
                if (result > requiredTicks)
                    intCache.Add(kvp.Key);

                count++;
                if (count == iterations)
                    break;
            }

            //Remove cached entries.
            int cCount = intCache.Count;
            for (int i = 0; i < cCount; i++)
                RecentlyDespawnedIds.Remove(intCache[i]);

            CollectionCaches<int>.Store(intCache);
        }

        /// <summary>
        /// Returns if an objectId was recently despawned.
        /// </summary>
        /// <param name="objectId">ObjectId to check.</param>
        /// <param name="ticks">Passed ticks to be within to be considered recently despawned.</param>
        /// <returns>True if an objectId was despawned with specified number of ticks.</returns>
        public bool RecentlyDespawned(int objectId, uint ticks)
        {
            uint despawnTick;
            if (!RecentlyDespawnedIds.TryGetValue(objectId, out despawnTick))
                return false;

            return ((NetworkManager.TimeManager.LocalTick - despawnTick) <= ticks);
        }

        /// <summary>
        /// Adds to objects pending destroy due to clientHost environment.
        /// </summary>
        /// <param name="nob"></param>
        internal void AddToPending(NetworkObject nob)
        {
            _pendingDestroy.Add(nob);
        }

        /// <summary>
        /// Tries to removes objectId from PendingDestroy and returns if successful.
        /// </summary>
        internal bool RemoveFromPending(NetworkObject nob)
        {
            return _pendingDestroy.Remove(nob);
        }

        /// <summary>
        /// Returns a NetworkObject in PendingDestroy.
        /// </summary>
        internal NetworkObject GetFromPending(int objectId)
        {
            /* Becomes true if there was a null entry and pending must be rebuilt.
             * This would be very uncommon */
            bool rebuildPending = false;

            foreach (NetworkObject n in _pendingDestroy)
            {
                if (n == null)
                {
                    rebuildPending = true;
                    continue;
                }

                if (n.ObjectId == objectId)
                    return n;
            }

            if (rebuildPending)
            {
                HashSet<NetworkObject> newPending = CollectionCaches<NetworkObject>.RetrieveHashSet();
                foreach (NetworkObject n in _pendingDestroy)
                {
                    if (n != null)
                        newPending.Add(n);
                }

                CollectionCaches<NetworkObject>.Store(_pendingDestroy);
                _pendingDestroy = newPending;
            }

            //Fall through, nothing found.
            return null;
        }

        /// <summary>
        /// Destroys NetworkObjects pending for destruction.
        /// </summary>
        internal void DestroyPending()
        {
            foreach (NetworkObject item in _pendingDestroy)
            {
                if (item != null)
                    UnityEngine.Object.Destroy(item.gameObject);
            }

            _pendingDestroy.Clear();
        }

        /// <summary>
        /// Despawns an object over the network.
        /// </summary>
        internal override void Despawn(NetworkObject networkObject, DespawnType despawnType, bool asServer)
        {
            //Default as false, will change if needed.
            bool predictedDespawn = false;

            if (networkObject == null)
            {
                base.NetworkManager.LogWarning($"NetworkObject cannot be despawned because it is null.");
                return;
            }

            if (networkObject.IsDeinitializing)
            {
                base.NetworkManager.LogWarning($"Object {networkObject.name} cannot be despawned because it is already deinitializing.");
                return;
            }

            if (!NetworkManager.ServerManager.Started)
            {
                //Neither server nor client are started.
                if (!NetworkManager.ClientManager.Started)
                {
                    base.NetworkManager.LogWarning("Cannot despawn object because server nor client are active.");
                    return;
                }

                //Server has predicted spawning disabled.
                if (!NetworkManager.ServerManager.GetAllowPredictedSpawning())
                {
                    base.NetworkManager.LogWarning("Cannot despawn object because server is not active and predicted spawning is not enabled.");
                    return;
                }

                //Various predicted despawn checks.
                if (!base.CanPredictedDespawn(networkObject, NetworkManager.ClientManager.Connection, false))
                    return;

                predictedDespawn = true;
            }

            if (!networkObject.gameObject.scene.IsValid())
            {
                base.NetworkManager.LogError($"{networkObject.name} is a prefab. You must instantiate the prefab first, then use Spawn on the instantiated copy.");
                return;
            }

            if (predictedDespawn)
            {
                base.NetworkManager.ClientManager.Objects.PredictedDespawn(networkObject);
            }
            else
            {
                FinalizeDespawn(networkObject, despawnType);
                RecentlyDespawnedIds[networkObject.ObjectId] = base.NetworkManager.TimeManager.LocalTick;
                base.Despawn(networkObject, despawnType, asServer);
            }
        }

        /// <summary>
        /// Called when a NetworkObject is destroyed without being deactivated first.
        /// </summary>
        /// <param name="nob"></param>
        internal override void NetworkObjectDestroyed(NetworkObject nob, bool asServer)
        {
            //Only finalize despawn if not already deinitialized.
            if (!nob.IsDeinitializing)
                FinalizeDespawn(nob, DespawnType.Destroy);
            
            base.NetworkObjectDestroyed(nob, asServer);
        }

        /// <summary>
        /// Finalizes the despawn process. By the time this is called the object is considered unaccessible.
        /// </summary>
        /// <param name="nob"></param>
        private void FinalizeDespawn(NetworkObject nob, DespawnType despawnType)
        {
            List<NetworkBehaviour> dirtiedNbs = _dirtySyncTypeBehaviours;
            if (nob != null && nob.ObjectId != NetworkObject.UNSET_OBJECTID_VALUE)
            {
                // Write out any pending sync types and be sure to clear from the dirty list
                // to avoid trying to write out a despawned object later on.
                for (int i = 0, count = nob.NetworkBehaviours.Count; i < count; ++i)
                {
                    NetworkBehaviour nb = nob.NetworkBehaviours[i];
                    if (nb.SyncTypeDirty && nb.WriteDirtySyncTypes((SyncTypeWriteFlag.ForceReliable | SyncTypeWriteFlag.IgnoreInterval)))
                        dirtiedNbs.Remove(nb);
                }

                WriteDespawnAndSend(nob, despawnType);

                CacheObjectId(nob);
            }
        }

        /// <summary>
        /// Writes a despawn and sends it to clients.
        /// </summary>
        private void WriteDespawnAndSend(NetworkObject nob, DespawnType despawnType)
        {
            HashSet<NetworkConnection> observers = nob.Observers;
            if (observers.Count == 0)
                return;

            PooledWriter everyoneWriter = WriterPool.Retrieve();
            WriteDespawn(nob, despawnType, everyoneWriter);

            ArraySegment<byte> despawnSegment = everyoneWriter.GetArraySegment();

            //Add observers to a list cache.
            List<NetworkConnection> cache = CollectionCaches<NetworkConnection>.RetrieveList();
            /* Must be added into a new collection because the
             * user might try and modify the observers in the despawn, which
             * would cause a collection modified error. */
            cache.AddRange(observers);
            int cacheCount = cache.Count;

            for (int i = 0; i < cacheCount; i++)
            {
                //Invoke ondespawn and send despawn.
                NetworkConnection conn = cache[i];
                nob.InvokeOnServerDespawn(conn);
                NetworkManager.TransportManager.SendToClient((byte)Channel.Reliable, despawnSegment, conn);
                //Remove from observers.
                //nob.Observers.Remove(conn);
            }

            everyoneWriter.Store();
            CollectionCaches<NetworkConnection>.Store(cache);
        }

        /// <summary>
        /// Reads a predicted despawn.
        /// </summary>
        internal void ReadDespawn(Reader reader, NetworkConnection conn)
        {
            NetworkObject nob = reader.ReadNetworkObject();

            //Maybe server destroyed the object so don't kick if null.
            if (nob == null)
                return;
            if (nob.IsDeinitializing)
                return;

            //Various predicted despawn checks.
            if (!base.CanPredictedDespawn(nob, conn, true))
                return;

            //Despawn object.
            nob.Despawn();
        }
        #endregion
    }
}﻿using FishNet.Connection;
using FishNet.Managing.Object;
using FishNet.Managing.Timing;
using FishNet.Object;
using FishNet.Observing;
using FishNet.Serializing;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Managing.Server
{
    public partial class ServerObjects : ManagedObjects
    {
        #region Private.
        /// <summary>
        /// Cache filled with objects which observers are being updated.
        /// This is primarily used to invoke events after all observers are updated, rather than as each is updated.
        /// </summary>
        private List<NetworkObject> _observerChangedObjectsCache = new(100);
        /// <summary>
        /// NetworkObservers which require regularly iteration.
        /// </summary>
        private List<NetworkObject> _timedNetworkObservers = new();
        /// <summary>
        /// Index in TimedNetworkObservers to start on next cycle.
        /// </summary>
        private int _nextTimedObserversIndex;
        /// <summary>
        /// Used to write spawns for everyone. This writer will exclude owner only information.
        /// </summary>
        private PooledWriter _writer = new();
        /// <summary>
        /// Indexes within TimedNetworkObservers which are unset.
        /// </summary>
        private Queue<int> _emptiedTimedIndexes = new();
        #endregion

        /// <summary>
        /// Called when MonoBehaviours call Update.
        /// </summary>
        private void Observers_OnUpdate()
        {
            UpdateTimedObservers();
        }

        /// <summary>
        /// Progressively updates NetworkObservers with timed conditions.
        /// </summary>
        private void UpdateTimedObservers()
        {
            if (!base.NetworkManager.IsServerStarted)
                return;
            //No point in updating if the timemanager isn't going to tick this frame.
            if (!base.NetworkManager.TimeManager.FrameTicked)
                return;
            int networkObserversCount = _timedNetworkObservers.Count;
            if (networkObserversCount == 0)
                return;

            /* Try to iterate all timed observers every half a second.
             * This value will increase as there's more observers or timed conditions. */
            float timeMultiplier = 1f + ((base.NetworkManager.ServerManager.Clients.Count * 0.005f) + (_timedNetworkObservers.Count * 0.0005f));
            //Check cap this way for readability.
            float completionTime = Mathf.Min((0.5f * timeMultiplier), base.NetworkManager.ObserverManager.MaximumTimedObserversDuration);
            uint completionTicks = base.NetworkManager.TimeManager.TimeToTicks(completionTime, TickRounding.RoundUp);
            /* Iterations will be the number of objects
             * to iterate to be have completed all objects by
             * the end of completionTicks. */
            int iterations = Mathf.CeilToInt((float)networkObserversCount / completionTicks);
            if (iterations > _timedNetworkObservers.Count)
                iterations = _timedNetworkObservers.Count;

            List<NetworkConnection> connCache = RetrieveAuthenticatedConnections();
            //Build nob cache.
            List<NetworkObject> nobCache = CollectionCaches<NetworkObject>.RetrieveList();
            for (int i = 0; i < iterations; i++)
            {
                if (_nextTimedObserversIndex >= _timedNetworkObservers.Count)
                    _nextTimedObserversIndex = 0;

                NetworkObject nob = _timedNetworkObservers[_nextTimedObserversIndex++];
                if (nob != null)
                    nobCache.Add(nob);
            }

            RebuildObservers(nobCache, connCache, true);

            CollectionCaches<NetworkConnection>.Store(connCache);
            CollectionCaches<NetworkObject>.Store(nobCache);
        }

        /// <summary>
        /// Indicates that a networkObserver component should be updated regularly. This is done automatically.
        /// </summary>
        /// <param name="networkObject">NetworkObject to be updated.</param>
        public void AddTimedNetworkObserver(NetworkObject networkObject)
        {
            if (_emptiedTimedIndexes.TryDequeue(out int index))
                _timedNetworkObservers[index] = networkObject;
            else
                _timedNetworkObservers.Add(networkObject);
        }

        /// <summary>
        /// Indicates that a networkObserver component no longer needs to be updated regularly. This is done automatically.
        /// </summary>
        /// <param name="networkObject">NetworkObject to be updated.</param>
        public void RemoveTimedNetworkObserver(NetworkObject networkObject)
        {
            int index = _timedNetworkObservers.IndexOf(networkObject);
            if (index == -1)
                return;

            _emptiedTimedIndexes.Enqueue(index);
            _timedNetworkObservers[index] = null;

            //If there's a decent amount missing then rebuild the collection.
            if (_emptiedTimedIndexes.Count > 20)
            {
                List<NetworkObject> newLst = CollectionCaches<NetworkObject>.RetrieveList();
                foreach (NetworkObject nob in _timedNetworkObservers)
                {
                    if (nob == null)
                        continue;

                    newLst.Add(nob);
                }

                CollectionCaches<NetworkObject>.Store(_timedNetworkObservers);
                _timedNetworkObservers = newLst;
                _emptiedTimedIndexes.Clear();
            }
        }

        /// <summary>
        /// Gets all NetworkConnections which are authenticated.
        /// </summary>
        /// <returns></returns>
        private List<NetworkConnection> RetrieveAuthenticatedConnections()
        {
            List<NetworkConnection> cache = CollectionCaches<NetworkConnection>.RetrieveList();
            foreach (NetworkConnection item in NetworkManager.ServerManager.Clients.Values)
            {
                if (item.IsAuthenticated)
                    cache.Add(item);
            }

            return cache;
        }

        /// <summary>
        /// Gets all spawned objects with root objects first.
        /// </summary>
        /// <returns></returns>
        private List<NetworkObject> RetrieveOrderedSpawnedObjects()
        {
            List<NetworkObject> spawnedCache = GetSpawnedNetworkObjects();

            List<NetworkObject> sortedCache = SortRootAndNestedByInitializeOrder(spawnedCache);

            CollectionCaches<NetworkObject>.Store(spawnedCache);

            return sortedCache;
        }

        /// <summary>
        /// Returns spawned NetworkObjects as a list.
        /// Collection returned is a new cache and should be disposed of properly.
        /// </summary>
        /// <returns></returns>
        private List<NetworkObject> GetSpawnedNetworkObjects()
        {
            List<NetworkObject> cache = CollectionCaches<NetworkObject>.RetrieveList();
            Spawned.ValuesToList(ref cache);

            return cache;
        }

        /// <summary>
        /// Sorts a collection of NetworkObjects root and nested by initialize order.
        /// Collection returned is a new cache and should be disposed of properly.
        /// </summary>
        internal List<NetworkObject> SortRootAndNestedByInitializeOrder(List<NetworkObject> nobs)
        {
            List<NetworkObject> sortedRootCache = CollectionCaches<NetworkObject>.RetrieveList();

            //First order root objects.
            foreach (NetworkObject item in nobs)
            {
                if (item.IsNested)
                    continue;

                sortedRootCache.AddOrdered(item);
            }

            /* After all root are ordered check
             * their nested. Order nested in segments
             * of each root then insert after the root.
             * This must be performed after all roots are ordered. */

            //This holds the results of all values.
            List<NetworkObject> sortedRootAndNestedCache = CollectionCaches<NetworkObject>.RetrieveList();

            //Cache for sorting nested.
            List<NetworkObject> sortedNestedCache = CollectionCaches<NetworkObject>.RetrieveList();

            foreach (NetworkObject item in sortedRootCache)
            {
                /* Remove recursive and only check Initialized and Runtime. Once iterated 
                 * check each added entry again using Initialized and Recursive. */
                List<NetworkObject> nested = item.GetNetworkObjects(GetNetworkObjectOption.AllNestedRecursive);
                foreach (NetworkObject nestedItem in nested)
                {
                    if (sortedNestedCache.Contains(nestedItem))
                        Debug.LogError("Already contains " + nestedItem.name);
                    else
                        sortedNestedCache.AddOrdered(nestedItem);
                }

                CollectionCaches<NetworkObject>.Store(nested);

                /* Once all nested are sorted then can be added to the
                 * sorted root and nested cache. */
                sortedRootAndNestedCache.Add(item);
                sortedRootAndNestedCache.AddRange(sortedNestedCache);

                //Reset cache.
                sortedNestedCache.Clear();
            }

            //Store temp caches.
            CollectionCaches<NetworkObject>.Store(sortedRootCache);
            CollectionCaches<NetworkObject>.Store(sortedNestedCache);

            return sortedRootAndNestedCache;
        }

        /// <summary>
        /// Removes a connection from observers without synchronizing changes.
        /// </summary>
        /// <param name="connection"></param>
        private void RemoveFromObserversWithoutSynchronization(NetworkConnection connection)
        {
            List<NetworkObject> observerChangedObjectsCache = _observerChangedObjectsCache;
            foreach (NetworkObject nob in Spawned.Values)
            {
                if (nob.RemoveObserver(connection))
                    observerChangedObjectsCache.Add(nob);
            }

            //Invoke despawn callbacks on nobs.
            for (int i = 0; i < observerChangedObjectsCache.Count; i++)
                observerChangedObjectsCache[i].InvokeOnServerDespawn(connection);
            observerChangedObjectsCache.Clear();
        }

        /// <summary>
        /// Rebuilds observers on all NetworkObjects for all connections.
        /// </summary>
        public void RebuildObservers(bool timedOnly = false)
        {
            List<NetworkObject> nobCache = RetrieveOrderedSpawnedObjects();
            List<NetworkConnection> connCache = RetrieveAuthenticatedConnections();

            RebuildObservers(nobCache, connCache, timedOnly);

            CollectionCaches<NetworkObject>.Store(nobCache);
            CollectionCaches<NetworkConnection>.Store(connCache);
        }

        /// <summary>
        /// Rebuilds observers for all connections for a NetworkObject.
        /// </summary>
        public void RebuildObservers(NetworkObject nob, bool timedOnly = false)
        {
            List<NetworkObject> nobCache = CollectionCaches<NetworkObject>.RetrieveList(nob);
            List<NetworkConnection> connCache = RetrieveAuthenticatedConnections();

            RebuildObservers(nobCache, connCache, timedOnly);

            CollectionCaches<NetworkObject>.Store(nobCache);
            CollectionCaches<NetworkConnection>.Store(connCache);
        }

        /// <summary>
        /// Rebuilds observers on all NetworkObjects for a connection.
        /// </summary>
        public void RebuildObservers(NetworkConnection connection, bool timedOnly = false)
        {
            List<NetworkObject> nobCache = RetrieveOrderedSpawnedObjects();
            List<NetworkConnection> connCache = CollectionCaches<NetworkConnection>.RetrieveList(connection);

            RebuildObservers(nobCache, connCache, timedOnly);

            CollectionCaches<NetworkObject>.Store(nobCache);
            CollectionCaches<NetworkConnection>.Store(connCache);
        }

        /// <summary>
        /// Rebuilds observers on NetworkObjects.
        /// </summary>
        public void RebuildObservers(IList<NetworkObject> nobs, bool timedOnly = false)
        {
            List<NetworkConnection> conns = RetrieveAuthenticatedConnections();

            RebuildObservers(nobs, conns, timedOnly);

            CollectionCaches<NetworkConnection>.Store(conns);
        }

        /// <summary>
        /// Rebuilds observers on all objects for connections.
        /// </summary>
        public void RebuildObservers(IList<NetworkConnection> connections, bool timedOnly = false)
        {
            List<NetworkObject> nobCache = RetrieveOrderedSpawnedObjects();

            RebuildObservers(nobCache, connections, timedOnly);

            CollectionCaches<NetworkObject>.Store(nobCache);
        }

        /// <summary>
        /// Rebuilds observers on NetworkObjects for connections.
        /// </summary>
        public void RebuildObservers(IList<NetworkObject> nobs, NetworkConnection conn, bool timedOnly = false)
        {
            List<NetworkConnection> connCache = CollectionCaches<NetworkConnection>.RetrieveList(conn);

            RebuildObservers(nobs, connCache, timedOnly);

            CollectionCaches<NetworkConnection>.Store(connCache);
        }

        /// <summary>
        /// Rebuilds observers for connections on NetworkObject.
        /// </summary>
        public void RebuildObservers(NetworkObject networkObject, IList<NetworkConnection> connections, bool timedOnly = false)
        {
            List<NetworkObject> nobCache = CollectionCaches<NetworkObject>.RetrieveList(networkObject);

            RebuildObservers(nobCache, connections, timedOnly);

            CollectionCaches<NetworkObject>.Store(nobCache);
        }

        /// <summary>
        /// Rebuilds observers on NetworkObjects for connections.
        /// </summary>
        public void RebuildObservers(IList<NetworkObject> nobs, IList<NetworkConnection> conns, bool timedOnly = false)
        {
            List<NetworkObject> nobCache = CollectionCaches<NetworkObject>.RetrieveList();
            NetworkConnection nc;

            int connsCount = conns.Count;
            for (int i = 0; i < connsCount; i++)
            {
                nobCache.Clear();

                nc = conns[i];
                int nobsCount = nobs.Count;
                for (int z = 0; z < nobsCount; z++)
                    RebuildObservers(nobs[z], nc, nobCache, timedOnly);

                //Send if change.
                if (_writer.Length > 0)
                {
                    NetworkManager.TransportManager.SendToClient((byte)Channel.Reliable, _writer.GetArraySegment(), nc);
                    _writer.Clear();

                    foreach (NetworkObject n in nobCache)
                        n.OnSpawnServer(nc);
                }
            }

            CollectionCaches<NetworkObject>.Store(nobCache);
        }

        /// <summary>
        /// Rebuilds observers for a connection on NetworkObject.
        /// </summary>
        public void RebuildObservers(NetworkObject nob, NetworkConnection conn, bool timedOnly = false)
        {
            if (ApplicationState.IsQuitting())
                return;
            _writer.Clear();

            conn.UpdateHashGridPositions(!timedOnly);
            //If observer state changed then write changes.
            ObserverStateChange osc = nob.RebuildObservers(conn, timedOnly);
            if (osc == ObserverStateChange.Added)
            {
                WriteSpawn(nob, _writer, conn);
            }
            else if (osc == ObserverStateChange.Removed)
            {
                nob.InvokeOnServerDespawn(conn);
                WriteDespawn(nob, nob.GetDefaultDespawnType(), _writer);
            }
            else
            {
                return;
            }

            NetworkManager.TransportManager.SendToClient((byte)Channel.Reliable, _writer.GetArraySegment(), conn);

            /* If spawning then also invoke server
             * start events, such as buffer last
             * and onspawnserver. */
            if (osc == ObserverStateChange.Added)
                nob.OnSpawnServer(conn);

            _writer.Clear();

            /* If there is change then also rebuild recursive networkObjects. */
            foreach (NetworkBehaviour item in nob.RuntimeChildNetworkBehaviours)
                RebuildObservers(item.NetworkObject, conn, timedOnly);
        }

        /// <summary>
        /// Rebuilds observers for a connection on NetworkObject.
        /// </summary>
        internal void RebuildObservers(NetworkObject nob, NetworkConnection conn, List<NetworkObject> addedNobs, bool timedOnly = false)
        {
            if (ApplicationState.IsQuitting())
                return;

            /* When not using a timed rebuild such as this connections must have
             * hashgrid data rebuilt immediately. */
            conn.UpdateHashGridPositions(!timedOnly);

            //If observer state changed then write changes.
            ObserverStateChange osc = nob.RebuildObservers(conn, timedOnly);
            if (osc == ObserverStateChange.Added)
            {
                WriteSpawn(nob, _writer, conn);
                addedNobs.Add(nob);
            }
            else if (osc == ObserverStateChange.Removed)
            {
                nob.InvokeOnServerDespawn(conn);
                WriteDespawn(nob, nob.GetDefaultDespawnType(), _writer);
            }
            else
            {
                return;
            }

            /* If there is change then also rebuild on any runtime children.
             * This is to ensure runtime children have visibility updated
             * in relation to parent.
             *
             * If here there is change. */
            foreach (NetworkBehaviour item in nob.RuntimeChildNetworkBehaviours)
                RebuildObservers(item.NetworkObject, conn, addedNobs, timedOnly);
        }
    }
}﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif

using FishNet.Connection;
using FishNet.Managing.Object;
using FishNet.Managing.Utility;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using System.Runtime.CompilerServices;

namespace FishNet.Managing.Server
{
    public partial class ServerObjects : ManagedObjects
    {

        /// <summary>
        /// Parses a ServerRpc.
        /// </summary>
        
        internal void ParseServerRpc(PooledReader reader, NetworkConnection conn, Channel channel)
        {
#if DEVELOPMENT
            NetworkBehaviour.ReadDebugForValidatedRpc(base.NetworkManager, reader, out int startReaderRemaining, out string rpcInformation, out uint expectedReadAmount);
#endif
            
            NetworkBehaviour nb = reader.ReadNetworkBehaviour();
            int dataLength = Packets.GetPacketLength((ushort)PacketId.ServerRpc, reader, channel);

            if (nb != null)
                nb.ReadServerRpc(fromRpcLink: false, methodHash: 0, reader, conn, channel);
            else
                SkipDataLength((ushort)PacketId.ServerRpc, reader, dataLength);
            
#if DEVELOPMENT
            NetworkBehaviour.TryPrintDebugForValidatedRpc(fromRpcLink: false, base.NetworkManager, reader, startReaderRemaining, rpcInformation, expectedReadAmount, channel);
#endif
        }
    }

}namespace FishNet.Managing.Statistic
{

    public struct NetworkTrafficArgs
    {
        /// <summary>
        /// Number of bytes sent to the server.
        /// </summary>
        public readonly ulong ToServerBytes;
        /// <summary>
        /// Number of bytes sent by the server.
        /// </summary>
        public readonly ulong FromServerBytes;

        public NetworkTrafficArgs(ulong toServerBytes, ulong fromServerBytes)
        {
            ToServerBytes = toServerBytes;
            FromServerBytes = fromServerBytes;
        }
    }
}

using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Managing.Statistic
{
    [System.Serializable]
    public class NetworkTraficStatistics
    {
        #region Public.
        /// <summary>
        /// Called when NetworkTraffic is updated for the client.
        /// </summary>
        public event Action<NetworkTrafficArgs> OnClientNetworkTraffic;
        /// <summary>
        /// Called when NetworkTraffic is updated for the server.
        /// </summary>
        public event Action<NetworkTrafficArgs> OnServerNetworkTraffic;
        #endregion

        #region Serialized.
        /// <summary>
        /// How often to update traffic statistics.
        /// </summary>
        [Tooltip("How often to update traffic statistics.")]
        [SerializeField]
        [Range(0f, 10f)]
        private float _updateInteval = 1f;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to update client statistics.")]
        [SerializeField]
        private bool _updateClient;
        /// <summary>
        /// True to update client statistics.
        /// </summary>
        public bool UpdateClient
        {
            get => _updateClient;
            private set => _updateClient = value;
        }
        /// <summary>
        /// Sets UpdateClient value.
        /// </summary>
        /// <param name="update"></param>
        public void SetUpdateClient(bool update)
        {
            UpdateClient = update;
        }
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to update server statistics.")]
        [SerializeField]
        private bool _updateServer;
        /// <summary>
        /// True to update client statistics.
        /// </summary>
        public bool UpdateServer
        {
            get => _updateServer;
            private set => _updateServer = value;
        }
        /// <summary>
        /// Sets UpdateServer value.
        /// </summary>
        /// <param name="update"></param>
        public void SetUpdateServer(bool update)
        {
            UpdateServer = update;
        }
        #endregion

        #region Private.
        /// <summary>
        /// NetworkManager for this statistics.
        /// </summary>
        private NetworkManager _networkManager;
        /// <summary>
        /// Bytes sent to the server from local client.
        /// </summary>
        private ulong _client_toServerBytes;
        /// <summary>
        /// Bytes received on the local client from the server.
        /// </summary>
        private ulong _client_fromServerBytes;
        /// <summary>
        /// Bytes sent to all clients from the local server.
        /// </summary>
        private ulong _server_toClientsBytes;
        /// <summary>
        /// Bytes received on the local server from all clients.
        /// </summary>
        private ulong _server_fromClientsBytes;
        /// <summary>
        /// Next time network traffic updates may invoke.
        /// </summary>
        private float _nextUpdateTime;
        /// <summary>
        /// Size suffixes as text.
        /// </summary>
        private static readonly string[] _sizeSuffixes = { "B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB" };
        #endregion

        internal void InitializeOnce_Internal(NetworkManager manager)
        {
            _networkManager = manager;
            manager.TimeManager.OnPreTick += TimeManager_OnPreTick;
        }

        /// <summary>
        /// Called before the TimeManager ticks.
        /// </summary>
        private void TimeManager_OnPreTick()
        {
            if (Time.unscaledTime < _nextUpdateTime)
                return;
            _nextUpdateTime = Time.unscaledTime + _updateInteval;

            if (UpdateClient && _networkManager.IsClientStarted)
                OnClientNetworkTraffic?.Invoke(new(_client_toServerBytes, _client_fromServerBytes));
            if (UpdateServer && _networkManager.IsServerStarted)
                OnServerNetworkTraffic?.Invoke(new(_server_fromClientsBytes, _server_toClientsBytes));

            _client_toServerBytes = 0;
            _client_fromServerBytes = 0;
            _server_toClientsBytes = 0;
            _server_fromClientsBytes = 0;
        }

        /// <summary>
        /// Called when the local client sends data.
        /// </summary>
        internal void LocalClientSentData(ulong dataLength)
        {
            _client_toServerBytes = Math.Min(_client_toServerBytes + dataLength, ulong.MaxValue);
        }
        /// <summary>
        /// Called when the local client receives data.
        /// </summary>
        public void LocalClientReceivedData(ulong dataLength)
        {
            _client_fromServerBytes = Math.Min(_client_fromServerBytes + dataLength, ulong.MaxValue);
        }


        /// <summary>
        /// Called when the local client sends data.
        /// </summary>
        internal void LocalServerSentData(ulong dataLength)
        {
            _server_toClientsBytes = Math.Min(_server_toClientsBytes + dataLength, ulong.MaxValue);
        }
        /// <summary>
        /// Called when the local client receives data.
        /// </summary>
        public void LocalServerReceivedData(ulong dataLength)
        {
            _server_fromClientsBytes = Math.Min(_server_fromClientsBytes + dataLength, ulong.MaxValue);
        }


        //Attribution: https://stackoverflow.com/questions/14488796/does-net-provide-an-easy-way-convert-bytes-to-kb-mb-gb-etc
        /// <summary>
        /// Formats passed in bytes value to the largest possible data type with 2 decimals.
        /// </summary>
        public static string FormatBytesToLargest(float bytes)
        {
            int decimalPlaces = 2;
            if (bytes < 1f || float.IsInfinity(bytes) || float.IsNaN(bytes))
                return ReturnZero();

            string ReturnZero() 
            {
                decimalPlaces = 0;
                return string.Format("{0:n" + decimalPlaces + "} B/s", 0);
            }
            
            // mag is 0 for bytes, 1 for KB, 2, for MB, etc.
            int mag = (int)Math.Log(bytes, 1024);

            // 1L << (mag * 10) == 2 ^ (10 * mag) 
            // [i.e. the number of bytes in the unit corresponding to mag]
            decimal adjustedSize = (decimal)bytes / (1L << (mag * 10));

            // make adjustment when the value is large enough that
            // it would round up to 1000 or more
            if (Math.Round(adjustedSize, decimalPlaces) >= 1000)
            {
                mag += 1;
                adjustedSize /= 1024;
            }

            //Don't show decimals for bytes.
            if (mag == 0)
                decimalPlaces = 0;

            return string.Format("{0:n" + decimalPlaces + "} {1}", adjustedSize, _sizeSuffixes[mag]);
        }
    }


}using UnityEngine;

namespace FishNet.Managing.Statistic
{

    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/StatisticsManager")]
    public class StatisticsManager : MonoBehaviour
    {
        /// <summary>
        /// Statistics for NetworkTraffic.
        /// </summary>
        public NetworkTraficStatistics NetworkTraffic = new();

        internal void InitializeOnce_Internal(NetworkManager manager)
        {
            NetworkTraffic.InitializeOnce_Internal(manager);
        }
  
    }

}﻿using FishNet.Documenting;
using System;

namespace FishNet.Managing.Timing
{

    [APIExclude]
    public class MovingAverage : IDisposable
    {
        #region Public.
        /// <summary>
        /// Average from samples favoring the most recent sample.
        /// </summary>
        public float Average { get; private set; }
        /// <summary>
        /// Sample size being used.
        /// </summary>
        public int SampleSize { get; private set; }
        #endregion

        /// <summary>
        /// Next index to write a sample to.
        /// </summary>
        private int _writeIndex;
        /// <summary>
        /// Collected samples.
        /// </summary>
        private float[] _samples;
        /// <summary>
        /// Number of samples written. Will be at most samples size.
        /// </summary>
        private int _writtenSamples;
        /// <summary>
        /// Samples accumulated over queue.
        /// </summary>
        private float _sampleAccumulator;

        public MovingAverage(int sampleSize)
        {
            if (sampleSize < 2)
            {
                NetworkManagerExtensions.LogWarning("Using a sampleSize of less than 2 will always return the most recent value as Average.");
                sampleSize = 1;
            }

            SampleSize = sampleSize;
            _samples = new float[sampleSize];
        }


        /// <summary>
        /// Computes a new windowed average each time a new sample arrives
        /// </summary>
        /// <param name="newSample"></param>
        public void ComputeAverage(float newSample)
        {
            if (_samples.Length <= 1)
            {
                Average = newSample;
                return;
            }

            _sampleAccumulator += newSample;
            _samples[_writeIndex] = newSample;

            //Increase writeIndex.
            _writeIndex++;
            _writtenSamples = Math.Max(_writtenSamples, _writeIndex);
            if (_writeIndex >= _samples.Length)
                _writeIndex = 0;

            Average = _sampleAccumulator / _writtenSamples;

            /* If samples are full then drop off
            * the oldest sample. This will always be
            * the one just after written. The entry isn't
            * actually removed from the array but will
            * be overwritten next sample. */
            if (_writtenSamples >= _samples.Length)
                _sampleAccumulator -= _samples[_writeIndex];

        }

        /// <summary>
        /// Resets values.
        /// </summary>
        public void Reset()
        {
            _sampleAccumulator = 0f;
            _writeIndex = 0;
            _writtenSamples = 0;
        }

        public void Dispose()
        {
            Reset();
        }
    }


}﻿namespace FishNet.Managing.Timing
{
    /// <summary>
    /// How to simulate physics.
    /// </summary>
    public enum PhysicsMode
    {
        /// <summary>
        /// Unity performs physics every FixedUpdate.
        /// </summary>
        Unity = 0,
        /// <summary>
        /// TimeManager performs physics each tick.
        /// </summary>
        TimeManager = 1,
        /// <summary>
        /// Physics will be disabled.
        /// </summary>
        Disabled = 2
    }


}﻿using System;
using FishNet.Serializing;
using GameKit.Dependencies.Utilities;

namespace FishNet.Managing.Timing
{
    public readonly struct PreciseTick : IEquatable<PreciseTick>
    {
        /// <summary>
        /// The current tick.
        /// </summary>
        public readonly uint Tick;
        /// <summary>
        /// Percentage of the tick returned between 0d and 1d.
        /// </summary>
        public readonly double PercentAsDouble;
        /// <summary>
        /// Percentage of the tick returned between 0 and 100.
        /// </summary>
        public readonly byte PercentAsByte;

        /// <summary>
        /// Maximum value a percent can be as a double.
        /// </summary>
        public const double MAXIMUM_DOUBLE_PERCENT = 1d;
        /// <summary>
        /// Maximum value a percent can be as a byte.
        /// </summary>
        public const byte MAXIMUM_BYTE_PERCENT = 100;

        /// <summary>
        /// Value to use when a precise tick is unset.
        /// </summary>
        public static PreciseTick GetUnsetValue() => new(TimeManager.UNSET_TICK, (byte)0);

        /// <summary>
        /// Creates a precise tick where the percentage is 0.
        /// </summary>
        public PreciseTick(uint tick)
        {
            Tick = tick;
            PercentAsByte = 0;
            PercentAsDouble = 0d;
        }
        
        /// <summary>
        /// Creates a precise tick where the percentage is a byte between 0 and 100.
        /// </summary>
        public PreciseTick(uint tick, byte percentAsByte)
        {
            Tick = tick;

            percentAsByte = Maths.ClampByte(percentAsByte, 0, MAXIMUM_BYTE_PERCENT);
            PercentAsByte = percentAsByte;
            PercentAsDouble = (percentAsByte / 100d);
        }

        /// <summary>
        /// Creates a precise tick where the percentage is a double between 0d and 1d.
        /// </summary>
        public PreciseTick(uint tick, double percent)
        {
            Tick = tick;
            percent = Maths.ClampDouble(percent, 0d, MAXIMUM_DOUBLE_PERCENT);
            PercentAsByte = (byte)(percent * 100d);
            PercentAsDouble = percent;
        }

        public bool IsValid() => (Tick != TimeManager.UNSET_TICK);

        /// <summary>
        /// Prints PreciseTick information as a string.
        /// </summary>
        /// <returns></returns>
        public override string ToString() => $"Tick {Tick}, Percent {PercentAsByte.ToString("000")}";

        public static bool operator ==(PreciseTick a, PreciseTick b)
        {
            return (a.Tick == b.Tick && a.PercentAsByte == b.PercentAsByte);
        }

        public static bool operator !=(PreciseTick a, PreciseTick b)
        {
            return !(a == b);
        }

        public static bool operator >=(PreciseTick a, PreciseTick b)
        {
            if (b.Tick > a.Tick) return false;
            if (a.Tick > b.Tick) return true;
            //If here ticks are the same.
            return a.PercentAsByte >= b.PercentAsByte;
        }

        public static bool operator <=(PreciseTick a, PreciseTick b) => (b >= a);

        public static bool operator >(PreciseTick a, PreciseTick b)
        {
            if (b.Tick > a.Tick) return false;
            if (a.Tick > b.Tick) return true;
            //if here ticks are the same.
            return a.PercentAsByte > b.PercentAsByte;
        }

        public static bool operator <(PreciseTick a, PreciseTick b) => (b > a);

        public bool Equals(PreciseTick other) => (Tick == other.Tick && PercentAsByte == other.PercentAsByte);

        public override bool Equals(object obj) => obj is PreciseTick other && Equals(other);

        public override int GetHashCode() => HashCode.Combine(Tick, PercentAsDouble, PercentAsByte);
    }

    public static class PreciseTickExtensions
    {
        /// <summary>
        /// Adds value onto a PreciseTick.
        /// </summary>
        /// <param name="value">Value to add.</param>
        /// <param name="delta">Tick delta.</param>
        /// <returns></returns>
        public static PreciseTick Add(this PreciseTick pt, PreciseTick value, double delta)
        {
            double ptDouble = pt.AsDouble(delta);
            double valueDouble = value.AsDouble(delta);

            double next = (ptDouble + valueDouble);

            return next.AsPreciseTick(delta);
        }

        /// <summary>
        /// Subtracts value from a PreciseTick.
        /// </summary>
        /// <param name="value">Value to subtract.</param>
        /// <param name="delta">Tick delta.</param>
        /// <returns></returns>
        public static PreciseTick Subtract(this PreciseTick pt, PreciseTick value, double delta)
        {
            double ptDouble = pt.AsDouble(delta);
            double valueDouble = value.AsDouble(delta);

            double remainder = (ptDouble - valueDouble);

            return remainder.AsPreciseTick(delta);
        }

        /// <summary>
        /// Converts a PreciceTick to a double.
        /// </summary>
        /// <param name="delta">Tick delta.</param>
        /// <returns></returns>
        public static double AsDouble(this PreciseTick pt, double delta)
        {
            return ((double)pt.Tick * delta) + (pt.PercentAsDouble * delta);
        }

        /// <summary>
        /// Converts a double to a PreciseTick.
        /// </summary>
        /// <param name="delta">Tick delta.</param>
        /// <returns></returns>
        public static PreciseTick AsPreciseTick(this double ptDouble, double delta)
        {
            if (ptDouble <= 0)
                return new(0, 0);
            
            ulong whole = (ulong)Math.Floor(ptDouble / delta);
            //Overflow.
            if (whole >= uint.MaxValue)
                return PreciseTick.GetUnsetValue();
            
            double remainder = (ptDouble % delta);

            double percent = (remainder / delta);
            return new((uint)whole, percent);
        }
    }

    public static class PreciseTickSerializer
    {
        public static void WritePreciseTick(this Writer writer, PreciseTick value)
        {
            writer.WriteTickUnpacked(value.Tick);
            writer.WriteUInt8Unpacked(value.PercentAsByte);
        }

        public static PreciseTick ReadPreciseTick(this Reader reader)
        {
            uint tick = reader.ReadTickUnpacked();
            byte percentByte = reader.ReadUInt8Unpacked();
            return new(tick, percentByte);
        }
    }
}﻿namespace FishNet.Managing.Timing
{
    /// <summary>
    /// How ticks are rounded when using time.
    /// </summary>
    public enum TickRounding
    {
        /// <summary>
        /// Rounds up.
        /// </summary>
        RoundUp,
        /// <summary>
        /// Rounds down.
        /// </summary>
        RoundDown,
        /// <summary>
        /// Rounds to the nearest whole.
        /// </summary>
        RoundNearest
    }


}﻿namespace FishNet.Managing.Timing
{
    public enum TickType : byte
    {
        Tick = 0,
        LocalTick = 1,
        LastPacketTick = 2
    }

}﻿using FishNet.Connection;
using FishNet.Serializing;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;
using SystemStopwatch = System.Diagnostics.Stopwatch;

namespace FishNet.Managing.Timing
{
    /// <summary>
    /// Provides data and actions for network time and tick based systems.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/TimeManager")]
    public sealed partial class TimeManager : MonoBehaviour
    {
        #region Types.
        /// <summary>
        /// How networking timing is performed.
        /// </summary>
        private enum TimingType
        {
            /// <summary>
            /// Send and read data on tick.
            /// </summary>
            Tick = 0,
            /// <summary>
            /// Send and read data as soon as possible. This does not include built-in components, which will still run on tick.
            /// </summary>
            Variable = 1
        }

        /// <summary>
        /// When OnUpdate is performed.
        /// </summary>
        private enum UpdateOrder : byte
        {
            BeforeTick = 0,
            AfterTick = 1,
        }
        #endregion

        #region Public.
        /// <summary>
        /// NetworkManager used with this.
        /// </summary>
        public NetworkManager NetworkManager { get; private set; }

        /// <summary>
        /// Called when the local clients ping is updated.
        /// </summary>
        public event Action<long> OnRoundTripTimeUpdated;

        /// <summary>
        /// Called right before a tick occurs, as well before data is read.
        /// </summary>
        public event Action OnPreTick;

        /// <summary>
        /// Called when a tick occurs.
        /// </summary>
        public event Action OnTick;

        /// <summary>
        /// When using TimeManager for physics timing, this is called immediately before physics simulation will occur for the tick.
        /// While using Unity for physics timing, this is called during FixedUpdate.
        /// This may be useful if you wish to run physics differently for stacked scenes.
        /// </summary>
        public event Action<float> OnPrePhysicsSimulation;

        /// <summary>
        /// When using TimeManager for physics timing, this is called immediately after the physics simulation has occured for the tick.
        /// While using Unity for physics timing, this is called during Update, only if a physics frame.
        /// This may be useful if you wish to run physics differently for stacked scenes.
        /// </summary>
        public event Action<float> OnPostPhysicsSimulation;

        /// <summary>
        /// Called after a tick occurs; physics would have simulated if using PhysicsMode.TimeManager.
        /// </summary>
        public event Action OnPostTick;

        /// <summary>
        /// Called when MonoBehaviours call Update.
        /// </summary>
        public event Action OnUpdate;

        /// <summary>
        /// Called when MonoBehaviours call LateUpdate.
        /// </summary>
        public event Action OnLateUpdate;

        /// <summary>
        /// Called when MonoBehaviours call FixedUpdate.
        /// </summary>
        public event Action OnFixedUpdate;

        /// <summary>
        /// How many ticks must pass to update timing.
        /// </summary>
        internal uint TimingTickInterval => _tickRate;

        /// <summary>
        /// RoundTripTime in milliseconds. This value includes latency from the tick rate.
        /// </summary>
        public long RoundTripTime { get; private set; }
        /// <summary>
        /// Returns half value of RoundTripTime rounded to nearest whole.
        /// </summary>
        public long HalfRoundTripTime => (long)Math.Round((double)RoundTripTime / 2d);

        /// <summary>
        /// True if the number of frames per second are less than the number of expected ticks per second.
        /// </summary>
        internal bool LowFrameRate => ((Time.unscaledTime - _lastMultipleTicksTime) < 1f);

        /// <summary>
        /// Tick on the last received packet, be it from server or client.
        /// </summary>
        public EstimatedTick LastPacketTick { get; internal set; } = new();

        /// <summary>
        /// Current approximate network tick as it is on server.
        /// When running as client only this is an approximation to what the server tick is.
        /// The value of this field may increase and decrease as timing adjusts.
        /// This value is reset upon disconnecting.
        /// Tick can be used to get the server time by using TicksToTime().
        /// Use LocalTick for values that only increase.
        /// </summary>
        public uint Tick { get; internal set; }

        /// <summary>
        /// A fixed deltaTime for TickRate.
        /// </summary>
        [HideInInspector]
        public double TickDelta { get; private set; }

        /// <summary>
        /// True if the TimeManager will or has ticked this frame.
        /// </summary>
        public bool FrameTicked { get; private set; }

        /// <summary>
        /// How long the local server has been connected.
        /// </summary>
        public float ServerUptime { get; private set; }

        /// <summary>
        /// How long the local client has been connected.
        /// </summary>
        public float ClientUptime { get; private set; }
        #endregion

        #region Serialized.
        /// <summary>
        /// When to invoke OnUpdate and other Unity callbacks relayed by the TimeManager.
        /// </summary>
        [Tooltip("When to invoke OnUpdate and other Unity callbacks relayed by the TimeManager.")]
        [SerializeField]
        private UpdateOrder _updateOrder = UpdateOrder.BeforeTick;
        /// <summary>
        /// Timing for sending and receiving data.
        /// </summary>
        [Tooltip("Timing for sending and receiving data.")]
        [SerializeField]
        private TimingType _timingType = TimingType.Tick;
        /// <summary>
        /// While true clients may drop local ticks if their devices are unable to maintain the tick rate.
        /// This could result in a temporary desynchronization but will prevent the client falling further behind on ticks by repeatedly running the logic cycle multiple times per frame.
        /// </summary>
        [Tooltip("While true clients may drop local ticks if their devices are unable to maintain the tick rate. This could result in a temporary desynchronization but will prevent the client falling further behind on ticks by repeatedly running the logic cycle multiple times per frame.")]
        [SerializeField]
        private bool _allowTickDropping = true;
        /// <summary>
        /// Maximum number of ticks which may occur in a single frame before remainder are dropped for the frame.
        /// </summary>
        [Tooltip("Maximum number of ticks which may occur in a single frame before remainder are dropped for the frame.")]
        [Range(1, 25)]
        [SerializeField]
        private byte _maximumFrameTicks = 3;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("How many times per second the server will simulate. This does not limit server frame rate.")]
        [Range(1, 240)]
        [SerializeField]
        private ushort _tickRate = 30;

        /// <summary>
        /// How many times per second the server will simulate. This does not limit server frame rate.
        /// </summary>
        public ushort TickRate
        {
            get => _tickRate;
            private set => _tickRate = value;
        }

        /// <summary>
        /// 
        /// </summary>        
        [Tooltip("How often in seconds to a connections ping. This is also responsible for approximating server tick. This value does not affect prediction.")]
        [Range(1, 15)]
        [SerializeField]
        private byte _pingInterval = 1;

        /// <summary>
        /// How often in seconds to a connections ping. This is also responsible for approximating server tick. This value does not affect prediction.
        /// </summary>
        public byte PingInterval => _pingInterval;

        /// <summary>
        /// 
        /// </summary>
        [Tooltip("How to perform physics.")]
        [SerializeField]
        private PhysicsMode _physicsMode = PhysicsMode.Unity;

        /// <summary>
        /// How to perform physics.
        /// </summary>
        public PhysicsMode PhysicsMode => _physicsMode;
        #endregion

        #region Private.
        /// <summary>
        /// 
        /// </summary>
        private uint _localTick;

        /// <summary>
        /// A tick that is not synchronized. This value will only increment. May be used for indexing or Ids with custom logic.
        /// When called on the server Tick is returned, otherwise LocalTick is returned.
        /// This value resets upon disconnecting.
        /// </summary>
        public uint LocalTick
        {
            get => (NetworkManager.IsServerStarted) ? Tick : _localTick;
            private set => _localTick = value;
        }

        /// <summary>
        /// Stopwatch used for pings.
        /// </summary>
        private SystemStopwatch _pingStopwatch = new();
        /// <summary>
        /// Ticks passed since last ping.
        /// </summary>
        private uint _pingTicks;
        /// <summary>
        /// MovingAverage instance used to calculate mean ping.
        /// </summary>
        private MovingAverage _pingAverage = new(5);
        /// <summary>
        /// Accumulating frame time to determine when to increase tick.
        /// </summary>
        private double _elapsedTickTime;
        /// <summary>
        /// Internal deltaTime for clients. Controlled by the server.
        /// </summary>
        private double _adjustedTickDelta;
        /// <summary>
        /// Last frame an iteration occurred for incoming.
        /// </summary>
        private int _lastIncomingIterationFrame = -1;
        /// <summary>
        /// True if client received Pong since last ping.
        /// </summary>
        private bool _receivedPong = true;
        /// <summary>
        /// Last unscaledTime multiple ticks occurred in a single frame.
        /// </summary>
        private float _lastMultipleTicksTime;
        /// <summary>
        /// Number of TimeManagers open which are using manual physics.
        /// </summary>
        private static uint _manualPhysics;
        /// <summary>
        /// True if FixedUpdate called this frame and using Unity physics mode.
        /// </summary>
        private bool _fixedUpdateTimeStep;
        /// <summary>
        /// 
        /// </summary>
        private float _physicsTimeScale = 1f;

        /// <summary>
        /// Gets the current physics time scale.
        /// </summary>
        /// <returns></returns>
        public float GetPhysicsTimeScale() => _physicsTimeScale;

        /// <summary>
        /// Sets the physics time scale.
        /// This is not automatically synchronized.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetPhysicsTimeScale(float value)
        {
            value = Mathf.Clamp(value, 0f, float.PositiveInfinity);
            _physicsTimeScale = value;
        }
        #endregion

        #region Const.
        /// <summary>
        /// Value for a tick that is invalid.
        /// </summary>
        public const uint UNSET_TICK = 0;
        /// <summary>
        /// Playerprefs string to load and save user fixed time.
        /// </summary>
        private const string SAVED_FIXED_TIME_TEXT = "SavedFixedTimeFN";
        #endregion

#if UNITY_EDITOR
        private void OnDisable()
        {
            //If closing/stopping.
            if (ApplicationState.IsQuitting())
            {
                _manualPhysics = 0;
                UnsetSimulationSettings();
            }
            else if (PhysicsMode == PhysicsMode.TimeManager)
            {
                _manualPhysics = Math.Max(0, _manualPhysics - 1);
            }
        }
#endif

        /// <summary>
        /// Called when FixedUpdate ticks. This is called before any other script.
        /// </summary>
        internal void TickFixedUpdate()
        {
            OnFixedUpdate?.Invoke();
            /* Invoke onsimulation if using Unity time.
             * Otherwise let the tick cycling part invoke. */
            if (PhysicsMode == PhysicsMode.Unity)
            {
                /* If fixedUpdateTimeStep then that means
                 * FixedUpdate already called for this frame, which
                 * means a post physics should also be called.
                 * This can only happen if a FixedUpdate occurs
                 * multiple times per frame. */
                if (_fixedUpdateTimeStep)
                    OnPostPhysicsSimulation?.Invoke(Time.fixedDeltaTime);

                _fixedUpdateTimeStep = true;
                OnPrePhysicsSimulation?.Invoke(Time.fixedDeltaTime);
            }
        }

        /// <summary>
        /// Called when Update ticks. This is called before any other script.
        /// </summary>
        internal void TickUpdate()
        {
            if (NetworkManager.IsServerStarted)
                ServerUptime += Time.deltaTime;
            if (NetworkManager.IsClientStarted)
                ClientUptime += Time.deltaTime;

            bool beforeTick = (_updateOrder == UpdateOrder.BeforeTick);
            if (beforeTick)
            {
                OnUpdate?.Invoke();
                MethodLogic();
            }
            else
            {
                MethodLogic();
                OnUpdate?.Invoke();
            }

            void MethodLogic()
            {
                IncreaseTick();
                /* Invoke onsimulation if using Unity time.
                 * Otherwise let the tick cycling part invoke. */
                if (PhysicsMode == PhysicsMode.Unity && _fixedUpdateTimeStep)
                {
                    _fixedUpdateTimeStep = false;
                    OnPostPhysicsSimulation?.Invoke(Time.fixedDeltaTime);
                }
            }
        }

        /// <summary>
        /// Called when LateUpdate ticks. This is called after all other scripts.
        /// </summary>
        internal void TickLateUpdate()
        {
            OnLateUpdate?.Invoke();
        }


        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        internal void InitializeOnce_Internal(NetworkManager networkManager)
        {
            NetworkManager = networkManager;
            LastPacketTick.Initialize(networkManager.TimeManager);
            SetInitialValues();
            networkManager.ServerManager.OnServerConnectionState += ServerManager_OnServerConnectionState;
            networkManager.ClientManager.OnClientConnectionState += ClientManager_OnClientConnectionState;

            AddNetworkLoops();
        }

        /// <summary>
        /// Adds network loops to gameObject.
        /// </summary>
        private void AddNetworkLoops()
        {
            //Writer.
            if (!gameObject.TryGetComponent<NetworkWriterLoop>(out _))
                gameObject.AddComponent<NetworkWriterLoop>();
            //Reader.
            if (!gameObject.TryGetComponent<NetworkReaderLoop>(out _))
                gameObject.AddComponent<NetworkReaderLoop>();
        }


        /// <summary>
        /// Called after the local client connection state changes.
        /// </summary>
        private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs obj)
        {
            if (obj.ConnectionState != LocalConnectionState.Started)
            {
                if (!NetworkManager.IsServerStarted)
                    LastPacketTick.ResetTicks();
                _pingStopwatch.Stop();
                ClientUptime = 0f;

                //Only reset ticks if also not server.
                if (!NetworkManager.IsServerStarted)
                {
                    LocalTick = 0;
                    Tick = 0;
                    SetTickRate(TickRate);
                }
            }
            //Started.
            else
            {
                _pingStopwatch.Restart();
            }
        }

        /// <summary>
        /// Called after the local server connection state changes.
        /// </summary>
        private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs obj)
        {
            //If no servers are running.
            if (!NetworkManager.ServerManager.IsAnyServerStarted())
            {
                LastPacketTick.ResetTicks();
                ServerUptime = 0f;
                Tick = 0;
            }
        }


        /// <summary>
        /// Sets values to use based on settings.
        /// </summary>
        private void SetInitialValues()
        {
            SetTickRate(TickRate);
            InitializePhysicsMode(PhysicsMode);
        }

        /// <summary>
        /// Sets simulation settings to Unity defaults.
        /// </summary>
        private void UnsetSimulationSettings()
        {
            SetAutomaticPhysicsSimulation(true);

            float simulationTime = PlayerPrefs.GetFloat(SAVED_FIXED_TIME_TEXT, float.MinValue);
            if (simulationTime != float.MinValue)
                Time.fixedDeltaTime = simulationTime;
        }

        /// <summary>
        /// Sets automatic physics simulation mode.
        /// </summary>
        /// <param name="automatic"></param>
        private void SetAutomaticPhysicsSimulation(bool automatic)
        {
#if UNITY_2022_1_OR_NEWER
            if (automatic)
            {
                Physics.simulationMode = SimulationMode.FixedUpdate;
                Physics2D.simulationMode = SimulationMode2D.FixedUpdate;
            }
            else
            {
                Physics.simulationMode = SimulationMode.Script;
                Physics2D.simulationMode = SimulationMode2D.Script;
            }
#else
            Physics.autoSimulation = automatic;
            if (automatic)
                Physics2D.simulationMode = SimulationMode2D.FixedUpdate;
            else
                Physics2D.simulationMode = SimulationMode2D.Script;
#endif
        }

        /// <summary>
        /// Initializes physics mode when starting.
        /// </summary>
        /// <param name="automatic"></param>
        private void InitializePhysicsMode(PhysicsMode mode)
        {
            //Disable.
            if (mode == PhysicsMode.Disabled)
            {
                SetPhysicsMode(mode);
            }
            //Do not automatically simulate.
            else if (mode == PhysicsMode.TimeManager)
            {
#if UNITY_EDITOR
                //Preserve user tick rate.
                PlayerPrefs.SetFloat(SAVED_FIXED_TIME_TEXT, Time.fixedDeltaTime);
                //Let the player know.
                //if (Time.fixedDeltaTime != (float)TickDelta)
                //    Debug.LogWarning("Time.fixedDeltaTime is being overriden with TimeManager.TickDelta");
#endif
                Time.fixedDeltaTime = (float)TickDelta;
                /* Only check this if network manager
                 * is not null. It would be null via
                 * OnValidate. */
                if (NetworkManager != null)
                {
                    //If at least one time manager is already running manual physics.
                    if (_manualPhysics > 0)
                        NetworkManager.LogError($"There are multiple TimeManagers instantiated which are using manual physics. Manual physics with multiple TimeManagers is not supported.");

                    _manualPhysics++;
                }

                SetPhysicsMode(mode);
            }
            //Automatically simulate.
            else
            {
#if UNITY_EDITOR
                float savedTime = PlayerPrefs.GetFloat(SAVED_FIXED_TIME_TEXT, float.MinValue);
                if (savedTime != float.MinValue && Time.fixedDeltaTime != savedTime)
                {
                    Debug.LogWarning("Time.fixedDeltaTime has been set back to user values.");
                    Time.fixedDeltaTime = savedTime;
                }

                PlayerPrefs.DeleteKey(SAVED_FIXED_TIME_TEXT);
#endif
                SetPhysicsMode(mode);
            }
        }

        /// <summary>
        /// Updates physics based on which physics mode to use.
        /// </summary>
        /// <param name="enabled"></param>
        public void SetPhysicsMode(PhysicsMode mode)
        {
            _physicsMode = mode;

            //Disable.
            if (mode == PhysicsMode.Disabled || mode == PhysicsMode.TimeManager)
                SetAutomaticPhysicsSimulation(false);
            //Automatically simulate.
            else
                SetAutomaticPhysicsSimulation(true);
        }

        #region PingPong.
        /// <summary>
        /// Modifies client ping based on LocalTick and clientTIck.
        /// </summary>
        /// <param name="clientTick"></param>
        internal void ModifyPing(uint clientTick)
        {
            uint tickDifference = (LocalTick - clientTick);
            _pingAverage.ComputeAverage(tickDifference);
            double averageInTime = (_pingAverage.Average * TickDelta * 1000);
            RoundTripTime = (long)Math.Round(averageInTime);
            _receivedPong = true;

            OnRoundTripTimeUpdated?.Invoke(RoundTripTime);
        }

        /// <summary>
        /// Sends a ping to the server.
        /// </summary>
        private void TrySendPing(uint? tickOverride = null)
        {
            byte pingInterval = PingInterval;

            /* How often client may send ping is based on if
             * the server responded to the last ping.
             * A response may not be received if the server
             * believes the client is pinging too fast, or if the
             * client is having difficulties reaching the server. */
            long requiredTime = (pingInterval * 1000);
            float multiplier = (_receivedPong) ? 1f : 1.5f;

            requiredTime = (long)(requiredTime * multiplier);
            uint requiredTicks = TimeToTicks(pingInterval * multiplier);

            _pingTicks++;
            /* We cannot just consider time because ticks might run slower
             * from adjustments. We also cannot only consider ticks because
             * they might run faster from adjustments. Therefor require both
             * to have pass checks. */
            if (_pingTicks < requiredTicks || _pingStopwatch.ElapsedMilliseconds < requiredTime)
                return;

            _pingTicks = 0;
            _pingStopwatch.Restart();
            //Unset receivedPong, wait for new response.
            _receivedPong = false;

            uint tick = (tickOverride == null) ? LocalTick : tickOverride.Value;
            PooledWriter writer = WriterPool.Retrieve();
            writer.WritePacketIdUnpacked(PacketId.PingPong);
            writer.WriteTickUnpacked(tick);
            NetworkManager.TransportManager.SendToServer((byte)Channel.Unreliable, writer.GetArraySegment());
            writer.Store();
        }

        /// <summary>
        /// Sends a pong to a client.
        /// </summary>
        internal void SendPong(NetworkConnection conn, uint clientTick)
        {
            if (!conn.IsActive || !conn.IsAuthenticated)
                return;

            PooledWriter writer = WriterPool.Retrieve();
            writer.WritePacketIdUnpacked(PacketId.PingPong);
            writer.WriteTickUnpacked(clientTick);
            conn.SendToClient((byte)Channel.Unreliable, writer.GetArraySegment());
            writer.Store();
        }
        #endregion

        /// <summary>
        /// Increases the tick based on simulation rate.
        /// </summary>
        private void IncreaseTick()
        {
            bool isClient = NetworkManager.IsClientStarted;
            bool isServer = NetworkManager.IsServerStarted;

            double timePerSimulation = (isServer) ? TickDelta : _adjustedTickDelta;
            if (timePerSimulation == 0d)
            {
                NetworkManagerExtensions.LogWarning($"Simulation delta cannot be 0. Network timing will not continue.");
                return;
            }

            double time = Time.unscaledDeltaTime;

            _elapsedTickTime += time;
            FrameTicked = (_elapsedTickTime >= timePerSimulation);

            //Number of ticks to occur this frame.
            int ticksCount = Mathf.FloorToInt((float)(_elapsedTickTime / timePerSimulation));
            if (ticksCount > 1)
                _lastMultipleTicksTime = Time.unscaledDeltaTime;

            if (_allowTickDropping)
            {
                //If ticks require dropping. Set exactly to maximum ticks.
                if (ticksCount > _maximumFrameTicks)
                    _elapsedTickTime = (timePerSimulation * (double)_maximumFrameTicks);
            }

            bool variableTiming = (_timingType == TimingType.Variable);
            bool frameTicked = FrameTicked;
            float tickDelta = ((float)TickDelta * GetPhysicsTimeScale());

            do
            {
                if (frameTicked)
                    OnPreTick?.Invoke();

                /* This has to be called inside the loop because
                 * OnPreTick promises data hasn't been read yet.
                 * Therefor iterate must occur after OnPreTick.
                 * Iteration will only run once per frame. */
                if (frameTicked || variableTiming)
                    TryIterateData(true);

                if (frameTicked)
                {
                    //Tell predicted objecs to reconcile before OnTick.
                    NetworkManager.PredictionManager.ReconcileToStates();
                    OnTick?.Invoke();

                    if (PhysicsMode == PhysicsMode.TimeManager && tickDelta > 0f)
                    {
                        OnPrePhysicsSimulation?.Invoke(tickDelta);
                        Physics.Simulate(tickDelta);
                        Physics2D.Simulate(tickDelta);
                        OnPostPhysicsSimulation?.Invoke(tickDelta);
                    }

                    OnPostTick?.Invoke();
                    //After post tick send states.
                    NetworkManager.PredictionManager.SendStateUpdate();

                    /* If isClient this is the
                     * last tick during this loop. */
                    bool lastTick = (_elapsedTickTime < (timePerSimulation * 2d));
                    if (isClient && lastTick)
                        TrySendPing(LocalTick + 1);
                    if (NetworkManager.IsServerStarted)
                        SendTimingAdjustment();
                }

                //Send out data.
                if (frameTicked || variableTiming)
                    TryIterateData(false);

                if (frameTicked)
                {
                    _elapsedTickTime -= timePerSimulation;
                    Tick++;
                    LocalTick++;
                }
            } while (_elapsedTickTime >= timePerSimulation);
        }


        #region Tick conversions.
        /// <summary>
        /// Returns the percentage of how far the TimeManager is into the next tick as a double.
        /// Value will return between 0d and 1d.
        /// </summary>
        /// <returns></returns>
        public double GetTickPercentAsDouble()
        {
            if (NetworkManager == null)
                return 0d;

            double percent = (_elapsedTickTime / TickDelta);
            return percent;
        }

        /// <summary>
        /// Returns the current elapsed amount for the next tick.
        /// </summary>
        /// <returns></returns>
        public double GetTickElapsedAsDouble() => _elapsedTickTime;

        /// <summary>
        /// Returns the percentage of how far the TimeManager is into the next tick.
        /// Value will return between 0 and 100.
        /// </summary>
        public byte GetTickPercentAsByte()
        {
            double result = GetTickPercentAsDouble();
            return (byte)(result * 100d);
        }

        /// <summary>
        /// Converts a 0 to 100 byte value to a 0d to 1d percent value.
        /// This does not check for excessive byte values, such as anything over 100.
        /// </summary>
        public static double GetTickPercentAsDouble(byte value)
        {
            return (value / 100d);
        }

        /// <summary>
        /// Returns a PreciseTick.
        /// </summary>
        /// <param name="tick">Tick to set within the returned PreciseTick.</param>
        /// <returns></returns>
        public PreciseTick GetPreciseTick(uint tick)
        {
            if (NetworkManager == null)
                return default;

            double delta = (NetworkManager.IsServerStarted) ? TickDelta : _adjustedTickDelta;
            double percent = (_elapsedTickTime / delta);

            return new(tick, percent);
        }

        /// <summary>
        /// Returns a PreciseTick.
        /// </summary>
        /// <param name="tickType">Tick to use within PreciseTick.</param>
        /// <returns></returns>
        public PreciseTick GetPreciseTick(TickType tickType)
        {
            if (NetworkManager == null)
                return default;

            if (tickType == TickType.Tick)
            {
                return GetPreciseTick(Tick);
            }
            else if (tickType == TickType.LocalTick)
            {
                return GetPreciseTick(LocalTick);
            }
            else if (tickType == TickType.LastPacketTick)
            {
                return GetPreciseTick(LastPacketTick.LastRemoteTick);
            }
            else
            {
                NetworkManager.LogError($"TickType {tickType.ToString()} is unhandled.");
                return default;
            }
        }


        /// <summary>
        /// Converts current ticks to time.
        /// </summary>
        /// <param name="tickType">TickType to compare against.</param>
        /// <returns></returns>
        
        public double TicksToTime(TickType tickType = TickType.LocalTick)
        {
            if (tickType == TickType.LocalTick)
            {
                return TicksToTime(LocalTick);
            }
            else if (tickType == TickType.Tick)
            {
                return TicksToTime(Tick);
            }
            else if (tickType == TickType.LastPacketTick)
            {
                return TicksToTime(LastPacketTick.LastRemoteTick);
            }
            else
            {
                NetworkManager.LogError($"TickType {tickType} is unhandled.");
                return 0d;
            }
        }

        /// <summary>
        /// Converts a PreciseTick to time.
        /// </summary>
        /// <param name="pt">PreciseTick to convert.</param>
        /// <returns></returns>
        
        public double TicksToTime(PreciseTick pt)
        {
            double tickTime = TicksToTime(pt.Tick);
            double percentTime = (pt.PercentAsDouble * TickDelta);
            return (tickTime + percentTime);
        }

        /// <summary>
        /// Converts a number ticks to time.
        /// </summary>
        /// <param name="ticks">Ticks to convert.</param>
        /// <returns></returns>
        public double TicksToTime(uint ticks)
        {
            return (TickDelta * (double)ticks);
        }

        /// <summary>
        /// Gets time passed from currentTick to previousTick.
        /// </summary>
        /// <param name="currentTick">The current tick.</param>
        /// <param name="previousTick">The previous tick.</param>
        /// <returns></returns>
        
        public double TimePassed(uint currentTick, uint previousTick)
        {
            double multiplier;
            double result;
            if (currentTick >= previousTick)
            {
                multiplier = 1f;
                result = TicksToTime(currentTick - previousTick);
            }
            else
            {
                multiplier = -1f;
                result = TicksToTime(previousTick - currentTick);
            }

            return (result * multiplier);
        }

        /// <summary>
        /// Gets time passed from Tick to preciseTick.
        /// </summary>
        /// <param name="preciseTick">PreciseTick value to compare against.</param>
        /// <param name="allowNegative">True to allow negative values. When false and value would be negative 0 is returned.</param>
        /// <returns></returns>
        
        public double TimePassed(PreciseTick preciseTick, bool allowNegative = false)
        {
            PreciseTick currentPt = GetPreciseTick(TickType.Tick);
            
            long tickDifference = ((long)currentPt.Tick - (long)preciseTick.Tick);
            double percentDifference = (currentPt.PercentAsDouble - preciseTick.PercentAsDouble);

            /* If tickDifference is less than 0 or tickDifference and percentDifference are 0 or less
             * then the result would be negative. */
            bool negativeValue = (tickDifference < 0 || (tickDifference <= 0 && percentDifference <= 0));

            if (!allowNegative && negativeValue)
                return 0d;

            double tickTime = TimePassed(preciseTick.Tick, true);
            double percentTime = (percentDifference * TickDelta);

            return (tickTime + percentTime);
        }

        /// <summary>
        /// Gets time passed from Tick to previousTick.
        /// </summary>
        /// <param name="previousTick">The previous tick.</param>
        /// <param name="allowNegative">True to allow negative values. When false and value would be negative 0 is returned.</param>
        /// <returns></returns>
        
        public double TimePassed(uint previousTick, bool allowNegative = false)
        {
            uint currentTick = Tick;
            //Difference will be positive.
            if (currentTick >= previousTick)
            {
                return TicksToTime(currentTick - previousTick);
            }
            //Difference would be negative.
            else
            {
                if (!allowNegative)
                {
                    return 0d;
                }
                else
                {
                    double difference = TicksToTime(previousTick - currentTick);
                    return (difference * -1d);
                }
            }
        }

        /// <summary>
        /// Converts time to ticks.
        /// </summary>
        /// <param name="time">Time to convert as decimal.</param>
        /// <returns></returns>
        
        public uint TimeToTicks(double time, TickRounding rounding = TickRounding.RoundNearest)
        {
            double result = (time / TickDelta);

            if (rounding == TickRounding.RoundNearest)
                return (uint)Math.Round(result);
            else if (rounding == TickRounding.RoundDown)
                return (uint)Math.Floor(result);
            else
                return (uint)Math.Ceiling(result);
        }

        /// <summary>
        /// Converts time to ticks.
        /// </summary>
        /// <param name="time">Time to convert as whole (milliseconds)</param>
        /// <returns></returns>
        
        public uint TimeToTicks(long time, TickRounding rounding = TickRounding.RoundNearest)
        {
            double dTime = ((double)time / 1000d);
            return TimeToTicks(dTime, rounding);
        }

        
        /// <summary>
        /// Converts time to a PreciseTick.
        /// </summary>
        /// <param name="time">Time to convert.</param>
        /// <returns></returns>
        public PreciseTick TimeToPreciseTick(double time) => time.AsPreciseTick(TickDelta);
        
        /// <summary>
        /// Estimatedly converts a synchronized tick to what it would be for the local tick.
        /// </summary>
        /// <param name="tick">Synchronized tick to convert.</param>
        /// <returns></returns>
        public uint TickToLocalTick(uint tick)
        {
            //Server will always have local and tick aligned.
            if (NetworkManager.IsServerStarted)
                return tick;

            long difference = (Tick - tick);

            long result = (LocalTick - difference);
            if (result <= 0)
                result = 0;

            return (uint)result;
        }

        /// <summary>
        /// Estimatedly converts a local tick to what it would be for the synchronized tick.
        /// </summary>
        /// <param name="localTick">Local tick to convert.</param>
        /// <returns></returns>
        public uint LocalTickToTick(uint localTick)
        {
            //Server will always have local and tick aligned.
            if (NetworkManager.IsServerStarted)
                return localTick;

            long difference = (LocalTick - localTick);

            long result = (Tick - difference);
            if (result <= 0)
                result = 0;

            return (uint)result;
        }
        #endregion


        /// <summary>
        /// Tries to iterate incoming or outgoing data.
        /// </summary>
        /// <param name="incoming">True to iterate incoming.</param>
        private void TryIterateData(bool incoming)
        {
            if (incoming)
            {
                /* It's not possible for data to come in
                 * more than once per frame but there could
                 * be new data going out each tick, since
                 * movement is often based off the tick system.
                 * Because of this don't iterate incoming if
                 * it's the same frame, but the outgoing
                 * may iterate multiple times per frame due to
                 * there possibly being multiple ticks per frame. */
                int frameCount = Time.frameCount;
                if (frameCount == _lastIncomingIterationFrame)
                    return;
                _lastIncomingIterationFrame = frameCount;

                NetworkManager.TransportManager.IterateIncoming(asServer: true);
                NetworkManager.TransportManager.IterateIncoming(asServer: false);
            }
            else
            {
                NetworkManager.TransportManager.IterateOutgoing(asServer: true);
                NetworkManager.TransportManager.IterateOutgoing(asServer: false);
            }
        }


        #region Timing adjusting.
        /// <summary>
        /// Changes the adjustedTickDelta, increasing or decreasing it.
        /// </summary>
        /// <param name="additionalMultiplier">Amount to multiply expected change by. This can be used to make larger or smaller changes.</param>
        internal void ChangeAdjustedTickDelta(bool speedUp, double additionalMultiplier = 1d)
        {
            double share = (TickDelta * 0.01d) * additionalMultiplier;
            if (speedUp)
                _adjustedTickDelta -= share;
            else
                _adjustedTickDelta += share;
        }

        /// <summary>
        /// Sends a TimingUpdate packet to clients.
        /// </summary>
        private void SendTimingAdjustment()
        {
            //Send every second.
            if (LocalTick % TimingTickInterval == 0)
            {
                //Now send using a packetId.
                PooledWriter writer = WriterPool.Retrieve();
                foreach (NetworkConnection item in NetworkManager.ServerManager.Clients.Values)
                {
                    if (!item.IsAuthenticated)
                        continue;

                    writer.WritePacketIdUnpacked(PacketId.TimingUpdate);
                    writer.WriteTickUnpacked(item.PacketTick.Value());
                    item.SendToClient((byte)Channel.Unreliable, writer.GetArraySegment());
                    writer.Clear();
                }

                writer.Store();
            }
        }

        /// <summary>
        /// Called on client when server sends a timing update.
        /// </summary>
        /// <param name="ta"></param>
        internal void ParseTimingUpdate(Reader reader)
        {
            uint clientTick = reader.ReadTickUnpacked();
            //Don't adjust timing on server.
            if (NetworkManager.IsServerStarted)
                return;
            /* This should never be possible since the server is sending a tick back
             * that the client previously sent. In other words, the value returned should
             * always be in the past. */
            if (LocalTick < clientTick)
                return;

            /* Use the last ordered remote tick rather than
             * lastPacketTick. This will help with out of order
             * packets where the timing update sent before
             * the remote tick but arrived after. By using ordered
             * remote tick we are comparing against however many
             * ticks really passed rather than the difference
             * between the out of order/late packet. */
            uint lastPacketTick = LastPacketTick.RemoteTick;
            //Set Tick based on difference between localTick and clientTick, added onto lastPacketTick.
            uint prevTick = Tick;
            //Added ticks for delay in reading packet.
            const uint socketReadDelay = 1;
            uint nextTick = ((LocalTick - clientTick) / 2) + lastPacketTick + socketReadDelay;
            long difference = ((long)nextTick - (long)prevTick);
            Tick = nextTick;

            //Maximum difference allowed before resetting values.
            const int maximumDifference = 4;
            //Difference is extreme, reset to default timings. Client probably had an issue.
            if (Mathf.Abs(difference) > maximumDifference)
            {
                _adjustedTickDelta = TickDelta;
            }
            //Otherwise adjust the delta marginally.
            else if (difference != 0)
            {
                /* A negative tickDifference indicates the client is
                 * moving too fast, while positive indicates too slow. */
                bool speedUp = (difference > 0);
                ChangeAdjustedTickDelta(speedUp);
            }
        }
        #endregion

        /// <summary>
        /// Sets the TickRate to use. This value is not synchronized, it must be set on client and server independently.
        /// </summary>
        /// <param name="value">New TickRate to use.</param>
        public void SetTickRate(ushort value)
        {
            TickRate = value;
            TickDelta = (1d / TickRate);
            _adjustedTickDelta = TickDelta;
        }

        #region UNITY_EDITOR
        private void OnValidate()
        {
            SetInitialValues();
        }
        #endregion
    }
}﻿#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace FishNet.Managing.Timing.Editing
{


    [CustomEditor(typeof(TimeManager), true)]
    [CanEditMultipleObjects]
    public class TimeManagerEditor : Editor
    {
        private SerializedProperty _updateOrder;
        private SerializedProperty _timingType;
        private SerializedProperty _tickRate;
        private SerializedProperty _allowTickDropping;
        private SerializedProperty _maximumFrameTicks;
        private SerializedProperty _pingInterval;
        //private SerializedProperty _timingInterval;
        private SerializedProperty _physicsMode;        

        protected virtual void OnEnable()
        {
            _updateOrder = serializedObject.FindProperty("_updateOrder");
            _timingType = serializedObject.FindProperty("_timingType");
            _tickRate = serializedObject.FindProperty("_tickRate");
            _allowTickDropping = serializedObject.FindProperty("_allowTickDropping");
            _maximumFrameTicks = serializedObject.FindProperty("_maximumFrameTicks");
            _pingInterval = serializedObject.FindProperty("_pingInterval");
            //_timingInterval = serializedObject.FindProperty("_timingInterval");
            _physicsMode = serializedObject.FindProperty("_physicsMode");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour((TimeManager)target), typeof(TimeManager), false);
            GUI.enabled = true;

            //Timing.
            EditorGUILayout.LabelField("Timing", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_updateOrder);
            EditorGUILayout.PropertyField(_timingType);
            EditorGUILayout.PropertyField(_allowTickDropping);
            if (_allowTickDropping.boolValue == true)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_maximumFrameTicks);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.PropertyField(_tickRate);
            EditorGUILayout.PropertyField(_pingInterval);
            //EditorGUILayout.PropertyField(_timingInterval);            
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            //Physics.
            EditorGUILayout.LabelField("Physics", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            if (_physicsMode.intValue == (int)FishNet.Managing.Timing.PhysicsMode.TimeManager)
                EditorGUILayout.HelpBox($"Time.fixedDeltaTime will be overriden with TimeManager.TickDelta ({(1f / (float)_tickRate.intValue).ToString("0.###")})", MessageType.Info);
            else
                EditorGUILayout.HelpBox("If you are using physics interactions be sure to change the PhysicsMode to TimeManager and implement physics within the TimeManager tick events. NetworkTransform may also jitter when not using PhysicsMode.TimeManager.", MessageType.Warning);
            EditorGUILayout.PropertyField(_physicsMode);
            EditorGUI.indentLevel--;

            ////Prediction.
            //EditorGUILayout.LabelField("Prediction", EditorStyles.boldLabel);
            //EditorGUI.indentLevel++;
            //EditorGUILayout.PropertyField(_maximumBufferedInputs);
            //EditorGUI.indentLevel--;

            serializedObject.ApplyModifiedProperties();
        }
    }

}
#endif﻿
using System;
using UnityEngine;

namespace FishNet.Managing.Transporting
{

    /// <summary>
    /// When inherited from this may be used with the TransportManager to alter messages before they are sent and received.
    /// </summary>
    public abstract class IntermediateLayer : MonoBehaviour
    {
        /// <summary>
        /// TransportManager associated with this script.
        /// </summary>
        public TransportManager TransportManager { get; private set; }

        /// <summary>
        /// Called when data is received.
        /// </summary>
        /// <param name="src">Original data.</param>
        /// <param name="fromServer">True if receiving from the server, false if from a client.</param>
        /// <returns>Modified data.</returns>
        public abstract ArraySegment<byte> HandleIncoming(ArraySegment<byte> src, bool fromServer);
        /// <summary>
        /// Called when data is sent.
        /// </summary>
        /// <param name="src">Original data.</param>
        /// <param name="toServer">True if sending to the server, false if to a client.</param>
        /// <returns>Modified data.</returns>
        public abstract ArraySegment<byte> HandleOutgoing(ArraySegment<byte> src, bool toServer);

        /// <summary>
        /// Initializes this IntermediateLayer for use.
        /// </summary>
        public virtual void InitializeOnce(TransportManager manager) => TransportManager = manager;
    }

}﻿using FishNet.Connection;
using FishNet.Transporting;
using FishNet.Utility.Performance;
using System;
using System.Collections.Generic;
using UnityEngine;

//Thanks to TiToMoskito originally creating this as a Transport.
//https://github.com/TiToMoskito/FishyLatency
namespace FishNet.Managing.Transporting
{
    [System.Serializable]
    public class LatencySimulator
    {
        #region Types.
        /// <summary>
        /// A message affected by latency.
        /// </summary>
        private struct Message
        {
            public readonly int ConnectionId;
            public readonly byte[] Data;
            public readonly int Length;
            public readonly float SendTime;

            public Message(int connectionId, ArraySegment<byte> segment, float latency)
            {
                this.ConnectionId = connectionId;
                this.SendTime = (Time.unscaledTime + latency);
                this.Length = segment.Count;
                this.Data = ByteArrayPool.Retrieve(this.Length);
                Buffer.BlockCopy(segment.Array, segment.Offset, this.Data, 0, this.Length);
            }

            public ArraySegment<byte> GetSegment()
            {
                return new(Data, 0, Length);
            }
        }
        #endregion

        #region Internal.
        /// <summary>
        /// True if latency can be simulated.
        /// </summary>
        internal bool CanSimulate => (GetEnabled() && (GetLatency() > 0 || GetPacketLost() > 0 || GetOutOfOrder() > 0));
        #endregion

        #region Serialized
        [Header("Settings")]
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True if latency simulator is enabled.")]
        [SerializeField]
        private bool _enabled;
        /// <summary>
        /// Gets the enabled value of simulator.
        /// </summary>
        public bool GetEnabled() => _enabled;
        /// <summary>
        /// Sets the enabled value of simulator.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetEnabled(bool value)
        {
            if (value == _enabled)
                return;

            _enabled = value;
            Reset();
        }
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to add latency on clientHost as well.")]
        [SerializeField]
        private bool _simulateHost = true;
        /// <summary>
        /// Milliseconds to add between packets. When acting as host this value will be doubled. Added latency will be a minimum of tick rate.
        /// </summary>
        [Tooltip("Milliseconds to add between packets. When acting as host this value will be doubled. Added latency will be a minimum of tick rate.")]
        [Range(0, 60000)]
        [SerializeField]
        private long _latency = 0;
        /// <summary>
        /// Gets the latency value.
        /// </summary>
        /// <returns></returns>
        public long GetLatency() => _latency;
        /// <summary>
        /// Sets a new latency value.
        /// </summary>
        /// <param name="value">Latency as milliseconds.</param>
        public void SetLatency(long value) => _latency = value;

        [Header("Unreliable")]
        /// <summary>
        /// Percentage of unreliable packets which should arrive out of order.
        /// </summary>
        [Tooltip("Percentage of unreliable packets which should arrive out of order.")]
        [Range(0f, 1f)]
        [SerializeField]
        private double _outOfOrder = 0;
        /// <summary>
        /// Out of order chance, 1f is a 100% chance to occur.
        /// </summary>
        /// <returns></returns>
        public double GetOutOfOrder() => _outOfOrder;
        /// <summary>
        /// Sets out of order chance. 1f is a 100% chance to occur.
        /// </summary>
        /// <param name="value">New Value.</param>
        public void SetOutOfOrder(double value) => _outOfOrder = value;
        /// <summary>
        /// Percentage of packets which should drop.
        /// </summary>
        [Tooltip("Percentage of packets which should drop.")]
        [Range(0, 1)]
        [SerializeField]
        private double _packetLoss = 0;
        /// <summary>
        /// Gets packet loss chance. 1f is a 100% chance to occur.
        /// </summary>
        /// <returns></returns>
        public double GetPacketLost() => _packetLoss;
        /// <summary>
        /// Sets packet loss chance. 1f is a 100% chance to occur.
        /// </summary>
        /// <param name="value">New Value.</param>
        public void SetPacketLoss(double value) => _packetLoss = value;
        #endregion

        #region Private
        /// <summary>
        /// Transport to send data on.
        /// </summary>
        private Transport _transport;
        /// <summary>
        /// Reliable messages to the server.
        /// </summary>
        private List<Message> _toServerReliable = new();
        /// <summary>
        /// Unreliable messages to the server.
        /// </summary>
        private List<Message> _toServerUnreliable = new();
        /// <summary>
        /// Reliable messages to clients.
        /// </summary>
        private List<Message> _toClientReliable = new();
        /// <summary>
        /// Unreliable messages to clients.
        /// </summary>
        private List<Message> _toClientUnreliable = new();
        /// <summary>
        /// NetworkManager for this instance.
        /// </summary>
        private NetworkManager _networkManager;
        /// <summary>
        /// Used to generate chances of latency.
        /// </summary>
        private readonly System.Random _random = new();
        #endregion

        #region Initialization and Unity
        public void Initialize(NetworkManager manager, Transport transport)
        {
            _networkManager = manager;
            _transport = transport;
        }
        #endregion        

        /// <summary>
        /// Stops both client and server.
        /// </summary>
        public void Reset()
        {
            bool enabled = GetEnabled();
            if (_transport != null && enabled)
            { 
                IterateAndStore(_toServerReliable);
                IterateAndStore(_toServerUnreliable);
                IterateAndStore(_toClientReliable);
                IterateAndStore(_toClientUnreliable);
            }

            void IterateAndStore(List<Message> messages)
            {
                foreach (Message m in messages)
                {
                    _transport.SendToServer((byte)Channel.Reliable, m.GetSegment());
                    ByteArrayPool.Store(m.Data);
                }
            }

            _toServerReliable.Clear();
            _toServerUnreliable.Clear();
            _toClientReliable.Clear();
            _toClientUnreliable.Clear();
        }

        /// <summary>
        /// Removes pending or held packets for a connection.
        /// </summary>
        /// <param name="conn">Connection to remove pending packets for.</param>
        public void RemovePendingForConnection(int connectionId)
        {
            //If not enabled exit early to save work.
            if (!GetEnabled())
                return;
            
            RemoveFromCollection(_toServerUnreliable);
            RemoveFromCollection(_toServerUnreliable);
            RemoveFromCollection(_toClientReliable);
            RemoveFromCollection(_toClientUnreliable);

            void RemoveFromCollection(List<Message> c)
            {
                for (int i = 0; i < c.Count; i++)
                {
                    if (c[i].ConnectionId == connectionId)
                    {
                        c.RemoveAt(i);
                        i--;
                    }
                }
            }
        }

        #region Simulation
        /// <summary>
        /// Returns long latency as a float.
        /// </summary>
        /// <param name="ms"></param>
        /// <returns></returns>
        private float GetLatencyAsFloat()
        {
            return (float)(_latency / 1000f);
        }

        /// <summary>
        /// Adds a packet for simulation.
        /// </summary>
        public void AddOutgoing(byte channelId, ArraySegment<byte> segment, bool toServer = true, int connectionId = -1)
        {
            /* If to not simulate for host see if this packet
             * should be sent normally. */
            if (!_simulateHost && _networkManager != null && _networkManager.IsHostStarted)
            {
                /* If going to the server and is host then
                 * it must be sent from clientHost. */
                if (toServer)
                {
                    _transport.SendToServer(channelId, segment);
                    return;
                }
                //Not to server, see if going to clientHost.
                else
                {
                    //If connId is the same as clientHost id.
                    if (_networkManager.ClientManager.Connection.ClientId == connectionId)
                    {
                        _transport.SendToClient(channelId, segment, connectionId);
                        return;
                    }
                }
            }

            List<Message> collection;
            Channel c = (Channel)channelId;

            if (toServer)
                collection = (c == Channel.Reliable) ? _toServerReliable : _toServerUnreliable;
            else
                collection = (c == Channel.Reliable) ? _toClientReliable : _toClientUnreliable;

            float latency = GetLatencyAsFloat();
            //If dropping check to add extra latency if reliable, or discard if not.
            if (DropPacket())
            {
                if (c == Channel.Reliable)
                {
                    latency += (latency * 0.3f); //add extra for resend.
                }
                //If not reliable then return the segment array to pool.
                else
                {
                    return;
                }
            }

            Message msg = new(connectionId, segment, latency);
            int count = collection.Count;
            if (c == Channel.Unreliable && count > 0 && OutOfOrderPacket(c))
                collection.Insert(count - 1, msg);
            else
                collection.Add(msg);
        }

        /// <summary>
        /// Simulates pending outgoing packets.
        /// </summary>
        /// <param name="asServer">True to send data from the local server to clients, false to send from the local client to server.
        public void IterateOutgoing(bool asServer)
        {
            if (_transport == null)
            {
                Reset();
                return;
            }

            if (asServer)
            {
                IterateCollection(_toClientReliable, Channel.Reliable);
                IterateCollection(_toClientUnreliable, Channel.Unreliable);
            }
            else
            {
                IterateCollection(_toServerReliable, Channel.Reliable);
                IterateCollection(_toServerUnreliable, Channel.Unreliable);
            }

            void IterateCollection(List<Message> collection, Channel channel)
            {
                byte cByte = (byte)channel;
                float unscaledTime = Time.unscaledTime;

                int count = collection.Count;
                int iterations = 0;
                for (int i = 0; i < count; i++)
                {
                    Message msg = collection[i];
                    //Not enough time has passed.
                    if (unscaledTime < msg.SendTime)
                        break;

                    if (asServer)
                        _transport.SendToClient(cByte, msg.GetSegment(), msg.ConnectionId);
                    else
                        _transport.SendToServer(cByte, msg.GetSegment());

                    iterations++;
                }

                if (iterations > 0)
                {
                    for (int i = 0; i < iterations; i++)
                        ByteArrayPool.Store(collection[i].Data);
                    collection.RemoveRange(0, iterations);
                }
            }

            _transport.IterateOutgoing(asServer);
        }

        /// <summary>
        /// Returns if a packet should drop.
        /// </summary>
        /// <returns></returns>
        private bool DropPacket()
        {
            return (_packetLoss > 0d && (_random.NextDouble() < _packetLoss));
        }

        /// <summary>
        /// Returns if a packet should be out of order.
        /// </summary>
        /// <param name="c"></param>
        /// <returns></returns>
        private bool OutOfOrderPacket(Channel c)
        {
            if (c == Channel.Reliable)
                return false;

            return (_outOfOrder > 0d && (_random.NextDouble() < _outOfOrder));
        }
        #endregion
    }
}

﻿using FishNet.Serializing;
using System;
using UnityEngine;

namespace FishNet.Managing.Transporting
{

    internal class SplitReader
    {
        #region Private.
        /// <summary>
        /// Tick split is for.
        /// Tick must be a negative value so that it's impossible for the first tick to align.
        /// </summary>
        private long _tick = -1;
        /// <summary>
        /// Expected number of splits.
        /// </summary>
        private int _expectedMessages;
        /// <summary>
        /// Number of splits received so far.
        /// </summary>
        private ushort _receivedMessages;
        /// <summary>
        /// Writer containing split packet combined.
        /// </summary>
        private PooledWriter _writer = WriterPool.Retrieve();
        #endregion

        internal SplitReader()
        {
            //Increase capacity to reduce the chance of resizing.
            _writer.EnsureBufferCapacity(20000);
        }

        /// <summary>
        /// Gets split header values.
        /// </summary>
        internal void GetHeader(PooledReader reader, out int expectedMessages)
        {
            expectedMessages = reader.ReadInt32();
        }

        /// <summary>
        /// Combines split data.
        /// </summary>
        internal void Write(uint tick, PooledReader reader, int expectedMessages)
        {
            //New tick which means new split.
            if (tick != _tick)
                Reset(tick, expectedMessages);

            /* This is just a guess as to how large the end
             * message could be. If the writer is not the minimum
             * of this length then resize it. */
            int estimatedBufferSize = (expectedMessages * 1500);
            if (_writer.Capacity < estimatedBufferSize)
                _writer.EnsureBufferCapacity(estimatedBufferSize);
            /* Empty remainder of reader into the writer.
             * It does not matter if parts of the reader
             * contain data added after the split because
             * once the split is fully combined the data
             * is parsed as though it came in as one message,
             * which is how data is normally read. */
            ArraySegment<byte> data = reader.ReadArraySegment(reader.Remaining);
            _writer.WriteArraySegment(data);
            _receivedMessages++;
        }

        /// <summary>
        /// Returns if all split messages have been received.
        /// </summary>
        /// <returns></returns>
        internal ArraySegment<byte> GetFullMessage()
        {
            if (_receivedMessages < _expectedMessages)
            {
                return default(ArraySegment<byte>);
            }
            else
            {
                ArraySegment<byte> segment = _writer.GetArraySegment();
                Reset();
                return segment;
            }
        }

        private void Reset(uint tick = 0, int expectedMessages = 0)
        {
            _tick = tick;
            _receivedMessages = 0;
            _expectedMessages = expectedMessages;
            _writer.Clear();
        }

    }


}﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.Connection;
using FishNet.Managing.Timing;
using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Transporting.Multipass;
using System;
using System.Collections.Generic;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Managing.Transporting
{
    /// <summary>
    /// Communicates with the Transport to send and receive data.
    /// </summary>
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Manager/TransportManager")]
    public sealed partial class TransportManager : MonoBehaviour
    {
        #region Types.
        private struct DisconnectingClient
        {
            public uint Tick;
            public NetworkConnection Connection;

            public DisconnectingClient(uint tick, NetworkConnection connection)
            {
                Tick = tick;
                Connection = connection;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Returns if an IntermediateLayer is in use.
        /// </summary>
        public bool HasIntermediateLayer => (_intermediateLayer != null);
        /// <summary>
        /// Called before IterateOutgoing has started.
        /// </summary>
        internal event Action OnIterateOutgoingStart;
        /// <summary>
        /// Called after IterateOutgoing has completed.
        /// </summary>
        internal event Action OnIterateOutgoingEnd;
        /// <summary>
        /// Called before IterateIncoming has started. True for on server, false for on client.
        /// </summary>
        internal event Action<bool> OnIterateIncomingStart;
        /// <summary>
        /// Called after IterateIncoming has completed. True for on server, false for on client.
        /// </summary>
        internal event Action<bool> OnIterateIncomingEnd;
        /// <summary>
        /// The current Transport being used.
        /// </summary>
        [Tooltip("The current Transport being used.")]
        public Transport Transport;
        #endregion

        #region Serialized.
        /// <summary>
        /// Layer used to modify data before it is sent or received.
        /// </summary>
        [Tooltip("Layer used to modify data before it is sent or received.")]
        [SerializeField]
        private IntermediateLayer _intermediateLayer;
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Latency simulation settings.")]
        [SerializeField]
        private LatencySimulator _latencySimulator = new();
        /// <summary>
        /// Latency simulation settings.
        /// </summary>
        public LatencySimulator LatencySimulator
        {
            get
            {
                //Shouldn't ever be null unless the user nullifies it.
                if (_latencySimulator == null)
                    _latencySimulator = new();
                return _latencySimulator;
            }
        }
        #endregion

        #region Private.
        /// <summary>
        /// NetworkConnections on the server which have to send data to clients.
        /// </summary>
        private List<NetworkConnection> _dirtyToClients = new();
        /// <summary>
        /// PacketBundles to send to the server.
        /// </summary>
        private List<PacketBundle> _toServerBundles = new();
        /// <summary>
        /// NetworkManager handling this TransportManager.
        /// </summary>
        private NetworkManager _networkManager;
        /// <summary>
        /// Clients which are pending disconnects.
        /// </summary>
        private List<DisconnectingClient> _disconnectingClients = new();
        /// <summary>
        /// Lowest MTU of all transports for channels.
        /// </summary>
        private int[] _lowestMtus;
        /// <summary>
        /// Lowest MTU of all transports of all channels.
        /// </summary>
        private int _lowestMtu = 0;
        /// <summary>
        /// Custom amount to reserve on the MTU.
        /// </summary>
        private int _customMtuReserve = MINIMUM_MTU_RESERVE;
        #endregion

        #region Consts.
        /// <summary>
        /// Number of bytes sent for PacketId.
        /// </summary>
        public const byte PACKETID_LENGTH = 2;
        /// <summary>
        /// Number of bytes sent for ObjectId.
        /// </summary>
        public const byte OBJECT_ID_LENGTH = 2;
        /// <summary>
        /// Number of bytes sent for ComponentIndex.
        /// </summary>
        public const byte COMPONENT_INDEX_LENGTH = 1;
        /// <summary>
        /// Number of bytes sent for Tick.
        /// </summary>
        public const byte UNPACKED_TICK_LENGTH = 4;
        /// <summary>
        /// Number of bytes sent for an unpacked size, such as a collection or array size.
        /// </summary>
        public const byte UNPACKED_SIZE_LENGTH = 4;
        /// <summary>
        /// Number of bytes sent to indicate split count.
        /// </summary>
        private const byte SPLIT_COUNT_LENGTH = 4;
        /// <summary>
        /// Number of bytes required for split data. 
        /// </summary> //todo: This shouldn't have to include TickBytes but there is a parse error if it's not included. Figure out why.
        public const byte SPLIT_INDICATOR_LENGTH = (UNPACKED_TICK_LENGTH + PACKETID_LENGTH + SPLIT_COUNT_LENGTH);
        /// <summary>
        /// Number of channels supported.
        /// </summary>
        public const byte CHANNEL_COUNT = 2;
        /// <summary>
        /// MTU reserved for internal use.
        /// 1 byte is used to specify channel in packets for transports that do not include channel within their packet header. This is transport dependent.
        /// </summary>
        public const int MINIMUM_MTU_RESERVE = 1;
        /// <summary>
        /// Value to use when a MTU could not be found.
        /// </summary>
        public const int INVALID_MTU = -1;
        #endregion

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        internal void InitializeOnce_Internal(NetworkManager manager)
        {
            _networkManager = manager;
            TryAddDefaultTransport();
            Transport.Initialize(_networkManager, 0);
            SetLowestMTUs();
            InitializeToServerBundles();

            manager.ServerManager.OnServerConnectionState += ServerManager_OnServerConnectionState;
            manager.ClientManager.OnClientConnectionState += ClientManager_OnClientConnectionState;

            if (_intermediateLayer != null)
                _intermediateLayer.InitializeOnce(this);
#if DEVELOPMENT
            _latencySimulator.Initialize(manager, Transport);
#endif
        }

        /// <summary>
        /// Sets the lowest MTU values.
        /// </summary>
        private void SetLowestMTUs()
        {
            //Already set.
            if (_lowestMtu != 0)
                return;

            /* At least one transport is required.
             * Try to add default. If a transport is already
             * specified the add method will just exit early. */
            TryAddDefaultTransport();

            int allLowest = int.MaxValue;
            //Cache lowest Mtus.
            _lowestMtus = new int[CHANNEL_COUNT];
            for (byte i = 0; i < CHANNEL_COUNT; i++)
            {
                int channelLowest = int.MaxValue;
                if (Transport is Multipass mp)
                {
                    foreach (Transport t in mp.Transports)
                    {
                        int mtu = t.GetMTU(i);
                        if (mtu != INVALID_MTU)
                            channelLowest = Mathf.Min(channelLowest, mtu);
                    }
                }
                else
                {
                    channelLowest = Transport.GetMTU(i);
                }

                _lowestMtus[i] = channelLowest;
                _lowestMtu = Mathf.Min(allLowest, channelLowest);
            }
        }

        /// <summary>
        /// Adds the default transport if a transport is not yet specified.
        /// </summary>
        private void TryAddDefaultTransport()
        {
            if (Transport == null && !gameObject.TryGetComponent(out Transport))
                Transport = gameObject.AddComponent<FishNet.Transporting.Tugboat.Tugboat>();
        }

        /// <summary>
        /// Called when the local connection state changes for the client.
        /// </summary>
        private void ClientManager_OnClientConnectionState(ClientConnectionStateArgs obj)
        {
            //Not stopped.
            if (obj.ConnectionState != LocalConnectionState.Stopped)
                return;

            //Reset toServer data.
            foreach (PacketBundle pb in _toServerBundles)
                pb.Reset(resetSendLast: true);
        }

        /// <summary>
        /// Called when the local connection state changes for the server.
        /// </summary>
        private void ServerManager_OnServerConnectionState(ServerConnectionStateArgs obj)
        {
            //Not stopped.
            if (obj.ConnectionState != LocalConnectionState.Stopped)
                return;

            //If no server is started just clear all dirtyToClients.
            if (!_networkManager.ServerManager.IsAnyServerStarted())
            {
                _dirtyToClients.Clear();
                return;
            }

            //Only one server is stopped, remove connections for that server.
            int index = obj.TransportIndex;

            List<NetworkConnection> clientsForIndex = CollectionCaches<NetworkConnection>.RetrieveList();
            foreach (NetworkConnection conn in _dirtyToClients)
            {
                if (conn.TransportIndex == index)
                    clientsForIndex.Add(conn);
            }

            foreach (NetworkConnection conn in clientsForIndex)
                _dirtyToClients.Remove(conn);

            CollectionCaches<NetworkConnection>.Store(clientsForIndex);
        }

        ///// <summary>
        ///// Gets port for the first transport, or client transport if using Multipass.
        ///// </summary>
        //private ushort GetPort(bool asServer)
        //{
        //    if (Transport is Multipass mp)
        //    {
        //        if (asServer)
        //            return mp.Transports[0].GetPort();
        //        else
        //            return mp.ClientTransport.GetPort();
        //    }
        //    else
        //    {
        //        return Transport.GetPort();
        //    }
        //}

        ///// <summary>
        ///// Stops the local server or client connection.
        ///// </summary>
        //internal bool StopConnection(bool asServer)
        //{
        //    return Transport.StopConnection(asServer);
        //}

        ///// <summary>
        ///// Starts the local server or client connection.
        ///// </summary>
        //internal bool StartConnection(bool asServer)
        //{
        //    return Transport.StartConnection(asServer);
        //}

        ///// <summary>
        ///// Starts the local server or client connection.
        ///// </summary>
        //internal bool StartConnection(string address, bool asServer)
        //{
        //    return StartConnection(address, GetPort(asServer), asServer);
        //}

        ///// <summary>
        ///// Starts the local server or client connection on the first transport or ClientTransport if using Multipass and as client.
        ///// </summary>
        //internal bool StartConnection(string address, ushort port, bool asServer)
        //{
        //    Transport t;
        //    if (Transport is Multipass mp)
        //    {
        //        if (asServer)
        //            t = mp.Transports[0];
        //        else
        //            t = mp.ClientTransport;
        //    }
        //    else
        //    {
        //        t = Transport;
        //    }

        //    /* SetServerBindAddress must be called explictly. Only
        //     * set address if for client. */
        //    if (!asServer)
        //        t.SetClientAddress(address);
        //    t.SetPort(port);

        //    return t.StartConnection(asServer);
        //}

        /// <summary>
        /// Sets a connection from server to client dirty.
        /// </summary>
        /// <param name="conn"></param>
        internal void ServerDirty(NetworkConnection conn)
        {
            _dirtyToClients.Add(conn);
        }

        /// <summary>
        /// Initializes ToServerBundles for use.
        /// </summary>
        private void InitializeToServerBundles()
        {
            /* For ease of use FishNet will always have
             * only two channels, reliable and unreliable.
             * Even if the transport only supports reliable
             * also setup for unreliable. */
            for (byte i = 0; i < CHANNEL_COUNT; i++)
            {
                int mtu = GetLowestMTU(i);
                _toServerBundles.Add(new(_networkManager, mtu));
            }
        }

        #region GetMTU.
        /// <summary>
        /// Returns MTU excluding reserve amount.
        /// </summary> 
        private int GetMTUWithReserve(int mtu)
        {
            int value = (mtu - MINIMUM_MTU_RESERVE - _customMtuReserve);
            /* If MTU is extremely low then warn user.
             * The number choosen has no significant value. */
            if (value <= 100)
            {
                string msg = $"Available MTU of {mtu} is significantly low; an invalid MTU will be returned. Check transport settings, or reduce MTU reserve if you set one using {nameof(TransportManager.SetMTUReserve)}";
                _networkManager.LogWarning(msg);

                return INVALID_MTU;
            }

            return value;
        }

        /// <summary>
        /// Sets a custom value to reserve for the internal buffers.
        /// This value is also deducted from transport MTU when using GetMTU methods.
        /// </summary>
        /// <param name="value">Value to use.</param>
        public void SetMTUReserve(int value)
        {
            if (_networkManager != null && _networkManager.IsClientStarted || _networkManager.IsServerStarted)
            {
                _networkManager.LogError($"A custom MTU reserve cannot be set after the server or client have been started or connected.");
                return;
            }

            if (value < MINIMUM_MTU_RESERVE)
            {
                _networkManager.Log($"MTU reserve {value} is below minimum value of {MINIMUM_MTU_RESERVE}. Value has been updated to {MINIMUM_MTU_RESERVE}.");
                value = MINIMUM_MTU_RESERVE;
            }

            _customMtuReserve = value;
            InitializeToServerBundles();
        }

        /// <summary>
        /// Returns the current MTU reserve.
        /// </summary>
        /// <returns></returns>
        public int GetMTUReserve() => _customMtuReserve;

        /// <summary>
        /// Returns the lowest MTU of all channels. When using multipass this will evaluate all transports within Multipass.
        /// </summary>
        /// <param name="channel"></param>
        /// <returns></returns>
        public int GetLowestMTU()
        {
            SetLowestMTUs();
            return GetMTUWithReserve(_lowestMtu);
        }

        /// <summary>
        /// Returns the lowest MTU for a channel. When using multipass this will evaluate all transports within Multipass.
        /// </summary>
        /// <param name="channel"></param>
        /// <returns></returns>
        public int GetLowestMTU(byte channel)
        {
            SetLowestMTUs();
            return GetMTUWithReserve(_lowestMtus[channel]);
        }

        /// <summary>
        /// Gets MTU on the current transport for channel.
        /// </summary>
        /// <param name="channel">Channel to get MTU of.</param>
        /// <returns></returns>
        public int GetMTU(byte channel)
        {
            SetLowestMTUs();
            int mtu = Transport.GetMTU(channel);
            if (mtu == INVALID_MTU)
                return mtu;

            return GetMTUWithReserve(mtu);
        }

        /// <summary>
        /// Gets MTU on the transportIndex for channel. This requires use of Multipass.
        /// </summary>
        /// <param name="transportIndex">Index of the transport to get the MTU on.</param>
        /// <param name="channel">Channel to get MTU of.</param>
        /// <returns></returns>
        public int GetMTU(int transportIndex, byte channel)
        {
            if (Transport is Multipass mp)
            {
                int mtu = mp.GetMTU(channel, transportIndex);
                if (mtu == INVALID_MTU)
                    return INVALID_MTU;

                return GetMTUWithReserve(mtu);
            }
            //Using first/only transport.
            else if (transportIndex == 0)
            {
                return GetMTU(channel);
            }
            //Unhandled.
            else
            {
                _networkManager.LogWarning($"MTU cannot be returned with transportIndex because {typeof(Multipass).Name} is not in use.");
                return -1;
            }
        }

        /// <summary>
        /// Gets MTU on the transport type for channel. This requires use of Multipass.
        /// </summary>
        /// <typeparam name="T">Tyep of transport to use.</typeparam>
        /// <param name="channel">Channel to get MTU of.</param>
        /// <returns></returns>
        public int GetMTU<T>(byte channel) where T : Transport
        {
            Transport transport = GetTransport<T>();
            if (transport != null)
            {
                int mtu = transport.GetMTU(channel);
                if (mtu == INVALID_MTU)
                    return mtu;

                return GetMTUWithReserve(mtu);
            }

            //Fall through.
            return INVALID_MTU;
        }
        #endregion

        /// <summary>
        /// Passes received to the intermediate layer.
        /// </summary>
        internal ArraySegment<byte> ProcessIntermediateIncoming(ArraySegment<byte> src, bool fromServer)
        {
            return _intermediateLayer.HandleIncoming(src, fromServer);
        }

        /// <summary>
        /// Passes sent to the intermediate layer.
        /// </summary>
        private ArraySegment<byte> ProcessIntermediateOutgoing(ArraySegment<byte> src, bool toServer)
        {
            return _intermediateLayer.HandleOutgoing(src, toServer);
        }

        /// <summary>
        /// Sends data to a client.
        /// </summary>
        /// <param name="channelId">Channel to send on.</param>
        /// <param name="segment">Data to send.</param>
        /// <param name="connection">Connection to send to. Use null for all clients.</param>
        /// <param name="splitLargeMessages">True to split large packets which exceed MTU and send them in order on the reliable channel.</param>
        internal void SendToClient(byte channelId, ArraySegment<byte> segment, NetworkConnection connection, bool splitLargeMessages = true, DataOrderType orderType = DataOrderType.Default)
        {
            SetSplitValues(channelId, segment, splitLargeMessages, out int requiredMessages, out int maxSplitMessageSize);
            SendToClient(channelId, segment, connection, requiredMessages, maxSplitMessageSize, orderType);
        }

        private void SendToClient(byte channelId, ArraySegment<byte> segment, NetworkConnection connection, int requiredSplitMessages, int maxSplitMessageSize, DataOrderType orderType = DataOrderType.Default)
        {
            if (connection == null)
                return;

            if (requiredSplitMessages > 1)
                SendSplitData(connection, ref segment, requiredSplitMessages, maxSplitMessageSize, orderType);
            else
                connection.SendToClient(channelId, segment, false, orderType);
        }

        /// <summary>
        /// Sends data to observers.
        /// </summary>
        internal void SendToClients(byte channelId, ArraySegment<byte> segment, HashSet<NetworkConnection> observers, HashSet<NetworkConnection> excludedConnections = null, bool splitLargeMessages = true, DataOrderType orderType = DataOrderType.Default)
        {
            SetSplitValues(channelId, segment, splitLargeMessages, out int requiredMessages, out int maxSplitMessageSize);
            SendToClients(channelId, segment, observers, excludedConnections, requiredMessages, maxSplitMessageSize, orderType);
        }

        private void SendToClients(byte channelId, ArraySegment<byte> segment, HashSet<NetworkConnection> observers, HashSet<NetworkConnection> excludedConnections, int requiredSplitMessages, int maxSplitMessageSize, DataOrderType orderType = DataOrderType.Default)
        {
            if (excludedConnections == null || excludedConnections.Count == 0)
            {
                foreach (NetworkConnection conn in observers)
                    SendToClient(channelId, segment, conn, requiredSplitMessages, maxSplitMessageSize, orderType);
            }
            else
            {
                foreach (NetworkConnection conn in observers)
                {
                    if (excludedConnections.Contains(conn))
                        continue;
                    SendToClient(channelId, segment, conn, requiredSplitMessages, maxSplitMessageSize, orderType);
                }
            }
        }

        /// <summary>
        /// Sends data to all clients.
        /// </summary>
        /// <param name="channelId">Channel to send on.</param>
        /// <param name="segment">Data to send.</param>
        /// <param name="splitLargeMessages">True to split large packets which exceed MTU and send them in order on the reliable channel.</param>
        internal void SendToClients(byte channelId, ArraySegment<byte> segment, bool splitLargeMessages = true)
        {
            SetSplitValues(channelId, segment, splitLargeMessages, out int requiredMessages, out int maxSplitMessageSize);
            SendToClients_Internal(channelId, segment, requiredMessages, maxSplitMessageSize);
        }

        private void SendToClients_Internal(byte channelId, ArraySegment<byte> segment, int requiredSplitMessages, int maxSplitMessageSize)
        {
            /* Rather than buffer the message once and send to every client
             * it must be queued into every client. This ensures clients
             * receive the message in order of other packets being
             * delivered to them. */
            foreach (NetworkConnection conn in _networkManager.ServerManager.Clients.Values)
                SendToClient(channelId, segment, conn, requiredSplitMessages, maxSplitMessageSize);
        }

        /// <summary>
        /// Sends data to the server.
        /// </summary>
        /// <param name="channelId">Channel to send on.</param>
        /// <param name="segment">Data to send.</param>
        /// <param name="splitLargeMessages">True to split large packets which exceed MTU and send them in order on the reliable channel.</param>
        internal void SendToServer(byte channelId, ArraySegment<byte> segment, bool splitLargeMessages = true, DataOrderType orderType = DataOrderType.Default)
        {
            SetSplitValues(channelId, segment, splitLargeMessages, out int requiredMessages, out int maxSplitMessageSize);
            SendToServer(channelId, segment, requiredMessages, maxSplitMessageSize, orderType);
        }

        private void SendToServer(byte channelId, ArraySegment<byte> segment, int requiredMessages, int maxSplitMessageSize, DataOrderType orderType)
        {
            if (channelId >= _toServerBundles.Count)
                channelId = (byte)Channel.Reliable;

            if (requiredMessages > 1)
                SendSplitData(null, ref segment, requiredMessages, maxSplitMessageSize, orderType);
            else
                _toServerBundles[channelId].Write(segment, false, orderType);
        }

        #region Splitting.
        /// <summary>
        /// Checks if a message can be split and outputs split information if so.
        /// </summary>
        private void SetSplitValues(byte channelId, ArraySegment<byte> segment, bool split, out int requiredMessages, out int maxSplitMessageSize)
        {
            if (!split)
            {
                requiredMessages = 0;
                maxSplitMessageSize = 0;
            }
            else
            {
                SplitRequired(channelId, segment.Count, out requiredMessages, out maxSplitMessageSize);
            }
        }

        /// <summary>
        /// Checks to set channel to reliable if dataLength is too long.
        /// </summary>
        internal void CheckSetReliableChannel(int dataLength, ref Channel channel)
        {
            if (channel == Channel.Reliable)
                return;

            bool requiresMultipleMessages = (GetRequiredMessageCount((byte)channel, dataLength, out _) > 1);
            if (requiresMultipleMessages)
                channel = Channel.Reliable;
        }

        /// <summary>
        /// Gets the required number of messages needed for segmentSize and channel.
        /// </summary>
        private int GetRequiredMessageCount(byte channelId, int segmentSize, out int maxMessageSize)
        {
            maxMessageSize = GetLowestMTU(channelId) - SPLIT_INDICATOR_LENGTH;
            return Mathf.CeilToInt((float)segmentSize / maxMessageSize);
        }

        /// <summary>
        /// True if data must be split.
        /// </summary>
        /// <param name="channelId"></param>
        /// <param name="segmentSize"></param>
        private bool SplitRequired(byte channelId, int segmentSize, out int requiredMessages, out int maxMessageSize)
        {
            requiredMessages = GetRequiredMessageCount(channelId, segmentSize, out maxMessageSize);

            bool splitRequired = (requiredMessages > 1);
            if (splitRequired && channelId != (byte)Channel.Reliable)
                _networkManager.LogError($"A message of length {segmentSize} requires the reliable channel but was sent on channel {(Channel)channelId}. Please file this stack trace as a bug report.");

            return splitRequired;
        }

        /// <summary>
        /// Splits data going to which is too large to fit within the transport MTU.
        /// </summary>
        /// <param name="conn">Connection to send to. If null data will be sent to the server.</param>
        /// <returns>True if data was sent split.</returns>
        private void SendSplitData(NetworkConnection conn, ref ArraySegment<byte> segment, int requiredMessages, int maxMessageSize, DataOrderType orderType)
        {
            if (requiredMessages <= 1)
            {
                _networkManager.LogError($"SendSplitData was called with {requiredMessages} required messages. This method should only be called if messages must be split into 2 pieces or more.");
                return;
            }

            byte channelId = (byte)Channel.Reliable;
            PooledWriter headerWriter = WriterPool.Retrieve();
            headerWriter.WritePacketIdUnpacked(PacketId.Split);
            headerWriter.WriteInt32(requiredMessages);
            ArraySegment<byte> headerSegment = headerWriter.GetArraySegment();

            int writeIndex = 0;
            bool firstWrite = true;
            //Send to connection until everything is written.
            while (writeIndex < segment.Count)
            {
                int headerReduction = 0;
                if (firstWrite)
                {
                    headerReduction = headerSegment.Count;
                    firstWrite = false;
                }
                int chunkSize = Mathf.Min(segment.Count - writeIndex - headerReduction, maxMessageSize);
                //Make a new array segment for the chunk that is getting split.
                ArraySegment<byte> splitSegment = new(segment.Array, segment.Offset + writeIndex, chunkSize);

                //If connection is specified then it's going to a client.
                if (conn != null)
                {
                    conn.SendToClient(channelId, headerSegment, true);
                    conn.SendToClient(channelId, splitSegment);
                }
                //Otherwise it's going to the server.
                else
                {
                    _toServerBundles[channelId].Write(headerSegment, true, orderType);
                    _toServerBundles[channelId].Write(splitSegment, false, orderType);
                }

                writeIndex += chunkSize;
            }

            headerWriter.Store();
        }
        #endregion

        /// <summary>
        /// Processes data received by the socket.
        /// </summary>
        /// <param name="asServer">True to read data from clients, false to read data from the server.
        internal void IterateIncoming(bool asServer)
        {
            OnIterateIncomingStart?.Invoke(asServer);
            Transport.IterateIncoming(asServer);
            OnIterateIncomingEnd?.Invoke(asServer);
        }

        /// <summary>
        /// Processes data to be sent by the socket.
        /// </summary>
        /// <param name="asServer">True to send data from the local server to clients, false to send from the local client to server.
        internal void IterateOutgoing(bool asServer)
        {
            if (asServer && _networkManager.ServerManager.AreAllServersStopped())
                return;

            OnIterateOutgoingStart?.Invoke();
            int channelCount = CHANNEL_COUNT;
            ulong sentBytes = 0;
#if DEVELOPMENT
            bool latencySimulatorEnabled = LatencySimulator.CanSimulate;
#endif
            if (asServer)
                SendAsServer();
            else
                SendAsClient();

            //Sends data as server.
            void SendAsServer()
            {
                TimeManager tm = _networkManager.TimeManager;
                uint localTick = tm.LocalTick;
                //Write any dirty syncTypes.
                _networkManager.ServerManager.Objects.WriteDirtySyncTypes();

                int dirtyCount = _dirtyToClients.Count;

                //Run through all dirty connections to send data to.
                for (int z = 0; z < dirtyCount; z++)
                {
                    NetworkConnection conn = _dirtyToClients[z];
                    if (conn == null || !conn.IsValid)
                        continue;

                    //Get packets for every channel.
                    for (byte channel = 0; channel < channelCount; channel++)
                    {
                        if (conn.GetPacketBundle(channel, out PacketBundle pb))
                        {
                            ProcessPacketBundle(pb);
                            ProcessPacketBundle(pb.GetSendLastBundle(), true);

                            void ProcessPacketBundle(PacketBundle ppb, bool isLast = false)
                            {
                                for (int i = 0; i < ppb.WrittenBuffers; i++)
                                {
                                    //Length should always be more than 0 but check to be safe.
                                    if (ppb.GetBuffer(i, out ByteBuffer bb))
                                    {
                                        ArraySegment<byte> segment = new(bb.Data, 0, bb.Length);
                                        if (HasIntermediateLayer)
                                            segment = ProcessIntermediateOutgoing(segment, false);
#if DEVELOPMENT
                                        if (latencySimulatorEnabled)
                                            _latencySimulator.AddOutgoing(channel, segment, false, conn.ClientId);
                                        else
#endif
                                            Transport.SendToClient(channel, segment, conn.ClientId);
                                        sentBytes += (ulong)segment.Count;
                                    }
                                }

                                ppb.Reset(false);
                            }
                        }
                    }

                    /* When marked as disconnecting data will still be sent
                     * this iteration but the connection will be marked as invalid.
                     * This will prevent future data from going out/coming in.
                     * Also the connection will be added to a disconnecting collection
                     * so it will it disconnected briefly later to allow data from
                     * this tick to send. */
                    if (conn.Disconnecting)
                    {
                        uint requiredTicks = tm.TimeToTicks(0.1d, TickRounding.RoundUp);
                        /* Require 100ms or 2 ticks to pass
                         * before disconnecting to allow for the
                         * higher chance of success that remaining
                         * data is sent. */
                        requiredTicks = Math.Max(requiredTicks, 2);
                        _disconnectingClients.Add(new(requiredTicks + localTick, conn));
                    }

                    conn.ResetServerDirty();
                }

                //Iterate disconnects.
                for (int i = 0; i < _disconnectingClients.Count; i++)
                {
                    DisconnectingClient dc = _disconnectingClients[i];
                    if (localTick >= dc.Tick)
                    {
                        _networkManager.TransportManager.Transport.StopConnection(dc.Connection.ClientId, true);
                        _disconnectingClients.RemoveAt(i);
                        i--;
                    }
                }

                _networkManager.StatisticsManager.NetworkTraffic.LocalServerSentData(sentBytes);

                if (dirtyCount == _dirtyToClients.Count)
                    _dirtyToClients.Clear();
                else if (dirtyCount > 0)
                    _dirtyToClients.RemoveRange(0, dirtyCount);
            }

            //Sends data as client.
            void SendAsClient()
            {
                for (byte channel = 0; channel < channelCount; channel++)
                {
                    if (PacketBundle.GetPacketBundle(channel, _toServerBundles, out PacketBundle pb))
                    {
                        ProcessPacketBundle(pb);
                        ProcessPacketBundle(pb.GetSendLastBundle());

                        void ProcessPacketBundle(PacketBundle ppb)
                        {
                            for (int i = 0; i < ppb.WrittenBuffers; i++)
                            {
                                if (ppb.GetBuffer(i, out ByteBuffer bb))
                                {
                                    ArraySegment<byte> segment = new(bb.Data, 0, bb.Length);
                                    if (HasIntermediateLayer)
                                        segment = ProcessIntermediateOutgoing(segment, true);
#if DEVELOPMENT
                                    if (latencySimulatorEnabled)
                                        _latencySimulator.AddOutgoing(channel, segment);
                                    else
#endif
                                        Transport.SendToServer(channel, segment);
                                    sentBytes += (ulong)segment.Count;
                                }
                            }

                            ppb.Reset(false);
                        }
                    }
                }

                _networkManager.StatisticsManager.NetworkTraffic.LocalClientSentData(sentBytes);
            }

#if DEVELOPMENT
            if (latencySimulatorEnabled)
                _latencySimulator.IterateOutgoing(asServer);
#endif

            Transport.IterateOutgoing(asServer);
            OnIterateOutgoingEnd?.Invoke();
        }

        #region Editor.
#if UNITY_EDITOR
        private void OnValidate()
        {
            if (Transport == null)
                Transport = GetComponent<Transport>();

            /* Update enabled state to force a reset if needed.
             * This may be required if the user checked the enabled
             * tick box at runtime. If enabled value didn't change
             * then the Get will be the same as the Set and nothing
             * will happen. */
            _latencySimulator.SetEnabled(_latencySimulator.GetEnabled());
        }
#endif
        #endregion
    }
}﻿using System.Collections.Generic;
using FishNet.Connection;
using FishNet.Transporting;
using FishNet.Transporting.Multipass;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Managing.Transporting
{

    /// <summary>
    /// Communicates with the Transport to send and receive data.
    /// </summary>
    public sealed partial class TransportManager : MonoBehaviour
    {
        /// <summary>
        /// Returns IsLocalTransport for the transportId, optionally checking against a connectionId.
        /// </summary>
        public bool IsLocalTransport(int transportId, int connectionId = NetworkConnection.UNSET_CLIENTID_VALUE)
        {
            if (Transport == null)
                return false;

            if (Transport is Multipass mp)
                return mp.IsLocalTransport(transportId, connectionId);
            else
                return Transport.IsLocalTransport(connectionId);
        }

        /// <summary>
        /// Gets transport on index.
        /// Commonly index will be 0 unless using Multipass.
        /// </summary>
        /// <returns></returns>
        public Transport GetTransport(int index)
        {
            //If using multipass try to find the correct transport.
            if (Transport is Multipass mp)
            {
                return mp.GetTransport(index);
            }
            //Not using multipass.
            else
            {
                return Transport;
            }
        }

        /// <summary>
        /// Gets transport of type T.
        /// </summary>
        /// <returns>Returns the found transport which is of type T. Returns default of T if not found.</returns>
        public T GetTransport<T>() where T : Transport
        {
            //If using multipass try to find the correct transport.
            if (Transport is Multipass mp)
            {
                if (typeof(T) == typeof(Multipass))
                    return (T)(object)mp;
                else
                    return mp.GetTransport<T>();
            }
            //Not using multipass.
            else
            {
                if (Transport.GetType() == typeof(T))
                    return (T)(object)Transport;
                else
                    return default(T);
            }
        }
        
        /// <summary>
        /// Returns all transports configured on the TransportManager.
        /// </summary>
        /// <param name="includeMultipass">True to add Multipass to the results if being used. When false and using Multipass only the transport specified within Multipass will be returned.</param>
        /// <returns></returns>
        /// <remarks>This returns a collection from cache.</remarks>
        public List<Transport> GetAllTransports(bool includeMultipass)
        {
            List<Transport> results = CollectionCaches<Transport>.RetrieveList();
            
            //If using multipass check all transports.
            if (Transport is Multipass mp)
            {
                if (includeMultipass)
                    results.Add(Transport);


                foreach (Transport t in mp.Transports)
                    results.Add(t);
            }
            //Not using multipass.
            else
            {
                results.Add(Transport);
            }

            return results;
        }
    }

}﻿using FishNet.Object;
using FishNet.Serializing;
using FishNet.Transporting;

namespace FishNet.Managing.Utility
{

    public class Packets
    {
        /// <summary>
        /// Returns written data length for packet.
        /// </summary>
        internal static int GetPacketLength(ushort packetId, PooledReader reader, Channel channel)
        {
            /* Broadcast is a special circumstance where data
            * will not be purged even if unreliable.
            * This is because a broadcast receiver may not
            * be set, which could be intentional. Because of this
            * length is always sent to skip
            * past the broadcast data. 
            *
            * Reliables also need length read in the instance a client
            * sends data to an object which server is despawning. Without
            * parsing length the remainer data from client will be corrupt. */
            /* //todo: we will not always get length on reconciles once
             * the issue with parsed headers is resolved. */
            PacketId pid = (PacketId)packetId;
            if (channel == Channel.Reliable ||
                pid == PacketId.Broadcast ||
                pid == PacketId.SyncType ||
                pid == PacketId.Reconcile
                )
            {
                return reader.ReadInt32();
            }
            //Unreliable purges remaining.
            else if (channel == Channel.Unreliable)
            {
                return (int)MissingObjectPacketLength.PurgeRemaiming;
            }
            /* Unhandled. This shouldn't be possible
             * since both reliable and unreliable is checked.
             * There are no other options. This is merely here
             * for a sanity check. */
            else
            {
                reader.NetworkManager.LogError($"Operation is unhandled for packetId {(PacketId)packetId} on channel {channel}.");
                return (int)MissingObjectPacketLength.PurgeRemaiming;
            }
        }
    }


}﻿//Remove on V5﻿using System;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Object
{

    public static class TransformPropertiesExtensions 
    {
        /// <summary>
        /// Creates direction between two TransformProperties.
        /// </summary>
        /// <param name="divisor">Value to divide results by.</param>
        /// <returns></returns>
        public static TransformProperties CreateDirections(this TransformProperties prevProperties, TransformProperties nextProperties, uint divisor = 1)
        {
            //PROSTART
            Vector3 position = (nextProperties.Position - prevProperties.Position) / divisor;

            Quaternion rotation = nextProperties.Rotation.Subtract(prevProperties.Rotation);
            //If more than 1 tick span then get a portion of the rotation.
            if (divisor > 1)
            {
                float percent = (1f / (float)divisor);
                rotation = Quaternion.Lerp(Quaternion.identity, nextProperties.Rotation, percent);
            }

            Vector3 scale = (nextProperties.Scale - prevProperties.Scale) / divisor;

            return new(position, rotation, scale);
        }

        /// <summary>
        /// Sets values of TransformPropertiesCls to a transforms world properties.
        /// </summary>
        public static void SetWorldProperties(this TransformPropertiesCls tp, Transform t)
        {
            tp.Position = t.position;
            tp.Rotation = t.rotation;
            tp.LocalScale = t.localScale;
        }
        
        /// <summary>
        /// Sets values of TransformPropertiesCls to a transforms world properties.
        /// </summary>
        public static void SetWorldProperties(this TransformProperties tp, Transform t)
        {
            tp.Position = t.position;
            tp.Rotation = t.rotation;
            tp.Scale = t.localScale;
        }



    }

    [System.Serializable]
    public class TransformPropertiesCls : IResettable
    {
        public Vector3 Position;
        public Quaternion Rotation;
        public Vector3 LocalScale;

        public TransformPropertiesCls() { }

        public TransformPropertiesCls(Vector3 position, Quaternion rotation, Vector3 localScale)
        {
            Position = position;
            Rotation = rotation;
            LocalScale = localScale;
        }

        public void InitializeState() { }

        public void ResetState()
        {
            Update(Vector3.zero, Quaternion.identity, Vector3.zero);
        }

        public void Update(Transform t)
        {
            Update(t.position, t.rotation, t.localScale);
        }

        public void Update(TransformPropertiesCls tp)
        {
            Update(tp.Position, tp.Rotation, tp.LocalScale);
        }

        public void Update(TransformProperties tp)
        {
            Update(tp.Position, tp.Rotation, tp.Scale);
        }

        public void Update(Vector3 position, Quaternion rotation)
        {
            Update(position, rotation, LocalScale);
        }

        public void Update(Vector3 position, Quaternion rotation, Vector3 localScale)
        {
            Position = position;
            Rotation = rotation;
            LocalScale = localScale;
        }

        /// <summary>
        /// Returns if this TransformProperties equals anothers values.
        /// </summary>
        public bool ValuesEquals(TransformPropertiesCls properties)
        {
            return (this.Position == properties.Position && this.Rotation == properties.Rotation && this.LocalScale == properties.LocalScale);
        }

        /// <summary>
        /// Returns this classes values as the struct version of TransformProperties.
        /// </summary>
        /// <returns></returns>
        public TransformProperties ToStruct()
        {
            TransformProperties result = new(Position, Rotation, LocalScale);
            return result;
        }
    }

    [System.Serializable]
    public struct TransformProperties
    {
        public Vector3 Position;
        public Quaternion Rotation;
        [Obsolete("Use Scale.")] //Remove V5
        public Vector3 LocalScale => Scale;
        public Vector3 Scale;
        /// <summary>
        /// Becomes true when values are set through update or constructor.
        /// </summary>
        public bool IsValid;

        public TransformProperties(Vector3 position, Quaternion rotation, Vector3 localScale)
        {
            Position = position;
            Rotation = rotation;
            Scale = localScale;
            IsValid = true;
        }

        /// <summary>
        /// Creates a TransformProperties with default position and rotation, with Vector3.one scale. 
        /// </summary>
        public static TransformProperties GetTransformDefault() => new(Vector3.zero, Quaternion.identity, Vector3.one);
        
        public override string ToString()
        {
            return $"Position: {Position.ToString()}, Rotation {Rotation.ToString()}, Scale {Scale.ToString()}";
        }

        public TransformProperties(Transform t) : this(t.position, t.rotation, t.localScale) { }

        [Obsolete("Use ResetState.")]
        public void Reset() => ResetState();

        public void ResetState()
        {
            Update(Vector3.zero, Quaternion.identity, Vector3.zero);
            IsValid = false;
        }

        public void Update(Transform t)
        {
            Update(t.position, t.rotation, t.localScale);
        }

        public void Update(TransformProperties tp)
        {
            Update(tp.Position, tp.Rotation, tp.Scale);
        }

        public void Update(Vector3 position, Quaternion rotation)
        {
            Update(position, rotation, Scale);
        }

        public void Update(Vector3 position, Quaternion rotation, Vector3 localScale)
        {
            Position = position;
            Rotation = rotation;
            Scale = localScale;
            IsValid = true;
        }

        /// <summary>
        /// Adds another transformProperties onto this.
        /// </summary>
        /// <param name="tp"></param>
        public void Add(TransformProperties tp)
        {
            Position += tp.Position;
            Rotation *= tp.Rotation;
            Scale += tp.Scale;
        }

        /// <summary>
        /// Subtracts another transformProperties from this.
        /// </summary>
        /// <param name="tp"></param>
        public void Subtract(TransformProperties tp)
        {
            Position -= tp.Position;
            Rotation *= Quaternion.Inverse(tp.Rotation);
            Scale -= tp.Scale;
        }

        /// <summary>
        /// Returns if this TransformProperties equals anothers values.
        /// </summary>
        public bool ValuesEquals(TransformProperties properties)
        {
            return (this.Position == properties.Position && this.Rotation == properties.Rotation && this.Scale == properties.Scale);
        }
    }
}﻿using GameKit.Dependencies.Utilities;

namespace FishNet.Object
{
    [System.Flags]
    public enum TransformPropertiesFlag : uint
    {
        Unset = 0,
        Position = (1 << 0),
        Rotation = (1 << 1),
        Scale = (1 << 2),
        Everything = Enums.SHIFT_EVERYTHING_UINT,
    }

    public static class TransformPropertiesOptionExtensions
    {
        /// <summary>
        /// Returns if enum contains a value.
        /// </summary>
        /// <param name="whole">Value checked against.</param>
        /// <param name="part">Value checked if whole contains.</param>
        /// <returns></returns>
        public static bool FastContains(this TransformPropertiesFlag whole, TransformPropertiesFlag part) => (whole & part) == part;        
    }
}

﻿#if UNITY_EDITOR
using FishNet.Component.Transforming;
using UnityEditor;
using UnityEngine;

namespace FishNet.Object.Editing
{
    [CustomEditor(typeof(NetworkObject), true)]
    [CanEditMultipleObjects]
    public class NetworkObjectEditor : Editor
    {
        private SerializedProperty _isNetworked;
        private SerializedProperty _isSpawnable;
        private SerializedProperty _isGlobal;
        private SerializedProperty _initializeOrder;
        private SerializedProperty _preventDespawnOnDisconnect;
        private SerializedProperty _defaultDespawnType;

        private SerializedProperty _enablePrediction;
        private SerializedProperty _enableStateForwarding;
        private SerializedProperty _networkTransform;
        private SerializedProperty _predictionType;
        private SerializedProperty _graphicalObject;
        private SerializedProperty _detachGraphicalObject;

        private SerializedProperty _ownerSmoothedProperties;
        private SerializedProperty _spectatorSmoothedProperties;
        private SerializedProperty _ownerInterpolation;
        private SerializedProperty _adaptiveInterpolation;
        private SerializedProperty _spectatorInterpolation;
        private SerializedProperty _enableTeleport;
        private SerializedProperty _teleportThreshold;

        private int _tabIndex;
        private int _savedTabIndex;

        private const string TAB_INDEX_PREFS_NAME = "FishNet_NetworkObject_TabIndex";

        protected virtual void OnEnable()
        {
            _tabIndex = EditorPrefs.GetInt(TAB_INDEX_PREFS_NAME);
            _savedTabIndex = _tabIndex;

            _isNetworked = serializedObject.FindProperty(nameof(_isNetworked));
            _isSpawnable = serializedObject.FindProperty(nameof(_isSpawnable));
            _isGlobal = serializedObject.FindProperty(nameof(_isGlobal));
            _initializeOrder = serializedObject.FindProperty(nameof(_initializeOrder));
            _preventDespawnOnDisconnect = serializedObject.FindProperty(nameof(_preventDespawnOnDisconnect));
            _defaultDespawnType = serializedObject.FindProperty(nameof(_defaultDespawnType));

            _enablePrediction = serializedObject.FindProperty(nameof(_enablePrediction));
            _enableStateForwarding = serializedObject.FindProperty(nameof(_enableStateForwarding));
            _networkTransform = serializedObject.FindProperty(nameof(_networkTransform));
            _predictionType = serializedObject.FindProperty(nameof(_predictionType));
            _graphicalObject = serializedObject.FindProperty(nameof(_graphicalObject));
            _detachGraphicalObject = serializedObject.FindProperty(nameof(_detachGraphicalObject));

            _ownerSmoothedProperties = serializedObject.FindProperty(nameof(_ownerSmoothedProperties));
            _ownerInterpolation = serializedObject.FindProperty(nameof(_ownerInterpolation));
            _adaptiveInterpolation = serializedObject.FindProperty(nameof(_adaptiveInterpolation));
            _spectatorSmoothedProperties = serializedObject.FindProperty(nameof(_spectatorSmoothedProperties));
            _spectatorInterpolation = serializedObject.FindProperty(nameof(_spectatorInterpolation));
            _enableTeleport = serializedObject.FindProperty(nameof(_enableTeleport));
            _teleportThreshold = serializedObject.FindProperty(nameof(_teleportThreshold));
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            NetworkObject nob = (NetworkObject)target;

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour(nob), typeof(NetworkObject), false);
            GUI.enabled = true;
            EditorGUILayout.Space();

            _tabIndex = GUILayout.Toolbar(_tabIndex, new string[] { "Settings", "Prediction" });
            EditorGUILayout.Space();
            switch (_tabIndex)
            {
                case 0:
                    ShowSettingsTab();
                    break;
                case 1:
                    ShowPredictionTab();
                    break;
                default:
                    ShowSettingsTab();
                    break;
            }


            void ShowSettingsTab()
            {
                SaveTabIndex();
                EditorGUILayout.PropertyField(_isNetworked);
                EditorGUILayout.PropertyField(_isSpawnable);
                EditorGUILayout.PropertyField(_isGlobal);
                EditorGUILayout.PropertyField(_initializeOrder);
                EditorGUILayout.PropertyField(_preventDespawnOnDisconnect);
                EditorGUILayout.PropertyField(_defaultDespawnType);
            }

            void ShowPredictionTab()
            {
                SaveTabIndex();
                EditorGUILayout.PropertyField(_enablePrediction);
                if (_enablePrediction.boolValue == true)
                {
                    EditorGUI.indentLevel++;
                    EditorGUILayout.PropertyField(_predictionType);
                    EditorGUILayout.PropertyField(_enableStateForwarding);
                    if (_enableStateForwarding.boolValue == false)
                    {
                        EditorGUI.indentLevel++;
                        EditorGUILayout.PropertyField(_networkTransform);
                        EditorGUI.indentLevel--;
                    }

                    EditorGUILayout.HelpBox("Smoothing settings on the NetworkObject will be obsoleted soon. Please unset the graphicalObject and use NetworkTickSmoother instead.", MessageType.Warning);
                    
                    bool graphicalSet = (_graphicalObject.objectReferenceValue != null);
                    EditorGUILayout.PropertyField(_graphicalObject);
                    if (graphicalSet)
                    {
                        EditorGUI.indentLevel++;
                        EditorGUILayout.PropertyField(_detachGraphicalObject);
                        EditorGUI.indentLevel--;
                    }
                    
                    EditorGUILayout.LabelField("Smoothing", EditorStyles.boldLabel);
                    if (!graphicalSet)
                    {
                        EditorGUILayout.HelpBox($"More smoothing settings will be displayed when a graphicalObject is set.", MessageType.Info);
                    }
                    else
                    {
                        EditorGUI.indentLevel++;
                        EditorGUILayout.PropertyField(_enableTeleport);
                        if (_enableTeleport.boolValue == true)
                        {
                            EditorGUI.indentLevel++;
                            EditorGUILayout.PropertyField(_teleportThreshold, new GUIContent("Teleport Threshold"));
                            EditorGUI.indentLevel--;
                        }

                        EditorGUILayout.LabelField("Owner", EditorStyles.boldLabel);
                        EditorGUI.indentLevel++;
                        EditorGUILayout.PropertyField(_ownerInterpolation, new GUIContent("Interpolation"));
                        EditorGUILayout.PropertyField(_ownerSmoothedProperties, new GUIContent("Smoothed Properties"));
                        EditorGUI.indentLevel--;

                        EditorGUILayout.LabelField("Spectator", EditorStyles.boldLabel);
                        EditorGUI.indentLevel++;
                        EditorGUILayout.PropertyField(_adaptiveInterpolation);
                        if (_adaptiveInterpolation.intValue == (int)AdaptiveInterpolationType.Off)
                        {
                            EditorGUI.indentLevel++;
                            EditorGUILayout.PropertyField(_spectatorInterpolation, new GUIContent("Interpolation"));
                            EditorGUI.indentLevel--;
                        }
                        EditorGUILayout.PropertyField(_spectatorSmoothedProperties, new GUIContent("Smoothed Properties"));
                        EditorGUI.indentLevel--;
                    }

                    EditorGUI.indentLevel--;
                }
            }

            serializedObject.ApplyModifiedProperties();
        }

        /// <summary>
        /// Saves tabIndex if it has changed.
        /// </summary>
        private void SaveTabIndex()
        {
            if (_tabIndex == _savedTabIndex)
                return;

            _savedTabIndex = _tabIndex;
            EditorPrefs.SetInt(TAB_INDEX_PREFS_NAME, _tabIndex);
        }
    }
}

#endif﻿using FishNet.Object.Helping;
using FishNet.Transporting;

namespace FishNet.Object
{

    #region Types.
    /// <summary>
    /// Lookup data for a RPC Link.
    /// </summary>
    internal readonly struct RpcLink
    {
        /// <summary>
        /// ObjectId for link.
        /// </summary>
        public readonly int ObjectId;
        /// <summary>
        /// NetworkBehaviour component index on ObjectId.
        /// </summary>
        public readonly byte ComponentIndex;
        /// <summary>
        /// RpcHash for link.
        /// </summary>
        public readonly uint RpcHash;
        /// <summary>
        /// PacketId used for the Rpc type when not using links.
        /// </summary>
        public readonly PacketId RpcPacketId;

        public RpcLink(int objectId, byte componentIndex, uint rpcHash, PacketId packetId)
        {
            ObjectId = objectId;
            ComponentIndex = componentIndex;
            RpcHash = rpcHash;
            RpcPacketId = packetId;
        }
    }
    #endregion

}﻿namespace FishNet.Object.Helping
{
    public enum RpcType : int
    {
        None = 0,
        Server = 1,
        Observers = 2,
        Target = 4,
        Replicate = 8,
        Reconcile = 16
    }

}﻿
namespace FishNet.Object.Helping
{

    public static class CodegenHelper
    {
        /// <summary>
        /// Returns if a NetworkObject is deinitializing.
        /// </summary>
        /// <param name="nb"></param>
        /// <returns></returns>
        public static bool NetworkObject_Deinitializing(NetworkBehaviour nb)
        {
            if (nb == null)
                return true;

            return nb.IsDeinitializing;
        }

        /// <summary>
        /// Returns if running as server.
        /// </summary>
        /// <param name="nb"></param>
        /// <returns></returns>
        public static bool IsServer(NetworkBehaviour nb)
        {
            if (nb == null)
                return false;

            return nb.IsServerStarted;
        }

        /// <summary>
        /// Returns if running as client.
        /// </summary>
        /// <param name="nb"></param>
        /// <returns></returns>
        public static bool IsClient(NetworkBehaviour nb)
        {
            if (nb == null)
                return false;

            return nb.IsClientStarted;
        }

    }


}﻿using FishNet.Managing.Logging;
using FishNet.Transporting;
using System;
using UnityEngine;

namespace FishNet.Object
{
    public enum DataOrderType
    {
        /// <summary>
        /// Data will buffer in the order originally intended.
        /// EG: SyncTypes will always send last, and RPCs will always send in the order they were called.
        /// </summary>
        Default = 0,
        /// <summary>
        /// Data will be attached to the end of the packet.
        /// RPCs can be sent after all SyncTypes by using this value. Multiple RPCs with this order type will send last, in the order they were called.
        /// </summary>
        Last = 1,
    }

    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class RpcAttribute : Attribute
    {
        /// <summary>
        /// True to also run the RPC logic locally.
        /// </summary>
        public bool RunLocally = false;
        /// <summary>
        /// Estimated length of data being sent.
        /// When a value other than -1 the minimum length of the used serializer will be this value.
        /// This is useful for writing large packets which otherwise resize the serializer.
        /// </summary>
        public int DataLength = -1;
        /// <summary>
        /// Order in which to send data for this RPC.
        /// </summary>
        public DataOrderType OrderType = DataOrderType.Default;
    }

    /// <summary>
    /// ServerRpc methods will send messages to the server.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class ServerRpcAttribute : RpcAttribute
    {
        /// <summary>
        /// True to only allow the owning client to call this RPC.
        /// </summary>
        public bool RequireOwnership = true;
        /// <summary>
        /// Type of logging to use when the IsServer check fails.
        /// </summary>
        public LoggingType Logging = LoggingType.Warning;
    }

    /// <summary>
    /// ObserversRpc methods will send messages to all observers.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class ObserversRpcAttribute : RpcAttribute
    {
        /// <summary>
        /// True to exclude the owner from receiving this RPC.
        /// </summary>
        public bool ExcludeOwner = false;
        /// <summary>
        /// True to prevent the connection from receiving this Rpc if they are also server.
        /// </summary>
        public bool ExcludeServer = false;
        /// <summary>
        /// True to buffer the last value and send it to new players when the object is spawned for them.
        /// RPC will be sent on the same channel as the original RPC, and immediately before the OnSpawnServer override.
        /// </summary>
        public bool BufferLast = false;
        /// <summary>
        /// Type of logging to use when the IsServer check fails.
        /// </summary>
        public LoggingType Logging = LoggingType.Warning;
    }

    /// <summary>
    /// TargetRpc methods will send messages to a single client.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class TargetRpcAttribute : RpcAttribute 
    {
        /// <summary>
        /// True to prevent the connection from receiving this Rpc if they are also server.
        /// </summary>
        public bool ExcludeServer = false;
        /// <summary>
        /// True to validate the target is possible and output debug when not.
        /// Use this field with caution as it may create undesired results when set to false.
        /// </summary>
        public bool ValidateTarget = true;
        /// <summary>
        /// Type of logging to use when the IsServer check fails.
        /// </summary>
        public LoggingType Logging = LoggingType.Warning;
    }

    /// <summary>
    /// Prevents a method from running if server is not active.
    /// <para>Can only be used inside a NetworkBehaviour</para>
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class ServerAttribute : Attribute
    {
        /// <summary>
        /// Type of logging to use when the IsServer check fails.
        /// </summary>
        public LoggingType Logging = LoggingType.Warning;
        /// <summary>
        /// False to prefer using networkObject.IsServer/ClientInitialized. True to use InstanceFinder.IsServer/ClientStarted.
        /// </summary>
        public bool UseIsStarted = false;
    }

    /// <summary>
    /// Prevents this method from running if client is not active.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class ClientAttribute : Attribute
    {
        /// <summary>
        /// Type of logging to use when the IsClient check fails.
        /// </summary>
        public LoggingType Logging = LoggingType.Warning;
        /// <summary>
        /// True to only allow a client to run the method if they are owner of the object.
        /// </summary>
        public bool RequireOwnership = false;
        /// <summary>
        /// False to prefer using networkObject.IsServer/ClientInitialized. True to use InstanceFinder.IsServer/ClientStarted.
        /// </summary>
        public bool UseIsStarted = false;
    }
}


namespace FishNet.Object.Synchronizing
{

    /// <summary>
    /// Synchronizes collections or objects from the server to clients. Can be used with custom SyncObjects.
    /// Value must be changed on server.
    /// </summary>
    [Obsolete("This no longer functions. See console errors and Break Solutions in the documentation for resolution.")]
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public class SyncObjectAttribute : PropertyAttribute
    {
        /// <summary>
        /// How often values may update over the network.
        /// </summary>
        public float SendRate = 0.1f;
        /// <summary>
        /// Clients which may receive value updates.
        /// </summary>
        public ReadPermission ReadPermissions = ReadPermission.Observers;
        /// <summary>
        /// Network roles which may update values.
        /// </summary>
        public WritePermission WritePermissions = WritePermission.ServerOnly;
        /// <summary>
        /// True if to require the readonly attribute.
        /// Setting to false will allow inspector serialization of this object. When false you must still initialize this object on it's field declaration, but never anywhere else.
        /// </summary>
        public bool RequireReadOnly = true;
    }

    /// <summary>
    /// Synchronizes a variable from server to clients automatically.
    /// Value must be changed on server.
    /// </summary>
    [Obsolete("This no longer functions. Use SyncVar<Type> instead. See console errors and Break Solutions in the documentation for resolution.")]
    [AttributeUsage(AttributeTargets.Field, Inherited = true, AllowMultiple = false)]
    public class SyncVarAttribute : PropertyAttribute
    {
        /// <summary>
        /// How often values may update over the network.
        /// </summary>
        public float SendRate = 0.1f;
        /// <summary>
        /// Clients which may receive value updates.
        /// </summary>
        public ReadPermission ReadPermissions = ReadPermission.Observers;
        /// <summary>
        /// Network roles which may update values.
        /// </summary>
        public WritePermission WritePermissions = WritePermission.ServerOnly;
        /// <summary>
        /// Channel to use. Unreliable SyncVars will use eventual consistency.
        /// </summary>
        public Channel Channel;
        ///<summary>
        /// Method which will be called on the server and clients when the value changes.
        ///</summary>
        public string OnChange;
    }

}
﻿using FishNet.Connection;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]
namespace FishNet.Object.Delegating
{
    public delegate void ServerRpcDelegate(PooledReader reader, Channel channel, NetworkConnection sender);
    public delegate void ClientRpcDelegate(PooledReader reader, Channel channel);
    public delegate bool SyncVarReadDelegate(PooledReader reader, byte index, bool asServer);
}
﻿
namespace FishNet.Object
{
    /// <summary>
    /// This may be added at runtime to find objects without any network scripts, beneath a NetworkObject.
    /// </summary>
    public class EmptyNetworkBehaviour : NetworkBehaviour
    {

    }


}﻿using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object
{
    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// True if OnStartServer has been called.
        /// </summary>
        [APIExclude]
        public bool OnStartServerCalled { get; private set; }
        /// <summary>
        /// True if OnStartClient has been called.
        /// </summary>
        [APIExclude]
        public bool OnStartClientCalled { get; private set; }
        #endregion

        #region Private.
        /// <summary>
        /// True if OnStartNetwork has been called.
        /// </summary>
        private bool _onStartNetworkCalled;
        /// <summary>
        /// True if OnStopNetwork has been called.
        /// </summary>
        private bool _onStopNetworkCalled;
        #endregion

        /* Payloads are written and read immediatley after the header containing the target NetworkObject/Behaviour. */
        /// <summary>
        /// Called when writing a spawn. This may be used to deliver information for predicted spawning, or simply have values set before initialization without depending on SyncTypes.
        /// </summary>
        /// <param name="connection">Connection receiving the payload. When sending to the server connection.IsValid will return false.</param>
        public virtual void WritePayload(NetworkConnection connection, Writer writer) { }

        /// <summary>
        /// Called before network start callbacks, but after the object is initialized with network values. This may be used to read information from predicted spawning, or simply have values set before initialization without depending on SyncTypes.
        /// </summary>
        /// <param name="connection">Connection sending the payload. When coming from the server connection.IsValid will return false.</param>
        public virtual void ReadPayload(NetworkConnection connection, Reader reader) { }

        /// <summary>
        /// Invokes OnStartXXXX for synctypes, letting them know the NetworkBehaviour start cycle has been completed.
        /// </summary>
        internal void InvokeSyncTypeOnStartCallbacks(bool asServer)
        {
            foreach (SyncBase item in _syncTypes.Values)
                item.OnStartCallback(asServer);
        }

        /// <summary>
        /// Invokes OnStopXXXX for synctypes, letting them know the NetworkBehaviour stop cycle is about to start.
        /// </summary>
        internal void InvokeSyncTypeOnStopCallbacks(bool asServer)
        {
            // if (_syncTypes == null)
            //     return;
            foreach (SyncBase item in _syncTypes.Values)
                item.OnStopCallback(asServer);
        }

        /// <summary>
        /// Invokes the OnStart/StopNetwork.
        /// </summary>
        internal void InvokeOnNetwork_Internal(bool start)
        {
            if (start)
            {
                if (_onStartNetworkCalled)
                    return;

                if (!gameObject.activeInHierarchy)
                {
                    NetworkInitialize___Early();
                    NetworkInitialize___Late();
                }
                OnStartNetwork_Internal();
            }
            else
            {
                if (_onStopNetworkCalled)
                    return;
                OnStopNetwork_Internal();
            }
        }

        internal virtual void OnStartNetwork_Internal()
        {
            _onStartNetworkCalled = true;
            _onStopNetworkCalled = false;
            OnStartNetwork();
        }

        /// <summary>
        /// Called when the network has initialized this object. May be called for server or client but will only be called once.
        /// When as host or server this method will run before OnStartServer. 
        /// When as client only the method will run before OnStartClient.
        /// </summary>
        public virtual void OnStartNetwork() { }

        internal virtual void OnStopNetwork_Internal()
        {
            _onStopNetworkCalled = true;
            _onStartNetworkCalled = false;

            OnStopNetwork();
        }

        /// <summary>
        /// Called when the network is deinitializing this object. May be called for server or client but will only be called once.
        /// When as host or server this method will run after OnStopServer.
        /// When as client only this method will run after OnStopClient.
        /// </summary>
        public virtual void OnStopNetwork() { }

        internal void OnStartServer_Internal()
        {
            OnStartServerCalled = true;
            OnStartServer();
        }

        /// <summary>
        /// Called on the server after initializing this object.
        /// SyncTypes modified before or during this method will be sent to clients in the spawn message.
        /// </summary> 
        public virtual void OnStartServer() { }

        internal void OnStopServer_Internal()
        {
            OnStartServerCalled = false;
            ReturnRpcLinks();
            OnStopServer();
        }

        /// <summary>
        /// Called on the server before deinitializing this object.
        /// </summary>
        public virtual void OnStopServer() { }

        internal void OnOwnershipServer_Internal(NetworkConnection prevOwner)
        {
            ResetState_Prediction(true);
            OnOwnershipServer(prevOwner);
        }

        /// <summary>
        /// Called on the server after ownership has changed.
        /// </summary>
        /// <param name="prevOwner">Previous owner of this object.</param>
        public virtual void OnOwnershipServer(NetworkConnection prevOwner) { }

        /// <summary>
        /// Called on the server after a spawn message for this object has been sent to clients.
        /// Useful for sending remote calls or data to clients.
        /// </summary>
        /// <param name="connection">Connection the object is being spawned for.</param>
        public virtual void OnSpawnServer(NetworkConnection connection) { }

        /// <summary>
        /// Called on the server before a despawn message for this object has been sent to connection.
        /// Useful for sending remote calls or actions to clients.
        /// </summary>
        public virtual void OnDespawnServer(NetworkConnection connection) { }

        internal void OnStartClient_Internal()
        {
            OnStartClientCalled = true;
            OnStartClient();
        }

        /// <summary>
        /// Called on the client after initializing this object.
        /// </summary>
        public virtual void OnStartClient() { }

        internal void OnStopClient_Internal()
        {
            OnStartClientCalled = false;
            OnStopClient();
        }

        /// <summary>
        /// Called on the client before deinitializing this object.
        /// </summary>
        public virtual void OnStopClient() { }

        internal void OnOwnershipClient_Internal(NetworkConnection prevOwner)
        {
            //If losing or gaining ownership then clear replicate cache.
            if (IsOwner || prevOwner == LocalConnection)
            {
                ResetState_Prediction(false);
            }

            OnOwnershipClient(prevOwner);
        }

        /// <summary>
        /// Called on the client after gaining or losing ownership.
        /// </summary>
        /// <param name="prevOwner">Previous owner of this object.</param>
        public virtual void OnOwnershipClient(NetworkConnection prevOwner) { }
    }
}﻿using FishNet.CodeGenerating;
using FishNet.Documenting;
using FishNet.Managing.Transporting;
using FishNet.Serializing.Helping;
using FishNet.Utility;
using System.Runtime.CompilerServices;
using FishNet.Managing;
using UnityEngine;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]

namespace FishNet.Object
{
    /// <summary>
    /// Scripts which inherit from NetworkBehaviour can be used to gain insight of, and perform actions on the network.
    /// </summary>
    [ExcludeSerialization]
    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// True if this NetworkBehaviour is initialized for the network.
        /// </summary>
        public bool IsSpawned => _networkObjectCache.IsSpawned;

        /// <summary>
        /// 
        /// </summary>
        [SerializeField, HideInInspector]
        private byte _componentIndexCache = NetworkBehaviour.UNSET_NETWORKBEHAVIOUR_ID;
        /// <summary>
        /// ComponentIndex for this NetworkBehaviour.
        /// </summary>
        public byte ComponentIndex
        {
            get => _componentIndexCache;
            private set => _componentIndexCache = value;
        }
#if UNITY_EDITOR
        /// <summary>
        /// NetworkObject automatically added or discovered during edit time.
        /// </summary>
        [SerializeField, HideInInspector]
        private NetworkObject _addedNetworkObject;
#endif
        /// <summary>
        /// Cache of the TransportManager.
        /// </summary>
        private TransportManager _transportManagerCache;
        /// <summary>
        /// 
        /// </summary>
        [SerializeField, HideInInspector]
        private NetworkObject _networkObjectCache;

        /// <summary>
        /// NetworkObject this behaviour is for.
        /// </summary>
        public NetworkObject NetworkObject => _networkObjectCache;
        #endregion

        #region Private.
        /// <summary>
        /// True if initialized at some point asServer.
        /// </summary>
        private bool _initializedOnceServer;
#pragma warning disable CS0414
        /// <summary>
        /// True if initialized at some point not asServer.
        /// </summary>
        private bool _initializedOnceClient;
#pragma warning restore CS0414
        #endregion

        #region Consts.
        /// <summary>
        /// Maximum number of allowed added NetworkBehaviours.
        /// </summary>
        public const byte MAXIMUM_NETWORKBEHAVIOURS = (UNSET_NETWORKBEHAVIOUR_ID - 1);
        /// <summary>
        /// Id for when a NetworkBehaviour is not valid.
        /// </summary>
        public const byte UNSET_NETWORKBEHAVIOUR_ID = byte.MaxValue;
        #endregion

        /// <summary>
        /// Outputs data about this NetworkBehaviour to string.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return $"Name [{gameObject.name}] ComponentId [{ComponentIndex}] NetworkObject Name [{_networkObjectCache.name}] NetworkObject Id [{_networkObjectCache.ObjectId}]";
        }

        [MakePublic]
        internal virtual void NetworkInitialize___Early() { }
        [MakePublic]
        internal virtual void NetworkInitialize___Late() { }


        /// <summary>
        /// Preinitializes this script for the network.
        /// </summary>
        internal void InitializeEarly(NetworkObject nob, bool asServer)
        {
            _transportManagerCache = nob.TransportManager;
            SyncTypes_Preinitialize(asServer);

            if (asServer)
            {
                InitializeRpcLinks();
                _initializedOnceServer = true;
            }
            else
            {
                if (!_initializedOnceClient && nob.EnablePrediction && _usesPrediction) 
                    nob.RegisterPredictionBehaviourOnce(this);

                _initializedOnceClient = true;
            }
        }

        internal void Deinitialize(bool asServer)
        {
            ResetState_SyncTypes(asServer);
        }

        /// <summary>
        /// Called by the NetworkObject when this object is destroyed.
        /// </summary>
        internal void NetworkBehaviour_OnDestroy()
        {
            SyncTypes_OnDestroy();
        }

        /// <summary>
        /// Serializes information for network components.
        /// </summary>
        internal void SerializeComponents(NetworkObject nob, byte componentIndex)
        {
            _networkObjectCache = nob;
            ComponentIndex = componentIndex;
        }

        /// <summary>
        /// Manually initializes network content for the NetworkBehaviour if the object it's on is disabled.
        /// </summary>
        internal void InitializeIfDisabled()
        {
            if (gameObject.activeInHierarchy)
                return;

            NetworkInitializeIfDisabled();
        }

        /// <summary>
        /// Long name is to prevent users from potentially creating their own method named the same.
        /// </summary>
        [MakePublic]
        [APIExclude]
        internal virtual void NetworkInitializeIfDisabled() { }

        #region Editor.
        protected virtual void Reset()
        {
#if UNITY_EDITOR
            if (Application.isPlaying)
                return;

            TryAddNetworkObject();
#endif
        }

        protected virtual void OnValidate()
        {
#if UNITY_EDITOR
            if (Application.isPlaying)
                return;

            TryAddNetworkObject();
#endif
        }

        /// <summary>
        /// Resets this NetworkBehaviour so that it may be added to an object pool.
        /// </summary>
        public virtual void ResetState(bool asServer)
        {
            ResetState_SyncTypes(asServer);
            ResetState_Prediction(asServer);
            ClearReplicateCache();
            ClearBuffedRpcs();
        }

        /// <summary>
        /// Tries to add the NetworkObject component.
        /// </summary>
        private NetworkObject TryAddNetworkObject()
        {
#if UNITY_EDITOR
            if (Application.isPlaying)
                return _addedNetworkObject;

            if (_addedNetworkObject != null)
            {
                AlertToDuplicateNetworkObjects(_addedNetworkObject.transform);
                return _addedNetworkObject;
            }

            /* Manually iterate up the chain because GetComponentInParent doesn't
             * work when modifying prefabs in the inspector. Unity, you're starting
             * to suck a lot right now. */
            NetworkObject result = null;
            Transform climb = transform;

            while (climb != null)
            {
                if (climb.TryGetComponent(out result))
                    break;
                else
                    climb = climb.parent;
            }

            if (result != null)
            {
                _addedNetworkObject = result;
            }
            //Not found, add a new nob.
            else
            {
                _addedNetworkObject = transform.root.gameObject.AddComponent<NetworkObject>();
                NetworkManagerExtensions.Log($"Script {GetType().Name} on object {gameObject.name} added a NetworkObject component to {transform.root.name}.");
            }

            AlertToDuplicateNetworkObjects(_addedNetworkObject.transform);
            return _addedNetworkObject;

            //Removes duplicate network objects from t.
            void AlertToDuplicateNetworkObjects(Transform t)
            {
                NetworkObject[] nobs = t.GetComponents<NetworkObject>();
                //This shouldn't be possible but does occur sometimes; maybe a unity bug?
                if (nobs.Length > 1)
                {
                    //Update added to first entryt.
                    _addedNetworkObject = nobs[0];

                    string useMenu = " You may also use the Fish-Networking menu to automatically remove duplicate NetworkObjects.";
                    string sceneName = t.gameObject.scene.name;
                    if (string.IsNullOrEmpty(sceneName))
                        Debug.LogError($"Prefab {t.name} has multiple NetworkObject components. Please remove the extra component(s) to prevent errors.{useMenu}");
                    else
                        Debug.LogError($"Object {t.name} in scene {sceneName} has multiple NetworkObject components. Please remove the extra component(s) to prevent errors.{useMenu}");
                }
            }
#else
            return null;
#endif
        }
        #endregion
    }
}﻿using FishNet.Managing;
using FishNet.Managing.Logging;
using UnityEngine;

namespace FishNet.Object
{

    public abstract partial class NetworkBehaviour : MonoBehaviour
    {

        /// <summary>
        /// True if can log for loggingType.
        /// </summary>
        /// <param name="loggingType">Type of logging being filtered.</param>
        /// <returns></returns>
        public bool CanLog(LoggingType loggingType)
        {
            return NetworkManager.CanLog(loggingType);
        }
    }


}﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.CodeGenerating;
using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Predicting;
using FishNet.Managing.Server;
using FishNet.Managing.Timing;
using FishNet.Object.Prediction;
using FishNet.Object.Prediction.Delegating;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using FishNet.Utility;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using GameKit.Dependencies.Utilities.Types;
using UnityEngine;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]

namespace FishNet.Object
{
    #region Types.
    internal static class ReplicateTickFinder
    {
        public enum DataPlacementResult
        {
            /// <summary>
            /// Something went wrong; this should never be returned.
            /// </summary>
            Error,
            /// <summary>
            /// Tick was found on an index.
            /// </summary>
            Exact,
            /// <summary>
            /// Tick was not found because it is lower than any of the replicates.
            /// This is also used when there are no datas.
            /// </summary>
            InsertBeginning,
            /// <summary>
            /// Tick was not found but can be inserted in the middle of the collection.
            /// </summary>
            InsertMiddle,
            /// <summary>
            /// Tick was not found because it is larger than any of the replicates.
            /// </summary>
            InsertEnd,
        }

        /// <summary>
        /// Gets the index in replicates where the tick matches.
        /// </summary>
        public static int GetReplicateHistoryIndex<T>(uint tick, RingBuffer<ReplicateDataContainer<T>> replicatesHistory, out DataPlacementResult findResult) where T : IReplicateData, new()
        {
            int replicatesCount = replicatesHistory.Count;
            if (replicatesCount == 0)
            {
                findResult = DataPlacementResult.InsertBeginning;
                return 0;
            }

            uint firstTick = replicatesHistory[0].Data.GetTick();

            //Try to find by skipping ahead the difference between tick and start.
            int diff = (int)(tick - firstTick);
            /* If the difference is larger than replicatesCount
             * then that means the replicates collection is missing
             * entries. EG if replicates values were 4, 7, 10 and tick were
             * 10 the difference would be 6. While replicates does contain the value
             * there is no way it could be found by pulling index 'diff' since that
             * would be out of bounds. This should never happen under normal conditions, return
             * missing if it does. */
            //Do not need to check less than 0 since we know if here tick is larger than first entry.
            if (diff >= replicatesCount)
            {
                //Try to return value using brute force.
                int index = FindIndexBruteForce(out findResult);
                return index;
            }
            else if (diff < 0)
            {
                findResult = DataPlacementResult.InsertBeginning;
                return 0;
            }
            else
            {
                /* If replicatesHistory contained the ticks
                 * of 1 2 3 4 5, and the tick is 3, then the difference
                 * would be 2 (because 3 - 1 = 2). As we can see index
                 * 2 of replicatesHistory does indeed return the proper tick. */
                //Expected diff to be result but was not.
                if (replicatesHistory[diff].Data.GetTick() != tick)
                {
                    //Try to return value using brute force.
                    int index = FindIndexBruteForce(out findResult);
                    return index;
                }
                //Exact was found, this is the most ideal situation.
                else
                {
                    findResult = DataPlacementResult.Exact;
                    return diff;
                }
            }

            //Tries to find the index by brute forcing the collection.
            int FindIndexBruteForce(out DataPlacementResult result)
            {
                /* Some quick exits to save perf. */
                //If tick is lower than first then it must be inserted at the beginning.
                if (tick < firstTick)
                {
                    result = DataPlacementResult.InsertBeginning;
                    return 0;
                }
                //If tick is larger the last then it must be inserted at the end.
                else if (tick > replicatesHistory[replicatesCount - 1].Data.GetTick())
                {
                    result = DataPlacementResult.InsertEnd;
                    return replicatesCount;
                }
                else
                {
                    //Brute check.
                    for (int i = 0; i < replicatesCount; i++)
                    {
                        uint lTick = replicatesHistory[i].Data.GetTick();
                        //Exact match found.
                        if (lTick == tick)
                        {
                            result = DataPlacementResult.Exact;
                            return i;
                        }
                        /* The checked data is greater than
                         * what was being searched. This means
                         * to insert right before it. */
                        else if (lTick > tick)
                        {
                            result = DataPlacementResult.InsertMiddle;
                            return i;
                        }
                    }

                    //Should be impossible to get here.
                    result = DataPlacementResult.Error;
                    return -1;
                }
            }
        }
    }

    //See todo below.
    /* Update codegen to remove arrBuffer from replicate method calls.
     * Update codegen to remove channel from replicate method calls where applicable.
     * Convert BasicQueue<T>/RingBuffer<T> to BasicQueue/RingBuffer<ReplicateData<T>>.
     * */
    #endregion

    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// True if this NetworkBehaviour is reconciling.
        /// If this NetworkBehaviour does not implemnent prediction methods this value will always be false.
        /// Value will be false if there is no data to reconcile to, even if the PredictionManager IsReconciling.
        /// Data may be missing if it were intentionally not sent, or due to packet loss.
        /// </summary>
        public bool IsBehaviourReconciling { get; internal set; }
        #endregion

        #region Private.
        /// <summary>
        /// Registered Replicate methods.
        /// </summary>
        private Dictionary<uint, ReplicateRpcDelegate> _replicateRpcDelegates;
        /// <summary>
        /// Registered Reconcile methods.
        /// </summary>
        private Dictionary<uint, ReconcileRpcDelegate> _reconcileRpcDelegates;
        /// <summary>
        /// Number of replicate resends which may occur.
        /// </summary>
        private int _remainingReplicateResends;
        /// <summary>
        /// Number of reconcile resends which may occur.
        /// </summary>
        private int _remainingReconcileResends;
        /// <summary>
        /// Last replicate tick read from remote. This can be the server reading a client or the other way around.
        /// </summary>
        private uint _lastReplicateReadRemoteTick = TimeManager.UNSET_TICK;
        /// <summary>
        /// Tick when replicates should begun to run. This is set and used when inputs are just received and need to queue to create a buffer.
        /// </summary>
        private uint _replicateStartTick = TimeManager.UNSET_TICK;
        /// <summary>
        /// Last tick to replicate which was not replayed.
        /// </summary>
        private uint _lastOrderedReplicatedTick = TimeManager.UNSET_TICK;
        /// <summary>
        /// Last tick read for a replicate.
        /// </summary>
        private uint _lastReadReplicateTick = TimeManager.UNSET_TICK;
        /// <summary>
        /// Last tick read for a reconcile. This is only set on the client.
        /// </summary>
        private uint _lastReadReconcileRemoteTick = TimeManager.UNSET_TICK;
        /// <summary>
        /// Last tick this object reconciled on.
        /// </summary>
        private uint _lastReconcileTick = TimeManager.UNSET_TICK;
        /// <summary>
        /// Last values when checking for transform changes since previous tick.
        /// </summary>
        private Vector3 _lastTransformPosition;
        /// <summary>
        /// Last values when checking for transform changes since previous tick.
        /// </summary>
        private Quaternion _lastTransformRotation;
        /// <summary>
        /// Last values when checking for transform changes since previous tick.
        /// </summary>
        private Vector3 _lastTransformScale;
        /// <summary>
        /// True if this Networkbehaviour implements prediction methods.
        /// </summary>
        [APIExclude]
        private bool _usesPrediction;
        #endregion

        /// <summary>
        /// Initializes the NetworkBehaviour for prediction.
        /// </summary>
        internal void Preinitialize_Prediction(bool asServer) { }

        /// <summary>
        /// Deinitializes the NetworkBehaviour for prediction.
        /// </summary>
        internal void Deinitialize_Prediction(bool asServer) { }

        /// <summary>
        /// Called when the object is destroyed.
        /// </summary>
        internal void OnDestroy_Prediction()
        {
            CollectionCaches<uint, ReplicateRpcDelegate>.StoreAndDefault(ref _replicateRpcDelegates);
            CollectionCaches<uint, ReconcileRpcDelegate>.StoreAndDefault(ref _reconcileRpcDelegates);
        }

        /// <summary>
        /// Registers a RPC method.
        /// Internal use.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="del"></param>
        [MakePublic]
        internal void RegisterReplicateRpc(uint hash, ReplicateRpcDelegate del)
        {
            _usesPrediction = true;

            if (_replicateRpcDelegates == null)
                _replicateRpcDelegates = CollectionCaches<uint, ReplicateRpcDelegate>.RetrieveDictionary();
            _replicateRpcDelegates[hash] = del;
        }

        /// <summary>
        /// Registers a RPC method.
        /// Internal use.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="del"></param>
        [MakePublic]
        internal void RegisterReconcileRpc(uint hash, ReconcileRpcDelegate del)
        {
            if (_reconcileRpcDelegates == null)
                _reconcileRpcDelegates = CollectionCaches<uint, ReconcileRpcDelegate>.RetrieveDictionary();
            _reconcileRpcDelegates[hash] = del;
        }

        /// <summary>
        /// Called when a replicate is received.
        /// </summary>
        internal void OnReplicateRpc(uint? methodHash, PooledReader reader, NetworkConnection sendingClient, Channel channel)
        {
            if (methodHash == null)
                methodHash = ReadRpcHash(reader);

            reader.NetworkManager = _networkObjectCache.NetworkManager;

            if (_replicateRpcDelegates.TryGetValueIL2CPP(methodHash.Value, out ReplicateRpcDelegate del))
                del.Invoke(reader, sendingClient, channel);
            else
                _networkObjectCache.NetworkManager.LogWarning($"Replicate not found for hash {methodHash.Value} on {gameObject.name}, behaviour {GetType().Name}. Remainder of packet may become corrupt.");
        }

        /// <summary>
        /// Called when a reconcile is received.
        /// </summary>
        internal void OnReconcileRpc(uint? methodHash, PooledReader reader, Channel channel)
        {
            if (methodHash == null)
                methodHash = ReadRpcHash(reader);

            reader.NetworkManager = _networkObjectCache.NetworkManager;

            if (_reconcileRpcDelegates.TryGetValueIL2CPP(methodHash.Value, out ReconcileRpcDelegate del))
                del.Invoke(reader, channel);
            else
                _networkObjectCache.NetworkManager.LogWarning($"Reconcile not found for hash {methodHash.Value}. Remainder of packet may become corrupt.");
        }

        /// <summary>
        /// Resets cached ticks used by prediction, such as last read and replicate tick.
        /// This is generally used when the ticks will be different then what was previously used; eg: when ownership changes.
        /// </summary>
        private void ResetState_Prediction(bool asServer)
        {
            if (!asServer)
            {
                _lastReadReconcileRemoteTick = TimeManager.UNSET_TICK;
                _lastReconcileTick = TimeManager.UNSET_TICK;
            }

            _lastOrderedReplicatedTick = TimeManager.UNSET_TICK;
            _lastReplicateReadRemoteTick = TimeManager.UNSET_TICK;
            _lastReadReplicateTick = TimeManager.UNSET_TICK;

            ClearReplicateCache();
        }

        /// <summary>
        /// Clears cached replicates for server and client. This can be useful to call on server and client after teleporting.
        /// </summary>
        public virtual void ClearReplicateCache() { }

        /// <summary>
        /// Clears cached replicates and histories.
        /// </summary>
        [MakePublic]
        internal void ClearReplicateCache_Internal<T, T2>(BasicQueue<ReplicateDataContainer<T>> replicatesQueue, RingBuffer<ReplicateDataContainer<T>> replicatesHistory, RingBuffer<LocalReconcile<T2>> reconcilesHistory, ref T lastReadReplicate, ref T2 lastReadReconcile) where T : IReplicateData, new() where T2 : IReconcileData, new()
        {
            while (replicatesQueue.Count > 0)
            {
                ReplicateDataContainer<T> dataContainer = replicatesQueue.Dequeue();
                dataContainer.Dispose();
            }

            if (lastReadReplicate != null)
                lastReadReplicate.Dispose();
            lastReadReplicate = default;
            
            if (lastReadReconcile != null)
                lastReadReconcile.Dispose();
            lastReadReconcile = default;

            for (int i = 0; i < replicatesHistory.Count; i++)
            {
                ReplicateDataContainer<T> dataContainer = replicatesHistory[i];
                dataContainer.Dispose();
            }
            replicatesHistory.Clear();

            ClearReconcileHistory(reconcilesHistory);
        }

        /// <summary>
        /// Sends a RPC to target.
        /// Internal use.
        /// </summary>
        [MakePublic]
        private void Server_SendReconcileRpc<T>(uint hash, ref T lastReconcileData, T reconcileData, Channel channel) where T : IReconcileData
        {
            if (!IsSpawned)
                return;

            //If channel is reliable set remaining resends to 1.
            if (channel == Channel.Reliable)
                _remainingReconcileResends = 1;

            if (_remainingReconcileResends == 0)
                return;
            _remainingReconcileResends--;

            //No owner and no state forwarding, nothing to do.
            bool stateForwarding = _networkObjectCache.EnableStateForwarding;
            if (!Owner.IsValid && !stateForwarding)
                return;

            /* Set the channel for Rpcs to reliable to that the length
             * is written. The data does not actually send reliable, unless
             * the channel is of course that to start. */
            /* This is a temporary solution to resolve an issue which was
             * causing parsing problems due to states sending unreliable and reliable
             * headers being written, or sending reliably and unreliable headers being written.
             * Using an extra byte to write length is more preferred than always forcing reliable
             * until properly resolved. */
            const Channel rpcChannel = Channel.Reliable;

            PooledWriter methodWriter = WriterPool.Retrieve();
            /* Tick does not need to be written because it will always
             * be the localTick of the server. For the clients, this will
             * be the LastRemoteTick of the packet.
             *
             * The exception is for the owner, which we send the last replicate
             * tick so the owner knows which to roll back to. */

//#if !FISHNET_STABLE_SYNCTYPES
#if DO_NOT_USE
            methodWriter.WriteDeltaReconcile(lastReconcileData, reconcileData, GetDeltaSerializeOption());
#else
            methodWriter.WriteReconcile<T>(reconcileData);
#endif
            lastReconcileData = reconcileData;

            PooledWriter writer;
#if DEVELOPMENT
            if (!NetworkManager.DebugManager.DisableReconcileRpcLinks && _rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
#else
			if (_rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
#endif
                writer = CreateLinkedRpc(link, methodWriter, rpcChannel);
            else
                writer = CreateRpc(hash, methodWriter, PacketId.Reconcile, rpcChannel);

            //If state forwarding is not enabled then only send to owner.
            if (!stateForwarding)
            {
                Owner.WriteState(writer);
            }
            //State forwarding, send to all.
            else
            {
                foreach (NetworkConnection nc in Observers)
                    nc.WriteState(writer);
            }

            methodWriter.Store();
            writer.Store();
        }

        /// <summary> 
        /// Returns if there is a chance the transform may change after the tick.
        /// </summary>
        /// <returns></returns>
        private bool TransformChanged()
        {
            if (TimeManager.PhysicsMode == PhysicsMode.Disabled)
                return false;

            /* Use distance when checking if changed because rigidbodies can twitch
             * or move an extremely small amount. These small moves are not worth
             * resending over because they often fix themselves each frame. */
            float changeDistance = 0.000004f;

            bool anyChanged = false;
            anyChanged |= (transform.position - _lastTransformPosition).sqrMagnitude > changeDistance;
            if (!anyChanged)
                anyChanged |= (transform.rotation.eulerAngles - _lastTransformRotation.eulerAngles).sqrMagnitude > changeDistance;
            if (!anyChanged)
                anyChanged |= (transform.localScale - _lastTransformScale).sqrMagnitude > changeDistance;

            //If transform changed update last values.
            if (anyChanged)
            {
                _lastTransformPosition = transform.position;
                _lastTransformRotation = transform.rotation;
                _lastTransformScale = transform.localScale;
            }

            return anyChanged;
        }

        /// <summary>
        /// Performs a replicate for current tick.
        /// </summary>
        [MakePublic]
        internal void Replicate_Current<T>(ReplicateUserLogicDelegate<T> del, uint methodHash, BasicQueue<ReplicateDataContainer<T>> replicatesQueue, RingBuffer<ReplicateDataContainer<T>> replicatesHistory, ReplicateDataContainer<T> dataContainer) where T : IReplicateData, new()
        {
            /* Do not run if currently reconciling.
             * This change allows devs to call inherited replicates
             * from replays to only run the method logic without
             * prompting for network action. */
            if (_networkObjectCache.PredictionManager.IsReconciling)
                return;

            if (_networkObjectCache.IsController)
                Replicate_Authoritative(del, methodHash, replicatesHistory, dataContainer);
            else
                Replicate_NonAuthoritative(del, replicatesQueue, replicatesHistory);
        }

        /// <summary>
        /// Returns if a replicates data changed and updates resends as well data tick.
        /// </summary>
        /// <param name="enqueueData">True to enqueue data for replaying.</param>
        /// <returns>True if data has changed..</returns>
        private void Replicate_Authoritative<T>(ReplicateUserLogicDelegate<T> del, uint methodHash, RingBuffer<ReplicateDataContainer<T>> replicatesHistory, ReplicateDataContainer<T> dataContainer) where T : IReplicateData, new()
        {
            bool ownerlessAndServer = (!Owner.IsValid && IsServerStarted);
            if (!IsOwner && !ownerlessAndServer)
                return;

            Func<T, bool> isDefaultDel = PublicPropertyComparer<T>.IsDefault;
            if (isDefaultDel == null)
            {
                NetworkManager.LogError($"{nameof(PublicPropertyComparer<T>)} not found for type {typeof(T).FullName}");
                return;
            }

            PredictionManager pm = NetworkManager.PredictionManager;
            uint dataTick = TimeManager.LocalTick;

            /* The following code is to remove replicates from replicatesHistory
             * which exceed the buffer allowance. Replicates are kept for up to
             * x seconds to clients can re-run them during a reconcile. The reconcile
             * method removes old histories but given the server does not reconcile,
             * it will never perform that operation.
             * The server would not actually need to keep replicates history except
             * when it is also client(clientHost). This is because the clientHost must
             * send redundancies to other clients still, therefor that redundancyCount
             * must be the allowance when clientHost. */
            if (IsHostStarted)
            {
                int replicatesHistoryCount = replicatesHistory.Count;
                int maxCount = pm.RedundancyCount;
                //Number to remove which is over max count.
                int removeCount = (replicatesHistoryCount - maxCount);
                //If there are any to remove.
                if (removeCount > 0)
                {
                    //Dispose first.
                    for (int i = 0; i < removeCount; i++)
                        replicatesHistory[i].Dispose();

                    //Then remove range.
                    replicatesHistory.RemoveRange(true, removeCount);
                }
            }

            dataContainer.SetDataTick(dataTick);
            AddReplicatesHistory(replicatesHistory, dataContainer);

            //Check to reset resends.
            bool isDefault = isDefaultDel.Invoke(dataContainer.Data);
            bool resetResends = (!isDefault || TransformChanged());

            byte redundancyCount = PredictionManager.RedundancyCount;

            //Standard delta serialize option.
            //+1 to redundancy so lastFirstRead is pushed out to the last actual input when server reads.
            if (resetResends)
            {
                _remainingReplicateResends = redundancyCount;
                _remainingReconcileResends = redundancyCount;
            }

            bool sendData = (_remainingReplicateResends > 0);
            if (sendData)
            {
                /* If not server then send to server.
                 * If server then send to clients. */
                bool toServer = !IsServerStarted;
                Replicate_SendAuthoritative(toServer, methodHash, redundancyCount, replicatesHistory, dataTick, dataContainer.Channel, GetDeltaSerializeOption());
                _remainingReplicateResends--;
            }

            SetReplicateTick(dataTick, createdReplicate: true);

#if !FISHNET_STABLE_REPLICATESTATES
            //Owner always replicates with new data.
            del.Invoke(dataContainer.Data, (ReplicateState.Ticked | ReplicateState.Created), dataContainer.Channel);
#else
            del.Invoke(dataContainer.Data, ReplicateState.CurrentCreated, dataContainer.Channel);
#endif
        }

        /// <summary>
        /// Gets the next replicate in perform when server or non-owning client.
        /// </summary>
        /// </summary>
        private void Replicate_NonAuthoritative<T>(ReplicateUserLogicDelegate<T> del, BasicQueue<ReplicateDataContainer<T>> replicatesQueue, RingBuffer<ReplicateDataContainer<T>> replicatesHistory) where T : IReplicateData, new()
        {
            bool serverStarted = _networkObjectCache.IsServerStarted;
            bool ownerlessAndServer = (!Owner.IsValid && serverStarted);
            if (IsOwner || ownerlessAndServer)
                return;
            /* Still need to run inputs if server, even if forwarding
             * is not enabled.*/
            if (!_networkObjectCache.EnableStateForwarding && !serverStarted)
                return;

            TimeManager tm = _networkObjectCache.TimeManager;
            PredictionManager pm = _networkObjectCache.PredictionManager;
            uint localTick = tm.LocalTick;
            bool isServer = _networkObjectCache.IsServerStarted;
            bool isAppendedOrder = pm.IsAppendedStateOrder;

            //Server is initialized or appended state order.
            if (isServer || isAppendedOrder)
            {
                int count = replicatesQueue.Count;
                /* If count is 0 then data must be set default
                 * and as predicted. */
                if (count == 0)
                {
                    ReplicateDefaultData();
                }
                //Not predicted, is user created.
                else
                {
                    //Check to unset start tick, which essentially voids it resulting in inputs being run immediately.
                    /* As said above, if start tick is unset then replicates
                     * can run. When still set that means the start condition has
                     * not been met yet. */
                    if (localTick >= _replicateStartTick)
                    {
                        _replicateStartTick = TimeManager.UNSET_TICK;
                        ReplicateDataContainer<T> queueEntry;
                        bool queueEntryValid = false;
                        while (replicatesQueue.TryDequeue(out queueEntry))
                        {
                            if (queueEntry.Data.GetTick() > _lastReconcileTick)
                            {
                                queueEntryValid = true;
                                break;
                            }
                        }

                        if (queueEntryValid)
                        {
                            _remainingReconcileResends = pm.RedundancyCount;

#if !FISHNET_STABLE_REPLICATESTATES
                            ReplicateData(queueEntry, (ReplicateState.Ticked | ReplicateState.Created));
#else
                            ReplicateData(queueEntry, ReplicateState.CurrentCreated);
#endif

                            //Update count since old entries were dropped and one replicate run.
                            count = replicatesQueue.Count;

                            bool consumeExcess = (!pm.DropExcessiveReplicates || IsClientOnlyStarted);
                            int leaveInBuffer = _networkObjectCache.PredictionManager.StateInterpolation;

                            //Only consume if the queue count is over leaveInBuffer.
                            if (consumeExcess && count > leaveInBuffer)
                            {
                                const byte maximumAllowedConsumes = 1;
                                int maximumPossibleConsumes = (count - leaveInBuffer);
                                int consumeAmount = Mathf.Min(maximumAllowedConsumes, maximumPossibleConsumes);

                                for (int i = 0; i < consumeAmount; i++)
#if !FISHNET_STABLE_REPLICATESTATES
                                    ReplicateData(replicatesQueue.Dequeue(), (ReplicateState.Ticked | ReplicateState.Created));
#else
                                    ReplicateData(replicatesQueue.Dequeue(), ReplicateState.CurrentCreated);
#endif
                            }
                        }
                    }
                    //Not enough ticks passed yet to run actually data.
                    else
                    {
                        ReplicateDefaultData();
                    }
                }
            }
            //Is client only and not using future state order.
            else
            {
                ReplicateDefaultData();
            }

            //Performs a replicate using default data.
            void ReplicateDefaultData()
            {
                uint tick = (GetDefaultedLastReplicateTick() + 1);
                ReplicateDataContainer<T> dataContainer = ReplicateDataContainer<T>.GetDefault(tick);
#if !FISHNET_STABLE_REPLICATESTATES
                ReplicateData(dataContainer, ReplicateState.Ticked);
#else
                ReplicateData(dataContainer, ReplicateState.CurrentFuture);
#endif
            }

            void ReplicateData(ReplicateDataContainer<T> data, ReplicateState state)
            {
                uint tick = data.Data.GetTick();
#if !FISHNET_STABLE_REPLICATESTATES
                SetReplicateTick(tick, state.ContainsCreated());
#else
                SetReplicateTick(tick, (state == ReplicateState.CurrentCreated));
#endif
                /* If server or appended state order then insert/add to history when run
                 * within this method.
                 * Whether data is inserted/added into the past (replicatesHistory) depends on
                 * if client only && and state order.
                 *
                 * Server only adds onto the history after running the inputs. This is so
                 * the server can send past inputs with redundancy.
                 *
                 * Client inserts into the history under two scenarios:
                 *  - If state order is using inserted. This is done when the data is read so it
                 *  can be iterated during the next reconcile, since the data is not added to
                 *  a queue otherwise. This is what causes the requirement to reconcile to run
                 *  datas.
                 *  - If the state order if using append, and the state just ran. This is so that
                 *  the reconcile does not replay data which hasn't yet run. But, the data should still
                 *  be inserted at point of run so reconciles can correct to the state at the right
                 *  point in history.*/

                //Server always adds.
                if (isServer)
                    AddReplicatesHistory(replicatesHistory, data);
                //If client insert value into history.
                else
                    InsertIntoReplicateHistory(data, replicatesHistory);

                del.Invoke(data.Data, state, data.Channel);
            }

            //Returns a replicate tick for when data is not created.
            uint GetDefaultedLastReplicateTick()
            {
                if (_lastOrderedReplicatedTick == TimeManager.UNSET_TICK)
                    _lastOrderedReplicatedTick = (tm.LastPacketTick.Value() + pm.StateInterpolation);

                return _lastOrderedReplicatedTick;
            }
        }

        /// <summary>
        /// Called internally when an input from localTick should be replayed.
        /// </summary>
        internal virtual void Replicate_Replay_Start(uint replayTick) { }

        /// <summary>
        /// Replays inputs from replicates.
        /// </summary>
        /// <remarks>The server calls this from codegen but it never completes as IsBehaviourReconciling will always be false on server.</remarks>
        [MakePublic]
        internal void Replicate_Replay<T>(uint replayTick, ReplicateUserLogicDelegate<T> del, RingBuffer<ReplicateDataContainer<T>> replicatesHistory) where T : IReplicateData, new()
        {
            //Reconcile data was not received so cannot replay.
            if (!IsBehaviourReconciling)
                return;

            if (_networkObjectCache.IsController)
                Replicate_Replay_Authoritative(replayTick, del, replicatesHistory);
            else
                Replicate_Replay_NonAuthoritative(replayTick, del, replicatesHistory);
        }

        /// <summary>
        /// Replays an input for authoritative entity.
        /// </summary>
        private void Replicate_Replay_Authoritative<T>(uint replayTick, ReplicateUserLogicDelegate<T> del, RingBuffer<ReplicateDataContainer<T>> replicatesHistory) where T : IReplicateData, new()
        {
            ReplicateTickFinder.DataPlacementResult findResult;
            int replicateIndex = ReplicateTickFinder.GetReplicateHistoryIndex(replayTick, replicatesHistory, out findResult);

            ReplicateDataContainer<T> dataContainer;
            ReplicateState state;
            //If found then the replicate has been received by the server.
            if (findResult == ReplicateTickFinder.DataPlacementResult.Exact)
            {
                dataContainer = replicatesHistory[replicateIndex];
#if !FISHNET_STABLE_REPLICATESTATES
                state = (ReplicateState.Replayed | ReplicateState.Ticked | ReplicateState.Created);
#else
                state = ReplicateState.ReplayedCreated;
#endif

                //SetReplicateTick(data.GetTick(), true);
                del.Invoke(dataContainer.Data, state, dataContainer.Channel);
            }
        }

        /// <summary>
        /// Replays an input for non authoritative entity.
        /// </summary>
        [MakePublic]
        private void Replicate_Replay_NonAuthoritative<T>(uint replayTick, ReplicateUserLogicDelegate<T> del, RingBuffer<ReplicateDataContainer<T>> replicatesHistory) where T : IReplicateData, new()
        {
                         
            ReplicateDataContainer<T> dataContainer;
            ReplicateState state;
            bool isAppendedOrder = _networkObjectCache.PredictionManager.IsAppendedStateOrder;
            //If the first replay.
            if (isAppendedOrder || replayTick == (_networkObjectCache.PredictionManager.ServerStateTick + 1))
            {
                ReplicateTickFinder.DataPlacementResult findResult;
                int replicateIndex = ReplicateTickFinder.GetReplicateHistoryIndex(replayTick, replicatesHistory, out findResult);
                //If not found then something went wrong.
                if (findResult == ReplicateTickFinder.DataPlacementResult.Exact)
                {
                    dataContainer = replicatesHistory[replicateIndex];

#if !FISHNET_STABLE_REPLICATESTATES
                    state = ReplicateState.Replayed;

                    bool isCreated = dataContainer.IsCreated;
                    //Set if created.
                    if (isCreated)
                        state |= ReplicateState.Created;
                    /* Ticked will be true if value had ticked outside of reconcile,
                     * or if data is created. It's possible for data to be created
                     * and not yet ticked if state order is inserted rather than append. */
                    if (replayTick <= _lastOrderedReplicatedTick || isCreated)
                        state |= ReplicateState.Ticked;
#else
                    //state = ReplicateState.ReplayedCreated;
                    state = (dataContainer.IsCreated) ? ReplicateState.ReplayedCreated : ReplicateState.ReplayedFuture;
#endif
                }
                else
                {
                    SetDataToDefault();
                }
            }
            //Not the first replay tick.
            else
            {
                SetDataToDefault();
            }

            void SetDataToDefault()
            {
                dataContainer = ReplicateDataContainer<T>.GetDefault(replayTick);
#if !FISHNET_STABLE_REPLICATESTATES
                state = ReplicateState.Replayed;
#else
                state = ReplicateState.ReplayedFuture;
#endif
            }

            del.Invoke(dataContainer.Data, state, dataContainer.Channel);
        }

        /// <summary>
        /// This is overriden by codegen to call EmptyReplicatesQueueIntoHistory().
        /// This should only be called when client only.
        /// </summary>
        [MakePublic]
        internal virtual void EmptyReplicatesQueueIntoHistory_Start() { }

        /// <summary>
        /// Replicates which are enqueued will be removed from the queue and put into replicatesHistory.
        /// This should only be called when client only.
        /// </summary>
        [MakePublic]
        internal void EmptyReplicatesQueueIntoHistory<T>(BasicQueue<ReplicateDataContainer<T>> replicatesQueue, RingBuffer<ReplicateDataContainer<T>> replicatesHistory) where T : IReplicateData, new()
        {
            while (replicatesQueue.TryDequeue(out ReplicateDataContainer<T> data))
                InsertIntoReplicateHistory(data, replicatesHistory);
        }

        /// <summary>
        /// Returns the DeltaSerializeOption to use for the tick.
        /// </summary>
        /// <param name="resendsEnded"></param>
        /// <returns></returns>
        private DeltaSerializerOption GetDeltaSerializeOption()
        {
            uint localTick = _networkObjectCache.TimeManager.LocalTick;
            ushort tickRate = _networkObjectCache.TimeManager.TickRate;
            /* New observers so send a full serialize next replicate.
             * This could go out to only the newly added observers, but it
             * would generate a lot more complexity to save presumably
             * a small amount of occasional bandwidth. */
            if (_networkObjectCache.ObserverAddedTick == localTick)
                return DeltaSerializerOption.FullSerialize;
            //Send full every half a second.
            //else if (localTick % tickRate == 0 || localTick % (tickRate / 2) == 0)
            //     return DeltaSerializerOption.FullSerialize;
            //Send full every second.
            else if (localTick % tickRate == 0)
                return DeltaSerializerOption.FullSerialize;
            //Otherwise return rootSerialize, the default for sending the child most data.
            else
                return DeltaSerializerOption.RootSerialize;
        }

        /// <summary>
        /// Sends a Replicate to server or clients.
        /// </summary>
        private void Replicate_SendAuthoritative<T>(bool toServer, uint hash, int pastInputs, RingBuffer<ReplicateDataContainer<T>> replicatesHistory, uint queuedTick, Channel channel, DeltaSerializerOption deltaOption) where T : IReplicateData, new()
        {
            /* Do not use IsSpawnedWithWarning because the server
             * will still call this a tick or two as clientHost when
             * an owner disconnects. This comes from calling Replicate(default)
             * for the server-side processing in NetworkBehaviours. */
            if (!IsSpawned)
                return;

            int historyCount = replicatesHistory.Count;
            //Nothing to send; should never be possible.
            if (historyCount <= 0)
                return;

            //Number of past inputs to send.
            if (historyCount < pastInputs)
                pastInputs = historyCount;
            /* Where to start writing from. When passed
             * into the writer values from this offset
             * and forward will be written.
             * Always write up to past inputs. */
            int offset = (historyCount - pastInputs);

            //Write history to methodWriter.
            PooledWriter methodWriter = WriterPool.Retrieve(WriterPool.LENGTH_BRACKET);
            /* If going to clients from the server then
             * write the queueTick. */
            if (!toServer)
                methodWriter.WriteTickUnpacked(queuedTick);
//#if !FISHNET_STABLE_SYNCTYPES
#if DO_NOT_USE
            methodWriter.WriteDeltaReplicate(replicatesHistory, offset, deltaOption);
#else
            methodWriter.WriteReplicate<T>(replicatesHistory, offset);
#endif
            _transportManagerCache.CheckSetReliableChannel(methodWriter.Length + MAXIMUM_RPC_HEADER_SIZE, ref channel);
            PooledWriter writer = CreateRpc(hash, methodWriter, PacketId.Replicate, channel);

            /* toServer will never be true if clientHost.
             * When clientHost and here replicates will
             * always just send to clients, while
             * excluding clientHost. */
            if (toServer)
            {
                NetworkManager.TransportManager.SendToServer((byte)channel, writer.GetArraySegment(), splitLargeMessages: true);
            }
            else
            {
                /* If going to clients from server, then only send
                 * if state forwarding is enabled. */
                if (_networkObjectCache.EnableStateForwarding)
                {
                    //Exclude owner and if clientHost, also localClient.
                    _networkConnectionCache.Clear();
                    _networkConnectionCache.Add(Owner);
                    if (IsClientStarted)
                        _networkConnectionCache.Add(ClientManager.Connection);

                    NetworkManager.TransportManager.SendToClients((byte)channel, writer.GetArraySegment(), Observers, _networkConnectionCache, splitLargeMessages: true);
                }
            }

            /* If sending as reliable there is no reason
             * to perform resends, so clear remaining resends. */
            if (channel == Channel.Reliable)
                _remainingReplicateResends = 0;

            methodWriter.StoreLength();
            writer.StoreLength();
        }

        /// <summary>
        /// Reads a replicate the client.
        /// </summary>
        [MakePublic]
        internal void Replicate_Reader<T>(uint hash, PooledReader reader, NetworkConnection sender, ref ReplicateDataContainer<T> lastReadReplicate, BasicQueue<ReplicateDataContainer<T>> replicatesQueue, RingBuffer<ReplicateDataContainer<T>> replicatesHistory, Channel channel) where T : IReplicateData, new()
        {
            /* This will never be received on owner, except in the condition
             * the server is the owner and also a client. In such condition
             * the method is exited after data is parsed. */
            PredictionManager pm = _networkObjectCache.PredictionManager;
            TimeManager tm = _networkObjectCache.TimeManager;
            bool fromServer = (reader.Source == Reader.DataSource.Server);

            uint tick;
            /* If coming from the server then read the tick. Server sends tick
             * if authority or if relaying from another client. The tick which
             * arrives will be the tick the replicate will run on the server. */
            if (fromServer)
                tick = reader.ReadTickUnpacked();
            /* When coming from a client it will always be owner.
             * Client sends out replicates soon as they are run.
             * It's safe to use the LastRemoteTick from the client
             * in addition to QueuedInputs. */
            else
                tick = (tm.LastPacketTick.LastRemoteTick);

//#if !FISHNET_STABLE_SYNCTYPES
#if DO_NOT_USE
            receivedReplicatesCount = reader.ReadDeltaReplicate(lastReadReplicate, ref arrBuffer, tick);
#else
            List<ReplicateDataContainer<T>> readReplicates = reader.ReadReplicate<T>(tick);
#endif
            //Update first read if able.
            if (readReplicates.Count > 0)
            {
                lastReadReplicate.Dispose();
                lastReadReplicate = readReplicates[^1];
            }

            //If received on clientHost simply ignore after parsing data.
            if (fromServer && IsHostStarted)
                return;

            /* Replicate rpc readers relay to this method and
             * do not have an owner check in the generated code.
             * Only server needs to check for owners. Clients
             * should accept the servers data regardless.
             *
             * If coming from a client and that client is not owner then exit. */
            if (!fromServer && !OwnerMatches(sender))
                return;
            //Early exit if old data.
            if (TimeManager.LastPacketTick.LastRemoteTick < _lastReplicateReadRemoteTick)
                return;
            _lastReplicateReadRemoteTick = TimeManager.LastPacketTick.LastRemoteTick;

            //If from a client that is not clientHost do some safety checks.
            if (!fromServer && !Owner.IsLocalClient)
            {
                if (readReplicates.Count > pm.RedundancyCount)
                {
                    sender.Kick(reader, KickReason.ExploitAttempt, LoggingType.Common, $"Connection {sender.ToString()} sent too many past replicates. Connection will be kicked immediately.");
                    return;
                }
            }

            Replicate_EnqueueReceivedReplicate(readReplicates, replicatesQueue, replicatesHistory);
            Replicate_SendNonAuthoritative(hash, replicatesQueue, channel);

            CollectionCaches<ReplicateDataContainer<T>>.Store(readReplicates);
        }

        /// <summary>
        /// Sends data from a reader which only contains the replicate packet.
        /// </summary>
        [MakePublic]
        internal void Replicate_SendNonAuthoritative<T>(uint hash, BasicQueue<ReplicateDataContainer<T>> replicatesQueue, Channel channel) where T : IReplicateData, new()
        {
            if (!IsServerStarted)
                return;
            if (!_networkObjectCache.EnableStateForwarding)
                return;

            int queueCount = replicatesQueue.Count;
            //None to send.
            if (queueCount == 0)
                return;

            //If the only observer is the owner then there is no need to write.
            int observersCount = Observers.Count;
            //Quick exit for no observers other than owner.
            if (observersCount == 0 || (Owner.IsValid && observersCount == 1))
                return;

            PooledWriter methodWriter = WriterPool.Retrieve(WriterPool.LENGTH_BRACKET);

            uint localTick = _networkObjectCache.TimeManager.LocalTick;
            /* Write when the last entry will run.
             *
             * Typically, the last entry will run on localTick + (queueCount - 1).
             * 1 is subtracted from queueCount because in most cases the first entry
             * is going to run same tick.
             * An exception is when the replicateStartTick is set, then there is going
             * to be a delayed based on start tick difference. */
            uint runTickOflastEntry = localTick + ((uint)queueCount - 1);
            //If start tick is set then add on the delay.
            if (_replicateStartTick != TimeManager.UNSET_TICK)
                runTickOflastEntry += (_replicateStartTick - TimeManager.LocalTick);
            //Write the run tick now.
            methodWriter.WriteTickUnpacked(runTickOflastEntry);
            //Write the replicates.
            int redundancyCount = (int)Mathf.Min(_networkObjectCache.PredictionManager.RedundancyCount, queueCount);
//#if !FISHNET_STABLE_SYNCTYPES
#if DO_NOT_USE
            methodWriter.WriteDeltaReplicate(replicatesQueue, redundancyCount, GetDeltaSerializeOption());
#else
            methodWriter.WriteReplicate<T>(replicatesQueue, redundancyCount);
#endif
            PooledWriter writer = CreateRpc(hash, methodWriter, PacketId.Replicate, channel);

            //Exclude owner and if clientHost, also localClient.
            _networkConnectionCache.Clear();
            if (Owner.IsValid)
                _networkConnectionCache.Add(Owner);
            if (IsClientStarted && !Owner.IsLocalClient)
                _networkConnectionCache.Add(ClientManager.Connection);

            NetworkManager.TransportManager.SendToClients((byte)channel, writer.GetArraySegment(), Observers, _networkConnectionCache, false);

            methodWriter.StoreLength();
            writer.StoreLength();
        }

        /// <summary>
        /// Handles a received replicate packet.
        /// </summary>
        private void Replicate_EnqueueReceivedReplicate<T>(List<ReplicateDataContainer<T>> readDatas, BasicQueue<ReplicateDataContainer<T>> replicatesQueue, RingBuffer<ReplicateDataContainer<T>> replicatesHistory) where T : IReplicateData, new()
        {
            int startQueueCount = replicatesQueue.Count;
            /* Owner never gets this for their own object so
             * this can be processed under the assumption data is only
             * handled on unowned objects. */
            PredictionManager pm = PredictionManager;

            bool isServer = _networkObjectCache.IsServerStarted;
            bool isAppendedOrder = pm.IsAppendedStateOrder;

            //Maximum number of replicates allowed to be queued at once.
            int maximmumReplicates = (IsServerStarted) ? pm.GetMaximumServerReplicates() : pm.MaximumPastReplicates;

            for (int i = 0; i < readDatas.Count; i++)
            {
                ReplicateDataContainer<T> dataContainer = readDatas[i];
                dataContainer.IsCreated = true;
                uint tick = dataContainer.Data.GetTick();

                //Skip if old data.
                if (tick <= _lastReadReplicateTick)
                {
                    dataContainer.Dispose();
                    continue;
                }

                _lastReadReplicateTick = tick;

                //Cannot queue anymore, discard oldest.
                if (replicatesQueue.Count > maximmumReplicates)
                {
                    ReplicateDataContainer<T> disposableDataContainer = replicatesQueue.Dequeue();
                    disposableDataContainer.Dispose();
                }

                /* Check if replicate is already in history.
                 * This can occur when the replicate method has a predicted
                 * state for the tick, but a user created replicate comes
                 * through afterward.
                 *
                 * Only perform this check if not the server, since server
                 * does not reconcile it will never use replicatesHistory.
                 *
                 * When clients are also using ReplicateStateOrder.Future the replicates
                 * do not need to be put into the past, as they're always added onto
                 * the end of the queue.
                 *
                 * The server also does not predict replicates in the same way
                 * a client does. When an owner sends a replicate to the server
                 * the server only uses the owner tick to check if it's an old replicate.
                 * But when running the replicate, the server applies it's local tick and
                 * sends that to spectators. */
                //Add automatically if server or future order.
                if (isServer || isAppendedOrder)
                    replicatesQueue.Enqueue(dataContainer);
                //Run checks to replace data if not server.
                else
                    InsertIntoReplicateHistory(dataContainer, replicatesHistory);
            }

            /* If entries are being added after nothing then
             * start the queued inputs delay. Only the server needs
             * to do this since clients implement the queue delay
             * by holding reconcile x ticks rather than not running received
             * x ticks. */
            if ((isServer || isAppendedOrder) && startQueueCount == 0 && replicatesQueue.Count > 0)
                _replicateStartTick = (_networkObjectCache.TimeManager.LocalTick + pm.StateInterpolation);
        }

        /// <summary>
        /// Inserts data into the replicatesHistory collection.
        /// This should only be called when client only.
        /// </summary>
        private void InsertIntoReplicateHistory<T>(ReplicateDataContainer<T> dataContainer, RingBuffer<ReplicateDataContainer<T>> replicatesHistory) where T : IReplicateData, new()
        {
            /* See if replicate tick is in history. Keep in mind
             * this is the localTick from the server, not the localTick of
             * the client which is having their replicate relayed. */
            ReplicateTickFinder.DataPlacementResult findResult;
            int index = ReplicateTickFinder.GetReplicateHistoryIndex(dataContainer.Data.GetTick(), replicatesHistory, out findResult);

            /* Exact entry found. This is the most likely
             * scenario. Client would have already run the tick
             * in the future, and it's now being replaced with
             * the proper data. */
            if (findResult == ReplicateTickFinder.DataPlacementResult.Exact)
            {
                ReplicateDataContainer<T> prevEntry = replicatesHistory[index];
                prevEntry.Dispose();
                replicatesHistory[index] = dataContainer;
            }
            else if (findResult == ReplicateTickFinder.DataPlacementResult.InsertMiddle)
            {
                InsertReplicatesHistory(replicatesHistory, dataContainer, index);
            }
            else if (findResult == ReplicateTickFinder.DataPlacementResult.InsertEnd)
            {
                AddReplicatesHistory(replicatesHistory, dataContainer);
            }

            /* Insert beginning should not happen unless the data is REALLY old.
             * This would mean the network was in an unplayable state. Discard the
             * data. */
            if (findResult == ReplicateTickFinder.DataPlacementResult.InsertBeginning)
                InsertReplicatesHistory(replicatesHistory, dataContainer, 0);
        }

        /// <summary>
        /// Adds to replicate history disposing of old entries if needed.
        /// </summary>
        private void AddReplicatesHistory<T>(RingBuffer<ReplicateDataContainer<T>> replicatesHistory, ReplicateDataContainer<T> value) where T : IReplicateData, new()
        {
            ReplicateDataContainer<T> prev = replicatesHistory.Add(value);
            if (prev.Data != null)
                prev.Dispose();
        }

        /// <summary>
        /// Inserts to replicate history disposing of old entries if needed.
        /// </summary>
        private void InsertReplicatesHistory<T>(RingBuffer<ReplicateDataContainer<T>> replicatesHistory, ReplicateDataContainer<T> value, int index) where T : IReplicateData, new()
        {
            ReplicateDataContainer<T> prev = replicatesHistory.Insert(index, value);
            if (prev.Data != null)
                prev.Dispose();
        }

        /// <summary>
        /// Override this method to create your reconcile data, and call your reconcile method.
        /// </summary>
        public virtual void CreateReconcile() { }

        /// <summary>
        /// Sends a reconcile to clients.
        /// </summary>
        [MakePublic]
        internal void Reconcile_Server<T>(uint methodHash, ref T lastReconcileData, T data, Channel channel) where T : IReconcileData
        {
            //Tick does not need to be set for reconciles since they come in as state updates, which have the tick included globally.
            if (IsServerInitialized)
                Server_SendReconcileRpc(methodHash, ref lastReconcileData, data, channel);
        }

        /// <summary>
        /// This is called when the NetworkBehaviour should perform a reconcile.
        /// Codegen overrides this calling Reconcile_Client with the needed data.
        /// </summary>
        [MakePublic]
        internal virtual void Reconcile_Client_Start() { }

        /// <summary>
        /// Adds a reconcile to local reconcile history.
        /// </summary>
        [MakePublic]
        internal void Reconcile_Client_AddToLocalHistory<T>(RingBuffer<LocalReconcile<T>> reconcilesHistory, T data) where T : IReconcileData
        {
            //Server does not need to store these locally.
            if (_networkObjectCache.IsServerStarted)
                return;
            if (!_networkObjectCache.PredictionManager.CreateLocalStates)
                return;

            /* This is called by the local client when creating
             * a local reconcile state. These states should always
             * be in order, so we will add data to the end
             * of the collection. */

            /* These datas are used to fill missing reconciles
             * be it the packet dropped, server doesnt need to send,
             * or if the player is throttling reconciles. */

            uint tick = _networkObjectCache.PredictionManager.GetCreateReconcileTick(_networkObjectCache.IsOwner);
            //Tick couldn't be retrieved.
            if (tick == TimeManager.UNSET_TICK)
                return;

            data.SetTick(tick);

            //Build LocalReconcile.
            LocalReconcile<T> lr = new();
            lr.Initialize(tick, data);

            reconcilesHistory.Add(lr);
        }

        /// <summary>
        /// Called by codegen with data provided by user, such as from overriding CreateReconcile.
        /// </summary>
        [MakePublic]
        internal void Reconcile_Current<T>(uint hash, ref T lastReconcileData, RingBuffer<LocalReconcile<T>> reconcilesHistory, T data, Channel channel) where T : IReconcileData, new()
        {
            if (_networkObjectCache.PredictionManager.IsReconciling)
                return;

            if (_networkObjectCache.IsServerInitialized)
                Reconcile_Server(hash, ref lastReconcileData, data, channel);
            else
                Reconcile_Client_AddToLocalHistory(reconcilesHistory, data);
        }

        /// <summary>
        /// Runs a reconcile. Prefers server data if available, otherwise uses local history data.
        /// </summary>
        [MakePublic]
        internal void Reconcile_Client<T, T2>(ReconcileUserLogicDelegate<T> reconcileDel, RingBuffer<ReplicateDataContainer<T2>> replicatesHistory, RingBuffer<LocalReconcile<T>> reconcilesHistory, T data) where T : IReconcileData where T2 : IReplicateData, new()
        {
            bool isBehaviourReconciling = IsBehaviourReconciling;

            const long unsetHistoryIndex = -1;
            long historyIndex = unsetHistoryIndex;

            /* There should always be entries, except when the object
             * first spawns.
             *
             * Find the history index associated with the reconcile tick. */
            if (reconcilesHistory.Count > 0)
            {
                //If reconcile data received then use that tick, otherwise get estimated tick for this reconcile.
                uint reconcileTick = (isBehaviourReconciling) ? data.GetTick() : _networkObjectCache.PredictionManager.GetReconcileStateTick(_networkObjectCache.IsOwner);

                uint firstHistoryTick = reconcilesHistory[0].Tick;
                historyIndex = ((long)reconcileTick - (long)firstHistoryTick);

                /* If difference is negative then
                 * the first history is beyond the tick being reconciled.
                 * EG: if history index 0 is 100 and reconcile tick is 90 then
                 * (90 - 100) = -10.
                 * This should only happen when first connecting and data hasn't been made yet. */
                if (!IsHistoryIndexValid((int)historyIndex))
                {
                    historyIndex = unsetHistoryIndex;
                    ClearReconcileHistory(reconcilesHistory);
                }
                //Valid history index.
                else
                {
                    //Get the tick at the index.
                    uint lrTick = reconcilesHistory[(int)historyIndex].Tick;
                    /* Since we store reconcile data every tick moving ahead a set number of ticks
                     * should usually match up to the reconcile tick. There are exceptions where the tick
                     * used to locally create the reconcile was for non owner, so using the server tick,
                     * and there is a slight misalignment in the server tick. This is not unusual as the
                     * client corrects it's tick timing regularly, but such an alignment could make this not line up. */
                    /* If the history tick does not match the reconcile tick try to find
                     * the correct history tick. This should rarely happen but since these reconciles
                     * are created locally and client timing can vary slightly it's still possible. */
                    if (lrTick != reconcileTick)
                    {
                        /* Get the difference between what tick is stored vs reconcile tick.
                         * Adjust the index based on this difference. */
                        long tickDifference = ((long)reconcileTick - (long)lrTick);

                        /* Add difference onto history index and again validate that it
                         * is in range of the collection. */
                        historyIndex += tickDifference;
                        //Invalid.
                        if (!IsHistoryIndexValid((int)historyIndex))
                        {
                            /* This shouldn't ever happen. Something went very wrong if here.
                             * When this does happen clear out the entire history collection
                             * and start over. */
                            ClearReconcileHistory(reconcilesHistory);
                            //Unset index.
                            historyIndex = unsetHistoryIndex;
                        }
                    }

                    //If index is set and behaviour is not reconciling then apply data.
                    if (!isBehaviourReconciling && historyIndex != unsetHistoryIndex)
                    {
                        LocalReconcile<T> localReconcile = reconcilesHistory[(int)historyIndex];
                        //Before disposing get the writer and call reconcile reader so it's parsed.
                        PooledWriter reconcileWritten = localReconcile.Writer;
                        /* Although this is actually from the local client the datasource is being set to server since server
                         * is what typically sends reconciles. */
                        PooledReader reader = ReaderPool.Retrieve(reconcileWritten.GetArraySegment(), _networkObjectCache.NetworkManager, Reader.DataSource.Server);
                        data = Reconcile_Reader_Local<T>(localReconcile.Tick, reader);
                        ReaderPool.Store(reader);
                    }
                }
            }

            //Returns if a history index can be within history collection.
            bool IsHistoryIndexValid(int index) => (index >= 0 && (index < reconcilesHistory.Count));

            //Dispose of old reconcile histories.
            if (historyIndex != unsetHistoryIndex)
            {
                int index = (int)historyIndex;
                //If here everything is good, remove up to used index.
                for (int i = 0; i < index; i++)
                    reconcilesHistory[i].Dispose();

                reconcilesHistory.RemoveRange(true, (int)historyIndex);
            }

            //If does not have data still then exit method.
            if (!IsBehaviourReconciling)
                return;

            //Set on the networkObject that a reconcile can now occur.
            _networkObjectCache.IsObjectReconciling = true;

            uint dataTick = data.GetTick();
            _lastReconcileTick = dataTick;

            if (replicatesHistory.Count > 0)
            {
                /* Remove replicates up to reconcile. Since the reconcile
                 * is the state after a replicate for it's tick we no longer
                 * need any replicates prior. */
                //Find the closest entry which can be removed.
                int removeCount = 0;
                //A few quick tests.
                if (replicatesHistory.Count > 0)
                {
                    /* If the last entry in history is less or equal
                     * to datatick then all histories need to be removed
                     * as reconcile is beyond them. */
                    if (replicatesHistory[^1].Data.GetTick() <= dataTick)
                    {
                        removeCount = replicatesHistory.Count;
                    }
                    //Somewhere in between. Find what to remove up to.
                    else
                    {
                        for (int i = 0; i < replicatesHistory.Count; i++)
                        {
                            uint entryTick = replicatesHistory[i].Data.GetTick();
                            /* Soon as an entry beyond dataTick is
                             * found remove up to that entry. */
                            if (entryTick > dataTick)
                            {
                                removeCount = i;
                                break;
                            }
                        }
                    }
                }

                for (int i = 0; i < removeCount; i++)
                    replicatesHistory[i].Dispose();
                replicatesHistory.RemoveRange(true, removeCount);
            }

            //Call reconcile user logic.
            reconcileDel?.Invoke(data, Channel.Reliable);
        }

        internal void Reconcile_Client_End()
        {
            IsBehaviourReconciling = false;
        }

        /// <summary>
        /// Disposes and clears LocalReconciles.
        /// </summary>
        private void ClearReconcileHistory<T>(RingBuffer<LocalReconcile<T>> reconcilesHistory) where T : IReconcileData
        {
            foreach (LocalReconcile<T> localReconcile in reconcilesHistory)
                localReconcile.Dispose();

            reconcilesHistory.Clear();
        }

        /// <summary>
        /// Reads a reconcile from the server.
        /// </summary>
        public void Reconcile_Reader<T>(PooledReader reader, ref T lastReconcileData) where T : IReconcileData
        {
            uint tick = (IsOwner) ? PredictionManager.ClientStateTick : PredictionManager.ServerStateTick;
//#if !FISHNET_STABLE_SYNCTYPES
#if DO_NOT_USE
            T newData = reader.ReadDeltaReconcile(lastReconciledata);
#else
            T newData = reader.ReadReconcile<T>();
#endif
            //Do not process if an old state.
            if (tick < _lastReadReconcileRemoteTick)
                return;

            lastReconcileData = newData;
            lastReconcileData.SetTick(tick);

            IsBehaviourReconciling = true;
            _networkObjectCache.IsObjectReconciling = true;
            _lastReadReconcileRemoteTick = tick;
        }

        /// <summary>
        /// Reads a local reconcile from the client.
        /// </summary>
        public T Reconcile_Reader_Local<T>(uint tick, PooledReader reader) where T : IReconcileData
        {
            reader.NetworkManager = _networkObjectCache.NetworkManager;
            T newData = reader.ReadReconcile<T>();
            newData.SetTick(tick);

            IsBehaviourReconciling = true;

            return newData;
        }

        /// <summary>
        /// Sets the last tick this NetworkBehaviour replicated with.
        /// </summary>
        /// <param name="setUnordered">True to set unordered value, false to set ordered.</param>
        private void SetReplicateTick(uint value, bool createdReplicate)
        {
            _lastOrderedReplicatedTick = value;
            _networkObjectCache.SetReplicateTick(value, createdReplicate);
        }
    }
}﻿using FishNet.CodeAnalysis.Annotations;
using FishNet.Component.ColliderRollback;
using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Client;
using FishNet.Managing.Observing;
using FishNet.Managing.Predicting;
using FishNet.Managing.Scened;
using FishNet.Managing.Server;
using FishNet.Managing.Timing;
using FishNet.Managing.Transporting;
using FishNet.Observing;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object
{

    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        #region Public.
        #region Obsoletes
        //Remove on v5
        [Obsolete("Use IsClientOnlyInitialized. Note the difference between IsClientOnlyInitialized and IsClientOnlyStarted.")]
        public bool IsClientOnly => IsClientOnlyInitialized;
        [Obsolete("Use IsServerOnlyInitialized. Note the difference between IsServerOnlyInitialized and IsServerOnlyStarted.")]
        public bool IsServerOnly => IsServerOnlyInitialized;
        [Obsolete("Use IsHostInitialized. Note the difference between IsHostInitialized and IsHostStarted.")]
        public bool IsHost => IsHostInitialized;
        [Obsolete("Use IsClientInitialized. Note the difference between IsClientInitialized and IsClientStarted.")]
        public bool IsClient => IsClientInitialized;
        [Obsolete("Use IsServerInitialized. Note the difference between IsServerInitialized and IsServerStarted.")]
        public bool IsServer => IsServerInitialized;
        #endregion
        /// <summary>
        /// True if the NetworkObject for this NetworkBehaviour is deinitializing.
        /// </summary>
        public bool IsDeinitializing => _networkObjectCache.IsDeinitializing;
        /// <summary>
        /// NetworkManager for this object.
        /// </summary>
        public NetworkManager NetworkManager => _networkObjectCache.NetworkManager;
        /// <summary>
        /// ServerManager for this object.
        /// </summary>
        public ServerManager ServerManager => _networkObjectCache.ServerManager;
        /// <summary>
        /// ClientManager for this object.
        /// </summary>
        public ClientManager ClientManager => _networkObjectCache.ClientManager;
        /// <summary>
        /// ObserverManager for this object.
        /// </summary>
        public ObserverManager ObserverManager => _networkObjectCache.ObserverManager;
        /// <summary>
        /// TransportManager for this object.
        /// </summary>
        public TransportManager TransportManager => _networkObjectCache.TransportManager;
        /// <summary>
        /// TimeManager for this object.
        /// </summary>
        public TimeManager TimeManager => _networkObjectCache.TimeManager;
        /// <summary>
        /// SceneManager for this object.
        /// </summary>
        public SceneManager SceneManager => _networkObjectCache.SceneManager;
        /// <summary>
        /// PredictionManager for this object.
        /// </summary>
        public PredictionManager PredictionManager => _networkObjectCache.PredictionManager;
        /// <summary>
        /// RollbackManager for this object.
        /// </summary>
        public RollbackManager RollbackManager => _networkObjectCache.RollbackManager;
        /// <summary>
        /// NetworkObserver on this object.
        /// </summary>
        public NetworkObserver NetworkObserver => _networkObjectCache.NetworkObserver;
        /// <summary>
        /// True if this object has been initialized on the client side.
        /// This is set true right before client start callbacks and after stop callbacks.
        /// </summary>
        public bool IsClientInitialized => _networkObjectCache.IsClientInitialized;
        /// <summary>
        /// True if the client is started and authenticated.
        /// </summary>
        public bool IsClientStarted => _networkObjectCache.IsClientStarted;
        /// <summary>
        /// True if this object has been initialized only on the client side.
        /// This is set true right before server start callbacks and after stop callbacks.
        public bool IsClientOnlyInitialized => _networkObjectCache.IsClientOnlyInitialized;
        /// <summary>
        /// True if only the client is started and authenticated.
        /// </summary>
        public bool IsClientOnlyStarted => _networkObjectCache.IsClientOnlyStarted;
        /// <summary>
        /// True if this object has been initialized on the server side.
        /// This is set true right before server start callbacks and after stop callbacks.
        /// </summary>
        public bool IsServerInitialized => _networkObjectCache.IsServerInitialized;
        /// <summary>
        /// True if server is started.
        /// </summary>
        public bool IsServerStarted => _networkObjectCache.IsServerStarted;
        /// <summary>
        /// True if this object has been initialized only on the server side.
        /// This is set true right before server start callbacks and after stop callbacks.
        public bool IsServerOnlyInitialized => _networkObjectCache.IsServerOnlyInitialized;
        /// <summary>
        /// True if only the server is started.
        /// </summary>
        public bool IsServerOnlyStarted => _networkObjectCache.IsServerOnlyStarted;
        /// <summary>
        /// True if this object has been initialized on the server and client side.
        /// </summary>
        public bool IsHostInitialized => _networkObjectCache.IsHostInitialized;
        /// <summary>
        /// True if client and server are started.
        /// </summary>
        public bool IsHostStarted => _networkObjectCache.IsHostStarted;
        /// <summary>
        /// True if client nor server are started.
        /// </summary>
        public bool IsOffline => _networkObjectCache.IsOffline;
        /// <summary>
        /// True if the object will always initialize as a networked object. When false the object will not automatically initialize over the network. Using Spawn() on an object will always set that instance as networked.
        /// To check if server or client has been initialized on this object use IsXYZInitialized.
        /// </summary>
        [Obsolete("Use GetIsNetworked.")] //Remove on V5.
        public bool IsNetworked => GetIsNetworked();

        /// <summary>
        /// True if the object will always initialize as a networked object. When false the object will not automatically initialize over the network. Using Spawn() on an object will always set that instance as networked.
        /// To check if server or client has been initialized on this object use IsXYZInitialized.
        /// </summary>
        public bool GetIsNetworked() => _networkObjectCache.GetIsNetworked();

        /// <summary>
        /// Sets IsNetworked value. This method must be called before Start.
        /// </summary>
        /// <param name="value">New IsNetworked value.</param>
        public void SetIsNetworked(bool value) => _networkObjectCache.SetIsNetworked(value);
        
        /// <summary>
        /// True if a reconcile is occuring on the PredictionManager. Note the difference between this and IsBehaviourReconciling.
        /// </summary>
        public bool IsManagerReconciling => _networkObjectCache.IsManagerReconciling;
        /// <summary>
        /// Observers for this NetworkBehaviour.
        /// </summary>
        public HashSet<NetworkConnection> Observers => _networkObjectCache.Observers;
        /// <summary>
        /// True if the local client is the owner of this object.
        /// </summary>
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "OnStartServer", "")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "OnStartNetwork", " Use base.Owner.IsLocalClient instead.")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "Awake", "")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "Start", "")]
        public bool IsOwner => _networkObjectCache.IsOwner;
        /// <summary>
        /// True if IsOwner, or if IsServerInitialized with no Owner.
        /// </summary>
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "OnStartServer", "")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "OnStartNetwork", " Use (base.Owner.IsLocalClient || (base.IsServerInitialized && !Owner.Isvalid) instead.")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "Awake", "")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "Start", "")]
        public bool IsController => (_networkObjectCache.IsOwner || (_networkObjectCache.IsServerInitialized && !_networkObjectCache.Owner.IsValid));
        [Obsolete("Use IsController.")]
        public bool HasAuthority => IsController;
        /// <summary>
        /// Owner of this object.
        /// </summary>
        public NetworkConnection Owner
        {
            get
            {
                //Ensures a null Owner is never returned.
                if (_networkObjectCache == null)
                    return FishNet.Managing.NetworkManager.EmptyConnection;

                return _networkObjectCache.Owner;
            }
        }
        /// <summary>
        /// ClientId for this NetworkObject owner.
        /// </summary>
        public int OwnerId => _networkObjectCache.OwnerId;
        /// <summary>
        /// Unique Id for this _networkObjectCache. This does not represent the object owner.
        /// </summary>
        public int ObjectId => _networkObjectCache.ObjectId;
        /// <summary>
        /// The local connection of the client calling this method.
        /// </summary>
        public NetworkConnection LocalConnection => _networkObjectCache.LocalConnection;
        #endregion

        /// <summary>
        /// Returns if a connection is the owner of this object.
        /// </summary>
        /// <param name="connection"></param>
        /// <returns></returns>
        public bool OwnerMatches(NetworkConnection connection)
        {
            return (_networkObjectCache.Owner == connection);
        }

        /// <summary>
        /// Despawns a GameObject. Only call from the server.
        /// </summary>
        /// <param name="go">GameObject to despawn.</param>
        /// <param name="despawnType">What happens to the object after being despawned.</param>
        public void Despawn(GameObject go, DespawnType? despawnType = null)
        {
            if (!IsNetworkObjectNull(true))
                _networkObjectCache.Despawn(go, despawnType);
        }
        /// <summary>
        /// Despawns  a NetworkObject. Only call from the server.
        /// </summary>
        /// <param name="nob">NetworkObject to despawn.</param>
        /// <param name="despawnType">What happens to the object after being despawned.</param>
        public void Despawn(NetworkObject nob, DespawnType? despawnType = null)
        {
            if (!IsNetworkObjectNull(true))
                _networkObjectCache.Despawn(nob, despawnType);
        }

        /// <summary>
        /// Despawns this _networkObjectCache. Can only be called on the server.
        /// </summary>
        /// <param name="despawnType">What happens to the object after being despawned.</param>
        public void Despawn(DespawnType? despawnType = null)
        {
            if (!IsNetworkObjectNull(true))
                _networkObjectCache.Despawn(despawnType);
        }
        /// <summary>
        /// Spawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="go">GameObject instance to spawn.</param>
        /// <param name="ownerConnection">Connection to give ownership to.</param>
        public void Spawn(GameObject go, NetworkConnection ownerConnection = null, UnityEngine.SceneManagement.Scene scene = default)
        {
            if (IsNetworkObjectNull(true))
                return;
            _networkObjectCache.Spawn(go, ownerConnection, scene);
        }
        /// <summary>
        /// Spawns an object over the network. Can only be called on the server.
        /// </summary>
        /// <param name="nob">GameObject instance to spawn.</param>
        /// <param name="ownerConnection">Connection to give ownership to.</param>
        public void Spawn(NetworkObject nob, NetworkConnection ownerConnection = null, UnityEngine.SceneManagement.Scene scene = default)
        {
            if (IsNetworkObjectNull(true))
                return;
            _networkObjectCache.Spawn(nob, ownerConnection, scene);
        }
        /// <summary>
        /// Returns if NetworkObject is null.
        /// </summary>
        /// <param name="warn">True to throw a warning if null.</param>
        /// <returns></returns>
        private bool IsNetworkObjectNull(bool warn)
        {
            bool isNull = (_networkObjectCache == null);
            if (isNull && warn)
                NetworkManager.LogWarning($"NetworkObject is null. This can occur if this object is not spawned, or initialized yet.");

            return isNull;
        }
        /// <summary>
        /// Removes ownership from all clients.
        /// </summary>
        
        public void RemoveOwnership() => _networkObjectCache.RemoveOwnership();
        /// <summary>
        /// Gives ownership to newOwner.
        /// </summary>
        
        public void GiveOwnership(NetworkConnection newOwner) => _networkObjectCache.GiveOwnership(newOwner, asServer: true, recursive: false);

        /// <summary>
        /// Gives ownership to newOwner.
        /// </summary>
        
        public void GiveOwnership(NetworkConnection newOwner, bool includeNested) => _networkObjectCache.GiveOwnership(newOwner, asServer: true, includeNested);

        #region Registered components
        /// <summary>
        /// Invokes an action when a specified component becomes registered. Action will invoke immediately if already registered.
        /// </summary>
        /// <typeparam name="T">Component type.</typeparam>
        /// <param name="handler">Action to invoke.</param>
        public void RegisterInvokeOnInstance<T>(Action<UnityEngine.Component> handler) where T : UnityEngine.Component => _networkObjectCache.RegisterInvokeOnInstance<T>(handler);
        /// <summary>
        /// Removes an action to be invoked when a specified component becomes registered.
        /// </summary>
        /// <typeparam name="T">Component type.</typeparam>
        /// <param name="handler">Action to invoke.</param>
        public void UnregisterInvokeOnInstance<T>(Action<UnityEngine.Component> handler) where T : UnityEngine.Component => _networkObjectCache.UnregisterInvokeOnInstance<T>(handler);
        /// <summary>
        /// Returns class of type if found within CodegenBase classes.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public T GetInstance<T>() where T : UnityEngine.Component => _networkObjectCache.GetInstance<T>();
        /// <summary>
        /// Registers a new component to this NetworkManager.
        /// </summary>
        /// <typeparam name="T">Type to register.</typeparam>
        /// <param name="component">Reference of the component being registered.</param>
        /// <param name="replace">True to replace existing references.</param>
        public void RegisterInstance<T>(T component, bool replace = true) where T : UnityEngine.Component => _networkObjectCache.RegisterInstance(component, replace);
        /// <summary>
        /// Tries to registers a new component to this NetworkManager.
        /// This will not register the instance if another already exists.
        /// </summary>
        /// <typeparam name="T">Type to register.</typeparam>
        /// <param name="component">Reference of the component being registered.</param>
        /// <returns>True if was able to register, false if an instance is already registered.</returns>
        public bool TryRegisterInstance<T>(T component) where T : UnityEngine.Component => _networkObjectCache.TryRegisterInstance(component);
        /// <summary>
        /// Unregisters a component from this NetworkManager.
        /// </summary>
        /// <typeparam name="T">Type to unregister.</typeparam>
        public void UnregisterInstance<T>() where T : UnityEngine.Component => _networkObjectCache.UnregisterInstance<T>();
        #endregion
    }


}﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.Managing.Server;
using FishNet.Object.Helping;
using FishNet.Serializing;
using FishNet.Transporting;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object
{
    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// Link indexes for RPCs.
        /// </summary>
        private Dictionary<uint, RpcLinkType> _rpcLinks = new();
        #endregion

        #region Consts.
        /// <summary>
        /// Number of bytes written for each RPCLinks.
        /// </summary>
        internal const int RPCLINK_RESERVED_BYTES = 2;
        #endregion

        /// <summary>
        /// Initializes RpcLinks. This will only call once even as host.
        /// </summary>
        private void InitializeRpcLinks()
        {
            /* Link only data from server to clients. While it is
             * just as easy to link client to server it's usually
             * not needed because server out data is more valuable
             * than server in data. */
            /* Links will be stored in the NetworkBehaviour so that
             * when the object is destroyed they can be added back
             * into availableRpcLinks, within the ServerManager. */

            ServerManager serverManager = NetworkManager.ServerManager;
            //ObserverRpcs.
            if (_observersRpcDelegates != null)
            {
                foreach (uint rpcHash in _observersRpcDelegates.Keys)
                {
                    if (!MakeLink(rpcHash, PacketId.ObserversRpc))
                        return;
                }
            }
            //TargetRpcs.
            if (_targetRpcDelegates != null)
            {
                foreach (uint rpcHash in _targetRpcDelegates.Keys)
                {
                    if (!MakeLink(rpcHash, PacketId.TargetRpc))
                        return;
                }
            }
            //ReconcileRpcs.
            if (_reconcileRpcDelegates != null)
            {
                foreach (uint rpcHash in _reconcileRpcDelegates.Keys)
                {
                    if (!MakeLink(rpcHash, PacketId.Reconcile))
                        return;
                }
            }

            /* Tries to make a link and returns if
             * successful. When a link cannot be made the method
             * should exit as no other links will be possible. */
            bool MakeLink(uint rpcHash, PacketId packetId)
            {
                if (serverManager.GetRpcLink(out ushort linkIndex))
                {
                    _rpcLinks[rpcHash] = new(rpcHash, packetId, linkIndex);
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }

        /// <summary>
        /// Returns an estimated length for any Rpc header.
        /// </summary>
        /// <returns></returns>
        private int GetEstimatedRpcHeaderLength()
        {
            /* Imaginary number for how long RPC headers are.
             * They are well under this value but this exist to
             * ensure a writer of appropriate length is pulled
             * from the pool. */
            return 20;
        }

        /// <summary>
        /// Creates a PooledWriter and writes the header for a rpc.
        /// </summary>
        private PooledWriter CreateLinkedRpc(RpcLinkType link, PooledWriter methodWriter, Channel channel)
        {
            int rpcHeaderBufferLength = GetEstimatedRpcHeaderLength();
            int methodWriterLength = methodWriter.Length;
            //Writer containing full packet.
            PooledWriter writer = WriterPool.Retrieve(rpcHeaderBufferLength + methodWriterLength);
            writer.WriteUInt16(link.LinkPacketId);

#if DEVELOPMENT
            int written = WriteDebugForValidateRpc(writer, link.RpcPacketId, link.RpcHash);
#endif

            //Write length only if reliable.
            if (channel == Channel.Reliable)
                writer.WriteInt32(methodWriter.Length);
            //Data.
            writer.WriteArraySegment(methodWriter.GetArraySegment());
            
#if DEVELOPMENT
            WriteDebugLengthForValidateRpc(writer, written);
#endif
            
            return writer;
        }

        /// <summary>
        /// Returns RpcLinks the ServerManager.
        /// </summary>
        private void ReturnRpcLinks()
        {
            if (_rpcLinks.Count == 0)
                return;

            ServerManager?.StoreRpcLinks(_rpcLinks);
            _rpcLinks.Clear();
        }

        /// <summary>
        /// Writes rpcLinks to writer.
        /// </summary>
        internal void WriteRpcLinks(Writer writer)
        {
            int rpcLinksCount = _rpcLinks.Count;
            if (rpcLinksCount == 0)
                return;

            writer.WriteNetworkBehaviourId(this);
            writer.WriteUInt16((ushort)rpcLinksCount);

            foreach (KeyValuePair<uint, RpcLinkType> item in _rpcLinks)
            {
                //RpcLink index.
                writer.WriteUInt16Unpacked(item.Value.LinkPacketId);
                //Hash.
                writer.WriteUInt16Unpacked((ushort)item.Key);
                //True/false if observersRpc.
                writer.WriteUInt16Unpacked((ushort)item.Value.RpcPacketId);
            }
        }
    }
}﻿#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using System;
using FishNet.CodeGenerating;
using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Managing.Transporting;
using FishNet.Object.Delegating;
using FishNet.Serializing;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using System.Text;
using FishNet.Serializing.Helping;
using UnityEngine;

namespace FishNet.Object
{
    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        #region Types.
        private struct BufferedRpc
        {
            /// <summary>
            /// Writer containing the full RPC.
            /// </summary>
            public PooledWriter Writer;
            /// <summary>
            /// Which order to send the data in relation to other packets.
            /// </summary>
            public DataOrderType OrderType;

            public BufferedRpc(PooledWriter writer, DataOrderType orderType)
            {
                Writer = writer;
                OrderType = orderType;
            }
        }
        #endregion

        #region Private.
        /// <summary>
        /// Registered ServerRpc methods.
        /// </summary>
        private readonly Dictionary<uint, ServerRpcDelegate> _serverRpcDelegates = new();
        /// <summary>
        /// Registered ObserversRpc methods.
        /// </summary>
        private readonly Dictionary<uint, ClientRpcDelegate> _observersRpcDelegates = new();
        /// <summary>
        /// Registered TargetRpc methods.
        /// </summary>
        private readonly Dictionary<uint, ClientRpcDelegate> _targetRpcDelegates = new();
        /// <summary>
        /// Number of total RPC methods for scripts in the same inheritance tree for this instance.
        /// </summary>
        private uint _rpcMethodCount;
        /// <summary>
        /// Size of every rpcHash for this networkBehaviour.
        /// </summary>
        private byte _rpcHashSize = 1;
        /// <summary>
        /// RPCs buffered for new clients.
        /// </summary>
        private readonly Dictionary<uint, BufferedRpc> _bufferedRpcs = new();
        /// <summary>
        /// Connections to exclude from RPCs, such as ExcludeOwner or ExcludeServer.
        /// </summary>
        private readonly HashSet<NetworkConnection> _networkConnectionCache = new();
        #endregion

        #region Const.
        /// <summary>
        /// This is an estimated value of what the maximum possible size of a RPC could be.
        /// Realistically this value is much smaller but this value is used as a buffer.
        /// </summary>
        private const int MAXIMUM_RPC_HEADER_SIZE = 10;
#if DEVELOPMENT
        /// <summary>
        /// Bytes used to write length for validating Rpc length.
        /// </summary>
        private const int VALIDATE_RPC_LENGTH_BYTES = 4;
#endif
        #endregion

        /// <summary>
        /// Called when buffered RPCs should be sent.
        /// </summary>
        internal void SendBufferedRpcs(NetworkConnection conn)
        {
            TransportManager tm = _networkObjectCache.NetworkManager.TransportManager;
            foreach (BufferedRpc bRpc in _bufferedRpcs.Values)
                tm.SendToClient((byte)Channel.Reliable, bRpc.Writer.GetArraySegment(), conn, true, bRpc.OrderType);
        }

        /// <summary>
        /// Registers a RPC method.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="del"></param>
        [APIExclude]
        [MakePublic]
        internal void RegisterServerRpc(uint hash, ServerRpcDelegate del)
        {
            if (_serverRpcDelegates.TryAdd(hash, del))
                IncreaseRpcMethodCount();
            else
                NetworkManager.LogError($"ServerRpc key {hash} has already been added for {GetType().FullName} on {gameObject.name}");
        }

        /// <summary>
        /// Registers a RPC method.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="del"></param>
        [APIExclude]
        [MakePublic]
        internal void RegisterObserversRpc(uint hash, ClientRpcDelegate del)
        {
            if (_observersRpcDelegates.TryAdd(hash, del))
                IncreaseRpcMethodCount();
            else
                NetworkManager.LogError($"ObserversRpc key {hash} has already been added for {GetType().FullName} on {gameObject.name}");
        }

        /// <summary>
        /// Registers a RPC method.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="del"></param>
        [APIExclude]
        [MakePublic]
        internal void RegisterTargetRpc(uint hash, ClientRpcDelegate del)
        {
            if (_targetRpcDelegates.TryAdd(hash, del))
                IncreaseRpcMethodCount();
            else
                NetworkManager.LogError($"TargetRpc key {hash} has already been added for {GetType().FullName} on {gameObject.name}");
        }

        /// <summary>
        /// Increases rpcMethodCount and rpcHashSize.
        /// </summary>
        private void IncreaseRpcMethodCount()
        {
            _rpcMethodCount++;
            if (_rpcMethodCount <= byte.MaxValue)
                _rpcHashSize = 1;
            else
                _rpcHashSize = 2;
        }

        /// <summary>
        /// Clears all buffered RPCs for this NetworkBehaviour.
        /// </summary>
        public void ClearBuffedRpcs()
        {
            foreach (BufferedRpc bRpc in _bufferedRpcs.Values)
                bRpc.Writer.Store();
            _bufferedRpcs.Clear();
        }

        /// <summary>
        /// Reads a RPC hash.
        /// </summary>
        /// <param name="reader"></param>
        /// <returns></returns>
        private uint ReadRpcHash(PooledReader reader)
        {
            if (_rpcHashSize == 1)
                return reader.ReadUInt8Unpacked();
            else
                return reader.ReadUInt16();
        }

        /// <summary>
        /// Called when a ServerRpc is received.
        /// </summary>
        internal void ReadServerRpc(bool fromRpcLink, uint methodHash, PooledReader reader, NetworkConnection sendingClient, Channel channel)
        {
            if (!fromRpcLink)
                methodHash = ReadRpcHash(reader);

            if (sendingClient == null)
            {
                _networkObjectCache.NetworkManager.LogError($"NetworkConnection is null. ServerRpc {methodHash} on object {gameObject.name} [id {ObjectId}] will not complete. Remainder of packet may become corrupt.");
                return;
            }

            if (_serverRpcDelegates.TryGetValueIL2CPP(methodHash, out ServerRpcDelegate data))
                data.Invoke(reader, channel, sendingClient);
            else
                _networkObjectCache.NetworkManager.LogError($"ServerRpc not found for hash {methodHash} on object {gameObject.name} [id {ObjectId}]. Remainder of packet may become corrupt.");
        }

        /// <summary>
        /// Called when an ObserversRpc is received.
        /// </summary>
        internal void ReadObserversRpc(bool fromRpcLink, uint methodHash, PooledReader reader, Channel channel)
        {
            if (!fromRpcLink)
                methodHash = ReadRpcHash(reader);

            if (_observersRpcDelegates.TryGetValueIL2CPP(methodHash, out ClientRpcDelegate del))
                del.Invoke(reader, channel);
            else
                _networkObjectCache.NetworkManager.LogError($"ObserversRpc not found for hash {methodHash} on object {gameObject.name} [id {ObjectId}] . Remainder of packet may become corrupt.");
        }

        /// <summary>
        /// Called when an TargetRpc is received.
        /// </summary>
        internal void ReadTargetRpc(bool fromRpcLink, uint methodHash, PooledReader reader, Channel channel)
        {
            if (!fromRpcLink)
                methodHash = ReadRpcHash(reader);

            if (_targetRpcDelegates.TryGetValueIL2CPP(methodHash, out ClientRpcDelegate del))
                del.Invoke(reader, channel);
            else
                _networkObjectCache.NetworkManager.LogError($"TargetRpc not found for hash {methodHash} on object {gameObject.name} [id {ObjectId}] . Remainder of packet may become corrupt.");
        }

        /// <summary>
        /// Sends a RPC to server.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="methodWriter"></param>
        /// <param name="channel"></param>
        [MakePublic]
        internal void SendServerRpc(uint hash, PooledWriter methodWriter, Channel channel, DataOrderType orderType)
        {
            if (!IsSpawnedWithWarning())
                return;

            _transportManagerCache.CheckSetReliableChannel(methodWriter.Length + MAXIMUM_RPC_HEADER_SIZE, ref channel);

            PooledWriter writer = CreateRpc(hash, methodWriter, PacketId.ServerRpc, channel);
            _networkObjectCache.NetworkManager.TransportManager.SendToServer((byte)channel, writer.GetArraySegment(), true, orderType);
            writer.StoreLength();
        }

        /// <summary>
        /// Sends a RPC to observers.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="methodWriter"></param>
        /// <param name="channel"></param>
        [APIExclude]
        [MakePublic]
        internal void SendObserversRpc(uint hash, PooledWriter methodWriter, Channel channel, DataOrderType orderType, bool bufferLast, bool excludeServer, bool excludeOwner)
        {
            if (!IsSpawnedWithWarning())
                return;

            _transportManagerCache.CheckSetReliableChannel(methodWriter.Length + MAXIMUM_RPC_HEADER_SIZE, ref channel);

            PooledWriter writer = lCreateRpc(channel);
            SetNetworkConnectionCache(excludeServer, excludeOwner);
            _networkObjectCache.NetworkManager.TransportManager.SendToClients((byte)channel, writer.GetArraySegment(), _networkObjectCache.Observers, _networkConnectionCache, true, orderType);

            /* If buffered then dispose of any already buffered
             * writers and replace with new one. Writers should
             * automatically dispose when references are lost
             * anyway but better safe than sorry. */
            if (bufferLast)
            {
                if (_bufferedRpcs.TryGetValueIL2CPP(hash, out BufferedRpc result))
                    result.Writer.StoreLength();

                /* If sent on unreliable the RPC has to be rebuilt for
                 * reliable headers since buffered RPCs always send reliably
                 * to new connections. */
                if (channel == Channel.Unreliable)
                {
                    writer.StoreLength();
                    writer = lCreateRpc(Channel.Reliable);
                }
                _bufferedRpcs[hash] = new(writer, orderType);
            }
            //If not buffered then dispose immediately.
            else
            {
                writer.StoreLength();
            }

            PooledWriter lCreateRpc(Channel c)
            {
#if DEVELOPMENT
                if (!NetworkManager.DebugManager.DisableObserversRpcLinks && _rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
#else
                if (_rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
#endif
                    writer = CreateLinkedRpc(link, methodWriter, c);
                else
                    writer = CreateRpc(hash, methodWriter, PacketId.ObserversRpc, c);

                return writer;
            }
        }

        /// <summary>
        /// Sends a RPC to target.
        /// </summary>
        [MakePublic]
        internal void SendTargetRpc(uint hash, PooledWriter methodWriter, Channel channel, DataOrderType orderType, NetworkConnection target, bool excludeServer, bool validateTarget = true)
        {
            if (!IsSpawnedWithWarning())
                return;

            _transportManagerCache.CheckSetReliableChannel(methodWriter.Length + MAXIMUM_RPC_HEADER_SIZE, ref channel);

            if (validateTarget)
            {
                if (target == null)
                {
                    _networkObjectCache.NetworkManager.LogWarning($"Action cannot be completed as no Target is specified.");
                    return;
                }
                else
                {
                    //If target is not an observer.
                    if (!_networkObjectCache.Observers.Contains(target))
                    {
                        _networkObjectCache.NetworkManager.LogWarning($"Action cannot be completed as Target is not an observer for object {gameObject.name} [id {ObjectId}].");
                        return;
                    }
                }
            }

            //Excluding server.
            if (excludeServer && target.IsLocalClient)
                return;

            PooledWriter writer;

#if DEVELOPMENT
            if (!NetworkManager.DebugManager.DisableTargetRpcLinks && _rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
#else
            if (_rpcLinks.TryGetValueIL2CPP(hash, out RpcLinkType link))
#endif
                writer = CreateLinkedRpc(link, methodWriter, channel);
            else
                writer = CreateRpc(hash, methodWriter, PacketId.TargetRpc, channel);

            _networkObjectCache.NetworkManager.TransportManager.SendToClient((byte)channel, writer.GetArraySegment(), target, true, orderType);
            writer.Store();
        }

        /// <summary>
        /// Adds excluded connections to ExcludedRpcConnections.
        /// </summary>
        private void SetNetworkConnectionCache(bool addClientHost, bool addOwner)
        {
            _networkConnectionCache.Clear();
            if (addClientHost && IsClientStarted)
                _networkConnectionCache.Add(LocalConnection);
            if (addOwner && Owner.IsValid)
                _networkConnectionCache.Add(Owner);
        }

        /// <summary>
        /// Returns if spawned and throws a warning if not.
        /// </summary>
        /// <returns></returns>
        private bool IsSpawnedWithWarning()
        {
            bool result = this.IsSpawned;
            if (!result)
                _networkObjectCache.NetworkManager.LogWarning($"Action cannot be completed as object {gameObject.name} [Id {ObjectId}] is not spawned.");

            return result;
        }

        /// <summary>
        /// Writes a full RPC and returns the writer.
        /// </summary>
        private PooledWriter CreateRpc(uint hash, PooledWriter methodWriter, PacketId packetId, Channel channel)
        {
            int rpcHeaderBufferLength = GetEstimatedRpcHeaderLength();
            int methodWriterLength = methodWriter.Length;
            //Writer containing full packet.
            PooledWriter writer = WriterPool.Retrieve(rpcHeaderBufferLength + methodWriterLength);
            writer.WritePacketIdUnpacked(packetId);

#if DEVELOPMENT
            int written = WriteDebugForValidateRpc(writer, packetId, hash);
#endif

            writer.WriteNetworkBehaviour(this);

            //Only write length if reliable.
            if (channel == Channel.Reliable)
                writer.WriteInt32(methodWriterLength + _rpcHashSize);

            //Hash and data.
            WriteRpcHash(hash, writer);
            writer.WriteArraySegment(methodWriter.GetArraySegment());

#if DEVELOPMENT
            WriteDebugLengthForValidateRpc(writer, written);
#endif

            return writer;
        }

#if DEVELOPMENT
        /// <summary>
        /// Gets the method name for a Rpc using packetId and Rpc hash.
        /// </summary>
        private string GetRpcMethodName(PacketId packetId, uint hash)
        {
            try
            {
                if (packetId == PacketId.ObserversRpc)
                    return _observersRpcDelegates[hash].Method.Name;
                else if (packetId == PacketId.TargetRpc)
                    return _targetRpcDelegates[hash].Method.Name;
                else if (packetId == PacketId.ServerRpc)
                    return _serverRpcDelegates[hash].Method.Name;
                else if (packetId == PacketId.Replicate)
                    return _replicateRpcDelegates[hash].Method.Name;
                else if (packetId == PacketId.Reconcile)
                    return _reconcileRpcDelegates[hash].Method.Name;
                else
                    _networkObjectCache.NetworkManager.LogError($"Unhandled packetId of {packetId} for hash {hash}.");
            }
            //This should not ever happen.
            catch
            {
                _networkObjectCache.NetworkManager.LogError($"Rpc method name not found for packetId {packetId}, hash {hash}.");
            }

            return "Error";
        }
#endif

        /// <summary>
        /// Writes rpcHash to writer.
        /// </summary>
        /// <param name="hash"></param>
        /// <param name="writer"></param>
        private void WriteRpcHash(uint hash, PooledWriter writer)
        {
            if (_rpcHashSize == 1)
                writer.WriteUInt8Unpacked((byte)hash);
            else
                writer.WriteUInt16((byte)hash);
        }

#if DEVELOPMENT
        private int WriteDebugForValidateRpc(Writer writer, PacketId packetId, uint hash)
        {
            if (!_networkObjectCache.NetworkManager.DebugManager.ValidateRpcLengths)
                return -1;

            writer.Skip(VALIDATE_RPC_LENGTH_BYTES);
            int positionStart = writer.Position;

            string txt = $"NetworkObject Details: {_networkObjectCache.ToString()}. NetworkBehaviour Details: Name [{GetType().Name}]. Rpc Details: Name [{GetRpcMethodName(packetId, hash)}] PacketId [{packetId}] Hash [{hash}]";
            writer.WriteString(txt);

            return positionStart;
        }

        private void WriteDebugLengthForValidateRpc(Writer writer, int positionStart)
        {
            if (!_networkObjectCache.NetworkManager.DebugManager.ValidateRpcLengths)
                return;

            //Write length.
            int writtenLength = (writer.Position - positionStart);
            writer.InsertInt32Unpacked(writtenLength, positionStart - VALIDATE_RPC_LENGTH_BYTES);
        }

        /// <summary>
        /// Parses written data used to validate a Rpc packet.
        /// </summary>
        internal static void ReadDebugForValidatedRpc(NetworkManager manager, PooledReader reader, out int readerRemainingAfterLength, out string rpcInformation, out uint expectedReadAmount)
        {
            rpcInformation = null;
            expectedReadAmount = 0;
            readerRemainingAfterLength = 0;

            if (!manager.DebugManager.ValidateRpcLengths)
                return;

            expectedReadAmount = (uint)reader.ReadInt32Unpacked();
            readerRemainingAfterLength = reader.Remaining;

            rpcInformation = reader.ReadStringAllocated();
        }

        /// <summary>
        /// Prints an error if an Rpc packet did not validate correctly.
        /// </summary>
        /// <returns>True if an error occurred.</returns>
        internal static bool TryPrintDebugForValidatedRpc(bool fromRpcLink, NetworkManager manager, PooledReader reader, int startReaderRemaining, string rpcInformation, uint expectedReadAmount, Channel channel)
        {
            if (!manager.DebugManager.ValidateRpcLengths)
                return false;

            int readAmount = (startReaderRemaining - reader.Remaining);
            if (readAmount != expectedReadAmount)
            {
                string src = (fromRpcLink) ? "RpcLink" : "Rpc";
                string msg = $"A {src} read an incorrect amount of data on channel {channel}. Read length was {readAmount}, expected length is {expectedReadAmount}. {rpcInformation}." + $" {manager.PacketIdHistory.GetReceivedPacketIds(packetsFromServer: (reader.Source == Reader.DataSource.Server))}.";
                manager.LogError(msg);

                return true;
            }

            return false;
        }
#endif
    }
}﻿using FishNet.CodeGenerating;
using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Transporting;
using FishNet.Object.Synchronizing;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using FishNet.Serializing.Helping;
using FishNet.Utility.Extension;
using UnityEngine;

namespace FishNet.Object
{
    public abstract partial class NetworkBehaviour : MonoBehaviour
    {
        #region Types.
        /// <summary>
        /// Used to generate data sent from synctypes.
        /// </summary>
        private struct SyncTypeWriter
        {
            /// <summary>
            /// Writers for each channel.
            /// </summary>
            public List<PooledWriter> Writers;

            /// <summary>
            /// Resets Writers.
            /// </summary>
            public void Reset()
            {
                if (Writers == null)
                    return;

                for (int i = 0; i < Writers.Count; i++)
                    Writers[i].Clear();
            }
            
            public void Initialize()
            {
                Writers = CollectionCaches<PooledWriter>.RetrieveList();
                for (int i = 0; i < TransportManager.CHANNEL_COUNT; i++)
                    Writers.Add(WriterPool.Retrieve());
            }
        }
        #endregion

        #region Private.
        /// <summary>
        /// Writers for syncTypes. A writer will exist for every ReadPermission type.
        /// </summary>
        private static Dictionary<ReadPermission, SyncTypeWriter> _syncTypeWriters = new();
        /// <summary>
        /// SyncTypes within this NetworkBehaviour.
        /// </summary>
        private Dictionary<uint, SyncBase> _syncTypes = new();
        /// <summary>
        /// True if at least one syncType is dirty.
        /// </summary>
        internal bool SyncTypeDirty;
        /// <summary>
        /// All ReadPermission values.
        /// This is used to build SyncTypeWriters on initialization.
        /// </summary>
        private static List<ReadPermission> _readPermissions;
        #endregion

        #region Consts.
        /// <summary>
        /// Bytes to reserve for writing SyncType headers.
        /// </summary>
        /// <returns></returns>
        internal const byte SYNCTYPE_RESERVE_BYTES = 4;
        /// <summary>
        /// Bytes to reserve for writing payload headers.
        /// </summary>
        /// <returns></returns>
        internal const byte PAYLOAD_RESERVE_BYTES = 4;
        #endregion

        /// <summary>
        /// Registers a SyncType.
        /// </summary>
        /// <param name="sb"></param>
        /// <param name="index"></param>
        internal void RegisterSyncType(SyncBase sb, uint index)
        {
            if (_syncTypes == null)
                _syncTypes = CollectionCaches<uint, SyncBase>.RetrieveDictionary();
            if (!_syncTypes.TryAdd(index, sb))
                NetworkManager.LogError($"SyncType key {index} has already been added for {GetType().FullName} on {gameObject.name}");
        }

        /// <summary>
        /// Sets a SyncType as dirty.
        /// </summary>
        /// <returns>True if able to dirty SyncType.</returns>
        internal bool DirtySyncType()
        {
            if (!IsServerStarted)
                return false;
            /* No reason to dirty if there are no observers.
             * This can happen even if a client is going to see
             * this object because the server side initializes
             * before observers are built. Clients which become observers
             * will get the latest values in the spawn message, which is separate
             * from writing dirty syncTypes. */
            if (_networkObjectCache.Observers.Count == 0 && !_networkObjectCache.PredictedSpawner.IsValid)
                return false;
            if (!SyncTypeDirty)
                _networkObjectCache.NetworkManager.ServerManager.Objects.SetDirtySyncType(this);

            SyncTypeDirty = true;

            return true;
        }

        /// <summary>
        /// Initializes SyncTypes. This will only call once even as host.
        /// </summary>
        private void SyncTypes_Preinitialize(bool asServer)
        {
            if (_networkObjectCache.DoubleLogic(asServer))
                return;

            //This only runs once since SyncTypeWriters are static.
            if (_syncTypeWriters.Count == 0)
            {
                List<ReadPermission> readPermissions = new();
                System.Array arr = System.Enum.GetValues(typeof(ReadPermission));
                foreach (ReadPermission rp in arr)
                    readPermissions.Add(rp);

                foreach (ReadPermission rp in readPermissions)
                {
                    SyncTypeWriter syncTypeWriter = new();
                    syncTypeWriter.Initialize();
                    _syncTypeWriters[rp] = syncTypeWriter;
                }
            }

            /* Initialize synctypes every spawn because there could be
             * callbacks which occur that the user or even we may implement
             * during the initialization. */
            foreach (SyncBase sb in _syncTypes.Values)
                sb.PreInitialize(_networkObjectCache.NetworkManager, asServer);
        }


        /// <summary>
        /// Reads a SyncType.
        /// </summary>
        internal void ReadSyncType(PooledReader reader, int writtenLength, bool asServer = false)
        {
            int endPosition = (reader.Position + writtenLength);
            while (reader.Position < endPosition)
            {
                byte syncTypeId = reader.ReadUInt8Unpacked();
                if (_syncTypes.TryGetValueIL2CPP(syncTypeId, out SyncBase sb))
                    sb.Read(reader, asServer);
                else
                    NetworkManager.LogError($"SyncType not found for index {syncTypeId} on {transform.name}, component {GetType().FullName}. The remainder of the packet will become corrupt likely resulting in unforeseen issues for this tick, such as data missing or objects not spawning.");
            }

            if (reader.Position > endPosition)
            {
                NetworkManager.LogError($"Remaining bytes in SyncType reader are less than expected. Something did not serialize or deserialize properly which will likely result in a SyncType being incorrect.");
                //Fix position.
                reader.Position = endPosition;
            }
        }

        /// <summary>
        /// Writes only dirty SyncTypes.
        /// </summary>
        /// <returns>True if there are no pending dirty sync types.</returns>
        internal bool WriteDirtySyncTypes(SyncTypeWriteFlag flags)
        {
            // /* IsSpawned Can occur when a synctype is queued after
            //  * the object is marked for destruction. This should not
            //  * happen under most conditions since synctypes will be
            //  * pushed through when despawn is called.
            //  *
            //  * No observers can occur when the server changes a syncType
            //  * value but gained no observers in the same tick. We still
            //  * want to mark a syncType as dirty in this situation because
            //  * it needs to write in a despawn message in the scenario the object
            //  * is spawned (no observers), synctype changed, then despawned immediately
            //  * after.
            //  */
            // if (!IsSpawned || _networkObjectCache.Observers.Count == 0)
            // {
            //     ResetState_SyncTypes(asServer: true);
            //     return true;
            // }
            
            /* IsSpawned Can occur when a synctype is queued after
             * the object is marked for destruction. This should not
             * happen under most conditions since synctypes will be
             * pushed through when despawn is called. */
            if (!IsSpawned)
            {
                ResetState_SyncTypes(asServer: true);
                return true;
            }

            /* Additional checks need to appear below the reset check
             * above. Resets should place priority as this method was called
             * when it should not have been, such as during a despawn. */

            //None dirty or no synctypes.
            if (!SyncTypeDirty || _syncTypes.Count == 0)
                return true;

            //Number of syncTypes which are/were dirty.
            int dirtyCount = 0;
            //Number of syncTypes which were written.
            int writtenCount = 0;

            //Flags as boolean.
            bool ignoreInterval = flags.FastContains(SyncTypeWriteFlag.IgnoreInterval);
            bool forceReliable = flags.FastContains(SyncTypeWriteFlag.ForceReliable);

            uint tick = _networkObjectCache.NetworkManager.TimeManager.Tick;
            bool ownerIsActive = _networkObjectCache.Owner.IsActive;

            //Reset syncTypeWriters.
            foreach (SyncTypeWriter stw in _syncTypeWriters.Values)
                stw.Reset();

            HashSet<ReadPermission> writtenReadPermissions = CollectionCaches<ReadPermission>.RetrieveHashSet();

            foreach (SyncBase sb in _syncTypes.Values)
            {
                //This entry is not dirty.
                if (!sb.IsDirty)
                    continue;

                /* Mark that at least one is still dirty.
                 * This does not mean that anything was written
                 * as there are still blocks to bypass. */
                dirtyCount++;

                //Interval not yet met.
                if (!ignoreInterval && !sb.IsNextSyncTimeMet(tick))
                    continue;

                //Unset that SyncType is dirty as it will be written now.
                sb.ResetDirty();

                /* SyncType is for owner only but the owner is not valid, therefor
                 * nothing can be written. It's possible for a SyncType to be dirty
                 * and owner only, with no owner, if the owner dropped after the syncType
                 * was dirtied. */
                ReadPermission rp = sb.Settings.ReadPermission;
                //If ReadPermission is owner but no owner skip this syncType write.
                if (!ownerIsActive && rp == ReadPermission.OwnerOnly)
                    continue;
                
                writtenCount++;

                if (forceReliable)
                    sb.SetCurrentChannel(Channel.Reliable);

                //Get channel
                byte channel = (byte)sb.Channel;

                /* Writer can be obtained quickly by using the readPermission byte value.
                 * Byte values are in order starting at 0. */


                //Find writer to use. Should never fail.
                if (!_syncTypeWriters.TryGetValueIL2CPP(rp, out SyncTypeWriter stw))
                    continue;

                /* Channel for syncType is beyond available channels in transport.
                 * Use default reliable. */
                if (channel >= TransportManager.CHANNEL_COUNT)
                    channel = (byte)Channel.Reliable;

                writtenReadPermissions.Add(rp);

                sb.WriteDelta(stw.Writers[channel]);
            }

            //If no dirty were found.
            if (dirtyCount == 0)
            {
                SyncTypeDirty = false;
                CollectionCaches<ReadPermission>.Store(writtenReadPermissions);
                return true;
            }
            //Nothing was written, but some are still dirty.
            else if (writtenReadPermissions.Count == 0)
            {
                CollectionCaches<ReadPermission>.Store(writtenReadPermissions);
                return false;
            }
            
            /* If here something was written. */

            PooledWriter fullWriter = WriterPool.Retrieve();
            TransportManager tm = _networkObjectCache.NetworkManager.TransportManager;

            foreach (ReadPermission rp in writtenReadPermissions)
            {
                //Find writer to use. Should never fail.
                if (!_syncTypeWriters.TryGetValueIL2CPP(rp, out SyncTypeWriter stw))
                    continue;

                for (int i = 0; i < stw.Writers.Count; i++)
                {
                    PooledWriter writer = stw.Writers[i];
                    //None written for this channel.
                    if (writer.Length == 0)
                        continue;
                    
                    CompleteSyncTypePacket(fullWriter, writer);
                    writer.Clear();
                    
                    //Should not be the case but check for safety.
                    if (fullWriter.Length == 0)
                        continue;

                    byte channel = (byte)i;

                    switch (rp)
                    {
                        //Send to everyone or excludeOwner.
                        case ReadPermission.Observers:
                            tm.SendToClients(channel, fullWriter.GetArraySegment(), _networkObjectCache.Observers);
                            break;
                        //Everyone but owner.
                        case ReadPermission.ExcludeOwner:
                            _networkConnectionCache.Clear();
                            if (ownerIsActive)
                                _networkConnectionCache.Add(_networkObjectCache.Owner);
                            tm.SendToClients(channel, fullWriter.GetArraySegment(), _networkObjectCache.Observers, _networkConnectionCache);
                            break;
                        //Owner only. Owner will always be valid if here.
                        case ReadPermission.OwnerOnly:
                            tm.SendToClient(channel, fullWriter.GetArraySegment(), _networkObjectCache.Owner);
                            break;
                    }

                    fullWriter.Clear();
                }
            }

            fullWriter.Store();
            CollectionCaches<ReadPermission>.Store(writtenReadPermissions);

            //Return if all dirty were written.
            bool allDirtyWritten = (dirtyCount == writtenCount);
            if (allDirtyWritten)
                SyncTypeDirty = false;

            return allDirtyWritten;
        }

        /// <summary>
        /// Writes all SyncTypes for a connection if readPermissions match.
        /// </summary>
        
        internal void WriteSyncTypesForConnection(NetworkConnection conn, ReadPermission readPermissions)
        {
            //There are no syncTypes.
            if (_syncTypes.Count == 0)
                return;

            //It will always exist but we need to out anyway.
            if (!_syncTypeWriters.TryGetValueIL2CPP(readPermissions, out SyncTypeWriter stw))
                return;

            //Reset syncTypeWriters.
            stw.Reset();

            PooledWriter fullWriter = WriterPool.Retrieve();

            foreach (SyncBase sb in _syncTypes.Values)
            {
                if (sb.Settings.ReadPermission != readPermissions)
                    continue;

                PooledWriter writer = stw.Writers[(byte)sb.Settings.Channel];
                sb.WriteFull(writer);
            }

            for (int i = 0; i < stw.Writers.Count; i++)
            {
                PooledWriter writer = stw.Writers[i];
                CompleteSyncTypePacket(fullWriter, writer);
                writer.Clear();

                byte channel = (byte)Channel.Reliable;
                _networkObjectCache.NetworkManager.TransportManager.SendToClient(channel, fullWriter.GetArraySegment(), conn);
            }

            fullWriter.Store();
        }

        /// <summary>
        /// Completes the writing of a SyncType by writing the header and serialized values.
        /// </summary>
        private void CompleteSyncTypePacket(PooledWriter fullWriter, PooledWriter syncTypeWriter)
        {
            //None written for this writer.
            if (syncTypeWriter.Length == 0)
                return;

            fullWriter.Clear();
            fullWriter.WritePacketIdUnpacked(PacketId.SyncType);
            fullWriter.WriteNetworkBehaviour(this);

            ReservedLengthWriter reservedWriter = ReservedWritersExtensions.Retrieve();
            reservedWriter.Initialize(fullWriter, SYNCTYPE_RESERVE_BYTES);
            
            fullWriter.WriteArraySegment(syncTypeWriter.GetArraySegment());
            
            reservedWriter.WriteLength();
            reservedWriter.Store();
        }

        /// <summary>
        /// Writes syncTypes for a spawn message.
        /// </summary>
        /// <param name="conn">Connection SyncTypes are being written for.</param>
        internal void WriteSyncTypesForSpawn(PooledWriter writer, NetworkConnection conn)
        {
            //There are no syncTypes.
            if (_syncTypes.Count == 0)
                return;

            //True if connection passed in is the owner of this object.
            bool connIsOwner = (conn == _networkObjectCache.Owner);

            //Reserved bytes for componentIndex and amount written.
            const byte reservedBytes = 2;
            writer.Skip(reservedBytes);
            int positionAfterReserve = writer.Position;

            byte written = 0;

            foreach (SyncBase sb in _syncTypes.Values)
            {
                ReadPermission rp = sb.Settings.ReadPermission;
                bool canWrite = (rp == ReadPermission.Observers) ||
                                (rp == ReadPermission.ExcludeOwner && !connIsOwner) ||
                                (rp == ReadPermission.OwnerOnly && connIsOwner);

                if (!canWrite)
                    continue;

                int startWriterPosition = writer.Position;
                sb.WriteFull(writer);
                if (writer.Position != startWriterPosition)
                    written++;
            }

            //If any where written.
            if (positionAfterReserve != writer.Position)
            {
                int insertPosition = (positionAfterReserve - reservedBytes);
                writer.InsertUInt8Unpacked(ComponentIndex, insertPosition++);
                writer.InsertUInt8Unpacked(written, insertPosition);
            }
            else
            {
                writer.Remove(reservedBytes);
            }
        }


        /// <summary>
        /// Reads a SyncType for spawn.
        /// </summary>
        internal void ReadSyncTypesForSpawn(PooledReader reader)
        {
            byte written = reader.ReadUInt8Unpacked();
            for (int i = 0; i < written; i++)
            {
                byte syncTypeId = reader.ReadUInt8Unpacked();
                
                if (_syncTypes.TryGetValueIL2CPP(syncTypeId, out SyncBase sb))
                    sb.Read(reader, asServer: false);
                else
                    NetworkManager.LogWarning($"SyncType not found for index {syncTypeId} on {transform.name}, component {GetType().FullName}. Remainder of packet may become corrupt.");
            }
        }


        /// <summary>
        /// Resets all SyncTypes for this NetworkBehaviour for server or client.
        /// </summary>
        internal void ResetState_SyncTypes(bool asServer)
        {
            if (_syncTypes != null)
            {
                foreach (SyncBase item in _syncTypes.Values)
                    item.ResetState(asServer);
            }

            if (_syncTypeWriters != null)
            {
                foreach (SyncTypeWriter syncTypeWriter in _syncTypeWriters.Values)
                    syncTypeWriter.Reset();
            }

            if (asServer)
                SyncTypeDirty = false;
        }

        private void SyncTypes_OnDestroy()
        {
            CollectionCaches<uint, SyncBase>.StoreAndDefault(ref _syncTypes);
        }
    }
}﻿using FishNet.Object.Helping;
using FishNet.Transporting;

namespace FishNet.Object
{


    internal struct RpcLinkType
    {
        /// <summary>
        /// Hash for the Rpc.
        /// </summary>
        public readonly uint RpcHash;
        /// <summary>
        /// PacketId used for the Rpc type when not using links.
        /// </summary>
        public readonly PacketId RpcPacketId;
        /// <summary>
        /// PacketId sent for the RpcLink.
        /// </summary>
        public readonly ushort LinkPacketId;

        public RpcLinkType(uint rpcHash, PacketId packetId, ushort linkPacketId)
        {
            RpcHash = rpcHash;
            RpcPacketId = packetId;
            LinkPacketId = linkPacketId;
        }
    }

}﻿// namespace FishNet.Object //Remove V5
// {
//
//     internal enum SyncTypeWriteType
//     {
//         Observers = 0,
//         Owner = 1,
//         All = 2,
//     }
//
//
// }﻿using FishNet.Broadcast;
using FishNet.Managing;
using FishNet.Transporting;
using UnityEngine;

namespace FishNet.Object
{
    public partial class NetworkObject : MonoBehaviour
    {

        /// <summary>
        /// Sends a broadcast to Observers on this NetworkObject.
        /// </summary>
        /// <typeparam name="T">Type of broadcast to send.</typeparam>
        /// <param name="message">Broadcast data being sent; for example: an instance of your broadcast type.</param>
        /// <param name="requireAuthenticated">True if the client must be authenticated for this broadcast to send.</param>
        /// <param name="channel">Channel to send on.</param>
        public void Broadcast<T>(T message, bool requireAuthenticated = true, Channel channel = Channel.Reliable) where T : struct, IBroadcast
        {
            if (NetworkManager == null)
            {
                NetworkManager.LogWarning($"Cannot send broadcast from {gameObject.name}, NetworkManager reference is null. This may occur if the object is not spawned or initialized.");
                return;
            }

            NetworkManager.ServerManager.Broadcast(Observers, message, requireAuthenticated, channel);
        }
    }

}

﻿using FishNet.Connection;
using System.Runtime.CompilerServices;
using FishNet.Serializing;
using UnityEngine;

namespace FishNet.Object
{
    public partial class NetworkObject : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// True if OnStartServer was called.
        /// </summary>
        private bool _onStartServerCalled;
        /// <summary>
        /// True if OnStartClient was called.
        /// </summary>
        private bool _onStartClientCalled;
        #endregion

        // ReSharper disable Unity.PerformanceAnalysis
        /// <summary>
        /// Called after all data is synchronized with this NetworkObject.
        /// </summary>
        private void InvokeStartCallbacks(bool asServer, bool invokeSyncTypeCallbacks)
        {
            /* Note: When invoking OnOwnership here previous owner will
             * always be an empty connection, since the object is just
             * now initializing. */

            //Invoke OnStartNetwork.
            bool invokeOnNetwork = (asServer || IsServerOnlyStarted || IsClientOnlyInitialized);
            if (invokeOnNetwork)
            {
                for (int i = 0; i < NetworkBehaviours.Count; i++)
                    NetworkBehaviours[i].InvokeOnNetwork_Internal(start: true);
            }

            //As server.
            if (asServer)
            {
                for (int i = 0; i < NetworkBehaviours.Count; i++)
                    NetworkBehaviours[i].OnStartServer_Internal();
                _onStartServerCalled = true;
                for (int i = 0; i < NetworkBehaviours.Count; i++)
                    NetworkBehaviours[i].OnOwnershipServer_Internal(FishNet.Managing.NetworkManager.EmptyConnection);
            }
            //As client.
            else
            {
                for (int i = 0; i < NetworkBehaviours.Count; i++)
                    NetworkBehaviours[i].OnStartClient_Internal();
                _onStartClientCalled = true;
                for (int i = 0; i < NetworkBehaviours.Count; i++)
                    NetworkBehaviours[i].OnOwnershipClient_Internal(FishNet.Managing.NetworkManager.EmptyConnection);
            }

            if (invokeSyncTypeCallbacks)
                InvokeOnStartSyncTypeCallbacks(true);

            InvokeStartCallbacks_Prediction(asServer);
        }

        /// <summary>
        /// Invokes OnStartXXXX for synctypes, letting them know the NetworkBehaviour start cycle has been completed.
        /// </summary>
        internal void InvokeOnStartSyncTypeCallbacks(bool asServer)
        {
            for (int i = 0; i < NetworkBehaviours.Count; i++)
                NetworkBehaviours[i].InvokeSyncTypeOnStartCallbacks(asServer);
        }

        /// <summary>
        /// Invokes OnStopXXXX for synctypes, letting them know the NetworkBehaviour stop cycle is about to start.
        /// </summary>
        internal void InvokeOnStopSyncTypeCallbacks(bool asServer)
        {
            for (int i = 0; i < NetworkBehaviours.Count; i++)
                NetworkBehaviours[i].InvokeSyncTypeOnStopCallbacks(asServer);
        }

        /// <summary>
        /// Invokes events to be called after OnServerStart.
        /// This is made one method to save instruction calls.
        /// </summary>
        /// <param name=""></param>
        internal void OnSpawnServer(NetworkConnection conn)
        {
            for (int i = 0; i < NetworkBehaviours.Count; i++)
                NetworkBehaviours[i].SendBufferedRpcs(conn);

            for (int i = 0; i < NetworkBehaviours.Count; i++)
                NetworkBehaviours[i].OnSpawnServer(conn);
        }

        /// <summary>
        /// Called on the server before it sends a despawn message to a client.
        /// </summary>
        /// <param name="conn">Connection spawn was sent to.</param>
        internal void InvokeOnServerDespawn(NetworkConnection conn)
        {
            for (int i = 0; i < NetworkBehaviours.Count; i++)
                NetworkBehaviours[i].OnDespawnServer(conn);
        }

        // ReSharper disable Unity.PerformanceAnalysis
        /// <summary>
        /// Invokes OnStop callbacks.
        /// </summary>
        internal void InvokeStopCallbacks(bool asServer, bool invokeSyncTypeCallbacks)
        {
            InvokeStopCallbacks_Prediction(asServer);

            if (invokeSyncTypeCallbacks)
                InvokeOnStopSyncTypeCallbacks(asServer);
            
            if (asServer && _onStartServerCalled)
            {
                for (int i = 0; i < NetworkBehaviours.Count; i++)
                    NetworkBehaviours[i].OnStopServer_Internal();

                if (!_onStartClientCalled)
                    InvokeOnNetwork();

                _onStartServerCalled = false;
            }
            else if (!asServer && _onStartClientCalled)
            {
                for (int i = 0; i < NetworkBehaviours.Count; i++)
                    NetworkBehaviours[i].OnStopClient_Internal();

                /* Only invoke OnNetwork if server start isn't called, otherwise
                 * that means this is still intialized on the server. This would
                 * happen if the object despawned for the clientHost but not on the
                 * server. */
                if (!_onStartServerCalled)
                    InvokeOnNetwork();

                _onStartClientCalled = false;
            }
 
            void InvokeOnNetwork()
            {
                for (int i = 0; i < NetworkBehaviours.Count; i++)
                    NetworkBehaviours[i].InvokeOnNetwork_Internal(start: false);
            }
        }

        /// <summary>
        /// Invokes OnOwnership callbacks when ownership changes.
        /// This is not to be called when assigning ownership during a spawn message.
        /// </summary>
        private void InvokeManualOwnershipChange(NetworkConnection prevOwner, bool asServer)
        {
            if (asServer)
            {
                for (int i = 0; i < NetworkBehaviours.Count; i++)
                    NetworkBehaviours[i].OnOwnershipServer_Internal(prevOwner);

                WriteSyncTypesForManualOwnershipChange(prevOwner);
            }
            else
            {
                /* If local client is owner and not server then only
                 * invoke if the prevOwner is different. This prevents
                 * the owner change callback from happening twice when
                 * using TakeOwnership.
                 *
                 * Further explained, the TakeOwnership sets local client
                 * as owner client-side, which invokes the OnOwnership method.
                 * Then when the server approves the owner change it would invoke
                 * again, which is not needed. */
                bool blockInvoke = ((IsOwner && !IsServerStarted) && (prevOwner == Owner));
                if (!blockInvoke)
                {
                    for (int i = 0; i < NetworkBehaviours.Count; i++)
                        NetworkBehaviours[i].OnOwnershipClient_Internal(prevOwner);
                }
            }
        }
    }
}﻿using System;
using FishNet.Managing;
using FishNet.Connection;
using UnityEngine;
using FishNet.Serializing;
using FishNet.Transporting;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using FishNet.Utility.Performance;
using FishNet.Component.Ownership;
using FishNet.Utility.Extension;
using GameKit.Dependencies.Utilities;
using GameKit.Dependencies.Utilities.Types;
using UnityEngine.Serialization;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace FishNet.Object
{
    public class NetworkObjectIdComparer : IEqualityComparer<NetworkObject>
    {
        public bool Equals(NetworkObject valueA, NetworkObject valueB)
        {
            bool aNull = (valueA is null);
            bool bNull = (valueB is null);
            //One null, one isn't.
            if (aNull != bNull)
                return false;
            //Both null.
            if (aNull && bNull)
                return true;

            //If here neither are null.
            return (valueA.ObjectId == valueB.ObjectId);
        }

        public int GetHashCode(NetworkObject obj)
        {
            return obj.ObjectId;
        }
    }

    [DefaultExecutionOrder(short.MinValue + 1)]
    [DisallowMultipleComponent]
    public partial class NetworkObject : MonoBehaviour, IOrderable
    {
        #region Public.
        /// <summary>
        /// True if this object is nested.
        /// This value is automatically applied for prefabs and scene objects during serialization. However, if changing parents at runtime use NetworkObject.SetParent().
        /// </summary>
        [field: SerializeField, HideInInspector]
        public bool IsNested { get; private set; }
        /// <summary>
        /// True if was set as nested during initialization.
        /// </summary>
        public bool IsInitializedNested => (InitializedParentNetworkBehaviour != null);

        /// <summary>
        /// NetworkConnection which predicted spawned this object.
        /// </summary>
        public NetworkConnection PredictedSpawner { get; private set; } = NetworkManager.EmptyConnection;
        /// <summary>
        /// True if this NetworkObject was active during edit. Will be true if a scene object or prefab that is active by default.
        /// </summary>
        [field: SerializeField, HideInInspector]
        internal bool WasActiveDuringEdit;
        /// <summary>
        /// This value is used to ensure users have reserialized NetworkObjects to apply WasActiveDuringEdit. //Remove V5.
        /// </summary>
        [field: SerializeField, HideInInspector]
        internal bool WasActiveDuringEdit_Set1;

        /// <summary>
        /// Returns if this object was placed in the scene during edit-time.
        /// </summary>
        /// <returns></returns>
        public bool IsSceneObject => (SceneId != NetworkObject.UNSET_SCENEID_VALUE);

        /// <summary>
        /// ComponentIndex for this NetworkBehaviour.
        /// </summary>
        [field: SerializeField, HideInInspector]
        public byte ComponentIndex { get; private set; }

        /// <summary>
        /// Unique Id for this NetworkObject. This does not represent the object owner.
        /// </summary>
        public int ObjectId { get; private set; } = NetworkObject.UNSET_OBJECTID_VALUE;

        /// <summary>
        /// True if this NetworkObject is deinitializing. Will also be true until Initialize is called. May be false until the object is cleaned up if object is destroyed without using Despawn.
        /// </summary>
        internal bool IsDeinitializing { get; private set; } = true;

        /// <summary>
        /// PredictedSpawn component on this object. Will be null if not added manually.
        /// </summary>
        [field: SerializeField, HideInInspector]
        public PredictedSpawn PredictedSpawn { get; private set; }

        /// <summary>
        /// PredictedOwner component on this object. Will be null if not added manually.
        /// </summary>
        [field: SerializeField, HideInInspector]
        public PredictedOwner PredictedOwner { get; private set; }

        /// <summary>
        /// Current Networkbehaviours.
        /// </summary>
        [HideInInspector]
        public List<NetworkBehaviour> NetworkBehaviours;
        /// <summary>
        /// NetworkBehaviour on the root of a NetworkObject parenting this instance. Value will be null if there was no parent during serialization.
        /// </summary>
        /// <remarks>This API is for internal use and may change at any time.</remarks>
        [HideInInspector]
        public NetworkBehaviour InitializedParentNetworkBehaviour;

        /// <summary>
        /// Nested NetworkObjects that existed during initialization.
        /// </summary>
        /// <remarks>This API is for internal use and may change at any time.</remarks>
        [HideInInspector]
        public List<NetworkObject> InitializedNestedNetworkObjects = new();
        /// <summary>
        /// NetworkBehaviour parenting this object when set at runtime using NetworkObject/NetworkBehaviour.SetParent.
        /// This is exposed only for low-level use and may change without notice.
        /// </summary>
        [HideInInspector]
        public NetworkBehaviour RuntimeParentNetworkBehaviour;
        /// <summary>
        /// NetworkObjects which are made child at runtime using NetworkObject.SetParent.
        /// This is exposed only for low-level use and may change without notice.
        /// </summary>
        [HideInInspector]
        public List<NetworkBehaviour> RuntimeChildNetworkBehaviours;
        /// <summary>
        /// NetworkBehaviour parenting this instance. This value prioritizes the runtime value, then initialized value.
        /// This is exposed only for low-level use and may change without notice.
        /// </summary>
        internal NetworkBehaviour CurrentParentNetworkBehaviour
        {
            get
            {
                if (RuntimeParentNetworkBehaviour != null)
                    return RuntimeParentNetworkBehaviour;
                if (InitializedParentNetworkBehaviour != null)
                    return InitializedParentNetworkBehaviour;

                return null;
            }
        }

        /// <summary>
        /// Current state of the NetworkObject.
        /// </summary>
        [System.NonSerialized]
        internal NetworkObjectState State = NetworkObjectState.Unset;
        #endregion

        #region Serialized.
        /// <summary>
        /// True if the object will always initialize as a networked object. When false the object will not automatically initialize over the network. Using Spawn() on an object will always set that instance as networked.
        /// To check if server or client has been initialized on this object use IsXYZInitialized.
        /// </summary>
        [Obsolete("Use Get/SetIsNetworked.")]
        public bool IsNetworked
        {
            get => GetIsNetworked();
            private set => SetIsNetworked(value);
        }

        /// <summary>
        /// Returns IsNetworked value.
        /// </summary>
        /// <returns></returns>
        public bool GetIsNetworked() => _isNetworked;

        /// <summary>
        /// Sets IsNetworked value. This method must be called before Start.
        /// </summary>
        /// <param name="value">New IsNetworked value.</param>
        public void SetIsNetworked(bool value)
        {
            _isNetworked = value;
        }

        [Tooltip("True if the object will always initialize as a networked object. When false the object will not automatically initialize over the network. Using Spawn() on an object will always set that instance as networked.")]
        [SerializeField]
        private bool _isNetworked = true;

        /// <summary>
        /// True if the object can be spawned at runtime; this is generally false for scene prefabs you do not spawn.
        /// </summary>
        [Obsolete("Use GetIsSpawnable.")] //Remove on V5.
        public bool IsSpawnable => _isSpawnable;

        /// <summary>
        /// Gets the current IsSpawnable value.
        /// </summary>
        /// <returns></returns>
        public bool GetIsSpawnable() => _isSpawnable;

        /// <summary>
        /// Sets IsSpawnable value.
        /// </summary>
        /// <param name="value">Next value.</param>
        public void SetIsSpawnable(bool value) => _isSpawnable = value;

        [Tooltip("True if the object can be spawned at runtime; this is generally false for scene prefabs you do not spawn.")]
        [SerializeField]
        private bool _isSpawnable = true;

        /// <summary>
        /// True to make this object global, and added to the DontDestroyOnLoad scene. This value may only be set for instantiated objects, and can be changed if done immediately after instantiating.
        /// </summary>
        public bool IsGlobal
        {
            get => _isGlobal;
            private set => _isGlobal = value;
        }

        /// <summary>
        /// Sets IsGlobal value.
        /// </summary>
        /// <param name="value">New global value.</param>
        public void SetIsGlobal(bool value)
        {
            if (IsNested && !CurrentParentNetworkBehaviour.NetworkObject.IsGlobal)
            {
                NetworkManager.LogWarning($"Object {gameObject.name} cannot change IsGlobal because it is nested and the parent NetorkObject is not global.");
                return;
            }

            if (!IsDeinitializing)
            {
                NetworkManager.LogWarning($"Object {gameObject.name} cannot change IsGlobal as it's already initialized. IsGlobal may only be changed immediately after instantiating.");
                return;
            }

            if (IsSceneObject)
            {
                NetworkManager.LogWarning($"Object {gameObject.name} cannot have be global because it is a scene object. Only instantiated objects may be global.");
                return;
            }

            _networkObserverInitiliazed = false;
            IsGlobal = value;
        }

        [Tooltip("True to make this object global, and added to the DontDestroyOnLoad scene. This value may only be set for instantiated objects, and can be changed if done immediately after instantiating.")]
        [SerializeField]
        private bool _isGlobal;

        /// <summary> 
        /// Order to initialize this object's callbacks when spawned with other NetworkObjects in the same tick. Default value is 0, negative values will execute callbacks first.
        /// </summary>
        public int GetInitializeOrder() => Order;

        /// <summary>
        /// This is for internal use. Returns the order to initialize the object.
        /// </summary>
        public int Order
        {
            get
            {
                /* Returns a value to add onto initialization order
                 * based on how nested the object is. This is a fairly
                 * cheap and quick way to ensure nested objects
                 * always initialize after ones in the hierarchy. */
                /* Assuming a modifier base of 100.
                 * A            0
                 *   B          100
                 *     C        200
                 *       D      300
                 *   E          100
                 *     F        200
                 */
                int GetOrderModifier()
                {
                    //Ensure at least 1 multiplier so initialization order isnt multiplied by 0.
                    int multiplier = 1;

                    //Add one multiplier per every nested.
                    NetworkBehaviour parentNb = CurrentParentNetworkBehaviour;
                    while (parentNb != null)
                    {
                        multiplier += 1;
                        parentNb = parentNb.NetworkObject.CurrentParentNetworkBehaviour;
                    }

                    //InitializeOrder max value + 1.
                    const int modifierBase = (sbyte.MaxValue + 1);

                    return (multiplier * modifierBase);
                }

                return (_initializeOrder + GetOrderModifier());
            }
        }

        [Tooltip("Order to initialize this object's callbacks when spawned with other NetworkObjects in the same tick. Default value is 0, negative values will execute callbacks first.")]
        [Range(sbyte.MinValue, sbyte.MaxValue)]
        [SerializeField]
        private sbyte _initializeOrder = 0;
        /// <summary>
        /// True to keep this object spawned when the owner disconnects.
        /// </summary>
        internal bool PreventDespawnOnDisconnect => _preventDespawnOnDisconnect;
        [Tooltip("True to keep this object spawned when the owner disconnects.")]
        [SerializeField]
        private bool _preventDespawnOnDisconnect;
        /// <summary>
        /// How to handle this object when it despawns. Scene objects are never destroyed when despawning.
        /// </summary>
        [SerializeField]
        [Tooltip("How to handle this object when it despawns. Scene objects are never destroyed when despawning.")]
        private DespawnType _defaultDespawnType = DespawnType.Destroy;

        /// <summary>
        /// True to use configured ObjectPool rather than destroy this NetworkObject when being despawned. Scene objects are never destroyed.
        /// </summary>
        public DespawnType GetDefaultDespawnType() => _defaultDespawnType;

        /// <summary>
        /// Sets DespawnType value.
        /// </summary>
        /// <param name="despawnType">Default despawn type for this NetworkObject.</param>
        public void SetDefaultDespawnType(DespawnType despawnType)
        {
            _defaultDespawnType = despawnType;
        }
        #endregion

        #region Private.
        /// <summary>
        /// True if disabled NetworkBehaviours have been initialized.
        /// </summary>
        private bool _disabledNetworkBehavioursInitialized;
        /// <summary>
        /// Becomes true once initialized values are set.
        /// </summary>
        private bool _initializedValusSet;
        /// <summary>
        /// Sets that InitializedValues have not yet been set. This can be used to force objects to reinitialize which may have changed since the prefab was initialized, such as placed scene objects.
        /// </summary>
        internal void UnsetInitializedValuesSet() => _initializedValusSet = false;
        #endregion

        #region Const.
        /// <summary>
        /// Value used when the ObjectId has not been set.
        /// </summary>
        public const int UNSET_SCENEID_VALUE = 0;
        /// <summary>
        /// Value used when the ObjectId has not been set.
        /// </summary>
        public const int UNSET_OBJECTID_VALUE = ushort.MaxValue;
        /// <summary>
        /// Value used when the PrefabId has not been set.
        /// </summary>
        public const int UNSET_PREFABID_VALUE = ushort.MaxValue;
        #endregion
        
        /// <summary>
        /// Outputs data about this NetworkObject to string.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            string hashCode = (gameObject == null) ? $"NetworkObject HashCode [{GetHashCode()}]" : $"GameObject HashCode [{gameObject.GetHashCode()}]";
            return $"Name [{gameObject.name}] ObjectId [{ObjectId}] OwnerId [{OwnerId}] {hashCode}";
        }

        protected virtual void Awake()
        {
            _isStatic = gameObject.isStatic;

            /* If networkBehaviours are not yet initialized then do so now.
             * After initializing at least 1 networkBehaviour will always exist
             * as emptyNetworkBehaviour is added automatically when none are present. */
            if (!_initializedValusSet)
            {
                bool isNested = false;
                //Make sure there are no networkObjects above this since initializing will trickle down.
                Transform parent = transform.parent;
                while (parent != null)
                {
                    if (parent.TryGetComponent<NetworkObject>(out _))
                    {
                        isNested = true;
                        break;
                    }

                    parent = parent.parent;
                }

                //If not nested then init
                if (!isNested)
                    SetInitializedValues(parentNob: null, force: false);
            }

            SetChildDespawnedState();
        }

        protected virtual void Start()
        {
            TryStartDeactivation();
        }

        private void OnDisable()
        {
            /* If deinitializing and an owner exist
             * then remove object from owner. */
            if (IsDeinitializing && Owner.IsValid)
            {
                Owner.RemoveObject(this);
            }
            //Nothing is started and is a sceneObject.
            else if (!IsServerStarted && !IsClientStarted && IsSceneObject)
            {
                ResetState(asServer: true);
                ResetState(asServer: false);
            }
        }

        private void OnDestroy()
        {
            SetIsDestroying(DespawnType.Destroy);

            //The object never initialized for use.
            if (!_initializedValusSet)
                return;
            
            if (NetworkObserver != null)
                NetworkObserver.Deinitialize(destroyed: true);
            
            if (NetworkManager != null)
            {
                //Server.
                Deinitialize_Prediction(asServer: true);
                NetworkManager.ServerManager.Objects.NetworkObjectDestroyed(this, asServer: true);
                InvokeStopCallbacks(asServer: true, invokeSyncTypeCallbacks: true);
 
                //Client.
                Deinitialize_Prediction(asServer: false);
                NetworkManager.ClientManager.Objects.NetworkObjectDestroyed(this, asServer: false);
                InvokeStopCallbacks(asServer: false, invokeSyncTypeCallbacks: true);
            }

            /* If owner exist then remove object from owner.
             * This has to be called here as well OnDisable because
             * the OnDisable will only remove the object if
             * deinitializing. This is because the object shouldn't
             * be removed from owner if the object is simply being
             * disabled, but not deinitialized. But in the scenario
             * the object is unexpectedly destroyed, which is how we
             * arrive here, the object needs to be removed from owner. */
            if (Owner.IsValid)
                Owner.RemoveObject(this);

            Observers.Clear();
            if (NetworkBehaviours.Count > 0)
            {
                NetworkBehaviour thisNb = NetworkBehaviours[0];
                /* A null check must also be run on the RuntimeChildNbs because the collection is stored
                 * when an object is destroyed, and if the other object OnDestroy runs before this one deinitializes/destroys
                 * then the collection will be null. */
                if (RuntimeParentNetworkBehaviour != null && RuntimeParentNetworkBehaviour.NetworkObject.RuntimeChildNetworkBehaviours != null)
                    RuntimeParentNetworkBehaviour.NetworkObject.RuntimeChildNetworkBehaviours.Remove(thisNb);
            }

            IsDeinitializing = true;

            SetDeinitializedStatus();

            NetworkBehaviour_OnDestroy();

            ResetState(asServer: true);
            ResetState(asServer: false);

            StoreCollections();

            void NetworkBehaviour_OnDestroy()
            {
                foreach (NetworkBehaviour nb in NetworkBehaviours)
                    nb.NetworkBehaviour_OnDestroy();
            }
        }

        /// <summary>
        /// Initializes NetworkBehaviours if they are disabled.
        /// </summary>
        private void InitializeNetworkBehavioursIfDisabled()
        {
            if (_disabledNetworkBehavioursInitialized)
                return;
            _disabledNetworkBehavioursInitialized = true;

            for (int i = 0; i < NetworkBehaviours.Count; i++)
                NetworkBehaviours[i].InitializeIfDisabled();
        }

        /// <summary>
        /// Returns a cached collection containing NetworkObjects belonging to this object.
        /// </summary>
        internal List<NetworkObject> GetNetworkObjects(GetNetworkObjectOption option)
        {
            List<NetworkObject> cache = CollectionCaches<NetworkObject>.RetrieveList();

            if (option.FastContains(GetNetworkObjectOption.Self))
                cache.Add(this);

            //Becomes true if to include any nested.
            bool includesNested = false;

            if (option.FastContains(GetNetworkObjectOption.InitializedNested))
            {
                cache.AddRange(InitializedNestedNetworkObjects);
                includesNested = true;
            }

            if (option.FastContains(GetNetworkObjectOption.RuntimeNested))
            {
                foreach (NetworkBehaviour nb in RuntimeChildNetworkBehaviours)
                    cache.Add(nb.NetworkObject);

                includesNested = true;
            }

            if (includesNested && option.FastContains(GetNetworkObjectOption.Recursive))
            {
                /* Remove include self from options otherwise
                 * each nested entry would get added twice. */
                option &= ~GetNetworkObjectOption.Self;

                int count = cache.Count;
                for (int i = 0; i < count; i++)
                {
                    List<NetworkObject> recursiveCache = cache[i].GetNetworkObjects(option);
                    cache.AddRange(recursiveCache);
                    CollectionCaches<NetworkObject>.Store(recursiveCache);
                }
            }

            return cache;
        }

        /// <summary>
        /// Makes children of this NetworkObject global if this object is global.
        /// </summary>
        private void SetChildGlobalState()
        {
            if (!IsGlobal)
                return;

            for (int i = 0; i < InitializedNestedNetworkObjects.Count; i++)
                InitializedNestedNetworkObjects[i].SetIsGlobal(true);
        }

        /// <summary>
        /// Sets Despawned on child NetworkObjects if they are not enabled.
        /// </summary>
        private void SetChildDespawnedState()
        {
            NetworkObject nob;
            for (int i = 0; i < InitializedNestedNetworkObjects.Count; i++)
            {
                nob = InitializedNestedNetworkObjects[i];
                if (!nob.gameObject.activeSelf)
                    nob.State = NetworkObjectState.Despawned;
            }
        }

        internal void TryStartDeactivation()
        {
            if (!GetIsNetworked())
                return;

            //Global.
            if (IsGlobal && !IsSceneObject && !IsNested)
                DontDestroyOnLoad(gameObject);

            if (NetworkManager == null || (!NetworkManager.IsClientStarted && !NetworkManager.IsServerStarted))
            {
                //ActiveDuringEdit is only used for scene objects.
                if (IsSceneObject)
                    WasActiveDuringEdit = true;
                gameObject.SetActive(false);
            }
        }

        /// <summary>
        /// Sets IsClient or IsServer to isActive.
        /// </summary>
        internal void SetInitializedStatus(bool isInitialized, bool asServer)
        {
            if (asServer)
                IsServerInitialized = isInitialized;
            else
                IsClientInitialized = isInitialized;
        }

        /// <summary>
        /// Sets IsServerInitialized and IsClientInitialized as false;
        /// </summary>
        private void SetDeinitializedStatus()
        {
            IsServerInitialized = false;
            IsClientInitialized = false;
        }

        /// <summary>
        /// Preinitializes this object for the network.
        /// </summary>
        /// <param name="networkManager"></param>
        //public static event Action DebugOnInitialize; //QUICK-TEST Uncomment this
        
        internal void InitializeEarly(NetworkManager networkManager, int objectId, NetworkConnection owner, bool asServer)
        {
            //Only initialize this bit once even if clientHost.
            if (!networkManager.DoubleLogic(asServer))
            {
                //DebugOnInitialize?.Invoke(); //QUICK-TEST Uncomment this
                
                State = NetworkObjectState.Spawned;
                InitializeNetworkBehavioursIfDisabled();
                IsDeinitializing = false;
                //QOL references.
                NetworkManager = networkManager;
                ServerManager = networkManager.ServerManager;
                ClientManager = networkManager.ClientManager;
                ObserverManager = networkManager.ObserverManager;
                TransportManager = networkManager.TransportManager;
                TimeManager = networkManager.TimeManager;
                SceneManager = networkManager.SceneManager;
                PredictionManager = networkManager.PredictionManager;
                RollbackManager = networkManager.RollbackManager;

                SetOwner(owner);

                if (ObjectId != NetworkObject.UNSET_OBJECTID_VALUE)
                    NetworkManager.LogError($"Object was initialized twice without being reset. Object {this.ToString()}");

                ObjectId = objectId;

                /* This must be called at the beginning
                 * so that all conditions are handled by the observer
                 * manager prior to the preinitialize call on networkobserver.
                 * The method called is dependent on NetworkManager being set. */
                AddDefaultNetworkObserverConditions();
            }

            for (int i = 0; i < NetworkBehaviours.Count; i++)
                NetworkBehaviours[i].InitializeEarly(this, asServer);

            /* NetworkObserver uses some information from
             * NetworkBehaviour so it must be preinitialized
             * after NetworkBehaviours are. */
            if (asServer)
            {
                if (networkManager.TryGetInstance(out _hashGrid))
                {
                    _hashGridPosition = _hashGrid.GetHashGridPosition(this);
                    HashGridEntry = _hashGrid.GetGridEntry(this);
                }

                NetworkObserver.Initialize(this);
            }

            _networkObserverInitiliazed = true;

            InitializePredictionEarly(networkManager, asServer);
            //Add to connections objects. Collection is a hashset so this can be called twice for clientHost.
            if (owner != null)
                owner.AddObject(this);
        }

        private void TimeManager_Update()
        {
            TimeManager_OnUpdate_Prediction();
        }

        /// <summary>
        /// Sets this NetworkObject as a child of another at runtime.
        /// </summary>
        /// <param name="nb">NetworkBehaviour to use as root. Use null to remove parenting.</param>
        public void SetParent(NetworkBehaviour nb)
        {
            if (!CanChangeParent(true))
                return;
            if (IsInvalidParent(nb))
                return;

            UpdateParent(nb);
        }

        /// <summary>
        /// Sets this NetworkObject as a child of another at runtime.
        /// </summary>
        /// <param name="nob">NetworkObject to use as root. Use null to remove parenting.</param>
        public void SetParent(NetworkObject nob)
        {
            if (!CanChangeParent(true))
                return;
            if (nob == null)
            {
                UnsetParent();
                return;
            }

            //No networkbehaviour.
            if (nob.NetworkBehaviours.Count == 0)
            {
                NetworkManager.LogWarning($"{nob.name} is not a valid parent because it does not have any NetworkBehaviours. Consider adding {nameof(EmptyNetworkBehaviour)} to {nob.name} to resolve this problem.");
                return;
            }

            NetworkBehaviour newParent = nob.NetworkBehaviours[0];
            UpdateParent(newParent);
        }

        /// <summary>
        /// Unsets this NetworkObject's parent at runtime.
        /// </summary>
        public void UnsetParent()
        {
            UpdateParent(newParent: null);
        }

        /// <summary>
        /// Updates which NetworkBehaviour to use as a parent.
        /// </summary>
        /// 
        private void UpdateParent(NetworkBehaviour newParent)
        {
            NetworkBehaviour thisNb;

            if (NetworkBehaviours.Count == 0)
            {
                NetworkManager.LogWarning($"{gameObject.name} cannot have it's parent updated because it does not have any NetworkBehaviours. Consider adding {nameof(EmptyNetworkBehaviour)} to {gameObject.name} to resolve this problem.");
                return;
            }
            else
            {
                //Always use the first to make life easier on everyone.
                thisNb = NetworkBehaviours[0];
            }

            //If current is set then remove from as child.
            if (RuntimeParentNetworkBehaviour != null)
                RuntimeParentNetworkBehaviour.NetworkObject.RuntimeChildNetworkBehaviours.Remove(thisNb);

            //If no new parent, then parent is being removed.
            if (newParent == null)
            {
                RuntimeParentNetworkBehaviour = null;
                transform.SetParent(null);
            }
            //Being set to something.
            else
            {
                RuntimeParentNetworkBehaviour = newParent;
                newParent.NetworkObject.RuntimeChildNetworkBehaviours.Add(thisNb);
                transform.SetParent(newParent.transform);
            }

            /* Rebuild observers since root changed.
             *
             * This only occurs if this nob is network spawned.
             * If not spawned the rebuild will occur after the
             * user calls Spawn on the nob/object. */
            if (NetworkManager != null)
                NetworkManager.ServerManager.Objects.RebuildObservers(this);
        }

        /// <summary>
        /// Returns if this NetworkObject can change it's parent.
        /// </summary>
        private bool CanChangeParent(bool logFailure)
        {
            if (IsSceneObject)
                return true;
            //No limitations on nobs without initialized parents.
            if (InitializedParentNetworkBehaviour == null)
                return true;

            if (logFailure)
                NetworkManager.LogWarning($"{this.ToString()} cannot have it's parent changed because it's nested. Only nested scene objects may change their parent runtime.");

            return false;
        }

        /// <summary>
        /// True if the NetworkObject specified cannot be used as a parent.
        /// </summary>
        /// <param name="nb"></param>
        /// <returns></returns>
        private bool IsInvalidParent(NetworkBehaviour nb)
        {
            /* Scene objects could face destruction if the user
             * childs them to an instantiated object that gets despawned.
             * If that occurs, the user is at fault. However a destroyed
             * scene object should be fine, it just won't spawn later given
             * it's been destroyed. Allow scene objects to change parents freely. */
            if (IsSceneObject)
                return false;

            //Setting to already current runtime parent. No need to make a change.
            if (nb == RuntimeParentNetworkBehaviour)
                return true;
            //Trying to parent a non-global to a global.
            if (nb.NetworkObject.IsGlobal && !IsGlobal)
            {
                NetworkManager.LogWarning($"{nb.NetworkObject.name} is a global NetworkObject but {gameObject.name} is not. Only global NetworkObjects can be set as a child of another global NetworkObject.");
                return true;
            }

            //Setting to self.
            if (nb.NetworkObject == this)
            {
                NetworkManager.LogWarning($"{gameObject.name} cannot be set as a child of itself.");
                return true;
            }

            return false;
        }

        /// <summary>
        /// Adds a NetworkBehaviour and serializes it's components.
        /// </summary>
        internal T AddAndSerialize<T>() where T : NetworkBehaviour //runtimeNB, might need to be public for users.
        {
            int startingLength = NetworkBehaviours.Count;
            T result = gameObject.AddComponent<T>();

            //Add to network behaviours.
            NetworkBehaviours.Add(result);
            //Serialize values and return.
            result.SerializeComponents(this, (byte)startingLength);
            return result;
        }

        /// <summary>
        /// Sets values as they are during initialization, such as componentId, NetworkBehaviour Ids, and more.
        /// Starts with a 0 componentId.
        /// </summary>
        internal void SetInitializedValues(NetworkObject parentNob, bool force = false)
        {
            byte componentId = 0;
            SetInitializedValues(parentNob, ref componentId, force);
        }

        /// <summary>
        /// Sets values as they are during initialization, such as componentId, NetworkBehaviour Ids, and more.
        /// </summary>
        /// <param name="componentId">ComponentId to start from for the NetworkObject.</param>
        internal void SetInitializedValues(NetworkObject parentNob, ref byte componentId, bool force = false)
        {
            if (!ApplicationState.IsPlaying())
            {
                NetworkManager.LogError($"Method {nameof(SetInitializedValues)} should only be called at runtime.");
                return;
            }

            /* If NetworkBehaviours is null then all collections are.
             * Set values for each collection. */
            if (force || !_initializedValusSet)
            {
                /* This only runs when playing, so it's safe to return existing to the pool. */
                StoreCollections();

                RetrieveCollections();

                _initializedValusSet = true;
            }

            SerializeTransformProperties();
            SetIsNestedThroughTraversal();
            /* This method can be called by the developer initializing prefabs, the prefab collection doing it automatically,
             * or when the networkobject is modified or added to an object.
             *
             * Prefab collections generally contain all prefabs, meaning they will not only call this on the topmost
             * networkobject but also each child, as the child would be it's own prefab in the collection. This assumes
             * that is, the child is a nested prefab.
             *
             * Because of this potential a check must be done where if the componentIndex is 0 we must look
             * for a networkobject above this one. If there is a networkObject above this one then we know the prefab
             * is being initialized individually, not part of a recursive check. In this case exit early
             * as the parent would have already resolved the needed information. */

            //If first componentIndex make sure there's no more than maximum allowed nested nobs.
            if (componentId == 0)
            {
                /* It's not possible to be nested while also having a componentIndex of 0.
                 * This would mean that the networkObject is being initialized outside of a
                 * recursive check. We only want to initialize recursively, or when not nested. */
                if (IsNested)
                    return;

                if (GetComponentsInChildren<NetworkObject>(true).Length > NetworkBehaviour.MAXIMUM_NETWORKBEHAVIOURS)
                {
                    NetworkManagerExtensions.LogError($"The number of child NetworkObjects on {gameObject.name} exceeds the maximum of {NetworkBehaviour.MAXIMUM_NETWORKBEHAVIOURS}.");
                    return;
                }
            }

            NetworkBehaviours.Clear();

            if (TryGetComponent(out PredictedSpawn ps))
                PredictedSpawn = ps;
            if (TryGetComponent(out PredictedOwner po))
                PredictedOwner = po;

            ComponentIndex = componentId;

            /* Since the parent being passed in should have already
             * added an empty nb if one didn't exist it's safe to
             * pull the first nb. If this value is null then something went
             * wrong. */
            if (parentNob != null)
            {
                /* Try to add an emptyNetworkBehaviour to this objects parent
                 * if one does not already exist. This is so this networkObject can
                 * identify it's parent properly. */
                AddEmptyNetworkBehaviour(parentNob, transform.parent, true);

                if (!transform.parent.TryGetComponent(out NetworkBehaviour parentNb))
                    NetworkManagerExtensions.LogError($"A NetworkBehaviour is expected to exist on {parentNob.name} but does not.");
                else
                    InitializedParentNetworkBehaviour = parentNb;
            }

            //Transforms which can be searched for networkbehaviours.
            List<Transform> transformCache = CollectionCaches<Transform>.RetrieveList();
            InitializedNestedNetworkObjects.Clear();

            transformCache.Add(transform);
            for (int z = 0; z < transformCache.Count; z++)
            {
                Transform currentT = transformCache[z];
                for (int i = 0; i < currentT.childCount; i++)
                {
                    Transform t = currentT.GetChild(i);
                    /* If contains a nob then do not add to transformsCache.
                     * Do add to ChildNetworkObjects so it can be initialized when
                     * parent is. */
                    if (t.TryGetComponent(out NetworkObject childNob))
                    {
                        /* Make sure both objects have the same value for
                         * IsSceneObject. It's possible the user instantiated
                         * an object and placed it beneath a scene object
                         * before the scene initialized. They may also
                         * add a scene object under an instantiated, even though
                         * this almost certainly will break things. */
                        if (IsSceneObject == childNob.IsSceneObject)
                            InitializedNestedNetworkObjects.Add(childNob);
                    }
                    else
                    {
                        transformCache.Add(t);
                    }
                }
            }

            //Iterate all cached transforms and get networkbehaviours.
            List<NetworkBehaviour> nbCache = CollectionCaches<NetworkBehaviour>.RetrieveList();
            //
            List<NetworkBehaviour> nbCache2 = CollectionCaches<NetworkBehaviour>.RetrieveList();
            for (int i = 0; i < transformCache.Count; i++)
            {
                nbCache2.Clear();
                transformCache[i].GetNetworkBehavioursNonAlloc(ref nbCache2);
                nbCache.AddRange(nbCache2);
            }

            /* If there's no NBs then add an empty one.
             * All NetworkObjects must have at least 1 NetworkBehaviour
             * to allow nesting. */
            if (nbCache.Count == 0)
            {
                NetworkBehaviour addedNb = AddEmptyNetworkBehaviour(this, transform, false);
                if (addedNb != null)
                    nbCache.Add(addedNb);
            }

            //Copy to array.
            int nbCount = nbCache.Count;
            //
            for (int i = 0; i < nbCount; i++)
            {
                NetworkBehaviour nb = nbCache[i];
                NetworkBehaviours.Add(nb);
                nb.SerializeComponents(this, (byte)i);
            }

            CollectionCaches<Transform>.Store(transformCache);
            CollectionCaches<NetworkBehaviour>.Store(nbCache);
            CollectionCaches<NetworkBehaviour>.Store(nbCache2);

            //Tell children nobs to update their NetworkBehaviours.
            foreach (NetworkObject item in InitializedNestedNetworkObjects)
            {
                componentId++;
                item.SetInitializedValues(this, ref componentId, force);
            }

            //Update global states to that of this one.
            SetChildGlobalState();
        }

        /// <summary>
        /// Adds EmptyNetworkBehaviour a target if it has no NetworkBehaviours. Updates a NetworkObject to contain the added behaviour.
        /// </summary>
        /// <typeparam name="addToNetworkBehaviours">If true an added NetworkBehaviour will be adeded to NetworkBehaviours, and initialized.</typeparam>
        /// <returns>Added NetworkBehaviour, or first NetworkBehaviour on the target if adding was not required.</returns>
        private NetworkBehaviour AddEmptyNetworkBehaviour(NetworkObject nob, Transform target, bool addToNetworkBehaviours)
        {
            NetworkBehaviour result;
            //Add to target if it does not have a NB yet.
            if (!target.TryGetComponent(out result))
            {
                //Already at maximum.
                if (nob.NetworkBehaviours.Count == NetworkBehaviour.MAXIMUM_NETWORKBEHAVIOURS)
                {
                    NetworkManager.LogError($"NetworkObject {this.ToString()} already has a maximum of {NetworkBehaviour.MAXIMUM_NETWORKBEHAVIOURS}. {nameof(EmptyNetworkBehaviour)} cannot be added. Nested spawning will likely fail for this object.");
                    return null;
                }

                result = target.gameObject.AddComponent<EmptyNetworkBehaviour>();
                if (addToNetworkBehaviours)
                {
                    nob.NetworkBehaviours.Add(result);
                    result.SerializeComponents(nob, (byte)(nob.NetworkBehaviours.Count - 1));
                }
            }

            return result;
        }

        /// <summary>
        /// Called after all data is synchronized with this NetworkObject.
        /// </summary>
        internal void Initialize(bool asServer, bool invokeSyncTypeCallbacks)
        {
            SetInitializedStatus(isInitialized: true, asServer);
            InvokeStartCallbacks(asServer, invokeSyncTypeCallbacks);
        }

        /// <summary>
        /// Returns if a deinitialize call can process.
        /// </summary>
        internal bool CanDeinitialize(bool asServer)
        {
            if (NetworkManager == null)
                return false;
            else if (asServer && !IsServerInitialized)
                return false;
            else if (!asServer && !IsClientInitialized)
                return false;

            return true;
        }

        /// <summary>
        /// Called to prepare this object to be destroyed or disabled.
        /// </summary>
        internal void Deinitialize(bool asServer)
        {
            if (!CanDeinitialize(asServer))
                return;

            Deinitialize_Prediction(asServer);

            InvokeStopCallbacks(asServer, invokeSyncTypeCallbacks: true);
            for (int i = 0; i < NetworkBehaviours.Count; i++)
                NetworkBehaviours[i].Deinitialize(asServer);

            bool asServerOnly = (asServer && !IsClientInitialized);

            if (asServer)
            {
                if (NetworkObserver != null)
                    NetworkObserver.Deinitialize(destroyed: false);
                IsDeinitializing = true;
            }
            else
            {
                //Client only.
                bool asClientOnly = !NetworkManager.IsServerStarted;
                if (asClientOnly)
                    IsDeinitializing = true;

                RemoveClientRpcLinkIndexes();
            }

            if (!asServer || asServerOnly)
                PredictedSpawner = NetworkManager.EmptyConnection;

            SetInitializedStatus(false, asServer);

            if (asServer)
                Observers.Clear();
        }

        /// <summary>
        /// Resets the state of this NetworkObject.
        /// This is used internally and typically with custom object pooling.
        /// </summary>
        public void ResetState(bool asServer)
        {
            int count = NetworkBehaviours.Count;
            for (int i = 0; i < count; i++)
                NetworkBehaviours[i].ResetState(asServer);

            ResetState_Prediction(asServer);
            ResetState_Observers(asServer);

            /* If nested only unset state if despawned.
             * This is to prevent nested NetworkObjects from
             * being unset as Spawned when only the root was despawned. */
            if (!IsNested || State == NetworkObjectState.Despawned)
                State = NetworkObjectState.Unset;

            // //If nested then set active state to serialized value.
            // if (IsNested)
            //     gameObject.SetActive(WasActiveDuringEdit);
            //
            SetOwner(NetworkManager.EmptyConnection);
            if (NetworkObserver != null)
                NetworkObserver.Deinitialize(false);

            //Never clear references -- these are needed for cleanup in unexpected destroys.
            // NetworkManager = null;
            // ServerManager = null;
            // ClientManager = null;
            // ObserverManager = null;
            // TransportManager = null;
            // TimeManager = null;
            // SceneManager = null;
            // RollbackManager = null;
            
            //Misc sets.
            ObjectId = NetworkObject.UNSET_OBJECTID_VALUE;
        }

        /// <summary>
        /// Removes ownership from all clients.
        /// </summary>
        public void RemoveOwnership(bool includeNested = false)
        {
            GiveOwnership(null, asServer: true, includeNested);
        }

        /// <summary>
        /// Gives ownership to newOwner.
        /// </summary>
        /// <param name="newOwner"></param>
        public void GiveOwnership(NetworkConnection newOwner) => GiveOwnership(newOwner, asServer: true, recursive: false);

        /// <summary>
        /// Gives ownership to newOwner.
        /// </summary>
        /// <param name="newOwner"></param>
        public void GiveOwnership(NetworkConnection newOwner, bool asServer) => GiveOwnership(newOwner, asServer, recursive: false);

        /// <summary>
        /// Gives ownership to newOwner.
        /// </summary>
        /// <param name="newOwner"></param>
        //Remove at --- In V5 make IncludeNested required.
        internal void GiveOwnership(NetworkConnection newOwner, bool asServer, bool recursive = false)
        {
            /* Additional asServer checks. */
            if (asServer)
            {
                if (!NetworkManager.IsServerStarted)
                {
                    NetworkManager.LogWarning($"Ownership cannot be given for object {gameObject.name}. Only server may give ownership.");
                    return;
                }

                //If the same owner don't bother sending a message, just ignore request.
                if (newOwner == Owner)
                    return;

                if (newOwner != null && newOwner.IsActive && !newOwner.LoadedStartScenes(true))
                {
                    NetworkManager.LogWarning($"Ownership has been transfered to ConnectionId {newOwner.ClientId} but this is not recommended until after they have loaded start scenes. You can be notified when a connection loads start scenes by using connection.OnLoadedStartScenes on the connection, or SceneManager.OnClientLoadStartScenes.");
                }
            }

            bool activeNewOwner = (newOwner != null && newOwner.IsActive);

            //Set prevOwner, disallowing null.
            NetworkConnection prevOwner = Owner;
            if (prevOwner == null)
                prevOwner = NetworkManager.EmptyConnection;

            SetOwner(newOwner);
            /* Only modify objects if asServer or not
             * host. When host, server would
             * have already modified objects
             * collection so there is no need
             * for client to as well. */
            if (asServer || !NetworkManager.IsHostStarted)
            {
                if (activeNewOwner)
                    newOwner.AddObject(this);
                if (prevOwner != newOwner)
                    prevOwner.RemoveObject(this);
            }

            //After changing owners invoke callbacks.
            InvokeManualOwnershipChange(prevOwner, asServer);

            //If asServer send updates to clients as needed.
            if (asServer)
            {
                if (activeNewOwner)
                    ServerManager.Objects.RebuildObservers(this, newOwner, false);

                PooledWriter writer = WriterPool.Retrieve();
                writer.WritePacketIdUnpacked(PacketId.OwnershipChange);
                writer.WriteNetworkObject(this);
                writer.WriteNetworkConnection(Owner);
                //If sharing then send to all observers.
                if (NetworkManager.ServerManager.ShareIds)
                {
                    NetworkManager.TransportManager.SendToClients((byte)Channel.Reliable, writer.GetArraySegment(), this);
                }
                //Only sending to old / new.
                else
                {
                    if (prevOwner.IsActive)
                        NetworkManager.TransportManager.SendToClient((byte)Channel.Reliable, writer.GetArraySegment(), prevOwner);
                    if (activeNewOwner)
                        NetworkManager.TransportManager.SendToClient((byte)Channel.Reliable, writer.GetArraySegment(), newOwner);
                }

                writer.Store();

                if (prevOwner.IsActive)
                    ServerManager.Objects.RebuildObservers(prevOwner);
            }

            if (recursive)
            {
                List<NetworkObject> allNested = GetNetworkObjects(GetNetworkObjectOption.AllNestedRecursive);

                foreach (NetworkObject nob in allNested)
                    nob.GiveOwnership(newOwner, asServer, recursive: true);

                CollectionCaches<NetworkObject>.Store(allNested);
            }
        }

        /// <summary>
        /// Initializes a predicted object for client.
        /// </summary>
        internal void InitializePredictedObject_Server(NetworkConnection predictedSpawner)
        {
            PredictedSpawner = predictedSpawner;
        }

        /// <summary>
        /// Initializes a predicted object for client.
        /// </summary>
        internal void InitializePredictedObject_Client(NetworkManager manager, int objectId, NetworkConnection owner, NetworkConnection predictedSpawner)
        {
            PredictedSpawner = predictedSpawner;
            InitializeEarly(manager, objectId, owner, false);
        }

        /// <summary>
        /// Sets the owner of this object.
        /// </summary>
        /// <param name="owner"></param>
        /// <param name="allowNull"></param>
        private void SetOwner(NetworkConnection owner)
        {
            Owner = owner;
        }

        /// <summary>
        /// Returns changed properties between this transform and values.
        /// </summary>
        internal TransformPropertiesFlag GetTransformChanges(TransformProperties stp)
        {
            Transform t = transform;
            return GetTransformChanges(t, stp.Position, stp.Rotation, stp.Scale);
        }

        /// <summary>
        /// Returns changed properties between this transform and a prefab.
        /// </summary>
        internal TransformPropertiesFlag GetTransformChanges(GameObject prefab)
        {
            Transform prefabT = prefab.transform;
            return GetTransformChanges(transform, prefabT.localPosition, prefabT.localRotation, prefabT.localScale);
        }

        /// <summary>
        /// Returns changed properties between a transform and values.
        /// </summary>
        private TransformPropertiesFlag GetTransformChanges(Transform t, Vector3 localPosition, Quaternion localRotation, Vector3 localScale)
        {
            TransformPropertiesFlag tpf = TransformPropertiesFlag.Unset;
            if (t.localPosition != localPosition)
                tpf |= TransformPropertiesFlag.Position;
            if (t.localRotation != localRotation)
                tpf |= TransformPropertiesFlag.Rotation;
            if (t.localScale != localScale)
                tpf |= TransformPropertiesFlag.Scale;

            return tpf;
        }

        /// <summary>
        /// Sets IsNested and returns the result.
        /// </summary>
        /// <returns></returns>
        internal bool SetIsNestedThroughTraversal()
        {
            Transform parent = transform.parent;
            //Iterate long as parent isn't null, and isnt self.
            while (parent != null && parent != transform)
            {
                if (parent.TryGetComponent<NetworkObject>(out _))
                {
                    IsNested = true;
                    return IsNested;
                }

                parent = parent.parent;
            }

            //No NetworkObject found in parents, meaning this is not nested.
            IsNested = false;
            return IsNested;
        }

        /// <summary>
        /// Serializes TransformProperties to current transform properties.
        /// Returns if serialized value changed.
        /// </summary>
        internal void SerializeTransformProperties()
        {
            SerializedTransformProperties = new(transform.localPosition, transform.localRotation, transform.localScale);
        }

        /// <summary>
        /// Stores collections to caches.
        /// </summary>
        private void StoreCollections()
        {
            CollectionCaches<NetworkBehaviour>.StoreAndDefault(ref NetworkBehaviours);
            CollectionCaches<NetworkObject>.StoreAndDefault(ref InitializedNestedNetworkObjects);
            CollectionCaches<NetworkBehaviour>.StoreAndDefault(ref RuntimeChildNetworkBehaviours);
        }

        private void RetrieveCollections()
        {
            NetworkBehaviours = CollectionCaches<NetworkBehaviour>.RetrieveList();
            InitializedNestedNetworkObjects = CollectionCaches<NetworkObject>.RetrieveList();
            RuntimeChildNetworkBehaviours = CollectionCaches<NetworkBehaviour>.RetrieveList();
        }

        #region Editor.
#if UNITY_EDITOR
        /// <summary>
        /// Removes duplicate NetworkObject components on this object returning the removed count.
        /// </summary>
        /// <returns></returns>
        internal int RemoveDuplicateNetworkObjects()
        {
            NetworkObject[] nobs = GetComponents<NetworkObject>();
            for (int i = 1; i < nobs.Length; i++)
                DestroyImmediate(nobs[i]);

            return (nobs.Length - 1);
        }

        internal void ReserializeEditorSetValues(bool setWasActiveDuringEdit, bool setSceneId)
        {
            if (ApplicationState.IsPlaying())
                return;

#if UNITY_EDITOR
            if (setWasActiveDuringEdit)
            {
                bool hasNetworkObjectParent = false;
                Transform parent = transform.parent;
                while (parent != null) 
                {
                    if (parent.TryGetComponent<NetworkObject>(out _)) 
                    {
                        hasNetworkObjectParent = true;
                        break;
                    }

                    parent = parent.parent;
                }

                WasActiveDuringEdit = (hasNetworkObjectParent && gameObject.activeSelf) || (!hasNetworkObjectParent && gameObject.activeInHierarchy);
                WasActiveDuringEdit_Set1 = true;
            }

            if (setSceneId)
                CreateSceneId(force: false);
#endif
        }

        private void OnValidate()
        {
            ReserializeEditorSetValues(setWasActiveDuringEdit: true, setSceneId: true);

            if (IsGlobal && IsSceneObject)
                NetworkManagerExtensions.LogWarning($"Object {gameObject.name} will have it's IsGlobal state ignored because it is a scene object. Instantiated copies will still be global. This warning is informative only.");
        }

        private void Reset()
        {
            ReferenceIds_Reset();
        }
#endif
        #endregion
    }
}﻿using FishNet.Component.Observing;
using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Timing;
using FishNet.Observing;
using System;
using System.Collections.Generic;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Object
{
    public partial class NetworkObject : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Called when the clientHost gains or loses visibility of this object.
        /// Boolean value will be true if clientHost has visibility.
        /// </summary>        
        public event HostVisibilityUpdatedDelegate OnHostVisibilityUpdated;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="prevVisible">True if clientHost was known to have visibility of the object prior to this invoking.</param>
        /// <param name="nextVisible">True if the clientHost now has visibility of the object.</param>
        public delegate void HostVisibilityUpdatedDelegate(bool prevVisible, bool nextVisible);

        /// <summary>
        /// Called when this NetworkObject losses all observers or gains observers while previously having none.
        /// </summary>
        public event Action<NetworkObject> OnObserversActive;

        /// <summary>
        /// NetworkObserver on this object.
        /// </summary>
        [HideInInspector]
        public NetworkObserver NetworkObserver = null;
        /// <summary>
        /// Clients which can see and get messages from this NetworkObject.
        /// </summary>
        [HideInInspector]
        public HashSet<NetworkConnection> Observers = new();
        #endregion

        #region Internal.
        /// <summary>
        /// Current HashGrid entry this belongs to.
        /// </summary>
        internal GridEntry HashGridEntry;
        /// <summary>
        /// Last tick an observer was added.
        /// </summary>
        internal uint ObserverAddedTick = TimeManager.UNSET_TICK;
        #endregion

        #region Private.
        /// <summary>
        /// True if NetworkObserver has been initialized.
        /// </summary>
        private bool _networkObserverInitiliazed = false;
        /// <summary>
        /// Found renderers on the NetworkObject and it's children. This is only used as clientHost to hide non-observers objects.
        /// </summary>
        [System.NonSerialized]
        private List<Renderer> _renderers;
        /// <summary>
        /// True if renderers have been looked up.
        /// </summary>
        private bool _renderersPopulated;
        /// <summary>
        /// Last visibility value for clientHost on this object.
        /// </summary>
        private bool _lastClientHostVisibility;
        /// <summary>
        /// HashGrid for this object.
        /// </summary>
        private HashGrid _hashGrid;
        /// <summary>
        /// Next time this object may update it's position for HashGrid.
        /// </summary>
        private float _nextHashGridUpdateTime;
        /// <summary>
        /// True if this gameObject is static.
        /// </summary>
        private bool _isStatic;
        /// <summary>
        /// Current grid position.
        /// </summary>
        private Vector2Int _hashGridPosition = HashGrid.UnsetGridPosition;
        #endregion

        /// <summary>
        /// Updates Objects positions in the HashGrid for this Networkmanager.
        /// </summary>
        internal void UpdateForNetworkObject(bool force)
        {
            if (_hashGrid == null)
                return;
            if (_isStatic)
                return;

            float unscaledTime = Time.unscaledTime;
            //Not enough time has passed to update.
            if (!force && unscaledTime < _nextHashGridUpdateTime)
                return;

            const float updateInterval = 1f;
            _nextHashGridUpdateTime = unscaledTime + updateInterval;
            Vector2Int newPosition = _hashGrid.GetHashGridPosition(this);
            if (newPosition != _hashGridPosition)
            {
                _hashGridPosition = newPosition;
                HashGridEntry = _hashGrid.GetGridEntry(newPosition);
            }
        }

        /// <summary>
        /// Updates cached renderers used to managing clientHost visibility.
        /// </summary>
        /// <param name="updateVisibility">True to also update visibility if clientHost.</param>
        public void UpdateRenderers(bool updateVisibility = true)
        {
            InitializeRendererCollection(force: true, updateVisibility);
        }

        /// <summary>
        /// Sets the renderer visibility for clientHost.
        /// </summary>
        /// <param name="visible">True if renderers are to be visibile.</param>
        /// <param name="force">True to skip blocking checks.</param>
        public void SetRenderersVisible(bool visible, bool force = false)
        {
            if (!force && !NetworkObserver.UpdateHostVisibility)
                return;
            
            UpdateRenderVisibility(visible);
        }
        
        /// <summary>
        /// Updates visibilites on renders without checks.
        /// </summary>
        /// <param name="visible"></param>
        private void UpdateRenderVisibility(bool visible)
        {
            InitializeRendererCollection(force: false, updateVisibility: false);

            List<Renderer> rs = _renderers;
            for (int i = 0; i < rs.Count; i++)
            {
                Renderer r = rs[i];
                if (r == null)
                {
                    _renderers.RemoveAt(i);
                    i--;
                }
                else
                {
                    r.enabled = visible;
                }
            }

            if (OnHostVisibilityUpdated != null)
                OnHostVisibilityUpdated.Invoke(_lastClientHostVisibility, visible);
            _lastClientHostVisibility = visible;
        }

        /// <summary>
        /// If needed Renderers collection is initialized and populated.
        /// </summary>
        private void InitializeRendererCollection(bool force, bool updateVisibility)
        {
            if (!force && _renderersPopulated)
                return;

            List<Renderer> cache = CollectionCaches<Renderer>.RetrieveList();
            GetComponentsInChildren<Renderer>(includeInactive: true, cache);

            _renderers = new();

            foreach (Renderer r in cache)
            {
                if (r.enabled)
                    _renderers.Add(r);
            }

            CollectionCaches<Renderer>.Store(cache);

            /* Intentionally set before event call. This is to prevent
             * a potential endless loop should the user make another call
             * to this objects renderer API from the event, resulting in
             * the population repeating. */
            _renderersPopulated = true;

            if (updateVisibility)
                UpdateRenderVisibility(_lastClientHostVisibility);
        }

        /// <summary>
        /// Adds the default NetworkObserver conditions using the ObserverManager.
        /// </summary>
        private void AddDefaultNetworkObserverConditions()
        {
            if (_networkObserverInitiliazed)
                return;

            NetworkObserver = NetworkManager.ObserverManager.AddDefaultConditions(this);
        }

        /// <summary>
        /// Removes a connection from observers for this object returning if the connection was removed.
        /// </summary>
        /// <param name="connection"></param>
        internal bool RemoveObserver(NetworkConnection connection)
        {
            int startCount = Observers.Count;
            bool removed = Observers.Remove(connection);
            if (removed)
                TryInvokeOnObserversActive(startCount);

            return removed;
        }

        /// <summary>
        /// Adds the connection to observers if conditions are met.
        /// </summary>
        /// <param name="connection"></param>
        /// <returns>True if added to Observers.</returns>
        internal ObserverStateChange RebuildObservers(NetworkConnection connection, bool timedOnly)
        {
            //If not a valid connection.
            if (!connection.IsValid)
            {
                NetworkManager.LogWarning($"An invalid connection was used when rebuilding observers.");
                return ObserverStateChange.Unchanged;
            }
            //Valid not not active.
            else if (!connection.IsActive)
            {
                /* Just remove from observers since connection isn't active
                 * and return unchanged because nothing should process
                 * given the connection isnt active. */
                Observers.Remove(connection);
                return ObserverStateChange.Unchanged;
            }
            else if (IsDeinitializing)
            {
                /* If object is deinitializing it's either being despawned
                 * this frame or it's not spawned. If we've made it this far,
                 * it's most likely being despawned. */
                return ObserverStateChange.Unchanged;
            }

            //Update hashgrid if needed.
            UpdateForNetworkObject(!timedOnly);

            int startCount = Observers.Count;
            ObserverStateChange osc = NetworkObserver.RebuildObservers(connection, timedOnly);

            if (osc == ObserverStateChange.Added)
                Observers.Add(connection);
            else if (osc == ObserverStateChange.Removed)
                Observers.Remove(connection);

            if (osc != ObserverStateChange.Unchanged)
                TryInvokeOnObserversActive(startCount);

            return osc;
        }

        /// <summary>
        /// Invokes OnObserversActive if observers are now 0 but previously were not, or if was previously 0 but now has observers.
        /// </summary>
        /// <param name="startCount"></param>
        private void TryInvokeOnObserversActive(int startCount)
        {
            if (TimeManager != null)
                ObserverAddedTick = TimeManager.LocalTick;

            if (OnObserversActive != null)
            {
                if ((Observers.Count > 0 && startCount == 0) || Observers.Count == 0 && startCount > 0)
                    OnObserversActive.Invoke(this);
            }
        }

        /// <summary>
        /// Resets this object to starting values.
        /// </summary>
        private void ResetState_Observers(bool asServer)
        {
            //As server or client it's safe to reset this value.
            ObserverAddedTick = TimeManager.UNSET_TICK;
        }
    }
}﻿#define NEW_RECONCILE_TEST
using System;
using FishNet.Component.Prediction;
using FishNet.Component.Transforming;
using FishNet.Managing;
using FishNet.Managing.Timing;
using FishNet.Object.Prediction;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using FishNet.Connection;
using FishNet.Managing.Server;
using UnityEngine;

#pragma warning disable CS0618 // Type or member is obsolete

namespace FishNet.Object
{
    public partial class NetworkObject : MonoBehaviour
    {
        #region Types.
        /// <summary>
        /// Type of prediction movement being used.
        /// </summary>
        [System.Serializable]
        internal enum PredictionType : byte
        {
            Other = 0,
            Rigidbody = 1,
            Rigidbody2D = 2
        }
        #endregion

        #region Public.
        /// <summary>
        /// True if a reconcile is occuring on any NetworkBehaviour that is on or nested of this NetworkObject. Runtime NetworkBehaviours are not included, such as if you child a NetworkObject to another at runtime.
        /// </summary>
        public bool IsObjectReconciling { get; internal set; }

        /// <summary>
        /// Graphical smoother to use when using set for owner.
        /// </summary> 
        [Obsolete("This field will be removed in v5. Instead reference NetworkTickSmoother on each graphical object used.")]
        public TransformTickSmoother PredictionSmoother { get; private set; }
        #endregion

        #region Internal.
        /// <summary>
        /// Pauses and unpauses rigidbodies when they do not have data to reconcile to.
        /// </summary>
        public RigidbodyPauser RigidbodyPauser => _rigidbodyPauser;

        private RigidbodyPauser _rigidbodyPauser;
        #endregion

        #region Serialized.
        /// <summary>
        /// True if this object uses prediciton methods.
        /// </summary>
        public bool EnablePrediction => _enablePrediction;

        [Tooltip("True if this object uses prediction methods.")]
        [SerializeField]
        private bool _enablePrediction;
        /// <summary>
        /// What type of component is being used for prediction? If not using rigidbodies set to other.
        /// </summary>
        [Tooltip("What type of component is being used for prediction? If not using rigidbodies set to other.")]
        [SerializeField]
        private PredictionType _predictionType = PredictionType.Other;
        /// <summary>
        /// Object containing graphics when using prediction. This should be child of the predicted root.
        /// </summary>
        [Tooltip("Object containing graphics when using prediction. This should be child of the predicted root.")]
        [SerializeField]
        private Transform _graphicalObject;

        /// <summary>
        /// Gets the current graphical object for prediction.
        /// </summary>
        /// <returns></returns>
        public Transform GetGraphicalObject() => _graphicalObject;

        /// <summary>
        /// Sets a new graphical object for prediction.
        /// </summary>
        /// <param name="t"></param>
        public void SetGraphicalObject(Transform t)
        {
            _graphicalObject = t;
            InitializeTickSmoother();
        }

        /// <summary>
        /// True to detach and re-attach the graphical object at runtime when the client initializes/deinitializes the item.
        /// This can resolve camera jitter or be helpful objects child of the graphical which do not handle reconiliation well, such as certain animation rigs.
        /// Transform is detached after OnStartClient, and reattached before OnStopClient.
        /// </summary>
        [Tooltip("True to detach and re-attach the graphical object at runtime when the client initializes/deinitializes the item. This can resolve camera jitter or be helpful objects child of the graphical which do not handle reconiliation well, such as certain animation rigs. Transform is detached after OnStartClient, and reattached before OnStopClient.")]
        [SerializeField]
        private bool _detachGraphicalObject;

        /// <summary>
        /// True to forward replicate and reconcile states to all clients. This is ideal with games where you want all clients and server to run the same inputs. False to only use prediction on the owner, and synchronize to spectators using other means such as a NetworkTransform.
        /// </summary>
        public bool EnableStateForwarding => (_enablePrediction && _enableStateForwarding);

        [Tooltip("True to forward replicate and reconcile states to all clients. This is ideal with games where you want all clients and server to run the same inputs. False to only use prediction on the owner, and synchronize to spectators using other means such as a NetworkTransform.")]
        [SerializeField]
        private bool _enableStateForwarding = true;
        /// <summary>
        /// NetworkTransform to configure for prediction. Specifying this is optional.
        /// </summary>
        [Tooltip("NetworkTransform to configure for prediction. Specifying this is optional.")]
        [SerializeField]
        private NetworkTransform _networkTransform;
        /// <summary>
        /// How many ticks to interpolate graphics on objects owned by the client. Typically low as 1 can be used to smooth over the frames between ticks.
        /// </summary>
        [Tooltip("How many ticks to interpolate graphics on objects owned by the client. Typically low as 1 can be used to smooth over the frames between ticks.")]
        [Range(1, byte.MaxValue)]
        [SerializeField]
        private byte _ownerInterpolation = 1;
        /// <summary>
        /// Properties of the graphicalObject to smooth when owned.
        /// </summary>
        [SerializeField]
        private TransformPropertiesFlag _ownerSmoothedProperties = (TransformPropertiesFlag)~(-1 << 8);
        /// <summary>
        /// Interpolation amount of adaptive interpolation to use on non-owned objects. Higher levels result in more interpolation. When off spectatorInterpolation is used; when on interpolation based on strength and local client latency is used.
        /// </summary>
        [Tooltip("Interpolation amount of adaptive interpolation to use on non-owned objects. Higher levels result in more interpolation. When off spectatorInterpolation is used; when on interpolation based on strength and local client latency is used.")]
        [SerializeField]
        private AdaptiveInterpolationType _adaptiveInterpolation = AdaptiveInterpolationType.Low;
        /// <summary>
        /// Properties of the graphicalObject to smooth when the object is spectated.
        /// </summary>
        [SerializeField]
        private TransformPropertiesFlag _spectatorSmoothedProperties = (TransformPropertiesFlag)~(-1 << 8);
        /// <summary>
        /// How many ticks to interpolate graphics on objects when not owned by the client.
        /// </summary>
        [Tooltip("How many ticks to interpolate graphics on objects when not owned by the client.")]
        [Range(1, byte.MaxValue)]
        [SerializeField]
        private byte _spectatorInterpolation = 2;
        /// <summary>
        /// True to enable teleport threshhold.
        /// </summary>
        [Tooltip("True to enable teleport threshhold.")]
        [SerializeField]
        private bool _enableTeleport;
        /// <summary>
        /// Distance the graphical object must move between ticks to teleport the transform properties.
        /// </summary>
        [Tooltip("Distance the graphical object must move between ticks to teleport the transform properties.")]
        [Range(0.001f, ushort.MaxValue)]
        [SerializeField]
        private float _teleportThreshold = 1f;
        #endregion

        #region Private.
        /// <summary>
        /// NetworkBehaviours which use prediction.
        /// </summary>
        private List<NetworkBehaviour> _predictionBehaviours = new();
        #endregion

        private void TimeManager_OnUpdate_Prediction()
        {
            if (!_enablePrediction)
                return;

            if (PredictionSmoother != null)
                PredictionSmoother.OnUpdate();
        }

        private void InitializePredictionEarly(NetworkManager manager, bool asServer)
        {
            if (!_enablePrediction)
                return;

            if (!_enableStateForwarding && _networkTransform != null)
                _networkTransform.ConfigureForPrediction(_predictionType);

            if (asServer)
                return;

            InitializeSmoothers();

            if (_predictionBehaviours.Count > 0)
            {
                ChangePredictionSubscriptions(true, manager);
                foreach (NetworkBehaviour item in _predictionBehaviours)
                    item.Preinitialize_Prediction(asServer);
            }
        }

        private void Deinitialize_Prediction(bool asServer)
        {
            if (!_enablePrediction)
                return;

            DeinitializeSmoothers();
            /* Only the client needs to unsubscribe from these but
             * asServer may not invoke as false if the client is suddenly
             * dropping their connection. */
            if (_predictionBehaviours.Count > 0)
            {
                ChangePredictionSubscriptions(subscribe: false, NetworkManager);
                foreach (NetworkBehaviour item in _predictionBehaviours)
                    item.Deinitialize_Prediction(asServer);
            }
        }

        /// <summary>
        /// Changes subscriptions to use callbacks for prediction.
        /// </summary>
        private void ChangePredictionSubscriptions(bool subscribe, NetworkManager manager)
        {
            if (manager == null)
                return;

            if (subscribe)
            {
                manager.PredictionManager.OnPreReconcile += PredictionManager_OnPreReconcile;
                manager.PredictionManager.OnReconcile += PredictionManager_OnReconcile;
                manager.PredictionManager.OnReplicateReplay += PredictionManager_OnReplicateReplay;
                manager.PredictionManager.OnPostReplicateReplay += PredictionManager_OnPostReplicateReplay;
                manager.PredictionManager.OnPostReconcile += PredictionManager_OnPostReconcile;
                manager.TimeManager.OnPreTick += TimeManager_OnPreTick;
                manager.TimeManager.OnPostTick += TimeManager_OnPostTick;
            }
            else
            {
                manager.PredictionManager.OnPreReconcile -= PredictionManager_OnPreReconcile;
                manager.PredictionManager.OnReconcile -= PredictionManager_OnReconcile;
                manager.PredictionManager.OnReplicateReplay -= PredictionManager_OnReplicateReplay;
                manager.PredictionManager.OnPostReplicateReplay -= PredictionManager_OnPostReplicateReplay;
                manager.PredictionManager.OnPostReconcile -= PredictionManager_OnPostReconcile;
                manager.TimeManager.OnPreTick -= TimeManager_OnPreTick;
                manager.TimeManager.OnPostTick -= TimeManager_OnPostTick;
            }
        }

        /// <summary>
        /// Initializes tick smoothing.
        /// </summary>
        private void InitializeSmoothers()
        {
            bool usesRb = (_predictionType == PredictionType.Rigidbody);
            bool usesRb2d = (_predictionType == PredictionType.Rigidbody2D);
            if (usesRb || usesRb2d)
            {
                _rigidbodyPauser = ResettableObjectCaches<RigidbodyPauser>.Retrieve();
                RigidbodyType rbType = (usesRb) ? RigidbodyType.Rigidbody : RigidbodyType.Rigidbody2D;
                _rigidbodyPauser.UpdateRigidbodies(transform, rbType, true);
            }

            if (_graphicalObject == null)
            {
                NetworkManagerExtensions.Log($"GraphicalObject is null on {gameObject.name}. This may be intentional, and acceptable, if you are smoothing between ticks yourself. Otherwise consider assigning the GraphicalObject field.");
            }
            else
            {
                if (PredictionSmoother == null)
                    PredictionSmoother = ResettableObjectCaches<TransformTickSmoother>.Retrieve();
                InitializeTickSmoother();
            }
        }

        /// <summary>
        /// Initializes the tick smoother.
        /// </summary>
        private void InitializeTickSmoother()
        {
            if (PredictionSmoother == null)
                return;
            float teleportT = (_enableTeleport) ? _teleportThreshold : MoveRates.UNSET_VALUE;
            PredictionSmoother.InitializeNetworked(this, _graphicalObject, _detachGraphicalObject, teleportT, (float)TimeManager.TickDelta, _ownerInterpolation, _ownerSmoothedProperties, _spectatorInterpolation, _spectatorSmoothedProperties, _adaptiveInterpolation);
        }

        /// <summary>
        /// Initializes tick smoothing.
        /// </summary>
        private void DeinitializeSmoothers()
        {
            if (PredictionSmoother != null)
            {
                PredictionSmoother.Deinitialize();
                ResettableObjectCaches<TransformTickSmoother>.Store(PredictionSmoother);
                PredictionSmoother = null;
                ResettableObjectCaches<RigidbodyPauser>.StoreAndDefault(ref _rigidbodyPauser);
            }
        }

        private void InvokeStartCallbacks_Prediction(bool asServer)
        {
            if (_predictionBehaviours.Count == 0)
                return;

            if (!asServer)
            {
                TimeManager.OnUpdate += TimeManager_Update;
                if (PredictionSmoother != null)
                    PredictionSmoother.OnStartClient();
            }
        }

        private void InvokeStopCallbacks_Prediction(bool asServer)
        {
            if (_predictionBehaviours.Count == 0)
                return;

            if (!asServer)
            {
                if (TimeManager != null)
                    TimeManager.OnUpdate -= TimeManager_Update;
                if (PredictionSmoother != null)
                    PredictionSmoother.OnStopClient();
            }
        }

        private void TimeManager_OnPreTick()
        {
            if (PredictionSmoother != null)
                PredictionSmoother.OnPreTick();
        }

        private void PredictionManager_OnPostReplicateReplay(uint clientTick, uint serverTick)
        {
            if (PredictionSmoother != null)
                PredictionSmoother.OnPostReplicateReplay(clientTick);
        }

        private void TimeManager_OnPostTick()
        {
            if (PredictionSmoother != null)
                PredictionSmoother.OnPostTick(NetworkManager.TimeManager.LocalTick);
        }

        private void PredictionManager_OnPreReconcile(uint clientTick, uint serverTick)
        {
            if (PredictionSmoother != null)
                PredictionSmoother.OnPreReconcile();
        }

        private void PredictionManager_OnReconcile(uint clientReconcileTick, uint serverReconcileTick)
        {
            /* Tell all prediction behaviours to set/validate their
             * reconcile data now. This will use reconciles from the server
             * whenever possible, and local reconciles if a server reconcile
             * is not available. */
            for (int i = 0; i < _predictionBehaviours.Count; i++)
                _predictionBehaviours[i].Reconcile_Client_Start();

            /* If still not reconciling then pause rigidbody.
             * This shouldn't happen unless the user is not calling
             * reconcile at all. */
            if (!IsObjectReconciling)
            {
                if (_rigidbodyPauser != null)
                    _rigidbodyPauser.Pause();
            }
        }

        private void PredictionManager_OnPostReconcile(uint clientReconcileTick, uint serverReconcileTick)
        {
            for (int i = 0; i < _predictionBehaviours.Count; i++)
                _predictionBehaviours[i].Reconcile_Client_End();

            /* Unpause rigidbody pauser. It's okay to do that here rather
             * than per NB, where the pausing occurs, because once here
             * the entire object is out of the replay cycle so there's
             * no reason to try and unpause per NB. */
            if (_rigidbodyPauser != null)
                _rigidbodyPauser.Unpause();
            IsObjectReconciling = false;
        }

        private void PredictionManager_OnReplicateReplay(uint clientTick, uint serverTick)
        {
            uint replayTick = (IsOwner) ? clientTick : serverTick;
            for (int i = 0; i < _predictionBehaviours.Count; i++)
                _predictionBehaviours[i].Replicate_Replay_Start(replayTick);
        }

        /// <summary>
        /// Registers a NetworkBehaviour that uses prediction with the NetworkObject.
        /// This method should only be called once throughout the entire lifetime of this object.
        /// </summary>
        internal void RegisterPredictionBehaviourOnce(NetworkBehaviour nb)
        {
            _predictionBehaviours.Add(nb);
        }

        /// <summary>
        /// Clears replication queue inserting them into the past replicates history when possible.
        /// This should only be called when client only.
        /// </summary>
        internal void EmptyReplicatesQueueIntoHistory()
        {
            for (int i = 0; i < _predictionBehaviours.Count; i++)
                _predictionBehaviours[i].EmptyReplicatesQueueIntoHistory_Start();
        }

        /// <summary>
        /// Sets the last tick a NetworkBehaviour replicated with.
        /// </summary>
        /// <param name="setUnordered">True to set unordered value, false to set ordered.</param>
        internal void SetReplicateTick(uint value, bool createdReplicate)
        {
            if (createdReplicate && Owner.IsValid)
                Owner.ReplicateTick.Update(NetworkManager.TimeManager, value, EstimatedTick.OldTickOption.Discard);
        }

        /// <summary>
        /// ResetState for prediction values.
        /// </summary>
        private void ResetState_Prediction(bool asServer) { }
    }

    /// <summary>
    /// Place this component on your NetworkManager object to remove ownership of objects for a disconnecting client.
    /// This prevents any owned object from being despawned when the owner disconnects.
    /// </summary>
    public class GlobalPreserveOwnedObjects : MonoBehaviour
    {
        private void Awake()
        {
            ServerManager sm = GetComponent<ServerManager>();
            sm.Objects.OnPreDestroyClientObjects += Objects_OnPreDestroyClientObjects;
        }

        protected virtual void Objects_OnPreDestroyClientObjects(NetworkConnection conn)
        {
            foreach (NetworkObject networkObject in conn.Objects)
                networkObject.RemoveOwnership();
        }
    }

    /// <summary>
    /// Place this component on NetworkObjects you wish to remove ownership on for a disconnecting owner.
    /// This prevents the object from being despawned when the owner disconnects.
    /// </summary>
    public class NetworkPreserveOwnedObjects : NetworkBehaviour
    {
        public override void OnStartServer()
        {
            ServerManager.Objects.OnPreDestroyClientObjects += OnPreDestroyClientObjects;
        }

        public override void OnStopServer()
        {
            if (ServerManager != null)
                ServerManager.Objects.OnPreDestroyClientObjects -= OnPreDestroyClientObjects;
        }

        private void OnPreDestroyClientObjects(NetworkConnection conn)
        {
            if (conn == Owner)
                RemoveOwnership();
        }
    }
}﻿using FishNet.CodeAnalysis.Annotations;
using FishNet.Component.ColliderRollback;
using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Client;
using FishNet.Managing.Observing;
using FishNet.Managing.Predicting;
using FishNet.Managing.Scened;
using FishNet.Managing.Server;
using FishNet.Managing.Timing;
using FishNet.Managing.Transporting;
using FishNet.Serializing.Helping;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Object
{
    public partial class NetworkObject : MonoBehaviour
    {
        #region Public.
        #region Obsoletes
        [Obsolete("Use IsClientOnlyInitialized. Note the difference between IsClientOnlyInitialized and IsClientOnlyStarted.")]
        public bool IsClientOnly => IsClientOnlyInitialized;
        [Obsolete("Use IsServerOnlyInitialized. Note the difference between IsServerOnlyInitialized and IsServerOnlyStarted.")]
        public bool IsServerOnly => IsServerOnlyInitialized;
        [Obsolete("Use IsHostInitialized. Note the difference between IsHostInitialized and IsHostStarted.")]
        public bool IsHost => IsHostInitialized;
        [Obsolete("Use IsClientInitialized. Note the difference between IsClientInitialized and IsClientStarted.")]
        public bool IsClient => IsClientInitialized;
        [Obsolete("Use IsServerInitialized. Note the difference between IsServerInitialized and IsServerStarted.")]
        public bool IsServer => IsServerInitialized;
        #endregion

        /// <summary>
        /// True if despawning without object pooling, or if OnDestroy was invoked on this NetworkObject. As clientHost this value becomes true when previous criteria are met and server begins to deinitialize the object.
        /// </summary>
        /// <remarks>This can be useful for checking if you wish to perform certain actions within OnStopNetwork based on destroying status.</remarks>
        public bool IsDestroying { get; private set; }

        /// <summary>
        /// Sets IsDestroying to true if DespawnType is not pooled. When DespawnType is not specified default DespawnType is checked.
        /// </summary>
        internal void SetIsDestroying(DespawnType? despawnType = null)
        {
            if (despawnType.HasValue)
            {
                if (despawnType.Value == DespawnType.Destroy)
                    IsDestroying = true;
            }
            else if (GetDefaultDespawnType() == DespawnType.Destroy)
            {
                IsDestroying = true;
            }
        }

        /// <summary>
        /// True if predicted spawning is allowed for this object.
        /// </summary>
        internal bool AllowPredictedSpawning => (PredictedSpawn == null) ? false : PredictedSpawn.GetAllowSpawning();
        /// <summary>
        /// True if predicted spawning is allowed for this object.
        /// </summary>
        internal bool AllowPredictedDespawning => (PredictedSpawn == null) ? false : PredictedSpawn.GetAllowDespawning();
        /// <summary>
        /// True if this object has been initialized on the client side.
        /// This is set true right before client start callbacks and after stop callbacks.
        /// </summary>
        public bool IsClientInitialized { get; private set; }
        /// <summary>
        /// True if the client is started and authenticated. This will return true on clientHost even if the object has not initialized yet for the client.
        /// To check if this object has been initialized for the client use IsClientInitialized.
        /// </summary>
        public bool IsClientStarted => (NetworkManager == null) ? false : NetworkManager.IsClientStarted;
        /// <summary>
        /// True if this object has been initialized only on the server side.
        /// This is set true right before server start callbacks and after stop callbacks.
        /// </summary>
        public bool IsClientOnlyInitialized => (!IsServerInitialized && IsClientInitialized);
        /// <summary>
        /// True if only the client is started and authenticated.
        /// </summary>
        public bool IsClientOnlyStarted => (IsClientStarted && !IsServerStarted);
        /// <summary>
        /// True if this object has been initialized on the server side.
        /// This is set true right before server start callbacks and after stop callbacks.
        /// </summary>
        public bool IsServerInitialized { get; private set; }
        /// <summary>
        /// True if the server is active. This will return true on clientHost even if the object is being deinitialized on the server.
        /// To check if this object has been initialized for the server use IsServerInitialized.
        /// </summary>
        public bool IsServerStarted => (NetworkManager == null) ? false : NetworkManager.IsServerStarted;
        /// <summary>
        /// True if this object has been initialized only on the server side.
        /// This is set true right before server start callbacks and after stop callbacks.
        /// </summary>
        public bool IsServerOnlyInitialized => (IsServerInitialized && !IsClientInitialized);
        /// <summary>
        /// True if only the server is started.
        /// </summary>
        public bool IsServerOnlyStarted => (IsServerStarted && !IsClientStarted);
        /// <summary>
        /// True if client and server are started.
        /// </summary>
        public bool IsHostStarted => (IsClientStarted && IsServerStarted);
        /// <summary>
        /// True if this object has been initialized on the server and client side.
        /// </summary>
        public bool IsHostInitialized => (IsClientInitialized && IsServerInitialized);
        /// <summary>
        /// True if client nor server are started.
        /// </summary>
        public bool IsOffline => (!IsClientStarted && !IsServerStarted);
        /// <summary>
        /// True if a reconcile is occuring on the PredictionManager. Note the difference between this and IsBehaviourReconciling.
        /// </summary>
        public bool IsManagerReconciling => PredictionManager.IsReconciling;

        /// <summary>
        /// True if the local client is currently using a PredictedOwner component on this object to take ownership.
        /// </summary>
        public bool IsTakingOwnership => (PredictedOwner != null && PredictedOwner.TakingOwnership);

        /// <summary>
        /// True if the local client is the owner of this object.
        /// This will only return true if IsClientInitialized is also true. You may check ownership status regardless of client initialized state by using Owner.IsLocalClient.
        /// </summary>
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "OnStartServer", "")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "OnStartNetwork", " Use base.Owner.IsLocalClient instead.")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "Awake", "")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "Start", "")]
        public bool IsOwner
        {
            get
            {
                /* ClientInitialized becomes true when this
                 * NetworkObject has been initialized on the client side.
                 *
                 * This value is used to prevent IsOwner from returning true
                 * when running as host; primarily in Update or Tick callbacks
                 * where IsOwner would be true as host but OnStartClient has
                 * not called yet.
                 *
                 * EG: server will set owner when it spawns the object.
                 * If IsOwner is checked before the object spawns on the
                 * client-host then it would also return true, since the
                 * Owner reference would be the same as what was set by server.
                 *
                 * This is however bad when the client hasn't initialized the object
                 * yet because it gives a false sense of execution order.
                 * As a result, Update or Ticks may return IsOwner as true well before OnStartClient
                 * is called. Many users rightfully create code with the assumption the client has been
                 * initialized by the time IsOwner is true.
                 *
                 * This is a double edged sword though because now IsOwner would return true
                 * within OnStartNetwork for clients only, but not for host given the client
                 * side won't be initialized yet as host. As a work around CodeAnalysis will
                 * inform users to instead use base.Owner.IsLocalClient within OnStartNetwork. */
                if (!IsClientInitialized)
                    return false;

                return Owner.IsLocalClient;
            }
        }
        /// <summary>
        /// True if IsOwner, or if IsServerInitialized with no Owner.
        /// </summary>
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "OnStartServer", "")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "OnStartNetwork", " Use (base.Owner.IsLocalClient || (base.IsServerInitialized && !Owner.Isvalid) instead.")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "Awake", "")]
        [PreventUsageInside("global::FishNet.Object.NetworkBehaviour", "Start", "")]
        public bool IsController => (IsOwner || (IsServerInitialized && !Owner.IsValid));

        [Obsolete("Use IsController.")]
        public bool HasAuthority => IsController;
        /// <summary>
        /// 
        /// </summary>
        private NetworkConnection _owner;
        /// <summary>
        /// Owner of this object.
        /// </summary>
        public NetworkConnection Owner
        {
            get
            {
                //Ensures a null Owner is never returned.
                if (_owner == null)
                    return FishNet.Managing.NetworkManager.EmptyConnection;

                return _owner;
            }
            private set { _owner = value; }
        }
        /// <summary>
        /// ClientId for this NetworkObject owner.
        /// </summary>
        public int OwnerId => (!Owner.IsValid) ? -1 : Owner.ClientId;
        /// <summary>
        /// True if the object is initialized for the network.
        /// </summary>
        public bool IsSpawned => (!IsDeinitializing && ObjectId != NetworkObject.UNSET_OBJECTID_VALUE);
        /// <summary>
        /// The local connection of the client calling this method.
        /// </summary>
        public NetworkConnection LocalConnection => (NetworkManager == null) ? new() : NetworkManager.ClientManager.Connection;
        /// <summary>
        /// NetworkManager for this object.
        /// </summary>
        public NetworkManager NetworkManager { get; private set; }
        /// <summary>
        /// ServerManager for this object.
        /// </summary>
        public ServerManager ServerManager { get; private set; }
        /// <summary>
        /// ClientManager for this object.
        /// </summary>
        public ClientManager ClientManager { get; private set; }
        /// <summary>
        /// ObserverManager for this object.
        /// </summary>
        public ObserverManager ObserverManager { get; private set; }
        /// <summary>
        /// TransportManager for this object.
        /// </summary>
        public TransportManager TransportManager { get; private set; }
        /// <summary>
        /// TimeManager for this object.
        /// </summary>
        public TimeManager TimeManager { get; private set; }
        /// <summary>
        /// SceneManager for this object.
        /// </summary>
        public SceneManager SceneManager { get; private set; }
        /// <summary>
        /// PredictionManager for this object.
        /// </summary>
        public PredictionManager PredictionManager { get; private set; }
        /// <summary>
        /// RollbackManager for this object.
        /// </summary>
        public RollbackManager RollbackManager { get; private set; }
        #endregion

        /// <summary>
        /// Returns a NetworkBehaviour on this NetworkObject.
        /// </summary>
        /// <param name="componentIndex">ComponentIndex of the NetworkBehaviour.</param>
        /// <param name="error">True to error if not found.</param>
        /// <returns></returns>
        public NetworkBehaviour GetNetworkBehaviour(byte componentIndex, bool error)
        {
            if (componentIndex >= NetworkBehaviours.Count)
            {
                if (error)
                {
                    string message = $"ComponentIndex of {componentIndex} is out of bounds on {gameObject.name} [id {ObjectId}]. This may occur if you have modified your gameObject/prefab without saving it, or the scene.";
                    NetworkManager.LogError(message);
                }
            }

            return NetworkBehaviours[componentIndex];
        }

        /// <summary>
        /// Despawns a GameObject. Only call from the server.
        /// </summary>
        /// <param name="go">GameObject to despawn.</param>
        /// <param name="despawnType">What happens to the object after being despawned.</param>
        public void Despawn(GameObject go, DespawnType? despawnType = null)
        {
            if (NetworkManager != null)
                NetworkManager.ServerManager.Despawn(go, despawnType);
        }

        /// <summary>
        /// Despawns  a NetworkObject. Only call from the server.
        /// </summary>
        /// <param name="nob">NetworkObject to despawn.</param>
        /// <param name="despawnType">What happens to the object after being despawned.</param>
        public void Despawn(NetworkObject nob, DespawnType? despawnType = null)
        {
            if (NetworkManager != null)
                NetworkManager.ServerManager.Despawn(nob, despawnType);
        }

        /// <summary>
        /// Despawns this NetworkObject. Only call from the server.
        /// </summary>
        /// <param name="despawnType">What happens to the object after being despawned.</param>
        public void Despawn(DespawnType? despawnType = null)
        {
            NetworkObject nob = this;
            if (NetworkManager != null)
                NetworkManager.ServerManager.Despawn(nob, despawnType);
        }

        /// <summary>
        /// Spawns an object over the network. Only call from the server.
        /// </summary>
        public void Spawn(GameObject go, NetworkConnection ownerConnection = null, UnityEngine.SceneManagement.Scene scene = default)
        {
            if (NetworkManager != null)
                NetworkManager.ServerManager.Spawn(go, ownerConnection, scene);
        }

        /// <summary>
        /// Spawns an object over the network. Only call from the server.
        /// </summary>
        public void Spawn(NetworkObject nob, NetworkConnection ownerConnection = null, UnityEngine.SceneManagement.Scene scene = default)
        {
            if (NetworkManager != null)
                NetworkManager.ServerManager.Spawn(nob, ownerConnection, scene);
        }

        [Obsolete("Use SetLocalOwnership(NetworkConnection, bool).")]
        public void SetLocalOwnership(NetworkConnection caller) => SetLocalOwnership(caller, recursive: false);

        /// <summary>
        /// Takes ownership of this object and child network objects, allowing immediate control.
        /// </summary>
        /// <param name="caller">Connection to give ownership to.</param>
        public void SetLocalOwnership(NetworkConnection caller, bool recursive)
        {
            NetworkConnection prevOwner = Owner;
            SetOwner(caller);

            int count;
            count = NetworkBehaviours.Count;
            for (int i = 0; i < count; i++)
                NetworkBehaviours[i].OnOwnershipClient_Internal(prevOwner);

            if (recursive)
            {
                List<NetworkObject> allNested = GetNetworkObjects(GetNetworkObjectOption.AllNestedRecursive);

                foreach (NetworkObject nob in allNested)
                    nob.SetLocalOwnership(caller, recursive: true);

                CollectionCaches<NetworkObject>.Store(allNested);
            }
        }

        #region Registered components
        /// <summary>
        /// Invokes an action when a specified component becomes registered. Action will invoke immediately if already registered.
        /// </summary>
        /// <typeparam name="T">Component type.</typeparam>
        /// <param name="handler">Action to invoke.</param>
        public void RegisterInvokeOnInstance<T>(Action<UnityEngine.Component> handler) where T : UnityEngine.Component => NetworkManager.RegisterInvokeOnInstance<T>(handler);

        /// <summary>
        /// Removes an action to be invoked when a specified component becomes registered.
        /// </summary>
        /// <typeparam name="T">Component type.</typeparam>
        /// <param name="handler">Action to invoke.</param>
        public void UnregisterInvokeOnInstance<T>(Action<UnityEngine.Component> handler) where T : UnityEngine.Component => NetworkManager.UnregisterInvokeOnInstance<T>(handler);

        /// <summary>
        /// Returns if an instance exists for type.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public bool HasInstance<T>() where T : UnityEngine.Component => NetworkManager.HasInstance<T>();

        /// <summary>
        /// Returns class of type if found within CodegenBase classes.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public T GetInstance<T>() where T : UnityEngine.Component => NetworkManager.GetInstance<T>();

        /// <summary>
        /// Registers a new component to this NetworkManager.
        /// </summary>
        /// <typeparam name="T">Type to register.</typeparam>
        /// <param name="component">Reference of the component being registered.</param>
        /// <param name="replace">True to replace existing references.</param>
        public void RegisterInstance<T>(T component, bool replace = true) where T : UnityEngine.Component => NetworkManager.RegisterInstance(component, replace);

        /// <summary>
        /// Tries to registers a new component to this NetworkManager.
        /// This will not register the instance if another already exists.
        /// </summary>
        /// <typeparam name="T">Type to register.</typeparam>
        /// <param name="component">Reference of the component being registered.</param>
        /// <returns>True if was able to register, false if an instance is already registered.</returns>
        public bool TryRegisterInstance<T>(T component) where T : UnityEngine.Component => NetworkManager.TryRegisterInstance(component);

        /// <summary>
        /// Returns class of type from registered instances.
        /// </summary>
        /// <param name="component">Outputted component.</param>
        /// <typeparam name="T">Type to get.</typeparam>
        /// <returns>True if was able to get instance.</returns>
        public bool TryGetInstance<T>(out T component) where T : UnityEngine.Component => NetworkManager.TryGetInstance(out component);

        /// <summary>
        /// Unregisters a component from this NetworkManager.
        /// </summary>
        /// <typeparam name="T">Type to unregister.</typeparam>
        public void UnregisterInstance<T>() where T : UnityEngine.Component => NetworkManager.UnregisterInstance<T>();
        #endregion
    }
}﻿//Remove in V5﻿using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Object
{
    public partial class NetworkObject : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// RpcLinks being used within this NetworkObject.
        /// </summary>
        private List<ushort> _rpcLinkIndexes;
        #endregion

        /// <summary>
        /// Sets rpcLinkIndexes to values.
        /// </summary>
        internal void SetRpcLinkIndexes(List<ushort> values)
        {
            _rpcLinkIndexes = values;
        }

        /// <summary>
        /// Removes used link indexes from ClientObjects.
        /// </summary>
        internal void RemoveClientRpcLinkIndexes()
        {
            //if (NetworkManager != null)
                NetworkManager.ClientManager.Objects.RemoveLinkIndexes(_rpcLinkIndexes);
        }
    }
}﻿//This file contains values serialized in editor or once at runtime.

using UnityEngine;
using System;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using FishNet.Managing;
using FishNet.Utility.Extension;


#if UNITY_EDITOR
using UnityEditor.Experimental.SceneManagement;
using UnityEditor.SceneManagement;
using UnityEditor;
#endif

namespace FishNet.Object
{
    public partial class NetworkObject : MonoBehaviour
    {
        #region Public.
        /// <summary>
        /// Networked PrefabId assigned to this Prefab.
        /// </summary>
        [field: SerializeField, HideInInspector]
        public ushort PrefabId { get; internal set; } = NetworkObject.UNSET_PREFABID_VALUE;

        /// <summary>
        /// Spawn collection to use assigned to this Prefab.
        /// </summary>
        [field: SerializeField, HideInInspector]
        public ushort SpawnableCollectionId { get; internal set; } = 0;

        /// <summary>
        /// Sets SceneId value. This is not synchronized automatically.
        /// </summary>
        /// <param name="sceneId"></param>
        public void SetSceneId(ulong sceneId) => SceneId = sceneId;

        /// <summary>
        /// Hash for the path which this asset resides. This value is set during edit time.
        /// </summary> 
        [field: SerializeField, HideInInspector]
        public ulong AssetPathHash { get; private set; }

        /// <summary>
        /// Sets AssetPathhash value.
        /// </summary>
        /// <param name="value">Value to use.</param>
        public void SetAssetPathHash(ulong value) => AssetPathHash = value;
        #endregion

        #region Internal.
        /// <summary>
        /// Network Id for this scene object.
        /// </summary>
        [field: SerializeField, HideInInspector]
        internal ulong SceneId { get; private set; }

        /// <summary>
        /// 
        /// </summary>
        [SerializeField, HideInInspector]
        internal TransformProperties SerializedTransformProperties = new();
        #endregion

        #region Private.
        /// <summary>
        /// Last time sceneIds were built automatically.
        /// </summary>
        [System.NonSerialized]
        private static double _lastSceneIdAutomaticRebuildTime;
        #endregion

        /// <summary>
        /// Removes SceneObject state.
        /// This may only be called at runtime.
        /// </summary>
        internal void ClearRuntimeSceneObject()
        {
            if (!Application.isPlaying)
            {
                NetworkManagerExtensions.LogError($"ClearRuntimeSceneObject may only be called at runtime.");
                return;
            }

            SceneId = NetworkObject.UNSET_SCENEID_VALUE;
        }

        
#if UNITY_EDITOR
        private void OnApplicationQuit()
        {
            _lastSceneIdAutomaticRebuildTime = 0;
        }

        /// <summary>
        /// Tries to generate a SceneIds for NetworkObjects in a scene.
        /// </summary>
        internal static List<NetworkObject> CreateSceneId(UnityEngine.SceneManagement.Scene scene, bool force, out int changed)
        {
            changed = 0;

            if (Application.isPlaying)
                return new();
            if (!scene.IsValid())
                return  new();
            if (!scene.isLoaded)
                return  new();

            HashSet<ulong> setIds = new();
            uint scenePathHash = scene.path.GetStableHashU32();
            List<NetworkObject> sceneNobs = new();

            Scenes.GetSceneNetworkObjects(scene, firstOnly: false, errorOnDuplicates: false, ignoreUnsetSceneIds: false, ref sceneNobs);
            System.Random rnd = new();

            //NetworkObjects which need their Ids rebuilt.
            List<NetworkObject> rebuildingNobs = new();

            foreach (NetworkObject item in sceneNobs)
            {
                bool canGenerate = (!item.IsSceneObject || !setIds.Add(item.SceneId));
                /* If an Id has not been generated yet or if it
                 * already exist then rebuild for this object. */
                if (force || canGenerate)
                {
                    item.SceneId = NetworkObject.UNSET_SCENEID_VALUE;
                    rebuildingNobs.Add(item);
                }
            }

            foreach (NetworkObject item in rebuildingNobs)
            {
                ulong nextSceneId = NetworkObject.UNSET_SCENEID_VALUE;
                while (nextSceneId == NetworkObject.UNSET_SCENEID_VALUE || setIds.Contains(nextSceneId))
                {
                    uint rndId = (uint)(rnd.Next(int.MinValue, int.MaxValue) + int.MaxValue);
                    nextSceneId = CombineHashes(scenePathHash, rndId);
                }

                ulong CombineHashes(uint a, uint b)
                {
                    return (b | a);
                }

                setIds.Add(nextSceneId);
                changed++;
                item.SceneId = nextSceneId;
                EditorUtility.SetDirty(item);
            }

            return sceneNobs;
        }

        /// <summary>
        /// Tries to generate a SceneId.
        /// </summary>
        private void CreateSceneId(bool force)
        {
            if (Application.isPlaying)
                return;
            //Unity bug, sometimes this can be null depending on editor callback orders.
            if (gameObject == null)
                return;
            //Not a scene object.
            if (string.IsNullOrEmpty(gameObject.scene.name))
            {
                SceneId = NetworkObject.UNSET_SCENEID_VALUE;
                return;
            }

            /* If building then only check if
             * scene networkobjects have their sceneIds
             * missing. */
            if (BuildPipeline.isBuildingPlayer)
            {
                //If prefab or part of a prefab, not a scene object.            
                if (PrefabUtility.IsPartOfPrefabAsset(this) || IsEditingInPrefabMode() ||
                    //Not in a scene, another prefab check.
                    !gameObject.scene.IsValid() ||
                    //Stored on disk, so is a prefab. Somehow prefabutility missed it.
                    EditorUtility.IsPersistent(this))
                    //If here this is a sceneObject, but sceneId is not set.
                    if (!IsSceneObject)
                        throw new InvalidOperationException($"Networked GameObject {gameObject.name} in scene {gameObject.scene.path} is missing a SceneId. Use the Fish-Networking menu -> Utility -> Reserialize NetworkObjects > Reserialize Scenes. If the problem persist ensures {gameObject.name} does not have any missing script references on it's prefab or in the scene. Also ensure that you have any prefab changes for the object applied.");
            }
            //If not building check to rebuild sceneIds this for object and the scene its in.
            else
            {
                double realtime = EditorApplication.timeSinceStartup;
                //Only do this once every Xms to prevent excessive rebiulds.
                if (realtime - _lastSceneIdAutomaticRebuildTime < 0.250d)
                    return;

                //Not in a scene, another prefab check.
                //Stored on disk, so is a prefab. Somehow prefabutility missed it.
                if (PrefabUtility.IsPartOfPrefabAsset(this) || IsEditingInPrefabMode() || !gameObject.scene.IsValid() || EditorUtility.IsPersistent(this))
                    return;

                _lastSceneIdAutomaticRebuildTime = realtime;

                CreateSceneId(gameObject.scene, force, out _);
            }
        }

        private bool IsEditingInPrefabMode()
        {
            if (EditorUtility.IsPersistent(this))
            {
                // if the game object is stored on disk, it is a prefab of some kind, despite not returning true for IsPartOfPrefabAsset =/
                return true;
            }
            else
            {
                // If the GameObject is not persistent let's determine which stage we are in first because getting Prefab info depends on it
                StageHandle mainStage = StageUtility.GetMainStageHandle();
                StageHandle currentStage = StageUtility.GetStageHandle(gameObject);
                if (currentStage != mainStage)
                {
                    var prefabStage = PrefabStageUtility.GetPrefabStage(gameObject);
                    if (prefabStage != null)
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private void ReferenceIds_Reset()
        {
            CreateSceneId(force: false);
        }
#endif
    }
}﻿using System.Runtime.CompilerServices;
using FishNet.Connection;
using FishNet.Object.Synchronizing;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Object
{
    public partial class NetworkObject : MonoBehaviour
    {
        /// <summary>
        /// Writes SyncTypes for previous and new owner where permissions apply.
        /// </summary>
        
        private void WriteSyncTypesForManualOwnershipChange(NetworkConnection prevOwner)
        {
            if (prevOwner.IsActive)
                WriteForConnection(prevOwner, ReadPermission.ExcludeOwner);
            if (Owner.IsActive)
                WriteForConnection(Owner, ReadPermission.OwnerOnly);
            
            void WriteForConnection(NetworkConnection conn, ReadPermission permission)
            {
                for (int i = 0; i < NetworkBehaviours.Count; i++)
                    NetworkBehaviours[i].WriteSyncTypesForConnection(conn, permission);
            }
        }
    }
}﻿
namespace FishNet.Object
{
    /// <summary>
    /// Action to take when despawning a NetworkObject.
    /// </summary>
    public enum DespawnType : byte
    {
        Destroy = 0,
        Pool = 1,
    }


    /// <summary>
    /// Current state of the NetworkObject.
    /// </summary>
    internal enum NetworkObjectState : byte
    {
        /// <summary>
        /// State has not been set. This occurs when the object has never been spawned or despawned.
        /// </summary>
        Unset = 0,
        /// <summary>
        /// Object is currently spawned.
        /// </summary>
        Spawned = 1,
        /// <summary>
        /// Object is currently despawned.
        /// </summary>
        Despawned = 2,
    }

    /// <summary>
    /// Options on retrieving nested NetworkObjects.
    /// </summary>
    [System.Flags]
    internal enum GetNetworkObjectOption : int
    {
        /// <summary>
        /// Include NetworkObject which nested are being returned for. 
        /// </summary>
        Self = (1 << 0),
        /// <summary>
        /// Include initialize nested.
        /// </summary>
        InitializedNested = (1 << 1),
        /// <summary>
        /// Include runtime nested.
        /// </summary>
        RuntimeNested = (1 << 2),
        /// <summary>
        /// Recursively iterate nested includes.
        /// </summary>
        /// <remarks>This only functions if Initialized or Runtime is flagged.</remarks>
        Recursive = (1 << 3),
        
        /// <summary>
        /// Uses InitializedNested and RuntimeNested flags.
        /// </summary>
        AllNested = (InitializedNested | RuntimeNested),
        /// <summary>
        /// Uses InitializedNested, RuntimeNested, and Recursive flags.
        /// </summary>
        AllNestedRecursive = (InitializedNested | RuntimeNested | Recursive),
        /// <summary>
        /// Sets all flags.
        /// </summary>
        All = ~0,
    }


    internal static class GetNetworkObjectOptionExtensions 
    {
        /// <summary>
        /// True if whole contains part.
        /// </summary>
        public static bool FastContains(this GetNetworkObjectOption whole, GetNetworkObjectOption part) => (whole & part) == part;
    }
}

﻿using System;

namespace FishNet.Object.Prediction
{
    /// <summary>
    /// Replicated methods are to be called from clients and will run the same data and logic on the server.
    /// Only data used as method arguments will be serialized.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class ReplicateAttribute : Attribute { }
    /// <summary>
    /// Reconcile methods indicate how to reset your script or object after the server has replicated user data.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
    public class ReconcileAttribute : Attribute { }
}﻿using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Serializing;
using FishNet.Transporting;
using FishNet.Utility;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]
namespace FishNet.Object.Prediction.Delegating
{
    [APIExclude]
    public delegate void ReplicateRpcDelegate(PooledReader reader, NetworkConnection sender, Channel channel);
    [APIExclude]
    public delegate void ReconcileRpcDelegate(PooledReader reader, Channel channel);

    [APIExclude]
    public delegate void ReplicateUserLogicDelegate<T>(T data, ReplicateState state, Channel channel);
    [APIExclude]
    public delegate void ReconcileUserLogicDelegate<T>(T data, Channel channel);
}﻿
namespace FishNet.Object.Prediction
{
    public interface IReplicateData
    {
        /// <summary>
        /// Local tick when the data was created.
        /// </summary>
        /// <returns></returns>
        uint GetTick();
        /// <summary>
        /// Sets the local tick when data was created.
        /// </summary>
        /// <param name="value"></param>
        void SetTick(uint value);
        /// <summary>
        /// Allows for any cleanup when the data is being discarded.
        /// </summary>
        void Dispose();
    }

    public interface IReconcileData
    {
        /// <summary>
        /// Local tick when the data was created.
        /// </summary>
        /// <returns></returns>
        uint GetTick();
        /// <summary>
        /// Sets the local tick when data was created.
        /// </summary>
        /// <param name="value"></param>
        void SetTick(uint value);
        /// <summary>
        /// Allows for any cleanup when the data is being discarded.
        /// </summary>
        void Dispose();
    }

}﻿using FishNet.Documenting;
using FishNet.Serializing;
using UnityEngine;

namespace FishNet.Object.Prediction
{
    /// <summary>
    /// Used to store reconciles locally.
    /// </summary>
    /// <remarks>This is for internal use only.</remarks>
    [APIExclude]
    public struct LocalReconcile<T> where T : IReconcileData
    {
        /// <summary>
        /// Tick for reconcile.
        /// </summary>
        public uint Tick;
        /// <summary>
        /// Writer reconcile was written to.
        /// </summary>
        public PooledWriter Writer;
        /// <summary>
        /// Data inside writer.
        /// </summary>
        public T Data;

        public void Initialize(uint tick, T data)
        {
            Tick = tick;
            Data = data;
            Writer = WriterPool.Retrieve();
            Writer.Write(data);
        }

        /// <summary>
        /// Disposes of used data.
        /// </summary>
        public void Dispose()
        {
            Data.Dispose();
            if (Writer != null)
                WriterPool.Store(Writer);
        }
    }


}﻿using GameKit.Dependencies.Utilities;
using UnityEngine;
using UnityEngine.Scripting;

namespace FishNet.Object.Prediction
{
    /// <summary>
    /// Used to make calculations and perform actions in moving transforms over time.
    /// </summary>
    [Preserve]
    public struct MoveRates
    {
        /// <summary>
        /// Rate at which to move Position.
        /// </summary>
        public float Position;
        /// <summary>
        /// Rate at which to move Rotation.
        /// </summary>
        public float Rotation;
        /// <summary>
        /// Rate at which to move Scale.
        /// </summary>
        public float Scale;
        /// <summary>
        /// Time remaining until the move is complete.
        /// </summary>
        public float TimeRemaining;

        /// <summary>
        /// Value used when data is not set.
        /// </summary>
        public const float UNSET_VALUE = float.NegativeInfinity;
        /// <summary>
        /// Value used when move rate should be instant.
        /// </summary>
        public const float INSTANT_VALUE = float.PositiveInfinity;

        /// <summary>
        /// True if any data is set. Once set, this will remain true until ResetState is called.
        /// </summary>
        public bool IsValid { get; private set; }

        public MoveRates(float value) : this()
        {
            Position = value;
            Rotation = value;
            Scale = value;

            IsValid = true;
        }

        public MoveRates(float position, float rotation) : this()
        {
            Position = position;
            Rotation = rotation;
            Scale = INSTANT_VALUE;

            IsValid = true;
        }

        public MoveRates(float position, float rotation, float scale) : this()
        {
            Position = position;
            Rotation = rotation;
            Scale = scale;

            IsValid = true;
        }

        public MoveRates(float position, float rotation, float scale, float timeRemaining)
        {
            Position = position;
            Rotation = rotation;
            Scale = scale;
            TimeRemaining = timeRemaining;

            IsValid = true;
        }

        /// <summary>
        /// True if a positional move rate is set.
        /// </summary>
        public bool IsPositionSet => (Position != UNSET_VALUE);
        /// <summary>
        /// True if rotation move rate is set.
        /// </summary>
        public bool IsRotationSet => (Rotation != UNSET_VALUE);
        /// <summary>
        /// True if a scale move rate is set.
        /// </summary>
        public bool IsScaleSet => (Scale != UNSET_VALUE);

        /// <summary>
        /// True if position move rate should be instant.
        /// </summary>
        public bool IsPositionInstantValue => (Position == INSTANT_VALUE);
        /// <summary>
        /// True if rotation move rate should be instant.
        /// </summary>
        public bool IsRotationInstantValue => (Rotation == INSTANT_VALUE);
        /// <summary>
        /// True if scale move rate should be instant.
        /// </summary>
        public bool IsScaleInstantValue => (Scale == INSTANT_VALUE);

        /// <summary>
        /// Sets all rates to instant.
        /// </summary>
        public void SetInstantRates() => Update(INSTANT_VALUE);

        /// <summary>
        /// Sets all rates to the same value.
        /// </summary>
        public void Update(float value) => Update(value, value, value);

        /// <summary>
        /// Sets rates for each property.
        /// </summary>
        public void Update(float position, float rotation, float scale)
        {
            Position = position;
            Rotation = rotation;
            Scale = scale;

            IsValid = true;
        }

        /// <summary>
        /// Sets rates for each property.
        /// </summary>
        public void Update(float position, float rotation, float scale, float timeRemaining)
        {
            Position = position;
            Rotation = rotation;
            Scale = scale;
            TimeRemaining = timeRemaining;

            IsValid = true;
        }

        /// <summary>
        /// Updates to new values.
        /// </summary>
        public void Update(MoveRates moveRates) => Update(moveRates.Position, moveRates.Rotation, moveRates.Scale, moveRates.TimeRemaining);

        /// <summary>
        /// Updates to new values.
        /// </summary>
        public void Update(MoveRatesCls moveRates) => Update(moveRates.Position, moveRates.Rotation, moveRates.Scale, moveRates.TimeRemaining);

        /// <summary>
        /// Resets to unset values.
        /// </summary>
        public void ResetState()
        {
            Update(MoveRates.UNSET_VALUE, MoveRates.UNSET_VALUE, MoveRates.UNSET_VALUE, timeRemaining: 0f);

            IsValid = false;
        }

        /// <summary>
        /// Returns a new MoveRates based on previous values, and a transforms current position.
        /// </summary>
        public static MoveRates GetWorldMoveRates(Transform from, Transform to, float duration, float teleportThreshold)
        {
            return GetMoveRates(from.position, to.position, from.rotation, to.rotation, from.localScale, to.localScale, duration, teleportThreshold);
        }

        /// <summary>
        /// Returns a new MoveRates based on previous values, and a transforms current position.
        /// </summary>
        public static MoveRates GetLocalMoveRates(Transform from, Transform to, float duration, float teleportThreshold)
        {
            return GetMoveRates(from.localPosition, to.localPosition, from.localRotation, to.localRotation, from.localScale, to.localScale, duration, teleportThreshold);
        }

        /// <summary>
        /// Returns a new MoveRates based on previous values, and a transforms current position.
        /// </summary>
        public static MoveRates GetWorldMoveRates(TransformProperties prevValues, Transform t, float duration, float teleportThreshold)
        {
            return GetMoveRates(prevValues.Position, t.position, prevValues.Rotation, t.rotation, prevValues.Scale, t.localScale, duration, teleportThreshold);
        }

        /// <summary>
        /// Returns a new MoveRates based on previous values, and a transforms current position.
        /// </summary>
        public static MoveRates GetLocalMoveRates(TransformProperties prevValues, Transform t, float duration, float teleportThreshold)
        {
            return GetMoveRates(prevValues.Position, t.localPosition, prevValues.Rotation, t.localRotation, prevValues.Scale, t.localScale, duration, teleportThreshold);
        }

        /// <summary>
        /// Returns a new MoveRates based on previous values, and a transforms current position.
        /// </summary>
        public static MoveRates GetMoveRates(TransformProperties prevValues, TransformProperties nextValues, float duration, float teleportThreshold)
        {
            return GetMoveRates(prevValues.Position, nextValues.Position, prevValues.Rotation, nextValues.Rotation, prevValues.Scale, nextValues.Scale, duration, teleportThreshold);
        }

        /// <summary>
        /// Returns a new MoveRates based on previous values, and a transforms current position.
        /// </summary>
        public static MoveRates GetMoveRates(Vector3 fromPosition, Vector3 toPosition, Quaternion fromRotation, Quaternion toRotation, Vector3 fromScale, Vector3 toScale, float duration, float teleportThreshold)
        {
            float rate;

            /* Position. */
            rate = toPosition.GetRate(fromPosition, duration, out float distance);
            //Basic teleport check.
            if (teleportThreshold != UNSET_VALUE && distance > teleportThreshold)
                return new(INSTANT_VALUE, INSTANT_VALUE, INSTANT_VALUE, duration);

            //Smoothing.
            float positionRate = rate.SetIfUnderTolerance(0.0001f, INSTANT_VALUE);
            rate = toRotation.GetRate(fromRotation, duration, out _);
            float rotationRate = rate.SetIfUnderTolerance(0.2f, INSTANT_VALUE);
            rate = toScale.GetRate(fromScale, duration, out _);
            float scaleRate = rate.SetIfUnderTolerance(0.0001f, INSTANT_VALUE);

            return new(positionRate, rotationRate, scaleRate, duration);
        }

        /// <summary>
        /// Gets a move rate for two Vector3s.
        /// </summary>
        public static float GetMoveRate(Vector3 fromPosition, Vector3 toPosition, float duration, float teleportThreshold)
        {
            float rate;
            float distance;

            /* Position. */
            rate = toPosition.GetRate(fromPosition, duration, out distance);
            //Basic teleport check.
            if (teleportThreshold != UNSET_VALUE && distance > teleportThreshold)
            {
                return INSTANT_VALUE;
            }
            //Smoothing.
            else
            {
                float positionRate = rate.SetIfUnderTolerance(0.0001f, INSTANT_VALUE);
                return positionRate;
            }
        }

        /// <summary>
        /// Gets a move rate for two Quaternions.
        /// </summary>
        public static float GetMoveRate(Quaternion fromRotation, Quaternion toRotation, float duration)
        {
            float rate = toRotation.GetRate(fromRotation, duration, out _);
            float rotationRate = rate.SetIfUnderTolerance(0.2f, INSTANT_VALUE);
            return rotationRate;
        }

        /// <summary>
        /// Moves transform to target values.
        /// </summary>
        public void Move(Transform movingTransform, TransformProperties goalProperties, float delta, bool useWorldSpace)
        {
            if (!IsValid)
                return;

            Move(movingTransform, TransformPropertiesFlag.Everything, goalProperties.Position, Position, goalProperties.Rotation, Rotation, goalProperties.Scale, Scale, delta, useWorldSpace);
            TimeRemaining -= delta;
        }
        
        /// <summary>
        /// Moves transform to target values.
        /// </summary>
        public void Move(Transform movingTransform, TransformProperties goalProperties, TransformPropertiesFlag movedProperties, float delta, bool useWorldSpace)
        {
            if (!IsValid)
                return;

            Move(movingTransform, movedProperties, goalProperties.Position, Position, goalProperties.Rotation, Rotation, goalProperties.Scale, Scale, delta, useWorldSpace);
            TimeRemaining -= delta;
        }

        /// <summary>
        /// Moves transform to target values.
        /// </summary>
        public static void Move(Transform movingTransform, TransformPropertiesFlag movedProperties, Vector3 posGoal, float posRate, Quaternion rotGoal, float rotRate, Vector3 scaleGoal, float scaleRate, float delta, bool useWorldSpace)
        {
            Transform t = movingTransform;

            bool containsPosition = movedProperties.FastContains(TransformPropertiesFlag.Position);
            bool containsRotation = movedProperties.FastContains(TransformPropertiesFlag.Rotation);
            bool containsScale = movedProperties.FastContains(TransformPropertiesFlag.Scale);

            //World space.
            if (useWorldSpace)
            {
                if (containsPosition)
                {
                    if (posRate == INSTANT_VALUE)
                        t.position = posGoal;
                    else if (posRate == UNSET_VALUE) { }
                    else
                        t.position = Vector3.MoveTowards(t.position, posGoal, posRate * delta);
                }

                if (containsRotation)
                {
                    if (rotRate == INSTANT_VALUE)
                        t.rotation = rotGoal;
                    else if (rotRate == UNSET_VALUE) { }
                    else
                        t.rotation = Quaternion.RotateTowards(t.rotation, rotGoal, rotRate * delta);
                }
            }
            //Local space.
            else
            {
                if (containsPosition)
                {
                    if (posRate == INSTANT_VALUE)
                        t.localPosition = posGoal;
                    else if (posRate == UNSET_VALUE) { }
                    else
                        t.localPosition = Vector3.MoveTowards(t.localPosition, posGoal, posRate * delta);
                }

                if (containsRotation)
                {
                    if (rotRate == INSTANT_VALUE)
                        t.localRotation = rotGoal;
                    else if (rotRate == UNSET_VALUE) { }
                    else
                        t.localRotation = Quaternion.RotateTowards(t.localRotation, rotGoal, rotRate * delta);
                }
            }

            //Scale always uses local.
            if (containsScale)
            {
                if (scaleRate == INSTANT_VALUE)
                    t.localScale = scaleGoal;
                else if (scaleRate == UNSET_VALUE) { }
                else
                    t.localScale = Vector3.MoveTowards(t.localScale, scaleGoal, scaleRate * delta);
            }
        }
    }

    /// <summary>
    /// Used to make calculations and perform actions in moving transforms over time.
    /// </summary>
    /// <remarks>This acts as a wrapper for MoveRates struct.</remarks>
    public class MoveRatesCls : IResettable
    {
        /// <summary>
        /// Container of all move rate information.
        /// </summary>
        private MoveRates _moveRates = new();

        /// <summary>
        /// Rate at which to move Position.
        /// </summary>
        public float Position => _moveRates.Position;
        /// <summary>
        /// Rate at which to move Rotation.
        /// </summary>
        public float Rotation => _moveRates.Rotation;
        /// <summary>
        /// Rate at which to move Scale.
        /// </summary>
        public float Scale => _moveRates.Scale;
        /// <summary>
        /// Time remaining until the move is complete.
        /// </summary>
        public float TimeRemaining => _moveRates.TimeRemaining;

        /// <summary>
        /// True if position move rate should be instant.
        /// </summary>
        public bool IsPositionInstantValue => _moveRates.IsPositionInstantValue;
        /// <summary>
        /// True if rotation move rate should be instant.
        /// </summary>
        public bool IsRotationInstantValue => _moveRates.IsRotationInstantValue;
        /// <summary>
        /// True if scale move rate should be instant.
        /// </summary>
        public bool IsScaleInstantValue => _moveRates.IsScaleInstantValue;

        /// <summary>
        /// True if any data is set.
        /// </summary>
        public bool IsValid => _moveRates.IsValid;

        public MoveRatesCls(float value) => _moveRates = new MoveRates(value);
        public MoveRatesCls(float position, float rotation) => _moveRates = new MoveRates(position, rotation);
        public MoveRatesCls(float position, float rotation, float scale) => _moveRates = new MoveRates(position, rotation, scale);
        public MoveRatesCls(float position, float rotation, float scale, float timeRemaining) => _moveRates = new MoveRates(position, rotation, scale, timeRemaining);

        public MoveRatesCls() => _moveRates.ResetState();

        /// <summary>
        /// Sets all rates to instant.
        /// </summary>
        public void SetInstantRates() => _moveRates.SetInstantRates();

        /// <summary>
        /// Sets all rates to the same value.
        /// </summary>
        public void Update(float value) => _moveRates.Update(value);

        /// <summary>
        /// Updates values.
        /// </summary>
        public void Update(float position, float rotation, float scale) => _moveRates.Update(position, rotation, scale);

        /// <summary>
        /// Updates values.
        /// </summary>
        public void Update(float position, float rotation, float scale, float timeRemaining) => _moveRates.Update(position, rotation, scale, timeRemaining);

        /// <summary>
        /// Updaes values.
        /// </summary>
        public void Update(MoveRatesCls mr) => _moveRates.Update(mr.Position, mr.Rotation, mr.Scale);
        
        /// <summary>
        /// Moves transform to target values.
        /// </summary>
        public void Move(Transform movingTransform, TransformProperties goalProperties, float delta, bool useWorldSpace) => _moveRates.Move(movingTransform, goalProperties, delta, useWorldSpace);
        
        /// <summary>
        /// Moves transform to target values.
        /// </summary>
        public void Move(Transform movingTransform, TransformProperties goalProperties, TransformPropertiesFlag movedProperties, float delta, bool useWorldSpace) => _moveRates.Move(movingTransform, goalProperties, movedProperties, delta, useWorldSpace);

        public void ResetState() => _moveRates.ResetState();

        public void InitializeState() { }
    }
}﻿using FishNet.CodeGenerating;
using FishNet.Component.Prediction;
using FishNet.Managing;
using FishNet.Serializing;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Scripting;

namespace FishNet.Object.Prediction
{
    [Preserve]
    [DefaultWriter]
    public static class PredictionigidbodySerializers
    {
        [DefaultWriter]
        public static void WriteEntryData(this Writer w, PredictionRigidbody.EntryData value)
        {
            PredictionRigidbody.ForceApplicationType appType = value.Type;
            w.WriteUInt8Unpacked((byte)appType);
            PredictionRigidbody.AllForceData data = value.Data;

            switch (appType)
            {
                case PredictionRigidbody.ForceApplicationType.AddTorque:
                case PredictionRigidbody.ForceApplicationType.AddForce:
                case PredictionRigidbody.ForceApplicationType.AddRelativeTorque:
                case PredictionRigidbody.ForceApplicationType.AddRelativeForce:
                    w.WriteVector3(data.Vector3Force);
                    w.WriteInt32((byte)data.Mode);
                    break;
                case PredictionRigidbody.ForceApplicationType.AddExplosiveForce:
                    w.WriteSingle(data.FloatForce);
                    w.WriteVector3(data.Position);
                    w.WriteSingle(data.Radius);
                    w.WriteSingle(data.UpwardsModifier);
                    w.WriteInt32((byte)data.Mode);
                    break;
                case PredictionRigidbody.ForceApplicationType.AddForceAtPosition:
                    w.WriteVector3(data.Vector3Force);
                    w.WriteVector3(data.Position);
                    w.WriteInt32((byte)data.Mode);
                    break;
                default:
                    NetworkManagerExtensions.LogError($"ForceApplicationType of {appType} is not supported.");
                    break;
            }
        }

        [DefaultReader]
        public static PredictionRigidbody.EntryData ReadEntryData(this Reader r)
        {
            PredictionRigidbody.EntryData fd = new();

            PredictionRigidbody.ForceApplicationType appType = (PredictionRigidbody.ForceApplicationType)r.ReadUInt8Unpacked();
            fd.Type = appType;

            PredictionRigidbody.AllForceData data = new();

            switch (appType)
            {
                case PredictionRigidbody.ForceApplicationType.AddTorque:
                case PredictionRigidbody.ForceApplicationType.AddForce:
                case PredictionRigidbody.ForceApplicationType.AddRelativeTorque:
                case PredictionRigidbody.ForceApplicationType.AddRelativeForce:
                    data.Vector3Force = r.ReadVector3();
                    data.Mode = (ForceMode)r.ReadInt32();
                    break;
                case PredictionRigidbody.ForceApplicationType.AddExplosiveForce:
                    data.FloatForce = r.ReadSingle();
                    data.Position = r.ReadVector3();
                    data.Radius = r.ReadSingle();
                    data.UpwardsModifier = r.ReadSingle();
                    data.Mode = (ForceMode)r.ReadInt32();
                    break;
                case PredictionRigidbody.ForceApplicationType.AddForceAtPosition:
                    data.Vector3Force = r.ReadVector3();
                    data.Position = r.ReadVector3();
                    data.Mode = (ForceMode)r.ReadInt32();
                    break;
                default:
                    NetworkManagerExtensions.LogError($"ForceApplicationType of {appType} is not supported.");
                    break;
            }

            fd.Data = data;
            return fd;
        }

        [DefaultWriter]
        public static void WritePredictionRigidbody(this Writer w, PredictionRigidbody pr)
        {
            w.Write(pr.Rigidbody.GetState());
            w.WriteList(pr.GetPendingForces());
        }

        [DefaultReader]
        public static PredictionRigidbody ReadPredictionRigidbody(this Reader r)
        {
            List<PredictionRigidbody.EntryData> lst = CollectionCaches<PredictionRigidbody.EntryData>.RetrieveList();

            RigidbodyState rs = r.Read<RigidbodyState>();
            r.ReadList(ref lst);
            PredictionRigidbody pr = ResettableObjectCaches<PredictionRigidbody>.Retrieve();

            pr.SetReconcileData(rs, lst);
            return pr;
        }

        [DefaultDeltaWriter]
        public static bool WriteDeltaEntryData(this Writer w, PredictionRigidbody.EntryData value)
        {
            w.WriteEntryData(value);
            return true;
        }

        [DefaultDeltaReader]
        public static PredictionRigidbody.EntryData ReadDeltaEntryData(this Reader r) => r.ReadEntryData();
        
        [DefaultDeltaWriter]
        public static bool WriteDeltaPredictionRigidbody(this Writer w, PredictionRigidbody pr)
        {
            w.WritePredictionRigidbody(pr);
            return true;
        }
        
        [DefaultDeltaReader]
        public static PredictionRigidbody ReadDeltaPredictionRigidbody(this Reader r) => r.ReadPredictionRigidbody();
    }

    [UseGlobalCustomSerializer]
    [Preserve]
    public class PredictionRigidbody : IResettable
    {
        #region Types.
        public struct AllForceData
        {
            public ForceMode Mode;
            public Vector3 Vector3Force;
            public Vector3 Position;
            public float FloatForce;
            public float Radius;
            public float UpwardsModifier;

            /// <summary>
            /// Used for Force and Torque.
            /// </summary>
            public AllForceData(Vector3 force, ForceMode mode) : this()
            {
                Vector3Force = force;
                Mode = mode;
            }

            /// <summary>
            /// Used for Position.
            /// </summary>
            public AllForceData(Vector3 force, Vector3 position, ForceMode mode) : this()
            {
                Vector3Force = force;
                Position = position;
                Mode = mode;
            }

            /// <summary>
            /// Used for Explosive.
            /// </summary>
            /// <param name="force"></param>
            /// <param name="position"></param>
            /// <param name="radius"></param>
            /// <param name="upwardsModifier"></param>
            /// <param name="mode"></param>
            public AllForceData(float force, Vector3 position, float radius, float upwardsModifier, ForceMode mode) : this()
            {
                FloatForce = force;
                Position = position;
                Radius = radius;
                UpwardsModifier = upwardsModifier;
                Mode = mode;
            }
        }

        public interface IForceData { }

        //How the force was applied.
        [System.Flags]
        public enum ForceApplicationType : byte
        {
            AddForceAtPosition = 1,
            AddExplosiveForce = 2,
            AddForce = 4,
            AddRelativeForce = 8,
            AddTorque = 16,
            AddRelativeTorque = 32,
        }

        [UseGlobalCustomSerializer]
        public struct EntryData
        {
            public ForceApplicationType Type;
            public AllForceData Data;

            public EntryData(ForceApplicationType type, AllForceData data)
            {
                Type = type;
                Data = data;
            }

            public EntryData(EntryData fd)
            {
                Type = fd.Type;
                Data = fd.Data;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Rigidbody which force is applied.
        /// </summary>
        public Rigidbody Rigidbody { get; private set; }
        /// <summary>
        /// Returns if there are any pending forces.
        /// </summary>
        public bool HasPendingForces => (_pendingForces != null && _pendingForces.Count > 0);
        #endregion

        #region Internal.
        /// <summary>
        /// RigidbodyState set only as reconcile data.
        /// </summary>
        [System.NonSerialized]
        internal RigidbodyState RigidbodyState;
        #endregion

        #region Private
        /// <summary>
        /// Forces waiting to be applied.
        /// </summary>
        [ExcludeSerialization]
        private List<EntryData> _pendingForces;

        /// <summary>
        /// Returns current pending forces.
        /// Modifying this collection could cause undesirable results.
        /// </summary>
        public List<EntryData> GetPendingForces() => _pendingForces;
        #endregion

        ~PredictionRigidbody()
        {
            if (_pendingForces != null)
                CollectionCaches<EntryData>.StoreAndDefault(ref _pendingForces);
            Rigidbody = null;
        }

        /// <summary>
        /// Rigidbody which force is applied.
        /// </summary>
        /// <param name="rb"></param>
        public void Initialize(Rigidbody rb)
        {
            Rigidbody = rb;
            if (_pendingForces == null)
                _pendingForces = CollectionCaches<EntryData>.RetrieveList();
            else
                _pendingForces.Clear();
        }

        /// <summary>
        /// Adds Velocity force to the Rigidbody.
        /// </summary>
        public void AddForce(Vector3 force, ForceMode mode = ForceMode.Force)
        {
            EntryData fd = new(ForceApplicationType.AddForce, new(force, mode));
            _pendingForces.Add(fd);
        }

        public void AddRelativeForce(Vector3 force, ForceMode mode = ForceMode.Force)
        {
            EntryData fd = new(ForceApplicationType.AddRelativeForce, new(force, mode));
            _pendingForces.Add(fd);
        }

        public void AddTorque(Vector3 force, ForceMode mode = ForceMode.Force)
        {
            EntryData fd = new(ForceApplicationType.AddTorque, new(force, mode));
            _pendingForces.Add(fd);
        }

        public void AddRelativeTorque(Vector3 force, ForceMode mode = ForceMode.Force)
        {
            EntryData fd = new(ForceApplicationType.AddRelativeTorque, new(force, mode));
            _pendingForces.Add(fd);
        }

        public void AddExplosiveForce(float force, Vector3 position, float radius, float upwardsModifier = 0f, ForceMode mode = ForceMode.Force)
        {
            EntryData fd = new(ForceApplicationType.AddExplosiveForce, new(force, position, radius, upwardsModifier, mode));
            _pendingForces.Add(fd);
        }

        public void AddForceAtPosition(Vector3 force, Vector3 position, ForceMode mode = ForceMode.Force)
        {
            EntryData fd = new(ForceApplicationType.AddForceAtPosition, new(force, position, mode));
            _pendingForces.Add(fd);
        }

        /// <summary>
        /// Sets velocity while clearing pending forces.
        /// Simulate should still be called normally.
        /// </summary>
        public void Velocity(Vector3 force)
        {
            Rigidbody.velocity = force;
            RemoveForces(true);
        }

        /// <summary>
        /// Sets angularVelocity while clearning pending forces.
        /// Simulate should still be called normally.
        /// </summary>
        public void AngularVelocity(Vector3 force)
        {
            Rigidbody.angularVelocity = force;
            RemoveForces(false);
        }

        /// <summary>
        /// Applies pending forces to rigidbody in the order they were added.
        /// </summary>
        public void Simulate()
        {
            foreach (EntryData item in _pendingForces)
            {
                AllForceData data = item.Data;
                switch (item.Type)
                {
                    case ForceApplicationType.AddTorque:
                        Rigidbody.AddTorque(data.Vector3Force, data.Mode);
                        break;
                    case ForceApplicationType.AddForce:
                        Rigidbody.AddForce(data.Vector3Force, data.Mode);
                        break;
                    case ForceApplicationType.AddRelativeTorque:
                        Rigidbody.AddRelativeTorque(data.Vector3Force, data.Mode);
                        break;
                    case ForceApplicationType.AddRelativeForce:
                        Rigidbody.AddRelativeForce(data.Vector3Force, data.Mode);
                        break;
                    case ForceApplicationType.AddExplosiveForce:
                        Rigidbody.AddExplosionForce(data.FloatForce, data.Position, data.Radius, data.UpwardsModifier, data.Mode);
                        break;
                    case ForceApplicationType.AddForceAtPosition:
                        Rigidbody.AddForceAtPosition(data.Vector3Force, data.Position, data.Mode);
                        break;
                }
            }
            _pendingForces.Clear();
        }

        /// <summary>
        /// Manually clears pending forces.
        /// </summary>
        /// <param name="velocity">True to clear velocities, false to clear angular velocities.</param>
        public void ClearPendingForces(bool velocity)
        {
            RemoveForces(velocity);
        }

        /// <summary>
        /// Clears pending velocity and angular velocity forces.
        /// </summary>
        public void ClearPendingForces()
        {
            _pendingForces.Clear();
        }

        /// <summary>
        /// Reconciles to a state.
        /// </summary>
        public void Reconcile(PredictionRigidbody pr)
        {
            _pendingForces.Clear();
            if (pr._pendingForces != null)
            {
                foreach (EntryData item in pr._pendingForces)
                    _pendingForces.Add(new(item));
            }
            //Set state.
            Rigidbody.SetState(pr.RigidbodyState);

            ResettableObjectCaches<PredictionRigidbody>.Store(pr);
        }

        /// <summary>
        /// Removes forces from pendingForces.
        /// </summary>
        /// <param name="velocity">True to remove if velocity, false if to remove angular velocity.</param>
        private void RemoveForces(bool velocity)
        {
            if (_pendingForces.Count > 0)
            {
                ForceApplicationType velocityApplicationTypes = (ForceApplicationType.AddRelativeForce | ForceApplicationType.AddForce | ForceApplicationType.AddExplosiveForce);

                List<EntryData> newDatas = CollectionCaches<EntryData>.RetrieveList();
                foreach (EntryData item in _pendingForces)
                {
                    if (VelocityApplicationTypesContains(item.Type) == !velocity)
                        newDatas.Add(item);
                }
                //Add back to _pendingForces if changed.
                if (newDatas.Count != _pendingForces.Count)
                {
                    _pendingForces.Clear();
                    foreach (EntryData item in newDatas)
                        _pendingForces.Add(item);
                }
                CollectionCaches<EntryData>.Store(newDatas);

                bool VelocityApplicationTypesContains(ForceApplicationType apt)
                {
                    return (velocityApplicationTypes & apt) == apt;
                }
            }
        }

        internal void SetReconcileData(RigidbodyState rs, List<EntryData> lst)
        {
            RigidbodyState = rs;
            _pendingForces = lst;
        }

        public void ResetState()
        {
            CollectionCaches<EntryData>.StoreAndDefault(ref _pendingForces);
            Rigidbody = null;
        }

        public void InitializeState() { }
    }
}﻿using FishNet.CodeGenerating;
using FishNet.Component.Prediction;
using FishNet.Managing;
using FishNet.Serializing;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Scripting;

namespace FishNet.Object.Prediction
{
    public static class PredictionRigidbody2DSerializers
    {
        public static void WriteForceData(this Writer w, PredictionRigidbody2D.EntryData value)
        {
            PredictionRigidbody2D.ForceApplicationType appType = value.Type;
            w.WriteUInt8Unpacked((byte)appType);
            PredictionRigidbody2D.AllForceData data = value.Data;

            switch (appType)
            {
                case PredictionRigidbody2D.ForceApplicationType.AddForce:
                case PredictionRigidbody2D.ForceApplicationType.AddRelativeForce:
                    w.WriteVector3(data.Vector3Force);
                    w.WriteInt32((byte)data.Mode);
                    break;
                case PredictionRigidbody2D.ForceApplicationType.AddTorque:
                    w.WriteSingle(data.FloatForce);
                    w.WriteInt32((byte)data.Mode);
                    break;
                case PredictionRigidbody2D.ForceApplicationType.AddForceAtPosition:
                    w.WriteVector3(data.Vector3Force);
                    w.WriteVector3(data.Position);
                    w.WriteInt32((byte)data.Mode);
                    break;
                default:
                    NetworkManagerExtensions.LogError($"ForceApplicationType of {appType} is not supported.");
                    break;
            }
        }

        public static PredictionRigidbody2D.EntryData ReadForceData(this Reader r)
        {
            PredictionRigidbody2D.EntryData fd = new();

            PredictionRigidbody2D.ForceApplicationType appType = (PredictionRigidbody2D.ForceApplicationType)r.ReadUInt8Unpacked();
            fd.Type = appType;

            PredictionRigidbody2D.AllForceData data = new();

            switch (appType)
            {
                case PredictionRigidbody2D.ForceApplicationType.AddForce:
                case PredictionRigidbody2D.ForceApplicationType.AddRelativeForce:
                    data.Vector3Force = r.ReadVector3();
                    data.Mode = (ForceMode2D)r.ReadUInt8Unpacked();
                    return fd;
                case PredictionRigidbody2D.ForceApplicationType.AddTorque:
                    data.FloatForce = r.ReadSingle();
                    data.Mode = (ForceMode2D)r.ReadUInt8Unpacked();
                    return fd;
                case PredictionRigidbody2D.ForceApplicationType.AddForceAtPosition:
                    data.Vector3Force = r.ReadVector3();
                    data.Position = r.ReadVector3();
                    data.Mode = (ForceMode2D)r.ReadUInt8Unpacked();
                    return fd;
                default:
                    NetworkManagerExtensions.LogError($"ForceApplicationType of {appType} is not supported.");
                    return fd;
            }
        }

        public static void WritePredictionRigidbody2D(this Writer w, PredictionRigidbody2D pr)
        {
            w.Write(pr.Rigidbody2D.GetState());
            w.WriteList(pr.GetPendingForces());
        }

        public static PredictionRigidbody2D ReadPredictionRigidbody2D(this Reader r)
        {
            List<PredictionRigidbody2D.EntryData> lst = CollectionCaches<PredictionRigidbody2D.EntryData>.RetrieveList();
            Rigidbody2DState rs = r.Read<Rigidbody2DState>();
            r.ReadList(ref lst);
            PredictionRigidbody2D pr = ResettableObjectCaches<PredictionRigidbody2D>.Retrieve();

            pr.SetReconcileData(rs, lst);
            pr.SetPendingForces(lst);
            return pr;
        }

    }

    [UseGlobalCustomSerializer]
    [Preserve]
    public class PredictionRigidbody2D : IResettable
    {
        #region Types.
        //How the force was applied.
        [System.Flags]
        public enum ForceApplicationType : byte
        {
            AddForceAtPosition = 1,
            AddForce = 4,
            AddRelativeForce = 8,
            AddTorque = 16,
        }
        public struct AllForceData
        {
            public Vector3 Vector3Force;
            public float FloatForce;
            public Vector3 Position;
            public ForceMode2D Mode;

            public AllForceData(Vector3 force, ForceMode2D mode) : this()
            {
                Vector3Force = force;
                Mode = mode;
            }


            public AllForceData(float force, ForceMode2D mode) : this()
            {
                FloatForce = force;
                Mode = mode;
            }

            public AllForceData(Vector3 force, Vector3 position, ForceMode2D mode) : this()
            {
                Vector3Force = force;
                Position = position;
                Mode = mode;
            }
        }


        [UseGlobalCustomSerializer]
        public struct EntryData
        {
            public ForceApplicationType Type;
            public AllForceData Data;

            public EntryData(ForceApplicationType type, AllForceData data)
            {
                Type = type;
                Data = data;
            }
            public EntryData(EntryData fd)
            {
                Type = fd.Type;
                Data = fd.Data;
            }
        }
        #endregion

        #region Internal.
        /// <summary>
        /// Rigidbody2DState set only as reconcile data.
        /// </summary>
        [System.NonSerialized]
        internal Rigidbody2DState Rigidbody2DState;
        #endregion

        #region Public.
        /// <summary>
        /// Rigidbody which force is applied.
        /// </summary>
        public Rigidbody2D Rigidbody2D { get; private set; }
        /// <summary>
        /// Returns if there are any pending forces.
        /// </summary>
        public bool HasPendingForces => (_pendingForces != null && _pendingForces.Count > 0);
        #endregion

        #region Private
        /// <summary>
        /// Forces waiting to be applied.
        /// </summary>
        [ExcludeSerialization]
        private List<EntryData> _pendingForces;
        /// <summary>
        /// Returns current pending forces.
        /// Modifying this collection could cause undesirable results.
        /// </summary>
        public List<EntryData> GetPendingForces() => _pendingForces;
        #endregion

        ~PredictionRigidbody2D()
        {
            if (_pendingForces != null)
                CollectionCaches<EntryData>.StoreAndDefault(ref _pendingForces);
            Rigidbody2D = null;
        }

        /// <summary>
        /// Rigidbody which force is applied.
        /// </summary>
        /// <param name="rb"></param>
        public void Initialize(Rigidbody2D rb)
        {
            Rigidbody2D = rb;
            if (_pendingForces == null)
                _pendingForces = CollectionCaches<EntryData>.RetrieveList();
            else
                _pendingForces.Clear();
        }

        /// <summary>
        /// Adds Velocity force to the Rigidbody.
        /// </summary>
        public void AddForce(Vector3 force, ForceMode2D mode = ForceMode2D.Force)
        {
            EntryData fd = new(ForceApplicationType.AddForce,
                new(force, mode));
            _pendingForces.Add(fd);
        }
        public void AddRelativeForce(Vector3 force, ForceMode2D mode = ForceMode2D.Force)
        {
            EntryData fd = new(ForceApplicationType.AddRelativeForce,
                new(force, mode));
            _pendingForces.Add(fd);

        }
        public void AddTorque(float force, ForceMode2D mode = ForceMode2D.Force)
        {
            EntryData fd = new(ForceApplicationType.AddTorque,
                new(force, mode));
            _pendingForces.Add(fd);
        }
        public void AddForceAtPosition(Vector3 force, Vector3 position, ForceMode2D mode = ForceMode2D.Force)
        {
            EntryData fd = new(ForceApplicationType.AddForceAtPosition,
                new(force, position, mode));
            _pendingForces.Add(fd);
        }

        /// <summary>
        /// Sets velocity while clearing pending forces.
        /// Simulate should still be called normally.
        /// </summary>
        public void Velocity(Vector3 force)
        {
            Rigidbody2D.velocity = force;
            RemoveForces(true);
        }

        /// <summary>
        /// Sets angularVelocity while clearning pending forces.
        /// Simulate should still be called normally.
        /// </summary>
        public void AngularVelocity(float force)
        {
            Rigidbody2D.angularVelocity = force;
            RemoveForces(false);
        }

        /// <summary>
        /// Applies pending forces to rigidbody in the order they were added.
        /// </summary>
        public void Simulate()
        {
            foreach (EntryData item in _pendingForces)
            {
                AllForceData data = item.Data;
                switch (item.Type)
                {
                    case ForceApplicationType.AddTorque:
                        Rigidbody2D.AddTorque(data.FloatForce, data.Mode);
                        break;
                    case ForceApplicationType.AddForce:
                        Rigidbody2D.AddForce(data.Vector3Force, data.Mode);
                        break;
                    case ForceApplicationType.AddRelativeForce:
                        Rigidbody2D.AddRelativeForce(data.Vector3Force, data.Mode);
                        break;
                    case ForceApplicationType.AddForceAtPosition:
                        Rigidbody2D.AddForceAtPosition(data.Vector3Force, data.Position, data.Mode);
                        break;
                }
            }
            _pendingForces.Clear();
        }

        /// <summary>
        /// Manually clears pending forces.
        /// </summary>
        /// <param name="velocity">True to clear velocities, false to clear angular velocities.</param>
        public void ClearPendingForces(bool velocity)
        {
            RemoveForces(velocity);
        }
        /// <summary>
        /// Clears pending velocity and angular velocity forces.
        /// </summary>
        public void ClearPendingForces()
        {
            _pendingForces.Clear();
        }

        /// <summary>
        /// Reconciles to a state.
        /// </summary>
        public void Reconcile(PredictionRigidbody2D pr)
        {
            _pendingForces.Clear();
            if (pr._pendingForces != null)
            {
                foreach (EntryData item in pr._pendingForces)
                    _pendingForces.Add(new(item));
            }
            Rigidbody2D.SetState(pr.Rigidbody2DState);

            ResettableObjectCaches<PredictionRigidbody2D>.Store(pr);
        }

        /// <summary>
        /// Removes forces from pendingForces.
        /// </summary>
        /// <param name="velocity">True to remove if velocity, false if to remove angular velocity.</param>
        private void RemoveForces(bool velocity)
        {
            if (_pendingForces.Count > 0)
            {
                bool shouldExist = velocity;
                ForceApplicationType velocityApplicationTypes = (ForceApplicationType.AddRelativeForce | ForceApplicationType.AddForce);

                List<EntryData> newDatas = CollectionCaches<EntryData>.RetrieveList();
                foreach (EntryData item in _pendingForces)
                {
                    if (VelocityApplicationTypesContains(item.Type) == !velocity)
                        newDatas.Add(item);
                }
                //Add back to _pendingForces if changed.
                if (newDatas.Count != _pendingForces.Count)
                {
                    _pendingForces.Clear();
                    foreach (EntryData item in newDatas)
                        _pendingForces.Add(item);
                }
                CollectionCaches<EntryData>.Store(newDatas);

                bool VelocityApplicationTypesContains(ForceApplicationType apt)
                {
                    return (velocityApplicationTypes & apt) == apt;
                }
            }


        }

        internal void SetPendingForces(List<EntryData> lst) => _pendingForces = lst;

        internal void SetReconcileData(Rigidbody2DState rs, List<EntryData> lst)
        {
            Rigidbody2DState = rs;
            _pendingForces = lst;
        }

        public void ResetState()
        {
            CollectionCaches<EntryData>.StoreAndDefault(ref _pendingForces);
            Rigidbody2D = null;
        }

        public void InitializeState() { }
    }

}

﻿using FishNet.Utility;
using System.Runtime.CompilerServices;
using FishNet.CodeGenerating;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]

namespace FishNet.Object.Prediction
{
    [MakePublic]
    internal struct ReplicateDataContainer<T> where T : IReplicateData, new()
    {
        #region Types
        private enum DataCachingType
        {
            Unset,
            ValueType,
            IResettableReferenceType,
            ReferenceType,
        }
        #endregion

        /// <summary>
        /// Replicate data.
        /// </summary>
        public T Data;
        /// <summary>
        /// True if the data was created locally or came through the network as created.
        /// </summary>
        public bool IsCreated;
        /// <summary>
        /// Channel the data came in on.
        /// </summary>
        public readonly Channel Channel;
        /// <summary>
        /// True if populated.
        /// </summary>
        public bool IsValid { get; private set; }

        /// <summary>
        /// How data should be cached and retrieved when not set.
        /// </summary>
        private static DataCachingType _dataCachingType = DataCachingType.Unset;

        public ReplicateDataContainer(T data, Channel channel) : this(data, channel, tick: 0, isCreated: false) { }

        public ReplicateDataContainer(T data, Channel channel, bool isCreated) : this(data, channel, tick: 0, isCreated) { }

        public ReplicateDataContainer(T data, Channel channel, uint tick, bool isCreated = false)
        {
            Data = data;
            Channel = channel;
            IsCreated = isCreated;
            IsValid = true;

            SetDataTick(tick);
        }

        /// <summary>
        /// A shortcut to calling Data.SetTick.
        /// </summary>
        public void SetDataTick(uint tick)
        {
            SetDataIfNull(ref Data);
            Data.SetTick(tick);
        }

        /// <summary>
        /// Sets data to new() if is nullable type, and is null.
        /// </summary>
        /// <param name="data"></param>
        private void SetDataIfNull(ref T data)
        {
            //Only figure out data caching type once to save perf.
            if (_dataCachingType == DataCachingType.Unset)
            {
                if (typeof(T).IsValueType)
                    _dataCachingType = DataCachingType.ValueType;
                else if (typeof(IResettable).IsAssignableFrom(typeof(T)))
                    _dataCachingType = DataCachingType.IResettableReferenceType;
                else
                    _dataCachingType = DataCachingType.ReferenceType;
            }

            if (_dataCachingType != DataCachingType.ValueType && data == null)
                data = ObjectCaches<T>.Retrieve();
        }

        public void Dispose()
        {
            if (Data != null)
                Data.Dispose();

            IsValid = false;
        }

        public static ReplicateDataContainer<T> GetDefault(uint tick) => new(default(T), Channel.Unreliable, tick);

        public static ReplicateDataContainer<T> GetDefault() => GetDefault(tick: 0);
    }
}﻿#if !FISHNET_STABLE_REPLICATESTATES
using System;
using FishNet.Utility;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]

namespace FishNet.Object.Prediction
{
    [System.Flags]
    public enum ReplicateState : byte
    {
        /// <summary>
        /// The default value of this state.
        /// This value should never occur when a replicate runs.
        /// </summary>
        Invalid = 0,
        /// <summary>
        /// Server and clients use this flag.
        /// Flag will be set if data tick has run outside a reconcile, such as from user code within OnTick.
        /// </summary>
        Ticked = (1 << 0), //1
        /// <summary>
        /// Only client will use this flag.
        /// Flag is set if data is being run during a reconcile.
        /// </summary>
        Replayed = (1 << 1), //2
        /// <summary>
        /// Server and client use this flag.
        /// Data has been created by the server or client.
        /// This indicates that data is known and was intentionally sent.
        /// </summary>
        Created = (1 << 2), //4
    }

    public static class ReplicateStateExtensions
    {
        /// <summary>
        /// Returns if value is valid.
        /// This should never be false.
        /// </summary>
        public static bool IsValid(this ReplicateState value) => (value != ReplicateState.Invalid);

        /// <summary>
        /// Returns if value contains ReplicateState.Ticked.
        /// </summary>
        public static bool ContainsTicked(this ReplicateState value) => value.FastContains(ReplicateState.Ticked);

        /// <summary>
        /// Returns if value contains ReplicateState.Created.
        /// </summary>
        public static bool ContainsCreated(this ReplicateState value) => value.FastContains(ReplicateState.Created);

        /// <summary>
        /// Returns if value contains ReplicateState.Replayed.
        /// </summary>
        public static bool ContainsReplayed(this ReplicateState value) => value.FastContains(ReplicateState.Replayed);

        [Obsolete("Use ContainsReplayed.")]
        public static bool IsReplayed(this ReplicateState value) => value.ContainsReplayed();

        /// <summary>
        /// Returns if value is (ReplicateState.Ticked | ReplicateState.Created).
        /// </summary>
        public static bool IsTickedCreated(this ReplicateState value) => (value == (ReplicateState.Ticked | ReplicateState.Created));

        /// <summary>
        /// Returns if value equals ReplicateState.Ticked.
        /// </summary>
        public static bool IsTickedNonCreated(this ReplicateState value) => (value == ReplicateState.Ticked);

        /// <summary>
        /// Returns if value is (ReplicateState.Replayed | ReplicateState.Ticked | ReplicateState.Created).
        /// </summary>
        public static bool IsReplayedCreated(this ReplicateState value) => (value == (ReplicateState.Replayed | ReplicateState.Created));

        /// <summary>
        /// Returns if value is ReplicateState.Replayed without ReplicateState.Ticked nor ReplicateState.Created.
        /// </summary>
        public static bool IsFuture(this ReplicateState value) => (value == ReplicateState.Replayed);

        [Obsolete("Use ContainsCreated.")]
        public static bool IsCreated(this ReplicateState value) => value.ContainsCreated();

        /// <summary>
        /// True if part is containined within whole.
        /// </summary>
        public static bool FastContains(this ReplicateState whole, ReplicateState part) => (whole & part) == part;
    }
}
#else
using FishNet.Utility;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.CODEGEN_ASSEMBLY_NAME)]
namespace FishNet.Object
{

    public enum ReplicateState : byte
    {
        /// <summary>
        /// The default value of this state.
        /// This value should never occur when a replicate runs.
        /// </summary>
        Invalid = 0,
        /// <summary>
        /// Value is seen on server and clients.
        /// Client or server has data on the object for the tick.
        /// Clients will only see this value on spectated objects when PredictionManager is using Appended state order.
        /// </summary>
        CurrentCreated = 1,
        /// <summary>
        /// Value is only seen on server when they do not own the object.
        /// Server does not have data on this non-owned object for the tick but expected to, such as a state should have arrived but did not.
        /// </summary>
        [System.Obsolete("This is currently not used but may be in a later release. Please read summary for value.")]
        CurrentPredicted = 2,
        /// <summary>
        /// Value is only seen on clients when they do not own the object.
        /// Client does not have data for the tick but expected to, such as a state should have arrived but did not.
        /// Client is currently reconciling.
        /// </summary>
        [System.Obsolete("This is currently not used but may be in a later release. Please read summary for value.")]
        ReplayedPredicted = 3,
        /// <summary>
        /// Value is only seen on clients.
        /// Client has data on the object for the tick.
        /// Client is currently reconciling.
        /// </summary>
        ReplayedCreated = 4,
        /// <summary>
        /// Value is only seen on clients when they do not own the object.
        /// Tick is in the future and data cannot yet be known.
        /// This can be used to exit replicate early to not process actions, or create actions based on previous datas.
        /// </summary>
        CurrentFuture = 5,
        /// <summary>
        /// Value is only seen on clients when they do not own the object.
        /// Tick is in the future and data cannot yet be known.
        /// Client is currently reconciling.
        /// This can be used to exit replicate early to not process actions, or create actions based on previous datas.
        /// </summary>
        ReplayedFuture = 6,
    }

    public static class ReplicateStateExtensions
    {
        /// <summary>
        /// Returns if value is valid.
        /// This should never be false.
        /// </summary>
        public static bool IsValid(this ReplicateState value) => (value != ReplicateState.Invalid);
        /// <summary>
        /// Returns if value is replayed.
        /// </summary>
#pragma warning disable CS0618 // Type or member is obsolete
        public static bool IsReplayed(this ReplicateState value) => (value == ReplicateState.ReplayedPredicted || value == ReplicateState.ReplayedCreated || value == ReplicateState.ReplayedFuture);
#pragma warning restore CS0618 // Type or member is obsolete
        /// <summary>
        /// Returns if value is user created.
        /// </summary>
        public static bool IsCreated(this ReplicateState value) => (value == ReplicateState.CurrentCreated || value == ReplicateState.ReplayedCreated);
        /// <summary>
        /// Returns if value is predicted.
        /// </summary>
#pragma warning disable CS0618 // Type or member is obsolete
        public static bool IsPredicted(this ReplicateState value) => (value == ReplicateState.ReplayedPredicted);
#pragma warning restore CS0618 // Type or member is obsolete
        /// <summary>
        /// Returns if value is in the future.
        /// </summary>
        public static bool IsFuture(this ReplicateState value) => (value == ReplicateState.CurrentFuture || value == ReplicateState.ReplayedFuture);
    }
}
#endif﻿
namespace FishNet.Object.Synchronizing
{
    /// <summary>
    /// Custom SyncObjects must inherit from SyncBase and implement this interface.
    /// </summary>
    public interface ICustomSync
    {
        /// <summary>
        /// Get the serialized type.
        /// This must return the value type you are synchronizing, for example a struct or class.
        /// If you are not synchronizing a particular value but instead of supported values such as int, bool, ect, then you may return null on this method.
        /// </summary>
        /// <returns></returns>
        object GetSerializedType();
    }


}﻿using UnityEngine;

namespace FishNet.Object.Synchronizing
{
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class FloatSyncVar : SyncVar<float>, ICustomSync
    {
        public object GetSerializedType() => typeof(float);
        protected override float Interpolate(float previous, float current, float percent) => Mathf.Lerp(previous, current, percent);
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class DoubleSyncVar : SyncVar<double>, ICustomSync
    {
        public object GetSerializedType() => typeof(double);
        protected override double Interpolate(double previous, double current, float percent)
        {
            float a = (float)previous;
            float b = (float)current;
            return Mathf.Lerp(a, b, percent);
        }
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class SbyteSyncVar : SyncVar<sbyte>, ICustomSync
    {
        public object GetSerializedType() => typeof(sbyte);
        protected override sbyte Interpolate(sbyte previous, sbyte current, float percent) => (sbyte)Mathf.Lerp(previous, current, percent);
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class ByteSyncVar : SyncVar<byte>, ICustomSync
    {
        public object GetSerializedType() => typeof(byte);
        protected override byte Interpolate(byte previous, byte current, float percent) => (byte)Mathf.Lerp(previous, current, percent);
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class ShortSyncVar : SyncVar<short>, ICustomSync
    {
        public object GetSerializedType() => typeof(short);
        protected override short Interpolate(short previous, short current, float percent) => (short)Mathf.Lerp(previous, current, percent);
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class UShortSyncVar : SyncVar<ushort>, ICustomSync
    {
        public object GetSerializedType() => typeof(ushort);
        protected override ushort Interpolate(ushort previous, ushort current, float percent) => (ushort)Mathf.Lerp(previous, current, percent);
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class IntSyncVar : SyncVar<int>, ICustomSync
    {
        public object GetSerializedType() => typeof(int);
        protected override int Interpolate(int previous, int current, float percent) => (int)Mathf.Lerp(previous, current, percent);
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class UIntSyncVar : SyncVar<uint>, ICustomSync
    {
        public object GetSerializedType() => typeof(uint);
        protected override uint Interpolate(uint previous, uint current, float percent) => (uint)Mathf.Lerp(previous, current, percent);
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class LongSyncVar : SyncVar<long>, ICustomSync
    {
        public object GetSerializedType() => typeof(long);
        protected override long Interpolate(long previous, long current, float percent) => (long)Mathf.Lerp(previous, current, percent);
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class ULongSyncVar : SyncVar<ulong>, ICustomSync
    {
        public object GetSerializedType() => typeof(ulong);
        protected override ulong Interpolate(ulong previous, ulong current, float percent) => (ulong)Mathf.Lerp(previous, current, percent);
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class Vector2SyncVar : SyncVar<Vector2>, ICustomSync
    {
        public object GetSerializedType() => typeof(Vector2);
        protected override Vector2 Interpolate(Vector2 previous, Vector2 current, float percent) => Vector2.Lerp(previous, current, percent);
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class Vector3SyncVar : SyncVar<Vector3>, ICustomSync
    {
        public object GetSerializedType() => typeof(Vector3);
        protected override Vector3 Interpolate(Vector3 previous, Vector3 current, float percent) => Vector3.Lerp(previous, current, percent);
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class Vector4SyncVar : SyncVar<Vector4>, ICustomSync
    {
        public object GetSerializedType() => typeof(Vector4);
        protected override Vector4 Interpolate(Vector4 previous, Vector4 current, float percent) => Vector4.Lerp(previous, current, percent);
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class Vector2IntSyncVar : SyncVar<Vector2Int>, ICustomSync
    {
        public object GetSerializedType() => typeof(Vector2);
        protected override Vector2Int Interpolate(Vector2Int previous, Vector2Int current, float percent)
        {
            int x = (int)Mathf.Lerp(previous.x, current.x, percent);
            int y = (int)Mathf.Lerp(previous.y, current.y, percent);
            return new(x, y);
        }
    }
    /// <summary>
    /// Implements features specific for a typed SyncVar.
    /// </summary>
    [System.Serializable]
    public class Vector3IntSyncVar : SyncVar<Vector3Int>, ICustomSync
    {
        public object GetSerializedType() => typeof(Vector3Int);
        protected override Vector3Int Interpolate(Vector3Int previous, Vector3Int current, float percent)
        {
            int x = (int)Mathf.Lerp(previous.x, current.x, percent);
            int y = (int)Mathf.Lerp(previous.y, current.y, percent);
            int z = (int)Mathf.Lerp(previous.z, current.z, percent);
            return new(x, y, z);
        }
    }

}


﻿namespace FishNet.Object
{

    internal enum MissingObjectPacketLength : int
    {
        Reliable = -1,
        PurgeRemaiming = -2,
    }


}namespace FishNet.Object.Synchronizing
{
    /// <summary>
    /// Which clients may receive synchronization updates.
    /// </summary> //Remove on V5. Just rename file to ReadPermission.cs, do not remove.
    public enum ReadPermission : byte
    {
        /// <summary>
        /// All observers will receive updates.
        /// </summary>
        Observers = 0,
        /// <summary>
        /// Only owner will receive updates.
        /// </summary>
        OwnerOnly = 1,
        /// <summary>
        /// Send to all observers except owner.
        /// </summary>
        ExcludeOwner = 2,
    }
}
﻿using System;
using FishNet.CodeGenerating;
using FishNet.Managing;
using FishNet.Managing.Timing;
using FishNet.Serializing;
using FishNet.Transporting;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object.Synchronizing.Internal
{
    public class SyncBase
    {
        #region Public.
        /// <summary>
        /// True if this SyncBase has been initialized on its NetworkBehaviour.
        /// Being true does not mean that the NetworkBehaviour has been initialized on the network, but rather that this SyncBase has been configured with the basics to be networked.
        /// </summary>
        public bool IsInitialized { get; private set; }
        /// <summary>
        /// True if the object for which this SyncType is for has been initialized for the network.
        /// </summary>
        public bool IsNetworkInitialized => (IsInitialized && (NetworkBehaviour.IsServerStarted || NetworkBehaviour.IsClientStarted));
        /// <summary>
        /// True if a SyncObject, false if a SyncVar.
        /// </summary>
        public bool IsSyncObject { get; private set; }
        /// <summary>
        /// The settings for this SyncVar.
        /// </summary>
        [MakePublic]
        internal SyncTypeSettings Settings;
        /// <summary>
        /// How often updates may send.
        /// </summary>
        [MakePublic]
        internal float SendRate => Settings.SendRate;
        /// <summary>
        /// True if this SyncVar needs to send data.
        /// </summary>        
        public bool IsDirty { get; private set; }
        /// <summary>
        /// NetworkManager this uses.
        /// </summary>
        public NetworkManager NetworkManager = null;
        /// <summary>
        /// NetworkBehaviour this SyncVar belongs to.
        /// </summary>
        public NetworkBehaviour NetworkBehaviour = null;
        /// <summary>
        /// True if the server side has initialized this SyncType.
        /// </summary>
        public bool OnStartServerCalled { get; private set; }
        /// <summary>
        /// True if the client side has initialized this SyncType.
        /// </summary>
        public bool OnStartClientCalled { get; private set; }
        /// <summary>
        /// Next time this SyncType may send data.
        /// This is also the next time a client may send to the server when using client-authoritative SyncTypes.
        /// </summary>
        [MakePublic]
        internal uint NextSyncTick = 0;
        /// <summary>
        /// Index within the sync collection.
        /// </summary>
        public uint SyncIndex { get; protected set; } = 0;
        /// <summary>
        /// Channel to send on.
        /// </summary>
        internal Channel Channel => _currentChannel;

        /// <summary>
        /// Sets a new currentChannel.
        /// </summary>
        /// <param name="channel"></param>
        internal void SetCurrentChannel(Channel channel) => _currentChannel = channel;
        #endregion

        #region Private.
        /// <summary>
        /// Sync interval converted to ticks.
        /// </summary>
        private uint _timeToTicks;
        /// <summary>
        /// Channel to use for next write. To ensure eventual consistency this eventually changes to reliable when Settings are unreliable.
        /// </summary>
        private Channel _currentChannel;
        /// <summary>
        /// Last changerId read from sender.
        /// </summary>
        private ushort _lastReadChangeId = UNSET_CHANGE_ID;
        /// <summary>
        /// Last changeId that was sent to receivers.
        /// </summary>
        private ushort _lastWrittenChangeId = UNSET_CHANGE_ID;
        #endregion

        #region Consts.
        /// <summary>
        /// Value to use when readId is unset.
        /// </summary>
        private const ushort UNSET_CHANGE_ID = 0;
        /// <summary>
        /// Maximum value readId can be before resetting to the beginning.
        /// </summary>
        private const ushort MAXIMUM_CHANGE_ID = ushort.MaxValue;
        #endregion

        #region Constructors
        public SyncBase() : this(new()) { }

        public SyncBase(SyncTypeSettings settings)
        {
            Settings = settings;
        }
        #endregion

        /// <summary>
        /// Updates settings with new values.
        /// </summary>
        public void UpdateSettings(SyncTypeSettings settings)
        {
            Settings = settings;
            SetTimeToTicks();
        }

        /// <summary>
        /// Updates settings with new values.
        /// </summary>
        public void UpdatePermissions(WritePermission writePermissions, ReadPermission readPermissions)
        {
            UpdatePermissions(writePermissions);
            UpdatePermissions(readPermissions);
        }

        /// <summary>
        /// Updates settings with new values.
        /// </summary>
        public void UpdatePermissions(WritePermission writePermissions) => Settings.WritePermission = writePermissions;

        /// <summary>
        /// Updates settings with new values.
        /// </summary>
        public void UpdatePermissions(ReadPermission readPermissions) => Settings.ReadPermission = readPermissions;

        /// <summary>
        /// Updates settings with new values.
        /// </summary>
        public void UpdateSendRate(float sendRate)
        {
            Settings.SendRate = sendRate;
            SetTimeToTicks();
        }

        /// <summary>
        /// Updates settings with new values.
        /// </summary>
        public void UpdateSettings(Channel channel)
        {
            CheckChannel(ref channel);
            _currentChannel = channel;
        }

        /// <summary>
        /// Updates settings with new values.
        /// </summary>
        public void UpdateSettings(WritePermission writePermissions, ReadPermission readPermissions, float sendRate, Channel channel)
        {
            CheckChannel(ref channel);
            _currentChannel = channel;
            Settings = new(writePermissions, readPermissions, sendRate, channel);
            SetTimeToTicks();
        }

        /// <summary>
        /// Checks channel and corrects if not valid.
        /// </summary>
        /// <param name="c"></param>
        private void CheckChannel(ref Channel c)
        {
            if (c == Channel.Unreliable && IsSyncObject)
            {
                c = Channel.Reliable;
                string warning = $"Channel cannot be unreliable for SyncObjects. Channel has been changed to reliable.";
                NetworkManager.LogWarning(warning);
            }
        }

        /// <summary>
        /// Initializes this SyncBase before user Awake code.
        /// </summary>
        [MakePublic]
        internal void InitializeEarly(NetworkBehaviour nb, uint syncIndex, bool isSyncObject)
        {
            NetworkBehaviour = nb;
            SyncIndex = syncIndex;
            IsSyncObject = isSyncObject;

            NetworkBehaviour.RegisterSyncType(this, SyncIndex);
        }

        /// <summary>
        /// Called during InitializeLate in NetworkBehaviours to indicate user Awake code has executed.
        /// </summary>
        [MakePublic]
        internal void InitializeLate()
        {
            Initialized();
        }

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected virtual void Initialized()
        {
            IsInitialized = true;
        }

        /// <summary>
        /// PreInitializes this for use with the network.
        /// </summary>
        [MakePublic]
        protected internal void PreInitialize(NetworkManager networkManager, bool asServer)
        {
            NetworkManager = networkManager;

            if (Settings.IsDefault())
            {
                float sendRate = Mathf.Max(networkManager.ServerManager.GetSyncTypeRate(), (float)networkManager.TimeManager.TickDelta);
                Settings = new(sendRate);
            }

            SetTimeToTicks();
        }

        /// <summary>
        /// Sets ticks needed to pass for send rate.
        /// </summary>
        private void SetTimeToTicks()
        {
            if (NetworkManager == null)
                return;
            _timeToTicks = NetworkManager.TimeManager.TimeToTicks(Settings.SendRate, TickRounding.RoundUp);
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred for the NetworkBehaviour.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        [MakePublic]
        protected internal virtual void OnStartCallback(bool asServer)
        {
            if (asServer)
                OnStartServerCalled = true;
            else
                OnStartClientCalled = true;
        }

        /// <summary>
        /// Called before OnStopXXXX has occurred for the NetworkBehaviour.
        /// </summary>
        /// <param name="asServer">True if OnStopServer was called, false if OnStopClient.</param>
        [MakePublic]
        protected internal virtual void OnStopCallback(bool asServer)
        {
            if (asServer)
                OnStartServerCalled = false;
            else
                OnStartClientCalled = false;
        }

        /// <summary>
        /// True if can set values and send them over the network.
        /// </summary>
        /// <param name="log"></param>
        /// <returns></returns>
        protected bool CanNetworkSetValues(bool log = true)
        {
            /* If not registered then values can be set
             * since at this point the object is still being initialized
             * in awake so we want those values to be applied. */
            if (!IsInitialized)
                return true;
            /* If the network is not initialized yet then let
             * values be set. Values set here will not synchronize
             * to the network. We are assuming the user is setting
             * these values on client and server appropriately
             * since they are being applied prior to this object
             * being networked. */
            if (!IsNetworkInitialized)
                return true;
            //If server is active then values can be set no matter what.
            if (NetworkBehaviour.IsServerStarted)
                return true;
            /* If here then server is not active and additional
             * checks must be performed. */
            bool result = (Settings.WritePermission == WritePermission.ClientUnsynchronized) || (Settings.ReadPermission == ReadPermission.ExcludeOwner && NetworkBehaviour.IsOwner);
            if (!result && log)
                LogServerNotActiveWarning();

            return result;
        }

        /// <summary>
        /// Logs that the operation could not be completed because the server is not active.
        /// </summary>
        protected void LogServerNotActiveWarning()
        {
            if (NetworkManager != null)
                NetworkManager.LogWarning($"Cannot complete operation as server when server is not active. You can disable this warning by setting WritePermissions to {WritePermission.ClientUnsynchronized.ToString()}.");
        }

        /// <summary>
        /// Dirties this Sync and the NetworkBehaviour.
        /// </summary>
        /// <param name="sendRpc">True to send current dirtied values immediately as a RPC. When this occurs values will arrive in the order they are sent and interval is ignored.</param>
        protected bool Dirty() //bool sendRpc = false)
        {
            //if (sendRpc)
            //    NextSyncTick = 0;
            /* Reset channel even if already dirty.
             * This is because the value might have changed
             * which will reset the eventual consistency state. */
            _currentChannel = Settings.Channel;

            /* Once dirty don't undirty until it's
             * processed. This ensures that data
             * is flushed. */
            bool canDirty = NetworkBehaviour.DirtySyncType();
            IsDirty |= canDirty;

            return canDirty;
        }

        /// <summary>
        /// Returns if callbacks can be invoked with asServer ture.
        /// This is typically used when the value is changing through user code, causing supplier to be unknown.
        /// </summary>
        /// <returns></returns>
        protected bool CanInvokeCallbackAsServer() => (!IsNetworkInitialized || NetworkBehaviour.IsServerStarted);

        /// <summary>
        /// Reads a change Id and returns true if the change is new.
        /// </summary>
        /// <remarks>This method is currently under evaluation and may change at any time.</remarks>
        protected virtual bool ReadChangeId(Reader reader)
        {
            if (NetworkManager == null)
            {
                NetworkManager.LogWarning($"NetworkManager is unexpectedly null during a SyncType read.");
                return false;
            }

            bool rolledOver = reader.ReadBoolean();
            ushort id = reader.ReadUInt16();

            //Only check lastReadId if its not unset.
            if (_lastReadChangeId != UNSET_CHANGE_ID)
            {
                /* If not rolledOver then Id should always be larger
                 * than the last read. If it's not then the data is
                 * old.
                 *
                 * If Id is smaller then rolledOver should be normal,
                 * as rolling over means to restart the Id from the lowest
                 * value. */
                if (rolledOver)
                {
                    if (id >= _lastReadChangeId)
                        return false;
                }
                else
                {
                    if (id <= _lastReadChangeId)
                        return false;
                }
            }

            _lastReadChangeId = id;
            return true;
        }

        /// <summary>
        /// Writes the readId for a change.
        /// </summary>
        /// <remarks>This method is currently under evaluation and may change at any time.</remarks>
        protected virtual void WriteChangeId(PooledWriter writer)
        {
            bool rollOver;
            if (_lastWrittenChangeId >= MAXIMUM_CHANGE_ID)
            {
                rollOver = true;
                _lastWrittenChangeId = UNSET_CHANGE_ID;
            }
            else
            {
                rollOver = false;
            }

            _lastWrittenChangeId++;
            writer.WriteBoolean(rollOver);
            writer.WriteUInt16(_lastWrittenChangeId);
        }

#if !FISHNET_STABLE_SYNCTYPES        
        /// <summary>
        /// Returns true if values are being read as clientHost.
        /// </summary>
        /// <param name="asServer">True if reading as server.</param>
        /// <remarks>This method is currently under evaluation and may change at any time.</remarks>
        protected bool IsReadAsClientHost(bool asServer) => (!asServer && NetworkManager.IsServerStarted);

        /// <summary>
        /// Returns true if values are being read as clientHost.
        /// </summary>
        /// <param name="asServer">True if reading as server.</param>
        /// <remarks>This method is currently under evaluation and may change at any time.</remarks>
        protected bool CanReset(bool asServer)
        {
            bool clientStarted = (IsNetworkInitialized && NetworkManager.IsClientStarted);
            return (asServer && !clientStarted) || (!asServer && NetworkBehaviour.IsDeinitializing);
        }
#else
        /// <summary>
        /// Returns true if values are being read as clientHost.
        /// </summary>
        /// <param name="asServer">True if reading as server.</param>
        /// <remarks>This method is currently under evaluation and may change at any time.</remarks>
        protected bool IsReadAsClientHost(bool asServer) => (!asServer && (NetworkManager != null && NetworkManager.IsServerStarted));
#endif

        /// <summary>
        /// Outputs values which may be helpful on how to process a read operation.
        /// </summary>
        /// <param name="newChangeId">True if the changeId read is not old data.</param>
        /// <param name="asClientHost">True if being read as clientHost.</param>
        /// <param name="canModifyValues">True if can modify values from the read, typically when asServer or not asServer and not clientHost.</param>
        /// <remarks>This method is currently under evaluation and may change at any time.</remarks>
        protected void SetReadArguments(PooledReader reader, bool asServer, out bool newChangeId, out bool asClientHost, out bool canModifyValues)
        {
            newChangeId = ReadChangeId(reader);
            asClientHost = IsReadAsClientHost(asServer);
            canModifyValues = (newChangeId && !asClientHost);
        }

        /// <summary>
        /// Sets IsDirty to false.
        /// </summary>
        internal void ResetDirty()
        {
            //If not a sync object and using unreliable channel.
            if (!IsSyncObject && Settings.Channel == Channel.Unreliable)
            {
                //Check if dirty can be unset or if another tick must be run using reliable.
                if (_currentChannel == Channel.Unreliable)
                    _currentChannel = Channel.Reliable;
                //Already sent reliable, can undirty. Channel will reset next time this dirties.
                else
                    IsDirty = false;
            }
            //If syncObject or using reliable unset dirty.
            else
            {
                IsDirty = false;
            }
        }

        /// <summary>
        /// True if dirty and enough time has passed to write changes.
        /// </summary>
        internal bool IsNextSyncTimeMet(uint tick) => (IsDirty && tick >= NextSyncTick);

        [Obsolete("Use IsNextSyncTimeMet.")] //Remove on V5
        internal bool SyncTimeMet(uint tick) => IsNextSyncTimeMet(tick);

        /// <summary>
        /// Writes current value.
        /// </summary>
        /// <param name="resetSyncTick">True to set the next time data may sync.</param>
        [MakePublic]
        protected internal virtual void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            WriteHeader(writer, resetSyncTick);
        }

        /// <summary>
        /// Writes the header for this SyncType.
        /// </summary>
        protected virtual void WriteHeader(PooledWriter writer, bool resetSyncTick = true)
        {
            if (resetSyncTick)
                NextSyncTick = NetworkManager.TimeManager.LocalTick + _timeToTicks;

            writer.WriteUInt8Unpacked((byte)SyncIndex);
            WriteChangeId(writer);
        }

        /// <summary>
        /// Indicates that a full write has occurred.
        /// This is called from WriteFull, or can be called manually.
        /// </summary>
        [Obsolete("This method no longer functions. You may remove it from your code.")] //Remove on V5.
        protected void FullWritten() { }

        /// <summary>
        /// Writes all values for the SyncType.
        /// </summary>
        [MakePublic]
        protected internal virtual void WriteFull(PooledWriter writer) { }

        /// <summary>
        /// Sets current value as server or client through deserialization.
        /// </summary>
        [MakePublic]
        protected internal virtual void Read(PooledReader reader, bool asServer) { }

        /// <summary>
        /// Resets initialized values for server and client.
        /// </summary>
        protected internal virtual void ResetState()
        {
            ResetState(true);
            ResetState(false);
        }

        /// <summary>
        /// Resets initialized values for server or client.
        /// </summary>
        [MakePublic]
        protected internal virtual void ResetState(bool asServer)
        {
            if (asServer)
            {
                NextSyncTick = 0;
                SetCurrentChannel(Settings.Channel);
                IsDirty = false;
            }

            /* This only needs to be reset for clients, since
             * it only applies to clients. But if the server is resetting
             * that means the object is deinitializing, and won't have any
             * client observers anyway. Because of this it's safe to reset
             * with asServer true, or false.
             *
             * This change is made to resolve a bug where asServer:false
             * sometimes does not invoke when stopping clientHost while not
             * also stopping play mode. */
            _lastReadChangeId = UNSET_CHANGE_ID;
        }
    }
}﻿#if FISHNET_STABLE_SYNCTYPES
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using GameKit.Dependencies.Utilities;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object.Synchronizing
{
    [System.Serializable]
    public class SyncDictionary<TKey, TValue> : SyncBase, IDictionary<TKey, TValue>, IReadOnlyDictionary<TKey, TValue>
    {
        #region Types.
        /// <summary>
        /// Information needed to invoke a callback.
        /// </summary>
        private struct CachedOnChange
        {
            internal readonly SyncDictionaryOperation Operation;
            internal readonly TKey Key;
            internal readonly TValue Value;

            public CachedOnChange(SyncDictionaryOperation operation, TKey key, TValue value)
            {
                Operation = operation;
                Key = key;
                Value = value;
            }
        }

        /// <summary>
        /// Information about how the collection has changed.
        /// </summary>
        private struct ChangeData
        {
            internal readonly SyncDictionaryOperation Operation;
            internal readonly TKey Key;
            internal readonly TValue Value;

            public ChangeData(SyncDictionaryOperation operation, TKey key, TValue value)
            {
                this.Operation = operation;
                this.Key = key;
                this.Value = value;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Implementation from Dictionary<TKey,TValue>. Not used.
        /// </summary>
        [APIExclude]
        public bool IsReadOnly => false;

        /// <summary>
        /// Delegate signature for when SyncDictionary changes.
        /// </summary>
        /// <param name="op">Operation being completed, such as Add, Set, Remove.</param>
        /// <param name="key">Key being modified.</param>
        /// <param name="value">Value of operation.</param>
        /// <param name="asServer">True if callback is on the server side. False is on the client side.</param>
        [APIExclude]
        public delegate void SyncDictionaryChanged(SyncDictionaryOperation op, TKey key, TValue value, bool asServer);

        /// <summary>
        /// Called when the SyncDictionary changes.
        /// </summary>
        public event SyncDictionaryChanged OnChange;
        /// <summary>
        /// Collection of objects.
        /// </summary>
        public Dictionary<TKey, TValue> Collection;
        /// <summary>
        /// Copy of objects on client portion when acting as a host.
        /// </summary>
        [HideInInspector]
        public Dictionary<TKey, TValue> ClientHostCollection;
        /// <summary>
        /// Number of objects in the collection.
        /// </summary>
        public int Count => Collection.Count;
        /// <summary>
        /// Keys within the collection.
        /// </summary>
        public ICollection<TKey> Keys => Collection.Keys;
        [APIExclude]
        IEnumerable<TKey> IReadOnlyDictionary<TKey, TValue>.Keys => Collection.Keys;
        /// <summary>
        /// Values within the collection.
        /// </summary>
        public ICollection<TValue> Values => Collection.Values;
        [APIExclude]
        IEnumerable<TValue> IReadOnlyDictionary<TKey, TValue>.Values => Collection.Values;
        #endregion

        #region Private.
        /// <summary>
        /// Initial values for the dictionary.
        /// </summary>
        private Dictionary<TKey, TValue> _initialValues = new();
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private List<ChangeData> _changed = new();
        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private List<CachedOnChange> _serverOnChanges = new();
        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private List<CachedOnChange> _clientOnChanges = new();
        /// <summary>
        /// True if values have changed since initialization.
        /// The only reasonable way to reset this during a Reset call is by duplicating the original list and setting all values to it on reset.
        /// </summary>
        private bool _valuesChanged;
        /// <summary>
        /// True to send all values in the next WriteDelta.
        /// </summary>
        private bool _sendAll;
        #endregion

        #region Constructors.
        public SyncDictionary(SyncTypeSettings settings = new()) : this(CollectionCaches<TKey, TValue>.RetrieveDictionary(), settings) { }

        public SyncDictionary(Dictionary<TKey, TValue> collection, SyncTypeSettings settings = new()) : base(settings)
        {
            Collection = (collection == null) ? CollectionCaches<TKey, TValue>.RetrieveDictionary() : collection;
            ClientHostCollection = CollectionCaches<TKey, TValue>.RetrieveDictionary();

            _initialValues = CollectionCaches<TKey, TValue>.RetrieveDictionary();
            _changed = CollectionCaches<ChangeData>.RetrieveList();
            _serverOnChanges = CollectionCaches<CachedOnChange>.RetrieveList();
            _clientOnChanges = CollectionCaches<CachedOnChange>.RetrieveList();
            //Add to clienthostcollection.
            foreach (KeyValuePair<TKey, TValue> item in collection)
                ClientHostCollection[item.Key] = item.Value;
        }
        #endregion

        #region Deconstructor.
        ~SyncDictionary()
        {
            CollectionCaches<TKey, TValue>.StoreAndDefault(ref Collection);
            CollectionCaches<TKey, TValue>.StoreAndDefault(ref ClientHostCollection);
            CollectionCaches<TKey, TValue>.StoreAndDefault(ref _initialValues);
            CollectionCaches<ChangeData>.StoreAndDefault(ref _changed);
            CollectionCaches<CachedOnChange>.StoreAndDefault(ref _serverOnChanges);
            CollectionCaches<CachedOnChange>.StoreAndDefault(ref _clientOnChanges);
        }
        #endregion

        /// <summary>
        /// Gets the collection being used within this SyncList.
        /// </summary>
        /// <param name="asServer">True if returning the server value, false if client value. The values will only differ when running as host. While asServer is true the most current values on server will be returned, and while false the latest values received by client will be returned.</param>
        /// <returns>The used collection.</returns>
        public Dictionary<TKey, TValue> GetCollection(bool asServer)
        {
            bool asClientAndHost = (!asServer && base.NetworkManager.IsServerStarted);
            IDictionary<TKey, TValue> collection = (asClientAndHost) ? ClientHostCollection : Collection;
            return (collection as Dictionary<TKey, TValue>);
        }

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Initialized()
        {
            base.Initialized();

            //Initialize collections if needed. OdinInspector can cause them to become deinitialized.
#if ODIN_INSPECTOR
            if (_initialValues == null) _initialValues = new();
            if (_changed == null) _changed = new();
            if (_serverOnChanges == null) _serverOnChanges = new();
            if (_clientOnChanges == null) _clientOnChanges = new();
#endif

            foreach (KeyValuePair<TKey, TValue> item in Collection)
                _initialValues[item.Key] = item.Value;
        }

        /// <summary>
        /// Adds an operation and invokes callback locally.
        /// Internal use.
        /// May be used for custom SyncObjects.
        /// </summary>
        /// <param name="operation"></param>
        /// <param name="key"></param>
        /// <param name="value"></param>
        [APIExclude]
        private void AddOperation(SyncDictionaryOperation operation, TKey key, TValue value)
        {
            if (!base.IsInitialized)
                return;

            /* asServer might be true if the client is setting the value
             * through user code. Typically synctypes can only be set
             * by the server, that's why it is assumed asServer via user code.
             * However, when excluding owner for the synctype the client should
             * have permission to update the value locally for use with
             * prediction. */
            bool asServerInvoke = (!base.IsNetworkInitialized || base.NetworkBehaviour.IsServerStarted);

            if (asServerInvoke)
            {
                _valuesChanged = true;
                if (base.Dirty())
                {
                    ChangeData change = new(operation, key, value);
                    _changed.Add(change);
                }
            }

            InvokeOnChange(operation, key, value, asServerInvoke);
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<CachedOnChange> collection = (asServer) ? _serverOnChanges : _clientOnChanges;

            if (OnChange != null)
            {
                foreach (CachedOnChange item in collection)
                    OnChange.Invoke(item.Operation, item.Key, item.Value, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Writes all changed values.
        /// Internal use.
        /// May be used for custom SyncObjects.
        /// </summary>
        /// <param name="writer"></param>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        [APIExclude]
        protected internal override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            //If sending all then clear changed and write full.
            if (_sendAll)
            {
                _sendAll = false;
                _changed.Clear();
                WriteFull(writer);
            }
            else
            {
                base.WriteDelta(writer, resetSyncTick);

                //False for not full write.
                writer.WriteBoolean(false);
                writer.WriteInt32(_changed.Count);

                for (int i = 0; i < _changed.Count; i++)
                {
                    ChangeData change = _changed[i];
                    writer.WriteUInt8Unpacked((byte)change.Operation);

                    //Clear does not need to write anymore data so it is not included in checks.
                    if (change.Operation == SyncDictionaryOperation.Add || change.Operation == SyncDictionaryOperation.Set)
                    {
                        writer.Write(change.Key);
                        writer.Write(change.Value);
                    }
                    else if (change.Operation == SyncDictionaryOperation.Remove)
                    {
                        writer.Write(change.Key);
                    }
                }

                _changed.Clear();
            }
        }

        /// <summary>
        /// Writers all values if not initial values.
        /// Internal use.
        /// May be used for custom SyncObjects.
        /// </summary>
        /// <param name="writer"></param>
        [APIExclude]
        protected internal override void WriteFull(PooledWriter writer)
        {
            if (!_valuesChanged)
                return;

            base.WriteHeader(writer, false);
            //True for full write.
            writer.WriteBoolean(true);
            writer.WriteInt32(Collection.Count);
            foreach (KeyValuePair<TKey, TValue> item in Collection)
            {
                writer.WriteUInt8Unpacked((byte)SyncDictionaryOperation.Add);
                writer.Write(item.Key);
                writer.Write(item.Value);
            }
        }

        /// <summary>
        /// Reads and sets the current values for server or client.
        /// </summary>
        [APIExclude]
        protected internal override void Read(PooledReader reader, bool asServer)
        {
            base.SetReadArguments(reader, asServer, out bool newChangeId, out bool asClientHost, out bool canModifyValues);

            //True to warn if this object was deinitialized on the server.
            bool deinitialized = (asClientHost && !base.OnStartServerCalled);
            if (deinitialized)
                base.NetworkManager.LogWarning($"SyncType {GetType().Name} received a Read but was deinitialized on the server. Client callback values may be incorrect. This is a ClientHost limitation.");

            IDictionary<TKey, TValue> collection = (asClientHost) ? ClientHostCollection : Collection;

            //Clear collection since it's a full write.
            bool fullWrite = reader.ReadBoolean();
            if (fullWrite)
                collection.Clear();

            int changes = reader.ReadInt32();
            for (int i = 0; i < changes; i++)
            {
                SyncDictionaryOperation operation = (SyncDictionaryOperation)reader.ReadUInt8Unpacked();
                TKey key = default;
                TValue value = default;

                /* Add, Set.
                 * Use the Set code for add and set,
                 * especially so collection doesn't throw
                 * if entry has already been added. */
                if (operation == SyncDictionaryOperation.Add || operation == SyncDictionaryOperation.Set)
                {
                    key = reader.Read<TKey>();
                    value = reader.Read<TValue>();

                    if (!deinitialized)
                        collection[key] = value;
                }
                //Clear.
                else if (operation == SyncDictionaryOperation.Clear)
                {
                    if (!deinitialized)
                        collection.Clear();
                }
                //Remove.
                else if (operation == SyncDictionaryOperation.Remove)
                {
                    key = reader.Read<TKey>();

                    if (!deinitialized)
                        collection.Remove(key);
                }

                if (newChangeId)
                    InvokeOnChange(operation, key, value, false);
            }

            //If changes were made invoke complete after all have been read.
            if (newChangeId && changes > 0)
                InvokeOnChange(SyncDictionaryOperation.Complete, default, default, false);
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncDictionaryOperation operation, TKey key, TValue value, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, key, value, asServer);
                else
                    _serverOnChanges.Add(new(operation, key, value));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, key, value, asServer);
                else
                    _clientOnChanges.Add(new(operation, key, value));
            }
        }

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        [APIExclude]
        protected internal override void ResetState(bool asServer)
        {
            base.ResetState(asServer);
            _sendAll = false;
            _changed.Clear();
            Collection.Clear();
            ClientHostCollection.Clear();
            _valuesChanged = false;

            foreach (KeyValuePair<TKey, TValue> item in _initialValues)
            {
                Collection[item.Key] = item.Value;
                ClientHostCollection[item.Key] = item.Value;
            }
        }

        /// <summary>
        /// Adds item.
        /// </summary>
        /// <param name="item">Item to add.</param>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Adds key and value.
        /// </summary>
        /// <param name="key">Key to add.</param>
        /// <param name="value">Value for key.</param>
        public void Add(TKey key, TValue value)
        {
            Add(key, value, true);
        }

        private void Add(TKey key, TValue value, bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            Collection.Add(key, value);
            if (asServer)
                AddOperation(SyncDictionaryOperation.Add, key, value);
        }

        /// <summary>
        /// Clears all values.
        /// </summary>
        public void Clear()
        {
            Clear(true);
        }

        private void Clear(bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            Collection.Clear();
            if (asServer)
                AddOperation(SyncDictionaryOperation.Clear, default, default);
        }

        /// <summary>
        /// Returns if key exist.
        /// </summary>
        /// <param name="key">Key to use.</param>
        /// <returns>True if found.</returns>
        public bool ContainsKey(TKey key)
        {
            return Collection.ContainsKey(key);
        }

        /// <summary>
        /// Returns if item exist.
        /// </summary>
        /// <param name="item">Item to use.</param>
        /// <returns>True if found.</returns>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            return TryGetValue(item.Key, out TValue value) && EqualityComparer<TValue>.Default.Equals(value, item.Value);
        }

        /// <summary>
        /// Copies collection to an array.
        /// </summary>
        /// <param name="array">Array to copy to.</param>
        /// <param name="offset">Offset of array data is copied to.</param>
        public void CopyTo([NotNull] KeyValuePair<TKey, TValue>[] array, int offset)
        {
            if (offset <= -1 || offset >= array.Length)
            {
                base.NetworkManager.LogError($"Index is out of range.");
                return;
            }

            int remaining = array.Length - offset;
            if (remaining < Count)
            {
                base.NetworkManager.LogError($"Array is not large enough to copy data. Array is of length {array.Length}, index is {offset}, and number of values to be copied is {Count.ToString()}.");
                return;
            }

            int i = offset;
            foreach (KeyValuePair<TKey, TValue> item in Collection)
            {
                array[i] = item;
                i++;
            }
        }

        /// <summary>
        /// Removes a key.
        /// </summary>
        /// <param name="key">Key to remove.</param>
        /// <returns>True if removed.</returns>
        public bool Remove(TKey key)
        {
            if (!base.CanNetworkSetValues(true))
                return false;

            if (Collection.Remove(key))
            {
                AddOperation(SyncDictionaryOperation.Remove, key, default);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Removes an item.
        /// </summary>
        /// <param name="item">Item to remove.</param>
        /// <returns>True if removed.</returns>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return Remove(item.Key);
        }

        /// <summary>
        /// Tries to get value from key.
        /// </summary>
        /// <param name="key">Key to use.</param>
        /// <param name="value">Variable to output to.</param>
        /// <returns>True if able to output value.</returns>
        public bool TryGetValue(TKey key, out TValue value)
        {
            return Collection.TryGetValueIL2CPP(key, out value);
        }

        /// <summary>
        /// Gets or sets value for a key.
        /// </summary>
        /// <param name="key">Key to use.</param>
        /// <returns>Value when using as Get.</returns>
        public TValue this[TKey key]
        {
            get => Collection[key];
            set
            {
                if (!base.CanNetworkSetValues(true))
                    return;

                Collection[key] = value;
                AddOperation(SyncDictionaryOperation.Set, key, value);
            }
        }

        /// <summary>
        /// Dirties the entire collection forcing a full send.
        /// </summary>
        public void DirtyAll()
        {
            if (!base.IsInitialized)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            if (base.Dirty())
                _sendAll = true;
        }

        /// <summary>
        /// Dirties an entry by key.
        /// </summary>
        /// <param name="key">Key to dirty.</param>
        public void Dirty(TKey key)
        {
            if (!base.IsInitialized)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            if (Collection.TryGetValueIL2CPP(key, out TValue value))
                AddOperation(SyncDictionaryOperation.Set, key, value);
        }

        /// <summary>
        /// Dirties an entry by value.
        /// This operation can be very expensive, will cause allocations, and may fail if your value cannot be compared.
        /// </summary>
        /// <param name="value">Value to dirty.</param>
        /// <returns>True if value was found and marked dirty.</returns>
        public bool Dirty(TValue value, EqualityComparer<TValue> comparer = null)
        {
            if (!base.IsInitialized)
                return false;
            if (!base.CanNetworkSetValues(true))
                return false;

            if (comparer == null)
                comparer = EqualityComparer<TValue>.Default;

            foreach (KeyValuePair<TKey, TValue> item in Collection)
            {
                if (comparer.Equals(item.Value, value))
                {
                    AddOperation(SyncDictionaryOperation.Set, item.Key, value);
                    return true;
                }
            }

            //Not found.
            return false;
        }

        /// <summary>
        /// Gets the IEnumerator for the collection.
        /// </summary>
        /// <returns></returns>
        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() => Collection.GetEnumerator();

        /// <summary>
        /// Gets the IEnumerator for the collection.
        /// </summary>
        /// <returns></returns>
        IEnumerator IEnumerable.GetEnumerator() => Collection.GetEnumerator();
    }
}
#endif﻿
using FishNet.Documenting;

namespace FishNet.Object.Synchronizing
{
    [APIExclude]
    public enum SyncDictionaryOperation : byte
    {
        /// <summary>
        /// A key and value have been added to the collection.
        /// </summary>
        Add,
        /// <summary>
        /// Collection has been cleared.
        /// </summary>
        Clear,
        /// <summary>
        /// A key was removed from the collection.
        /// </summary>
        Remove,
        /// <summary>
        /// A value has been set for a key in the collection.
        /// </summary>
        Set,
        /// <summary>
        /// All operations for the tick have been processed.
        /// </summary>
        Complete
    }

}
﻿#if FISHNET_STABLE_SYNCTYPES
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using GameKit.Dependencies.Utilities;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object.Synchronizing
{
    [System.Serializable]
    public class SyncHashSet<T> : SyncBase, ISet<T>
    {
        #region Types.
        /// <summary>
        /// Information needed to invoke a callback.
        /// </summary>
        private struct CachedOnChange
        {
            internal readonly SyncHashSetOperation Operation;
            internal readonly T Item;

            public CachedOnChange(SyncHashSetOperation operation, T item)
            {
                Operation = operation;
                Item = item;
            }
        }

        /// <summary>
        /// Information about how the collection has changed.
        /// </summary>
        private struct ChangeData
        {
            internal readonly SyncHashSetOperation Operation;
            internal readonly T Item;

            public ChangeData(SyncHashSetOperation operation, T item)
            {
                Operation = operation;

                Item = item;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Implementation from List<T>. Not used.
        /// </summary>
        [APIExclude]
        public bool IsReadOnly => false;

        /// <summary>
        /// Delegate signature for when SyncList changes.
        /// </summary>
        /// <param name="op">Type of change.</param>
        /// <param name="item">Item which was modified.</param>
        /// <param name="asServer">True if callback is occuring on the server.</param>
        [APIExclude]
        public delegate void SyncHashSetChanged(SyncHashSetOperation op, T item, bool asServer);

        /// <summary>
        /// Called when the SyncList changes.
        /// </summary>
        public event SyncHashSetChanged OnChange;
        /// <summary>
        /// Collection of objects.
        /// </summary>
        public HashSet<T> Collection;
        /// <summary>
        /// Copy of objects on client portion when acting as a host.
        /// </summary>
        [HideInInspector]
        public HashSet<T> ClientHostCollection;
        /// <summary>
        /// Number of objects in the collection.
        /// </summary>
        public int Count => Collection.Count;
        #endregion

        #region Private.
        /// <summary>
        /// ListCache for comparing.
        /// </summary>
        private static List<T> _cache = new();
        /// <summary>
        /// Values upon initialization.
        /// </summary>
        private HashSet<T> _initialValues;
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private List<ChangeData> _changed;
        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private List<CachedOnChange> _serverOnChanges;
        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private List<CachedOnChange> _clientOnChanges;
        /// <summary>
        /// Comparer to see if entries change when calling public methods.
        /// //Not used right now.
        /// </summary>
        private readonly IEqualityComparer<T> _comparer;
        /// <summary>
        /// True if values have changed since initialization.
        /// The only reasonable way to reset this during a Reset call is by duplicating the original list and setting all values to it on reset.
        /// </summary>
        private bool _valuesChanged;
        /// <summary>
        /// True to send all values in the next WriteDelta.
        /// </summary>
        private bool _sendAll;
        #endregion

        #region Constructors.
        public SyncHashSet(SyncTypeSettings settings = new()) : this(CollectionCaches<T>.RetrieveHashSet(), EqualityComparer<T>.Default, settings) { }
        public SyncHashSet(IEqualityComparer<T> comparer, SyncTypeSettings settings = new()) : this(CollectionCaches<T>.RetrieveHashSet(), (comparer == null) ? EqualityComparer<T>.Default : comparer, settings) { }

        public SyncHashSet(HashSet<T> collection, IEqualityComparer<T> comparer = null, SyncTypeSettings settings = new()) : base(settings)
        {
            _comparer = (comparer == null) ? EqualityComparer<T>.Default : comparer;
            Collection = (collection == null) ? CollectionCaches<T>.RetrieveHashSet() : collection;
            ClientHostCollection = CollectionCaches<T>.RetrieveHashSet();

            _initialValues = CollectionCaches<T>.RetrieveHashSet();
            _changed = CollectionCaches<ChangeData>.RetrieveList();
            _serverOnChanges = CollectionCaches<CachedOnChange>.RetrieveList();
            _clientOnChanges = CollectionCaches<CachedOnChange>.RetrieveList();

            //Add each in collection to clienthostcollection.
            foreach (T item in collection)
                ClientHostCollection.Add(item);
        }
        #endregion

        #region Deconstructor.
        ~SyncHashSet()
        {
            CollectionCaches<T>.StoreAndDefault(ref Collection);
            CollectionCaches<T>.StoreAndDefault(ref ClientHostCollection);
            CollectionCaches<T>.StoreAndDefault(ref _initialValues);
            CollectionCaches<ChangeData>.StoreAndDefault(ref _changed);
            CollectionCaches<CachedOnChange>.StoreAndDefault(ref _serverOnChanges);
            CollectionCaches<CachedOnChange>.StoreAndDefault(ref _clientOnChanges);
        }
        #endregion

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Initialized()
        {
            base.Initialized();

            //Initialize collections if needed. OdinInspector can cause them to become deinitialized.
#if ODIN_INSPECTOR
            if (_initialValues == null) _initialValues = new();
            if (_changed == null) _changed = new();
            if (_serverOnChanges == null) _serverOnChanges = new();
            if (_clientOnChanges == null) _clientOnChanges = new();
#endif
            foreach (T item in Collection)
                _initialValues.Add(item);
        }

        /// <summary>
        /// Gets the collection being used within this SyncList.
        /// </summary>
        /// <returns></returns>
        public HashSet<T> GetCollection(bool asServer)
        {
            bool asClientAndHost = (!asServer && base.NetworkManager.IsServerStarted);
            ISet<T> collection = (asClientAndHost) ? ClientHostCollection : Collection;
            return (collection as HashSet<T>);
        }

        /// <summary>
        /// Adds an operation and invokes locally.
        /// </summary>
        private void AddOperation(SyncHashSetOperation operation, T item)
        {
            if (!base.IsInitialized)
                return;

            bool asServerInvoke = (!base.IsNetworkInitialized || base.NetworkBehaviour.IsServerStarted);

            if (asServerInvoke)
            {
                _valuesChanged = true;
                if (base.Dirty())
                {
                    ChangeData change = new(operation, item);
                    _changed.Add(change);
                }
            }

            InvokeOnChange(operation, item, asServerInvoke);
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<CachedOnChange> collection = (asServer) ? _serverOnChanges : _clientOnChanges;
            if (OnChange != null)
            {
                foreach (CachedOnChange item in collection)
                    OnChange.Invoke(item.Operation, item.Item, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Writes all changed values.
        /// </summary>
        /// <param name="writer"></param>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        protected internal override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            //If sending all then clear changed and write full.
            if (_sendAll)
            {
                _sendAll = false;
                _changed.Clear();
                WriteFull(writer);
            }
            else
            {
                base.WriteDelta(writer, resetSyncTick);

                //False for not full write.
                writer.WriteBoolean(false);
                writer.WriteInt32(_changed.Count);

                for (int i = 0; i < _changed.Count; i++)
                {
                    ChangeData change = _changed[i];
                    writer.WriteUInt8Unpacked((byte)change.Operation);

                    //Clear does not need to write anymore data so it is not included in checks.
                    if (change.Operation == SyncHashSetOperation.Add || change.Operation == SyncHashSetOperation.Remove || change.Operation == SyncHashSetOperation.Update)
                    {
                        writer.Write(change.Item);
                    }
                }

                _changed.Clear();
            }
        }

        /// <summary>
        /// Writes all values if not initial values.
        /// </summary>
        /// <param name="writer"></param>
        protected internal override void WriteFull(PooledWriter writer)
        {
            if (!_valuesChanged)
                return;

            base.WriteHeader(writer, false);
            //True for full write.
            writer.WriteBoolean(true);
            int count = Collection.Count;
            writer.WriteInt32(count);
            foreach (T item in Collection)
            {
                writer.WriteUInt8Unpacked((byte)SyncHashSetOperation.Add);
                writer.Write(item);
            }
        }

        /// <summary>
        /// Reads and sets the current values for server or client.
        /// </summary>
        [APIExclude]
        protected internal override void Read(PooledReader reader, bool asServer)
        {
            base.SetReadArguments(reader, asServer, out bool newChangeId, out bool asClientHost, out bool canModifyValues);

            //True to warn if this object was deinitialized on the server.
            bool deinitialized = (asClientHost && !base.OnStartServerCalled);
            if (deinitialized)
                base.NetworkManager.LogWarning($"SyncType {GetType().Name} received a Read but was deinitialized on the server. Client callback values may be incorrect. This is a ClientHost limitation.");

            ISet<T> collection = (asClientHost) ? ClientHostCollection : Collection;

            //Clear collection since it's a full write.
            bool fullWrite = reader.ReadBoolean();
            if (fullWrite)
                collection.Clear();

            int changes = reader.ReadInt32();
            for (int i = 0; i < changes; i++)
            {
                SyncHashSetOperation operation = (SyncHashSetOperation)reader.ReadUInt8Unpacked();
                T next = default;

                //Add.
                if (operation == SyncHashSetOperation.Add)
                {
                    next = reader.Read<T>();
                    if (!deinitialized)
                        collection.Add(next);
                }
                //Clear.
                else if (operation == SyncHashSetOperation.Clear)
                {
                    if (!deinitialized)
                        collection.Clear();
                }
                //Remove.
                else if (operation == SyncHashSetOperation.Remove)
                {
                    next = reader.Read<T>();
                    if (!deinitialized)
                        collection.Remove(next);
                }
                //Updated.
                else if (operation == SyncHashSetOperation.Update)
                {
                    next = reader.Read<T>();
                    if (!deinitialized)
                    {
                        collection.Remove(next);
                        collection.Add(next);
                    }
                }

                if (newChangeId)
                    InvokeOnChange(operation, next, false);
            }

            //If changes were made invoke complete after all have been read.
            if (newChangeId && changes > 0)
                InvokeOnChange(SyncHashSetOperation.Complete, default, false);
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncHashSetOperation operation, T item, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, item, asServer);
                else
                    _serverOnChanges.Add(new(operation, item));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, item, asServer);
                else
                    _clientOnChanges.Add(new(operation, item));
            }
        }

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        protected internal override void ResetState(bool asServer)
        {
            base.ResetState(asServer);
            _sendAll = false;
            _changed.Clear();
            Collection.Clear();
            ClientHostCollection.Clear();

            foreach (T item in _initialValues)
            {
                Collection.Add(item);
                ClientHostCollection.Add(item);
            }
        }

        /// <summary>
        /// Adds value.
        /// </summary>
        /// <param name="item"></param>
        public bool Add(T item)
        {
            return Add(item, true);
        }

        private bool Add(T item, bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return false;

            bool result = Collection.Add(item);
            //Only process if remove was successful.
            if (result && asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.Add(item);
                AddOperation(SyncHashSetOperation.Add, item);
            }

            return result;
        }

        /// <summary>
        /// Adds a range of values.
        /// </summary>
        /// <param name="range"></param>
        public void AddRange(IEnumerable<T> range)
        {
            foreach (T entry in range)
                Add(entry, true);
        }

        /// <summary>
        /// Clears all values.
        /// </summary>
        public void Clear()
        {
            Clear(true);
        }

        private void Clear(bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            Collection.Clear();
            if (asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.Clear();
                AddOperation(SyncHashSetOperation.Clear, default);
            }
        }

        /// <summary>
        /// Returns if value exist.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Contains(T item)
        {
            return Collection.Contains(item);
        }

        /// <summary>
        /// Removes a value.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Remove(T item)
        {
            return Remove(item, true);
        }

        private bool Remove(T item, bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return false;

            bool result = Collection.Remove(item);
            //Only process if remove was successful.
            if (result && asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.Remove(item);
                AddOperation(SyncHashSetOperation.Remove, item);
            }

            return result;
        }

        /// <summary>
        /// Dirties the entire collection forcing a full send.
        /// </summary>
        public void DirtyAll()
        {
            if (!base.IsInitialized)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            if (base.Dirty())
                _sendAll = true;
        }

        /// <summary>
        /// Looks up obj in Collection and if found marks it's index as dirty.
        /// This operation can be very expensive, will cause allocations, and may fail if your value cannot be compared.
        /// </summary>
        /// <param name="obj">Object to lookup.</param>
        public void Dirty(T obj)
        {
            if (!base.IsInitialized)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            foreach (T item in Collection)
            {
                if (item.Equals(obj))
                {
                    AddOperation(SyncHashSetOperation.Update, obj);
                    return;
                }
            }

            //Not found.
            base.NetworkManager.LogError($"Could not find object within SyncHashSet, dirty will not be set.");
        }

        /// <summary>
        /// Returns Enumerator for collection.
        /// </summary>
        /// <returns></returns>
        public IEnumerator GetEnumerator() => Collection.GetEnumerator();

        [APIExclude]
        IEnumerator<T> IEnumerable<T>.GetEnumerator() => Collection.GetEnumerator();

        [APIExclude]
        IEnumerator IEnumerable.GetEnumerator() => Collection.GetEnumerator();

        public void ExceptWith(IEnumerable<T> other)
        {
            //Again, removing from self is a clear.
            if (other == Collection)
            {
                Clear();
            }
            else
            {
                foreach (T item in other)
                    Remove(item);
            }
        }

        public void IntersectWith(IEnumerable<T> other)
        {
            ISet<T> set;
            if (other is ISet<T> setA)
                set = setA;
            else
                set = new HashSet<T>(other);

            IntersectWith(set);
        }

        private void IntersectWith(ISet<T> other)
        {
            Intersect(Collection);
            if (base.NetworkManager == null)
                Intersect(ClientHostCollection);

            void Intersect(ISet<T> collection)
            {
                _cache.AddRange(collection);

                int count = _cache.Count;
                for (int i = 0; i < count; i++)
                {
                    T entry = _cache[i];
                    if (!other.Contains(entry))
                        Remove(entry);
                }
            }

            _cache.Clear();
        }

        public bool IsProperSubsetOf(IEnumerable<T> other)
        {
            return Collection.IsProperSubsetOf(other);
        }

        public bool IsProperSupersetOf(IEnumerable<T> other)
        {
            return Collection.IsProperSupersetOf(other);
        }

        public bool IsSubsetOf(IEnumerable<T> other)
        {
            return Collection.IsSubsetOf(other);
        }

        public bool IsSupersetOf(IEnumerable<T> other)
        {
            return Collection.IsSupersetOf(other);
        }

        public bool Overlaps(IEnumerable<T> other)
        {
            bool result = Collection.Overlaps(other);
            return result;
        }

        public bool SetEquals(IEnumerable<T> other)
        {
            return Collection.SetEquals(other);
        }

        public void SymmetricExceptWith(IEnumerable<T> other)
        {
            //If calling except on self then that is the same as a clear.
            if (other == Collection)
            {
                Clear();
            }
            else
            {
                foreach (T item in other)
                    Remove(item);
            }
        }

        public void UnionWith(IEnumerable<T> other)
        {
            if (other == Collection)
                return;

            foreach (T item in other)
                Add(item);
        }

        /// <summary>
        /// Adds an item.
        /// </summary>
        /// <param name="item"></param>
        void ICollection<T>.Add(T item)
        {
            Add(item, true);
        }

        /// <summary>
        /// Copies values to an array.
        /// </summary>
        /// <param name="array"></param>
        /// <param name="index"></param>
        public void CopyTo(T[] array, int index)
        {
            Collection.CopyTo(array, index);
            if (base.NetworkManager == null)
                ClientHostCollection.CopyTo(array, index);
        }
    }
}
#endif﻿
using FishNet.Documenting;

namespace FishNet.Object.Synchronizing
{
    [APIExclude]
    public enum SyncHashSetOperation : byte
    {
        /// <summary>
        /// An item is added to the collection.
        /// </summary>
        Add,
        /// <summary>
        /// An item is removed from the collection.
        /// </summary>
        Remove,
        /// <summary>
        /// Collection is cleared.
        /// </summary>
        Clear,
        /// <summary>
        /// All operations for the tick have been processed. This only occurs on clients as the server is unable to be aware of when the user is done modifying the list.
        /// </summary>
        Complete,
        /// <summary>
        /// An item has been updated within the collection. This is generally used when modifying data within a container.
        /// </summary>
        Update,
    }

}
﻿#if FISHNET_STABLE_SYNCTYPES
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object.Synchronizing
{
    [System.Serializable]
    public class SyncList<T> : SyncBase, IList<T>, IReadOnlyList<T>
    { 
        #region Types.
        /// <summary>
        /// Information needed to invoke a callback.
        /// </summary>
        private struct CachedOnChange
        {
            internal readonly SyncListOperation Operation;
            internal readonly int Index;
            internal readonly T Previous;
            internal readonly T Next;

            public CachedOnChange(SyncListOperation operation, int index, T previous, T next)
            {
                Operation = operation;
                Index = index;
                Previous = previous;
                Next = next;
            }
        }

        /// <summary>
        /// Information about how the collection has changed.
        /// </summary>
        private struct ChangeData
        {
            internal readonly SyncListOperation Operation;
            internal readonly int Index;
            internal readonly T Item;

            public ChangeData(SyncListOperation operation, int index, T item)
            {
                Operation = operation;
                Index = index;
                Item = item;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Implementation from List<T>. Not used.
        /// </summary>
        [APIExclude]
        public bool IsReadOnly => false;
        /// <summary>
        /// Delegate signature for when SyncList changes.
        /// </summary>
        /// <param name="op"></param>
        /// <param name="index"></param>
        /// <param name="oldItem"></param>
        /// <param name="newItem"></param>
        [APIExclude]
        public delegate void SyncListChanged(SyncListOperation op, int index, T oldItem, T newItem, bool asServer);
        /// <summary>
        /// Called when the SyncList changes.
        /// </summary>
        public event SyncListChanged OnChange;
        /// <summary>
        /// Collection of objects.
        /// </summary>
        public List<T> Collection;
        /// <summary>
        /// Copy of objects on client portion when acting as a host.
        /// </summary>
        [HideInInspector]
        public List<T> ClientHostCollection;
        /// <summary>
        /// Number of objects in the collection.
        /// </summary>
        public int Count => Collection.Count;
        #endregion

        #region Private.        
        /// <summary>
        /// Values upon initialization.
        /// </summary>
        private List<T> _initialValues;
        /// <summary>
        /// Comparer to see if entries change when calling public methods.
        /// </summary>
        private readonly IEqualityComparer<T> _comparer;
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private List<ChangeData> _changed;
        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private List<CachedOnChange> _serverOnChanges;
        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private List<CachedOnChange> _clientOnChanges;
        /// <summary>
        /// True if values have changed since initialization.
        /// The only reasonable way to reset this during a Reset call is by duplicating the original list and setting all values to it on reset.
        /// </summary>
        private bool _valuesChanged;
        /// <summary>
        /// True to send all values in the next WriteDelta.
        /// </summary>
        private bool _sendAll;
        #endregion

        #region Constructors.
        public SyncList(SyncTypeSettings settings = new()) : this(CollectionCaches<T>.RetrieveList(), EqualityComparer<T>.Default, settings) { }
        public SyncList(IEqualityComparer<T> comparer, SyncTypeSettings settings = new()) : this(new(), (comparer == null) ? EqualityComparer<T>.Default : comparer, settings) { }
        public SyncList(List<T> collection, IEqualityComparer<T> comparer = null, SyncTypeSettings settings = new()) : base(settings)
        {
            _comparer = (comparer == null) ? EqualityComparer<T>.Default : comparer;
            Collection = (collection == null) ? CollectionCaches<T>.RetrieveList() : collection;
            ClientHostCollection = CollectionCaches<T>.RetrieveList();

            _initialValues = CollectionCaches<T>.RetrieveList();
            _changed = CollectionCaches<ChangeData>.RetrieveList();
            _serverOnChanges = CollectionCaches<CachedOnChange>.RetrieveList();
            _clientOnChanges = CollectionCaches<CachedOnChange>.RetrieveList();

            //Add each in collection to clienthostcollection.
            foreach (T item in collection)
                ClientHostCollection.Add(item);
        }
        #endregion

        #region Deconstructor.
        ~SyncList()
        {
            CollectionCaches<T>.StoreAndDefault(ref Collection);
            CollectionCaches<T>.StoreAndDefault(ref ClientHostCollection);
            CollectionCaches<T>.StoreAndDefault(ref _initialValues);
            CollectionCaches<ChangeData>.StoreAndDefault(ref _changed);
            CollectionCaches<CachedOnChange>.StoreAndDefault(ref _serverOnChanges);
            CollectionCaches<CachedOnChange>.StoreAndDefault(ref _clientOnChanges);
        }
        #endregion

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Initialized()
        {
            base.Initialized();

            //Initialize collections if needed. OdinInspector can cause them to become deinitialized.
#if ODIN_INSPECTOR
            if (_initialValues == null) _initialValues = new();
            if (_changed == null) _changed = new();
            if (_serverOnChanges == null) _serverOnChanges = new();
            if (_clientOnChanges == null) _clientOnChanges = new();
#endif

            foreach (T item in Collection)
                _initialValues.Add(item);
        }

        /// <summary>
        /// Gets the collection being used within this SyncList.
        /// </summary>
        /// <param name="asServer">True if returning the server value, false if client value. The values will only differ when running as host. While asServer is true the most current values on server will be returned, and while false the latest values received by client will be returned.</param>
        /// <returns></returns>
        public List<T> GetCollection(bool asServer)
        {
            bool asClientAndHost = (!asServer && base.NetworkManager.IsServerStarted);
            List<T> collection = (asClientAndHost) ? ClientHostCollection : Collection;
            return (collection as List<T>);
        }

        /// <summary>
        /// Adds an operation and invokes locally.
        /// </summary>
        /// <param name="operation"></param>
        /// <param name="index"></param>
        /// <param name="prev"></param>
        /// <param name="next"></param>
        
        private void AddOperation(SyncListOperation operation, int index, T prev, T next)
        {
            if (!base.IsInitialized)
                return;

            /* asServer might be true if the client is setting the value
            * through user code. Typically synctypes can only be set
            * by the server, that's why it is assumed asServer via user code.
            * However, when excluding owner for the synctype the client should
            * have permission to update the value locally for use with
            * prediction. */
            bool asServerInvoke = (!base.IsNetworkInitialized || base.NetworkBehaviour.IsServerStarted);

            /* Only the adds asServer may set
             * this synctype as dirty and add
             * to pending changes. However, the event may still
             * invoke for clientside. */
            if (asServerInvoke)
            {
                /* Set as changed even if cannot dirty.
                * Dirty is only set when there are observers,
                * but even if there are not observers
                * values must be marked as changed so when
                * there are observers, new values are sent. */
                _valuesChanged = true;

                /* If unable to dirty then do not add to changed.
                 * A dirty may fail if the server is not started
                 * or if there's no observers. Changed doesn't need
                 * to be populated in this situations because clients
                 * will get the full collection on spawn. If we
                 * were to also add to changed clients would get the full
                 * collection as well the changed, which would double results. */
                if (base.Dirty())
                {
                    ChangeData change = new(operation, index, next);
                    _changed.Add(change);
                }
            }

            InvokeOnChange(operation, index, prev, next, asServerInvoke);
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<CachedOnChange> collection = (asServer) ? _serverOnChanges : _clientOnChanges;

            if (OnChange != null)
            {
                foreach (CachedOnChange item in collection)
                    OnChange.Invoke(item.Operation, item.Index, item.Previous, item.Next, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Writes all changed values.
        /// </summary>
        /// <param name="writer"></param>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        protected internal override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            //If sending all then clear changed and write full.
            if (_sendAll)
            {
                _sendAll = false;
                _changed.Clear();
                WriteFull(writer);
            }
            else
            {
                base.WriteDelta(writer, resetSyncTick);

                //False for not full write.
                writer.WriteBoolean(false);

                //Number of entries expected.
                writer.WriteInt32(_changed.Count);

                for (int i = 0; i < _changed.Count; i++)
                {
                    ChangeData change = _changed[i];
                    writer.WriteUInt8Unpacked((byte)change.Operation);

                    //Clear does not need to write anymore data so it is not included in checks.
                    if (change.Operation == SyncListOperation.Add)
                    {
                        writer.Write(change.Item);
                    }
                    else if (change.Operation == SyncListOperation.RemoveAt)
                    {
                        writer.WriteInt32(change.Index);
                    }
                    else if (change.Operation == SyncListOperation.Insert || change.Operation == SyncListOperation.Set)
                    {
                        writer.WriteInt32(change.Index);
                        writer.Write(change.Item);
                    }
                }

                _changed.Clear();
            }
        }

        /// <summary>
        /// Writes all values if not initial values.
        /// </summary>
        /// <param name="writer"></param>
        protected internal override void WriteFull(PooledWriter writer)
        {
            if (!_valuesChanged)
                return;

            base.WriteHeader(writer, false);
            //True for full write.
            writer.WriteBoolean(true);

            int count = Collection.Count;
            writer.WriteInt32(count);
            for (int i = 0; i < count; i++)
            {
                writer.WriteUInt8Unpacked((byte)SyncListOperation.Add);
                writer.Write(Collection[i]);
            }
        }

        /// <summary>
        /// Reads and sets the current values for server or client.
        /// </summary>
        
        [APIExclude]
        protected internal override void Read(PooledReader reader, bool asServer)
        {
            base.SetReadArguments(reader, asServer, out bool newChangeId, out bool asClientHost, out bool canModifyValues);
            
            //True to warn if this object was deinitialized on the server.
            bool deinitialized = (asClientHost && !base.OnStartServerCalled);
            if (deinitialized)
                base.NetworkManager.LogWarning($"SyncType {GetType().Name} received a Read but was deinitialized on the server. Client callback values may be incorrect. This is a ClientHost limitation.");

            List<T> collection = (asClientHost) ? ClientHostCollection : Collection;

            //Clear collection since it's a full write.
            bool fullWrite = reader.ReadBoolean();
            if (fullWrite)
                collection.Clear();

            int changes = reader.ReadInt32();

            for (int i = 0; i < changes; i++)
            {
                SyncListOperation operation = (SyncListOperation)reader.ReadUInt8Unpacked();
                int index = -1;
                T prev = default;
                T next = default;

                //Add.
                if (operation == SyncListOperation.Add)
                {
                    next = reader.Read<T>();
                    
                    if (newChangeId)
                    {
                        index = collection.Count;
                        collection.Add(next);
                    }
                }
                //Clear.
                else if (operation == SyncListOperation.Clear)
                {
                    if (newChangeId)
                        collection.Clear();
                }
                //Insert.
                else if (operation == SyncListOperation.Insert)
                {
                    index = reader.ReadInt32();
                    next = reader.Read<T>();
                    
                    if (newChangeId)
                        collection.Insert(index, next);
                }
                //RemoveAt.
                else if (operation == SyncListOperation.RemoveAt)
                {
                    index = reader.ReadInt32();
                    
                    if (newChangeId)
                    {
                        prev = collection[index];
                        collection.RemoveAt(index);
                    }
                }
                //Set
                else if (operation == SyncListOperation.Set)
                {
                    index = reader.ReadInt32();
                    next = reader.Read<T>();
                    
                    if (newChangeId)
                    {
                        prev = collection[index];
                        collection[index] = next;
                    }
                }

                if (newChangeId)
                    InvokeOnChange(operation, index, prev, next, false);
            }

            //If changes were made invoke complete after all have been read.
            if (newChangeId && changes > 0)
                InvokeOnChange(SyncListOperation.Complete, -1, default, default, false);
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncListOperation operation, int index, T prev, T next, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, index, prev, next, asServer);
                else
                    _serverOnChanges.Add(new(operation, index, prev, next));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, index, prev, next, asServer);
                else
                    _clientOnChanges.Add(new(operation, index, prev, next));
            }
        }

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        protected internal override void ResetState(bool asServer)
        {
            base.ResetState(asServer);
            _sendAll = false;
            _changed.Clear();
            ClientHostCollection.Clear();
            Collection.Clear();

            foreach (T item in _initialValues)
            {
                Collection.Add(item);
                ClientHostCollection.Add(item);
            }
        }


        /// <summary>
        /// Adds value.
        /// </summary>
        /// <param name="item"></param>
        public void Add(T item)
        {
            Add(item, true);
        }
        private void Add(T item, bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            Collection.Add(item);
            if (asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.Add(item);
                AddOperation(SyncListOperation.Add, Collection.Count - 1, default, item);
            }
        }
        /// <summary>
        /// Adds a range of values.
        /// </summary>
        /// <param name="range"></param>
        public void AddRange(IEnumerable<T> range)
        {
            foreach (T entry in range)
                Add(entry, true);
        }

        /// <summary>
        /// Clears all values.
        /// </summary>
        public void Clear()
        {
            Clear(true);
        }
        private void Clear(bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            Collection.Clear();
            if (asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.Clear();
                AddOperation(SyncListOperation.Clear, -1, default, default);
            }
        }

        /// <summary>
        /// Returns if value exist.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Contains(T item)
        {
            return (IndexOf(item) >= 0);
        }

        /// <summary>
        /// Copies values to an array.
        /// </summary>
        /// <param name="array"></param>
        /// <param name="index"></param>
        public void CopyTo(T[] array, int index)
        {
            Collection.CopyTo(array, index);
        }

        /// <summary>
        /// Gets the index of value.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public int IndexOf(T item)
        {
            for (int i = 0; i < Collection.Count; ++i)
            {
                if (_comparer.Equals(item, Collection[i]))
                    return i;
            }
            return -1;
        }

        /// <summary>
        /// Finds index using match.
        /// </summary>
        /// <param name="match"></param>
        /// <returns></returns>
        public int FindIndex(Predicate<T> match)
        {
            for (int i = 0; i < Collection.Count; ++i)
            {
                if (match(Collection[i]))
                    return i;
            }
            return -1;
        }

        /// <summary>
        /// Finds value using match.
        /// </summary>
        /// <param name="match"></param>
        /// <returns></returns>
        public T Find(Predicate<T> match)
        {
            int i = FindIndex(match);
            return (i != -1) ? Collection[i] : default;
        }

        /// <summary>
        /// Finds all values using match.
        /// </summary>
        /// <param name="match"></param>
        /// <returns></returns>
        public List<T> FindAll(Predicate<T> match)
        {
            List<T> results = new();
            for (int i = 0; i < Collection.Count; ++i)
            {
                if (match(Collection[i]))
                    results.Add(Collection[i]);
            }
            return results;
        }

        /// <summary>
        /// Inserts value at index.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="item"></param>
        public void Insert(int index, T item)
        {
            Insert(index, item, true);
        }
        private void Insert(int index, T item, bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            Collection.Insert(index, item);
            if (asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.Insert(index, item);
                AddOperation(SyncListOperation.Insert, index, default, item);
            }
        }

        /// <summary>
        /// Inserts a range of values.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="range"></param>
        public void InsertRange(int index, IEnumerable<T> range)
        {
            foreach (T entry in range)
            {
                Insert(index, entry);
                index++;
            }
        }

        /// <summary>
        /// Removes a value.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Remove(T item)
        {
            int index = IndexOf(item);
            bool result = index >= 0;
            if (result)
                RemoveAt(index);

            return result;
        }

        /// <summary>
        /// Removes value at index.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="asServer"></param>
        public void RemoveAt(int index)
        {
            RemoveAt(index, true);
        }
        private void RemoveAt(int index, bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            T oldItem = Collection[index];
            Collection.RemoveAt(index);
            if (asServer)
            {
                if (base.NetworkManager == null)
                    ClientHostCollection.RemoveAt(index);
                AddOperation(SyncListOperation.RemoveAt, index, oldItem, default);
            }
        }

        /// <summary>
        /// Removes all values within the collection.
        /// </summary>
        /// <param name="match"></param>
        /// <returns></returns>
        public int RemoveAll(Predicate<T> match)
        {
            List<T> toRemove = new();
            for (int i = 0; i < Collection.Count; ++i)
            { 
                if (match(Collection[i]))
                    toRemove.Add(Collection[i]);
            }
            
            foreach (T entry in toRemove)
                Remove(entry);

            return toRemove.Count;
        }

        /// <summary>
        /// Gets or sets value at an index.
        /// </summary>
        /// <param name="i"></param>
        /// <returns></returns>
        public T this[int i]
        {
            get => Collection[i];
            set => Set(i, value, true, true);
        }

        /// <summary>
        /// Dirties the entire collection forcing a full send.
        /// This will not invoke the callback on server.
        /// </summary>
        public void DirtyAll()
        {
            if (!base.IsInitialized)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            if (base.Dirty())
                _sendAll = true;
        }

        /// <summary>
        /// Looks up obj in Collection and if found marks it's index as dirty.
        /// While using this operation previous value will be the same as next.
        /// This operation can be very expensive, and may fail if your value cannot be compared.
        /// </summary>
        /// <param name="obj">Object to lookup.</param>
        public void Dirty(T obj)
        {
            int index = Collection.IndexOf(obj);
            if (index != -1)
                Dirty(index);
            else
                base.NetworkManager.LogError($"Could not find object within SyncList, dirty will not be set.");
        }
        /// <summary>
        /// Marks an index as dirty.
        /// While using this operation previous value will be the same as next.
        /// </summary>
        /// <param name="index"></param>
        public void Dirty(int index)
        {
            if (!base.CanNetworkSetValues(true))
                return;

//            bool asServer = true;
            T value = Collection[index];
//            if (asServer)
                AddOperation(SyncListOperation.Set, index, value, value);
        }
        /// <summary>
        /// Sets value at index.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="value"></param>
        public void Set(int index, T value, bool force = true)
        {
            Set(index, value, true, force);
        }
        private void Set(int index, T value, bool asServer, bool force)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            bool sameValue = (!force && _comparer.Equals(Collection[index], value));
            if (!sameValue)
            {
                T prev = Collection[index];
                Collection[index] = value;
                if (asServer)
                {
                    if (base.NetworkManager == null)
                        ClientHostCollection[index] = value;
                    AddOperation(SyncListOperation.Set, index, prev, value);
                }
            }
        }


        /// <summary>
        /// Returns Enumerator for collection.
        /// </summary>
        /// <returns></returns>
        public IEnumerator GetEnumerator() => Collection.GetEnumerator();
        [APIExclude]
        IEnumerator<T> IEnumerable<T>.GetEnumerator() => Collection.GetEnumerator();
        [APIExclude]
        IEnumerator IEnumerable.GetEnumerator() => Collection.GetEnumerator();

    }
}
#endif﻿
using FishNet.Documenting;

namespace FishNet.Object.Synchronizing
{
    [APIExclude]
    public enum SyncListOperation : byte
    {
        /// <summary>
        /// An item is added to the collection.
        /// </summary>
        Add,
        /// <summary>
        /// An item is inserted into the collection.
        /// </summary>
        Insert,
        /// <summary>
        /// An item is set in the collection.
        /// </summary>
        Set,
        /// <summary>
        /// An item is removed from the collection.
        /// </summary>
        RemoveAt,
        /// <summary>
        /// Collection is cleared.
        /// </summary>
        Clear,
        /// <summary>
        /// All operations for the tick have been processed. This only occurs on clients as the server is unable to be aware of when the user is done modifying the list.
        /// </summary>
        Complete
    }

}
﻿#if FISHNET_STABLE_SYNCTYPES
using FishNet.CodeGenerating;
using FishNet.Documenting;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace FishNet.Object.Synchronizing
{
    /// <summary>
    /// A SyncObject to efficiently synchronize Stopwatchs over the network.
    /// </summary>
    public class SyncStopwatch : SyncBase, ICustomSync
    {
        #region Type.
        /// <summary>
        /// Information about how the Stopwatch has changed.
        /// </summary>
        private struct ChangeData
        {
            public readonly SyncStopwatchOperation Operation;
            public readonly float Previous;

            public ChangeData(SyncStopwatchOperation operation, float previous)
            {
                Operation = operation;
                Previous = previous;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Delegate signature for when the Stopwatch operation occurs.
        /// </summary>
        /// <param name="op">Operation which was performed.</param>
        /// <param name="prev">Previous value of the Stopwatch. This will be -1f is the value is not available.</param>
        /// <param name="asServer">True if occurring on server.</param>
        public delegate void SyncTypeChanged(SyncStopwatchOperation op, float prev, bool asServer);

        /// <summary>
        /// Called when a Stopwatch operation occurs.
        /// </summary>
        public event SyncTypeChanged OnChange;
        /// <summary>
        /// How much time has passed since the Stopwatch started.
        /// </summary>
        public float Elapsed { get; private set; } = -1f;
        /// <summary>
        /// True if the SyncStopwatch is currently paused. Calls to Update(float) will be ignored when paused.
        /// </summary>
        public bool Paused { get; private set; }
        #endregion

        #region Private.
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private List<ChangeData> _changed = new();
        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private List<ChangeData> _serverOnChanges = new();
        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private List<ChangeData> _clientOnChanges = new();
        #endregion

        #region Constructors
        public SyncStopwatch(SyncTypeSettings settings = new()) : base(settings) { }
        #endregion

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Initialized()
        {
            base.Initialized();

            //Initialize collections if needed. OdinInspector can cause them to become deinitialized.
#if ODIN_INSPECTOR
            if (_changed == null) _changed = new();
            if (_serverOnChanges == null) _serverOnChanges = new();
            if (_clientOnChanges == null) _clientOnChanges = new();
#endif
        }

        /// <summary>
        /// Starts a Stopwatch. If called when a Stopwatch is already active then StopStopwatch will automatically be sent.
        /// </summary>
        /// <param name="remaining">Time in which the Stopwatch should start with.</param>
        /// <param name="sendElapsedOnStop">True to include remaining time when automatically sending StopStopwatch.</param>
        public void StartStopwatch(bool sendElapsedOnStop = true)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            if (Elapsed > 0f)
                StopStopwatch(sendElapsedOnStop);

            Elapsed = 0f;
            AddOperation(SyncStopwatchOperation.Start, 0f);
        }

        /// <summary>
        /// Pauses the Stopwatch. Calling while already paused will be result in no action.
        /// </summary>
        /// <param name="sendElapsed">True to send Remaining with this operation.</param>
        public void PauseStopwatch(bool sendElapsed = false)
        {
            if (Elapsed < 0f)
                return;
            if (Paused)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            Paused = true;
            float prev;
            SyncStopwatchOperation op;
            if (sendElapsed)
            {
                prev = Elapsed;
                op = SyncStopwatchOperation.PauseUpdated;
            }
            else
            {
                prev = -1f;
                op = SyncStopwatchOperation.Pause;
            }

            AddOperation(op, prev);
        }

        /// <summary>
        /// Unpauses the Stopwatch. Calling while already unpaused will be result in no action.
        /// </summary>
        public void UnpauseStopwatch()
        {
            if (Elapsed < 0f)
                return;
            if (!Paused)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            Paused = false;
            AddOperation(SyncStopwatchOperation.Unpause, -1f);
        }

        /// <summary>
        /// Stops and resets the Stopwatch. 
        /// </summary>
        public void StopStopwatch(bool sendElapsed = false)
        {
            if (Elapsed < 0f)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            float prev = (sendElapsed) ? -1f : Elapsed;
            StopStopwatch_Internal(true);
            SyncStopwatchOperation op = (sendElapsed) ? SyncStopwatchOperation.StopUpdated : SyncStopwatchOperation.Stop;
            AddOperation(op, prev);
        }

        /// <summary>
        /// Adds an operation to synchronize.
        /// </summary>
        private void AddOperation(SyncStopwatchOperation operation, float prev)
        {
            if (!base.IsInitialized)
                return;

            bool asServerInvoke = (!base.IsNetworkInitialized || base.NetworkBehaviour.IsServerStarted);

            if (asServerInvoke)
            {
                if (base.Dirty())
                {
                    ChangeData change = new(operation, prev);
                    _changed.Add(change);
                }
            }

            OnChange?.Invoke(operation, prev, asServerInvoke);
        }

        /// <summary>
        /// Writes all changed values.
        /// </summary>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        protected internal override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            base.WriteDelta(writer, resetSyncTick);
            writer.WriteInt32(_changed.Count);

            for (int i = 0; i < _changed.Count; i++)
            {
                ChangeData change = _changed[i];
                writer.WriteUInt8Unpacked((byte)change.Operation);
                if (change.Operation == SyncStopwatchOperation.Start)
                    WriteStartStopwatch(writer, 0f, false);
                //Pause and unpause updated need current value written.
                //Updated stop also writes current value.
                else if (change.Operation == SyncStopwatchOperation.PauseUpdated || change.Operation == SyncStopwatchOperation.StopUpdated)
                    writer.WriteSingle(change.Previous);
            }

            _changed.Clear();
        }

        /// <summary>
        /// Writes all values.
        /// </summary>
        protected internal override void WriteFull(PooledWriter writer)
        {
            //Only write full if a Stopwatch is running.
            if (Elapsed < 0f)
                return;

            base.WriteDelta(writer, false);

            //There will be 1 or 2 entries. If paused 2, if not 1.
            int entries = (Paused) ? 2 : 1;
            writer.WriteInt32(entries);
            //And the operations.
            WriteStartStopwatch(writer, Elapsed, true);
            if (Paused)
                writer.WriteUInt8Unpacked((byte)SyncStopwatchOperation.Pause);
        }

        /// <summary>
        /// Writers a start with elapsed time.
        /// </summary>
        /// <param name="elapsed"></param>
        private void WriteStartStopwatch(Writer w, float elapsed, bool includeOperationByte)
        {
            if (includeOperationByte)
                w.WriteUInt8Unpacked((byte)SyncStopwatchOperation.Start);

            w.WriteSingle(elapsed);
        }

        /// <summary>
        /// Reads and sets the current values for server or client.
        /// </summary>
        [APIExclude]
        protected internal override void Read(PooledReader reader, bool asServer)
        {
            base.SetReadArguments(reader, asServer, out bool newChangeId, out bool asClientHost, out bool canModifyValues);

            int changes = reader.ReadInt32();

            for (int i = 0; i < changes; i++)
            {
                SyncStopwatchOperation op = (SyncStopwatchOperation)reader.ReadUInt8Unpacked();
                if (op == SyncStopwatchOperation.Start)
                {
                    float elapsed = reader.ReadSingle();

                    if (canModifyValues)
                        Elapsed = elapsed;

                    if (newChangeId)
                        InvokeOnChange(op, elapsed, asServer);
                }
                else if (op == SyncStopwatchOperation.Pause)
                {
                    if (canModifyValues)
                        Paused = true;

                    if (newChangeId)
                        InvokeOnChange(op, -1f, asServer);
                }
                else if (op == SyncStopwatchOperation.PauseUpdated)
                {
                    float prev = reader.ReadSingle();

                    if (newChangeId)
                        Paused = true;

                    if (newChangeId)
                        InvokeOnChange(op, prev, asServer);
                }
                else if (op == SyncStopwatchOperation.Unpause)
                {
                    if (canModifyValues)
                        Paused = false;

                    if (newChangeId)
                        InvokeOnChange(op, -1f, asServer);
                }
                else if (op == SyncStopwatchOperation.Stop)
                {
                    if (canModifyValues)
                        StopStopwatch_Internal(asServer);

                    if (newChangeId)
                        InvokeOnChange(op, -1f, false);
                }
                else if (op == SyncStopwatchOperation.StopUpdated)
                {
                    float prev = reader.ReadSingle();

                    if (canModifyValues)
                        StopStopwatch_Internal(asServer);

                    if (newChangeId)
                        InvokeOnChange(op, prev, asServer);
                }
            }

            if (newChangeId && changes > 0)
                InvokeOnChange(SyncStopwatchOperation.Complete, -1f, asServer);
        }

        /// <summary>
        /// Stops the Stopwatch and resets.
        /// </summary>
        private void StopStopwatch_Internal(bool asServer)
        {
            Paused = false;
            Elapsed = -1f;
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncStopwatchOperation operation, float prev, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, prev, asServer);
                else
                    _serverOnChanges.Add(new(operation, prev));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, prev, asServer);
                else
                    _clientOnChanges.Add(new(operation, prev));
            }
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<ChangeData> collection = (asServer) ? _serverOnChanges : _clientOnChanges;

            if (OnChange != null)
            {
                foreach (ChangeData item in collection)
                    OnChange.Invoke(item.Operation, item.Previous, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Adds delta from Remaining for server and client.
        /// </summary>
        /// <param name="delta">Value to remove from Remaining.</param>
        public void Update(float delta)
        {
            //Not enabled.
            if (Elapsed == -1f)
                return;
            if (Paused)
                return;

            Elapsed += delta;
        }

        /// <summary>
        /// Return the serialized type.
        /// </summary>
        /// <returns></returns>
        public object GetSerializedType() => null;
    }
}
#endif﻿namespace FishNet.Object.Synchronizing
{

    public enum SyncStopwatchOperation : byte
    {
        /// <summary>
        /// Stopwatch is started. Value is included with start.
        /// </summary>
        Start = 1,
        /// <summary>
        /// Stopwatch was paused.
        /// </summary>
        Pause = 2,
        /// <summary>
        /// Stopwatch was paused. Value at time of pause is sent.
        /// </summary>
        PauseUpdated = 3,
        /// <summary>
        /// Stopwatch was unpaused.
        /// </summary>
        Unpause = 4,
        /// <summary>
        /// Stopwatch was stopped.
        /// </summary>
        Stop = 6,
        /// <summary>
        /// Stopwatch was stopped. Value prior to stopping is sent.
        /// </summary>
        StopUpdated = 7,
        /// <summary>
        /// All operations for the tick have been processed. This only occurs on clients as the server is unable to be aware of when the user is done modifying the list.
        /// </summary>
        Complete = 9,
    }

}
﻿#if FISHNET_STABLE_SYNCTYPES
using FishNet.CodeGenerating;
using FishNet.Documenting;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object.Synchronizing
{
    /// <summary>
    /// A SyncObject to efficiently synchronize timers over the network.
    /// </summary>
    public class SyncTimer : SyncBase, ICustomSync
    {
        #region Type.
        /// <summary>
        /// Information about how the timer has changed.
        /// </summary>
        private struct ChangeData
        {
            public readonly SyncTimerOperation Operation;
            public readonly float Previous;
            public readonly float Next;

            public ChangeData(SyncTimerOperation operation, float previous, float next)
            {
                Operation = operation;
                Previous = previous;
                Next = next;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Delegate signature for when the timer operation occurs.
        /// </summary>
        /// <param name="op">Operation which was performed.</param>
        /// <param name="prev">Previous value of the timer. This will be -1f is the value is not available.</param>
        /// <param name="next">Value of the timer. This will be -1f is the value is not available.</param>
        /// <param name="asServer">True if occurring on server.</param>
        public delegate void SyncTypeChanged(SyncTimerOperation op, float prev, float next, bool asServer);

        /// <summary>
        /// Called when a timer operation occurs.
        /// </summary>
        public event SyncTypeChanged OnChange;

        /// <summary>
        /// Time remaining on the timer. When the timer is expired this value will be 0f.
        /// </summary>
        public float Remaining { get; private set; }

        /// <summary>
        /// How much time has passed since the timer started.
        /// </summary>
        public float Elapsed => (Duration - Remaining);

        /// <summary>
        /// Starting duration of the timer.
        /// </summary>
        public float Duration { get; private set; }

        /// <summary>
        /// True if the SyncTimer is currently paused. Calls to Update(float) will be ignored when paused.
        /// </summary>
        public bool Paused { get; private set; }
        #endregion

        #region Private.
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private List<ChangeData> _changed = new();

        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private List<ChangeData> _serverOnChanges = new();

        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private List<ChangeData> _clientOnChanges = new();

        /// <summary>
        /// Last Time.unscaledTime the timer delta was updated.
        /// </summary>
        private float _updateTime;
        #endregion

        #region Constructors
        public SyncTimer(SyncTypeSettings settings = new()) : base(settings) { }
        #endregion

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Initialized()
        {
            base.Initialized();

            //Initialize collections if needed. OdinInspector can cause them to become deinitialized.
#if ODIN_INSPECTOR
            if (_changed == null) _changed = new();
            if (_serverOnChanges == null) _serverOnChanges = new();
            if (_clientOnChanges == null) _clientOnChanges = new();
#endif
        }

        /// <summary>
        /// Starts a timer. If called when a timer is already active then StopTimer will automatically be sent.
        /// </summary>
        /// <param name="remaining">Time in which the timer should start with.</param>
        /// <param name="sendRemainingOnStop">True to include remaining time when automatically sending StopTimer.</param>
        public void StartTimer(float remaining, bool sendRemainingOnStop = true)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            if (Remaining > 0f)
                StopTimer(sendRemainingOnStop);

            Paused = false;
            Remaining = remaining;
            Duration = remaining;
            SetUpdateTime();
            AddOperation(SyncTimerOperation.Start, -1f, remaining);
        }

        /// <summary>
        /// Pauses the timer. Calling while already paused will be result in no action.
        /// </summary>
        /// <param name="sendRemaining">True to send Remaining with this operation.</param>
        public void PauseTimer(bool sendRemaining = false)
        {
            if (Remaining <= 0f)
                return;
            if (Paused)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            Paused = true;
            SyncTimerOperation op = (sendRemaining) ? SyncTimerOperation.PauseUpdated : SyncTimerOperation.Pause;
            AddOperation(op, Remaining, Remaining);
        }

        /// <summary>
        /// Unpauses the timer. Calling while already unpaused will be result in no action.
        /// </summary>
        public void UnpauseTimer()
        {
            if (Remaining <= 0f)
                return;
            if (!Paused)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            Paused = false;
            SetUpdateTime();
            AddOperation(SyncTimerOperation.Unpause, Remaining, Remaining);
        }

        /// <summary>
        /// Stops and resets the timer. 
        /// </summary>
        public void StopTimer(bool sendRemaining = false)
        {
            if (Remaining <= 0f)
                return;
            if (!base.CanNetworkSetValues(log: true))
                return;

            bool asServer = true;
            float prev = Remaining;
            
            StopTimer_Internal(asServer);
            SyncTimerOperation op = (sendRemaining) ? SyncTimerOperation.StopUpdated : SyncTimerOperation.Stop;
            AddOperation(op, prev, 0f);
        }

        /// <summary>
        /// Adds an operation to synchronize.
        /// </summary>
        private void AddOperation(SyncTimerOperation operation, float prev, float next)
        {
            if (!base.IsInitialized)
                return;

            bool asServerInvoke = (!base.IsNetworkInitialized || base.NetworkBehaviour.IsServerStarted);

            if (asServerInvoke)
            {
                if (base.Dirty())
                {
                    ChangeData change = new(operation, prev, next);
                    _changed.Add(change);
                }
            }

            OnChange?.Invoke(operation, prev, next, asServerInvoke);
        }

        /// <summary>
        /// Writes all changed values.
        /// </summary>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        protected internal override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            base.WriteDelta(writer, resetSyncTick);
            writer.WriteInt32(_changed.Count);

            for (int i = 0; i < _changed.Count; i++)
            {
                ChangeData change = _changed[i];
                writer.WriteUInt8Unpacked((byte)change.Operation);

                if (change.Operation == SyncTimerOperation.Start)
                {
                    WriteStartTimer(writer, false);
                }
                //Pause and unpause updated need current value written.
                //Updated stop also writes current value.
                else if (change.Operation == SyncTimerOperation.PauseUpdated || change.Operation == SyncTimerOperation.StopUpdated)
                {
                    writer.WriteSingle(change.Next);
                }
            }

            _changed.Clear();
        }

        /// <summary>
        /// Writes all values.
        /// </summary>
        protected internal override void WriteFull(PooledWriter writer)
        {
            //Only write full if a timer is running.
            if (Remaining <= 0f)
                return;

            base.WriteDelta(writer, false);
            //There will be 1 or 2 entries. If paused 2, if not 1.
            int entries = (Paused) ? 2 : 1;
            writer.WriteInt32(entries);
            //And the operations.
            WriteStartTimer(writer, true);
            if (Paused)
                writer.WriteUInt8Unpacked((byte)SyncTimerOperation.Pause);
        }

        /// <summary>
        /// Writes a StartTimer operation.
        /// </summary>
        /// <param name="w"></param>
        /// <param name="includeOperationByte"></param>
        private void WriteStartTimer(Writer w, bool includeOperationByte)
        {
            if (includeOperationByte)
                w.WriteUInt8Unpacked((byte)SyncTimerOperation.Start);
            w.WriteSingle(Remaining);
            w.WriteSingle(Duration);
        }

        /// <summary>
        /// Reads and sets the current values for server or client.
        /// </summary>
        [APIExclude]
        protected internal override void Read(PooledReader reader, bool asServer)
        {
            base.SetReadArguments(reader, asServer, out bool newChangeId, out bool asClientHost, out bool canModifyValues);

            int changes = reader.ReadInt32();

            for (int i = 0; i < changes; i++)
            {
                SyncTimerOperation op = (SyncTimerOperation)reader.ReadUInt8Unpacked();
                if (op == SyncTimerOperation.Start)
                {
                    float next = reader.ReadSingle();
                    float duration = reader.ReadSingle();
                    
                    if (canModifyValues)
                    {
                        Paused = false;
                        Remaining = next;
                        Duration = duration;
                    }

                    if (newChangeId)
                        InvokeOnChange(op, -1f, next, asServer);
                }
                else if (op == SyncTimerOperation.Pause || op == SyncTimerOperation.PauseUpdated || op == SyncTimerOperation.Unpause)
                {
                    if (canModifyValues)
                        UpdatePauseState(op);
                }
                else if (op == SyncTimerOperation.Stop)
                {
                    float prev = Remaining;

                    if (canModifyValues)
                        StopTimer_Internal(asServer);

                    if (newChangeId)
                        InvokeOnChange(op, prev, 0f, false);
                }
                //
                else if (op == SyncTimerOperation.StopUpdated)
                {
                    float prev = Remaining;
                    float next = reader.ReadSingle();

                    if (canModifyValues)
                        StopTimer_Internal(asServer);

                    if (newChangeId)
                        InvokeOnChange(op, prev, next, asServer);
                }
            }

            //Updates a pause state with a pause or unpause operation.
            void UpdatePauseState(SyncTimerOperation op)
            {
                bool newPauseState = (op == SyncTimerOperation.Pause || op == SyncTimerOperation.PauseUpdated);

                float prev = Remaining;
                float next;
                //If updated time as well.
                if (op == SyncTimerOperation.PauseUpdated)
                {
                    next = reader.ReadSingle();
                    Remaining = next;
                }
                else
                {
                    next = Remaining;
                }

                Paused = newPauseState;
                InvokeOnChange(op, prev, next, asServer);
            }

            if (newChangeId && changes > 0)
                InvokeOnChange(SyncTimerOperation.Complete, -1f, -1f, false);
        }

        /// <summary>
        /// Stops the timer and resets.
        /// </summary>
        private void StopTimer_Internal(bool asServer)
        {
            Paused = false;
            Remaining = 0f;
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncTimerOperation operation, float prev, float next, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, prev, next, asServer);
                else
                    _serverOnChanges.Add(new(operation, prev, next));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, prev, next, asServer);
                else
                    _clientOnChanges.Add(new(operation, prev, next));
            }
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<ChangeData> collection = (asServer) ? _serverOnChanges : _clientOnChanges;

            if (OnChange != null)
            {
                foreach (ChangeData item in collection)
                    OnChange.Invoke(item.Operation, item.Previous, item.Next, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Sets updateTime to current values.
        /// </summary>
        private void SetUpdateTime()
        {
            _updateTime = Time.unscaledTime;
        }

        /// <summary>
        /// Removes time passed from Remaining since the last unscaled time using this method.
        /// </summary>
        public void Update()
        {
            float delta = (Time.unscaledTime - _updateTime);
            Update(delta);
        }

        /// <summary>
        /// Removes delta from Remaining for server and client.
        /// This also resets unscaledTime delta for Update().
        /// </summary>
        /// <param name="delta">Value to remove from Remaining.</param>
        public void Update(float delta)
        {
            //Not enabled.
            if (Remaining <= 0f)
                return;
            if (Paused)
                return;

            SetUpdateTime();
            if (delta < 0)
                delta *= -1f;
            float prev = Remaining;
            Remaining -= delta;
            //Still time left.
            if (Remaining > 0f)
                return;

            /* If here then the timer has
             * ended. Invoking the events is tricky
             * here because both the server and the client
             * would share the same value. Because of this check
             * if each socket is started and if so invoke for that
             * side. There's a chance down the road this may need to be improved
             * for some but at this time I'm unable to think of any
             * problems. */
            Remaining = 0f;
            if (base.NetworkManager.IsServerStarted)
                OnChange?.Invoke(SyncTimerOperation.Finished, prev, 0f, true);
            if (base.NetworkManager.IsClientStarted)
                OnChange?.Invoke(SyncTimerOperation.Finished, prev, 0f, false);
        }

        /// <summary>
        /// Return the serialized type.
        /// </summary>
        /// <returns></returns>
        public object GetSerializedType() => null;
    }
}
#endif﻿namespace FishNet.Object.Synchronizing
{
    public enum SyncTimerOperation : byte
    {
        /// <summary>
        /// Timer is started. Value is included with start.
        /// </summary>
        Start = 1,
        /// <summary>
        /// Timer was paused.
        /// </summary>
        Pause = 2,
        /// <summary>
        /// Timer was paused. Value at time of pause is sent.
        /// </summary>
        PauseUpdated = 3,
        /// <summary>
        /// Timer was unpaused.
        /// </summary>
        Unpause = 4,
        /// <summary>
        /// Timer was stopped.
        /// </summary>
        Stop = 6,
        /// <summary>
        /// Timer was stopped. Value prior to stopping is sent.
        /// </summary>
        StopUpdated = 7,
        /// <summary>
        /// The timer has ended finished it's duration.
        /// </summary>
        Finished = 8,
        /// <summary>
        /// All operations for the tick have been processed. This only occurs on clients as the server is unable to be aware of when the user is done modifying the list.
        /// </summary>
        Complete = 9,
    }
}using FishNet.Transporting;

namespace FishNet.Object.Synchronizing
{
    /// <summary>
    /// Settings which can be passed into SyncTypes.
    /// </summary>
    [System.Serializable]
    public struct SyncTypeSettings
    {
        public WritePermission WritePermission;
        public ReadPermission ReadPermission;
        public float SendRate;
        public Channel Channel;

        internal bool IsDefault()
        {
            return (WritePermission == WritePermission.ServerOnly && ReadPermission == ReadPermission.Observers
                && SendRate == 0f && Channel == (Channel)0);
        }

        //Work around for C# parameterless struct limitation.
        public SyncTypeSettings(float sendRate = 0.1f)
        {
            WritePermission = WritePermission.ServerOnly;
            ReadPermission = ReadPermission.Observers;
            SendRate = sendRate;
            Channel = Channel.Reliable;
        }

        public SyncTypeSettings(float sendRate, Channel channel)
        {
            WritePermission = WritePermission.ServerOnly;
            ReadPermission = ReadPermission.Observers;
            SendRate = sendRate;
            Channel = channel;
        }

        public SyncTypeSettings(Channel channel)
        {
            WritePermission = WritePermission.ServerOnly;
            ReadPermission = ReadPermission.Observers;
            SendRate = 0.1f;
            Channel = channel;
        }

        public SyncTypeSettings(WritePermission writePermissions)
        {

            WritePermission = writePermissions;
            ReadPermission = ReadPermission.Observers;
            SendRate = 0.1f;
            Channel = Channel.Reliable;
        }

        public SyncTypeSettings(ReadPermission readPermissions)
        {
            WritePermission = WritePermission.ServerOnly;
            ReadPermission = readPermissions;
            SendRate = 0.1f;
            Channel = Channel.Reliable;
        }

        public SyncTypeSettings(WritePermission writePermissions, ReadPermission readPermissions)
        {

            WritePermission = writePermissions;
            ReadPermission = readPermissions;
            SendRate = 0.1f;
            Channel = Channel.Reliable;
        }

        public SyncTypeSettings(WritePermission writePermissions, ReadPermission readPermissions, float sendRate, Channel channel)
        {
                
            WritePermission = writePermissions;
            ReadPermission = readPermissions;
            SendRate = sendRate;
            Channel = channel;
        }
    }
}
namespace FishNet.Object.Synchronizing
{
    [System.Flags]
    internal enum SyncTypeWriteFlag
    {
        Unset = 0,
        IgnoreInterval = 1,
        ForceReliable = 2,
    }

    internal static class SyncTypeWriteFlagExtensions
    {
        public static bool FastContains(this SyncTypeWriteFlag whole, SyncTypeWriteFlag part) => (whole & part) == part;
    }
}
﻿#if FISHNET_STABLE_SYNCTYPES
using FishNet.CodeGenerating;
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Object.Helping;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using UnityEngine;

namespace FishNet.Object.Synchronizing
{

    internal interface ISyncVar { }

    [APIExclude]
    [System.Serializable]
    [StructLayout(LayoutKind.Auto, CharSet = CharSet.Auto)]
    public class SyncVar<T> : SyncBase, ISyncVar
    {
        #region Types.
        public struct InterpolationContainer
        {
            /// <summary>
            /// Value prior to setting new.
            /// </summary>
            public T LastValue;
            /// <summary>
            /// Tick when LastValue was set.
            /// </summary>
            public float UpdateTime;

            public void Update(T prevValue)
            {
                LastValue = prevValue;
                UpdateTime = Time.unscaledTime;
            }
        }

        /// <summary>
        /// Information needed to invoke a callback.
        /// </summary>
        private struct CachedOnChange
        {
            internal readonly T Previous;
            internal readonly T Next;

            public CachedOnChange(T previous, T next)
            {
                Previous = previous;
                Next = next;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Value interpolated between last received and current.
        /// </summary>
        /// <param name="useCurrentValue">True if to ignore interpolated calculations and use the current value.
        /// This can be useful if you are able to write this SyncVars values in update.
        /// </param>
        public T InterpolatedValue(bool useCurrentValue = false)
        {
            if (useCurrentValue)
                return _value;

            float diff = (Time.unscaledTime - _interpolator.UpdateTime);
            float percent = Mathf.InverseLerp(0f, base.Settings.SendRate, diff);

            return Interpolate(_interpolator.LastValue, _value, percent);
        }

        /// <summary>
        /// Gets and sets the current value for this SyncVar.
        /// </summary>
        public T Value
        {
            get => _value;
            set => SetValue(value, true);
        }
        ///// <summary>
        ///// Sets the current value for this SyncVar while sending it immediately.
        ///// </summary>
        //public T ValueRpc
        //{
        //    set => SetValue(value, true, true);
        //}
        ///// <summary>
        ///// Gets the current value for this SyncVar while marking it dirty. This could be useful to change properties or fields on a reference type SyncVar and have the SyncVar be dirtied after.
        ///// </summary>
        //public T ValueDirty
        //{
        //    get
        //    {
        //        base.Dirty();
        //        return _value;
        //    }
        //}
        ///// <summary>
        ///// Gets the current value for this SyncVar while sending it imediately. This could be useful to change properties or fields on a reference type SyncVar and have the SyncVar send after.
        ///// </summary>
        //public T ValueDirtyRpc
        //{
        //    get
        //    {
        //        base.Dirty(true);
        //        return _value;
        //    }
        //}
        /// <summary>
        /// Called when the SyncDictionary changes.
        /// </summary>
        public event OnChanged OnChange;
        public delegate void OnChanged(T prev, T next, bool asServer);
        #endregion

        #region Private.
        /// <summary>
        /// Server OnChange event waiting for start callbacks.
        /// </summary>
        private CachedOnChange? _serverOnChange;
        /// <summary>
        /// Client OnChange event waiting for start callbacks.
        /// </summary>
        private CachedOnChange? _clientOnChange;
        /// <summary>
        /// Value before the network is initialized on the containing object.
        /// </summary>
        private T _initialValue;
        /// <summary>
        /// Previous value on the client.
        /// </summary>
        private T _previousClientValue;
        /// <summary>
        /// Current value on the server, or client.
        /// </summary>
        [SerializeField]
        private T _value;
        /// <summary>
        /// Holds information about interpolating between values.
        /// </summary>
        private InterpolationContainer _interpolator = new();
        /// <summary>
        /// True if T IsValueType.
        /// </summary>
        private bool _isValueType;
        /// <summary>
        /// True if value was ever set after the SyncType initialized.
        /// This is true even if SetInitialValues was called at runtime.
        /// </summary>
        private bool _valueSetAfterInitialized;
        #endregion

        #region Constructors.
        public SyncVar(SyncTypeSettings settings = new()) : this(default(T), settings) { }
        public SyncVar(T initialValue, SyncTypeSettings settings = new()) : base(settings) => SetInitialValues(initialValue);
        #endregion

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Initialized()
        {
            base.Initialized();
            _isValueType = typeof(T).IsValueType;
            _initialValue = _value;
        }

        /// <summary>
        /// Sets initial values.
        /// Initial values are not automatically synchronized, as it is assumed clients and server already have them set to the specified value.
        /// When a SyncVar is reset, such as when the object despawns, current values are set to initial values.
        /// </summary>
        public void SetInitialValues(T value)
        {
            _initialValue = value;
            UpdateValues(value, true);

            if (base.IsInitialized)
                _valueSetAfterInitialized = true;
        }
        /// <summary>
        /// Sets current and previous values.
        /// </summary>
        /// <param name="next"></param>
        private void UpdateValues(T next, bool updateClient)
        {
            if (updateClient)
                _previousClientValue = next;

            //If network initialized then update interpolator.
            if (base.IsNetworkInitialized)
                _interpolator.Update(_value);

            _value = next;
        }
        /// <summary>
        /// Sets current value and marks the SyncVar dirty when able to. Returns if able to set value.
        /// </summary>
        /// <param name="calledByUser">True if SetValue was called in response to user code. False if from automated code.</param>
        
        internal void SetValue(T nextValue, bool calledByUser, bool sendRpc = false)
        {
            /* IsInitialized is only set after the script containing this SyncVar
             * has executed our codegen in the beginning of awake, and after awake
             * user logic. When not set update the initial values */
            if (!base.IsInitialized)
            {
                SetInitialValues(nextValue);
                return;
            }
            else
            {
                _valueSetAfterInitialized = true;
            }

            /* If not client or server then set skipChecks
             * as true. When neither is true it's likely user is changing
             * value before object is initialized. This is allowed
             * but checks cannot be processed because they would otherwise
             * stop setting the value. */
            bool isNetworkInitialized = base.IsNetworkInitialized;

            //Object is deinitializing.
            if (isNetworkInitialized && CodegenHelper.NetworkObject_Deinitializing(this.NetworkBehaviour))
                return;

            //If being set by user code.
            if (calledByUser)
            {
                if (!base.CanNetworkSetValues(true))
                    return;
                /* We will only be this far if the network is not active yet,
                 * server is active, or client has setting permissions. 
                 * We only need to set asServerInvoke to false if the network
                 * is initialized and the server is not active. */
                bool asServerInvoke = CanInvokeCallbackAsServer();

                /* If the network has not been network initialized then
                 * Value is expected to be set on server and client since
                 * it's being set before the object is initialized. */
                if (!isNetworkInitialized)
                {
                    T prev = _value;
                    UpdateValues(nextValue, false);
                    //Still call invoke because change will be cached for when the network initializes.
                    InvokeOnChange(prev, _value, calledByUser);
                }
                else
                {
                    if (Comparers.EqualityCompare(_value, nextValue))
                        return;

                    T prev = _value;
                    UpdateValues(nextValue, false);
                    InvokeOnChange(prev, _value, asServerInvoke);
                }

                TryDirty(asServerInvoke);
            }
            //Not called by user.
            else
            {
                /* Previously clients were not allowed to set values
                 * but this has been changed because clients may want
                 * to update values locally while occasionally
                 * letting the syncvar adjust their side. */
                T prev = _previousClientValue;
                if (Comparers.EqualityCompare(prev, nextValue))
                    return;
                /* If also server do not update value.
                 * Server side has say of the current value. */
                if (base.NetworkManager.IsServerStarted)
                    _previousClientValue = nextValue;
                /* If server is not started then update both. */
                else
                    UpdateValues(nextValue, true);

                InvokeOnChange(prev, nextValue, calledByUser);
            }


            /* Tries to dirty so update
             * is sent over network. This needs to be called
             * anytime the data changes because there is no way
             * to know if the user set the value on both server
             * and client or just one side. */
            void TryDirty(bool asServer)
            {
                //Cannot dirty when network is not initialized.
                if (!isNetworkInitialized)
                    return;

                if (asServer)
                    base.Dirty();
                //base.Dirty(sendRpc);
            }
        }

        /// <summary>
        /// Returns interpolated values between previous and current using a percentage.
        /// </summary>
        protected virtual T Interpolate(T previous, T current, float percent)
        {
            base.NetworkManager.LogError($"Type {typeof(T).FullName} does not support interpolation. Implement a supported type class or create your own. See class FloatSyncVar for an example.");
            return default;
        }

        /// <summary>
        /// True if callback can be invoked with asServer true.
        /// </summary>
        /// <returns></returns>
        private bool AsServerInvoke() => (!base.IsNetworkInitialized || base.NetworkBehaviour.IsServerStarted);

        /// <summary>
        /// Dirties the the syncVar for a full send.
        /// </summary>
        public void DirtyAll()
        {
            if (!base.IsInitialized)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            base.Dirty();
            /* Invoke even if was unable to dirty. Dirtying only
             * becomes true if server is running, but also if there are
             * observers. Even if there are not observers we still want
             * to invoke for the server side. */
            //todo: this behaviour needs to be done for all synctypes with dirt/dirtyall.
            bool asServerInvoke = CanInvokeCallbackAsServer();
            InvokeOnChange(_value, _value, asServerInvoke);
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(T prev, T next, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(prev, next, asServer);
                else
                    _serverOnChange = new CachedOnChange(prev, next);
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(prev, next, asServer);
                else
                    _clientOnChange = new CachedOnChange(prev, next);
            }
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        
        [MakePublic]
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);

            if (OnChange != null)
            {
                CachedOnChange? change = (asServer) ? _serverOnChange : _clientOnChange;
                if (change != null)
                    InvokeOnChange(change.Value.Previous, change.Value.Next, asServer);
            }

            if (asServer)
                _serverOnChange = null;
            else
                _clientOnChange = null;
        }

        /// <summary>
        /// Writes current value.
        /// </summary>
        /// <param name="resetSyncTick">True to set the next time data may sync.</param>
        [MakePublic]
        protected internal override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            base.WriteDelta(writer, resetSyncTick);
            writer.Write(_value);
        }

        /// <summary>
        /// Writes current value if not initialized value.
        /// </summary>m>
        [MakePublic]
        protected internal override void WriteFull(PooledWriter obj0)
        {
            /* If a class then skip comparer check.
             * InitialValue and Value will be the same reference.
             * 
             * If a value then compare field changes, since the references
             * will not be the same. */
            //Compare if a value type.
            if (_isValueType)
            {
                if (Comparers.EqualityCompare(_initialValue, _value))
                    return;
            }
            else
            {
                if (!_valueSetAfterInitialized)
                    return;
            }
            /* SyncVars only hold latest value, so just
             * write current delta. */
            WriteDelta(obj0, false);
        }

        /// <summary>
        /// Reads a SyncVar value.
        /// </summary>
        protected internal override void Read(PooledReader reader, bool asServer)
        {
            T value = reader.Read<T>();
            
            if (!ReadChangeId(reader))
                return;
            
            SetValue(value, false);
            //TODO this needs to separate invokes from setting values so that syncvar can be written like remainder of synctypes.
        }
        
        //SyncVars do not use changeId.
        [APIExclude]
        protected override bool ReadChangeId(Reader reader) => true;

        //SyncVars do not use changeId.
        [APIExclude]
        protected override void WriteChangeId(PooledWriter writer) { }

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        [MakePublic]
        protected internal override void ResetState(bool asServer)
        {
            base.ResetState(asServer);
            /* Only full reset under the following conditions:
             * asServer is true.
             * Is not network initialized.
             * asServer is false, and server is not started. */
            bool clientStarted = (base.IsNetworkInitialized && base.NetworkManager.IsClientStarted);
            if ((asServer && !clientStarted) || (!asServer && base.NetworkBehaviour.IsDeinitializing))
            {
                _value = _initialValue;
                _previousClientValue = _initialValue;
                _valueSetAfterInitialized = false;
            }
        }
    }
}
#endifnamespace FishNet.Object.Synchronizing
{
    /// <summary>
    /// Which clients or server may write updates.
    /// </summary>
    public enum WritePermission : byte
    {
        /// <summary>
        /// Only the server can change the value of the SyncType.
        /// </summary>
        ServerOnly = 0,
        /// <summary>
        /// Server and clients can change the value of the SyncType. When changed by client the value is not sent to the server.
        /// </summary>
        ClientUnsynchronized = 1,
    }
}﻿#if !FISHNET_STABLE_SYNCTYPES
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using GameKit.Dependencies.Utilities;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace FishNet.Object.Synchronizing
{
    [System.Serializable]
    public class SyncDictionary<TKey, TValue> : SyncBase, IDictionary<TKey, TValue>, IReadOnlyDictionary<TKey, TValue>
    {
        #region Types.
        /// <summary>
        /// Information needed to invoke a callback.
        /// </summary>
        private struct CachedOnChange
        {
            internal readonly SyncDictionaryOperation Operation;
            internal readonly TKey Key;
            internal readonly TValue Value;

            public CachedOnChange(SyncDictionaryOperation operation, TKey key, TValue value)
            {
                Operation = operation;
                Key = key;
                Value = value;
            }
        }

        /// <summary>
        /// Information about how the collection has changed.
        /// </summary>
        private struct ChangeData
        {
            internal readonly SyncDictionaryOperation Operation;
            internal readonly TKey Key;
            internal readonly TValue Value;

            public ChangeData(SyncDictionaryOperation operation, TKey key, TValue value)
            {
                this.Operation = operation;
                this.Key = key;
                this.Value = value;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Implementation from Dictionary<TKey,TValue>. Not used.
        /// </summary>
        [APIExclude]
        public bool IsReadOnly => false;

        /// <summary>
        /// Delegate signature for when SyncDictionary changes.
        /// </summary>
        /// <param name="op">Operation being completed, such as Add, Set, Remove.</param>
        /// <param name="key">Key being modified.</param>
        /// <param name="value">Value of operation.</param>
        /// <param name="asServer">True if callback is on the server side. False is on the client side.</param>
        [APIExclude]
        public delegate void SyncDictionaryChanged(SyncDictionaryOperation op, TKey key, TValue value, bool asServer);

        /// <summary>
        /// Called when the SyncDictionary changes.
        /// </summary>
        public event SyncDictionaryChanged OnChange;
        /// <summary>
        /// Collection of objects.
        /// </summary>
        public Dictionary<TKey, TValue> Collection;
        /// <summary>
        /// Number of objects in the collection.
        /// </summary>
        public int Count => Collection.Count;
        /// <summary>
        /// Keys within the collection.
        /// </summary>
        public ICollection<TKey> Keys => Collection.Keys;
        [APIExclude]
        IEnumerable<TKey> IReadOnlyDictionary<TKey, TValue>.Keys => Collection.Keys;
        /// <summary>
        /// Values within the collection.
        /// </summary>
        public ICollection<TValue> Values => Collection.Values;
        [APIExclude]
        IEnumerable<TValue> IReadOnlyDictionary<TKey, TValue>.Values => Collection.Values;
        #endregion

        #region Private.
        /// <summary>
        /// Initial values for the dictionary.
        /// </summary>
        private Dictionary<TKey, TValue> _initialValues = new();
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private List<ChangeData> _changed = new();
        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private List<CachedOnChange> _serverOnChanges = new();
        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private List<CachedOnChange> _clientOnChanges = new();
        /// <summary>
        /// True if values have changed since initialization.
        /// The only reasonable way to reset this during a Reset call is by duplicating the original list and setting all values to it on reset.
        /// </summary>
        private bool _valuesChanged;
        /// <summary>
        /// True to send all values in the next WriteDelta.
        /// </summary>
        private bool _sendAll;
        #endregion

        #region Constructors.
        public SyncDictionary(SyncTypeSettings settings = new()) : this(CollectionCaches<TKey, TValue>.RetrieveDictionary(), settings) { }

        public SyncDictionary(Dictionary<TKey, TValue> collection, SyncTypeSettings settings = new()) : base(settings)
        {
            Collection = (collection == null) ? CollectionCaches<TKey, TValue>.RetrieveDictionary() : collection;
            _initialValues = CollectionCaches<TKey, TValue>.RetrieveDictionary();
            _changed = CollectionCaches<ChangeData>.RetrieveList();
            _serverOnChanges = CollectionCaches<CachedOnChange>.RetrieveList();
            _clientOnChanges = CollectionCaches<CachedOnChange>.RetrieveList();
        }
        #endregion

        #region Deconstructor.
        ~SyncDictionary()
        {
            CollectionCaches<TKey, TValue>.StoreAndDefault(ref Collection);
            CollectionCaches<TKey, TValue>.StoreAndDefault(ref _initialValues);
            CollectionCaches<ChangeData>.StoreAndDefault(ref _changed);
            CollectionCaches<CachedOnChange>.StoreAndDefault(ref _serverOnChanges);
            CollectionCaches<CachedOnChange>.StoreAndDefault(ref _clientOnChanges);
        }
        #endregion

        /// <summary>
        /// Gets the collection being used within this SyncList.
        /// </summary>
        /// <param name="asServer">True if returning the server value, false if client value. The values will only differ when running as host. While asServer is true the most current values on server will be returned, and while false the latest values received by client will be returned.</param>
        /// <returns>The used collection.</returns>
        public Dictionary<TKey, TValue> GetCollection(bool asServer)
        {
            return Collection;
        }

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Initialized()
        {
            base.Initialized();

            //Initialize collections if needed. OdinInspector can cause them to become deinitialized.
#if ODIN_INSPECTOR
            if (_initialValues == null) _initialValues = new();
            if (_changed == null) _changed = new();
            if (_serverOnChanges == null) _serverOnChanges = new();
            if (_clientOnChanges == null) _clientOnChanges = new();
#endif

            foreach (KeyValuePair<TKey, TValue> item in Collection)
                _initialValues[item.Key] = item.Value;
        }

        /// <summary>
        /// Adds an operation and invokes callback locally.
        /// Internal use.
        /// May be used for custom SyncObjects.
        /// </summary>
        /// <param name="operation"></param>
        /// <param name="key"></param>
        /// <param name="value"></param>
        [APIExclude]
        private void AddOperation(SyncDictionaryOperation operation, TKey key, TValue value)
        {
            if (!base.IsInitialized)
                return;

            /* asServer might be true if the client is setting the value
             * through user code. Typically synctypes can only be set
             * by the server, that's why it is assumed asServer via user code.
             * However, when excluding owner for the synctype the client should
             * have permission to update the value locally for use with
             * prediction. */
            bool asServerInvoke = (!base.IsNetworkInitialized || base.NetworkBehaviour.IsServerStarted);

            if (asServerInvoke)
            {
                _valuesChanged = true;
                if (base.Dirty())
                {
                    ChangeData change = new(operation, key, value);
                    _changed.Add(change);
                }
            }

            InvokeOnChange(operation, key, value, asServerInvoke);
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<CachedOnChange> collection = (asServer) ? _serverOnChanges : _clientOnChanges;

            if (OnChange != null)
            {
                foreach (CachedOnChange item in collection)
                    OnChange.Invoke(item.Operation, item.Key, item.Value, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Writes all changed values.
        /// Internal use.
        /// May be used for custom SyncObjects.
        /// </summary>
        /// <param name="writer"></param>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        [APIExclude]
        protected internal override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            //If sending all then clear changed and write full.
            if (_sendAll)
            {
                _sendAll = false;
                _changed.Clear();
                WriteFull(writer);
            }
            else
            {
                base.WriteDelta(writer, resetSyncTick);

                //False for not full write.
                writer.WriteBoolean(false);

                writer.WriteInt32(_changed.Count);

                for (int i = 0; i < _changed.Count; i++)
                {
                    ChangeData change = _changed[i];
                    writer.WriteUInt8Unpacked((byte)change.Operation);

                    //Clear does not need to write anymore data so it is not included in checks.
                    if (change.Operation == SyncDictionaryOperation.Add || change.Operation == SyncDictionaryOperation.Set)
                    {
                        writer.Write(change.Key);
                        writer.Write(change.Value);
                    }
                    else if (change.Operation == SyncDictionaryOperation.Remove)
                    {
                        writer.Write(change.Key);
                    }
                }

                _changed.Clear();
            }
        }

        /// <summary>
        /// Writers all values if not initial values.
        /// Internal use.
        /// May be used for custom SyncObjects.
        /// </summary>
        /// <param name="writer"></param>
        [APIExclude]
        protected internal override void WriteFull(PooledWriter writer)
        {
            if (!_valuesChanged)
                return;

            base.WriteHeader(writer, false);

            //True for full write.
            writer.WriteBoolean(true);

            writer.WriteInt32(Collection.Count);
            foreach (KeyValuePair<TKey, TValue> item in Collection)
            {
                writer.WriteUInt8Unpacked((byte)SyncDictionaryOperation.Add);
                writer.Write(item.Key);
                writer.Write(item.Value);
            }
        }

        /// <summary>
        /// Reads and sets the current values for server or client.
        /// </summary>
        [APIExclude]
        protected internal override void Read(PooledReader reader, bool asServer)
        {
            base.SetReadArguments(reader, asServer, out bool newChangeId, out bool asClientHost, out bool canModifyValues);

            //True to warn if this object was deinitialized on the server.
            bool deinitialized = (asClientHost && !base.OnStartServerCalled);
            if (deinitialized)
                base.NetworkManager.LogWarning($"SyncType {GetType().Name} received a Read but was deinitialized on the server. Client callback values may be incorrect. This is a ClientHost limitation.");

            IDictionary<TKey, TValue> collection = Collection;

            bool fullWrite = reader.ReadBoolean();

            //Clear collection since it's a full write.
            if (canModifyValues && fullWrite)
                collection.Clear();

            int changes = reader.ReadInt32();
            for (int i = 0; i < changes; i++)
            {
                SyncDictionaryOperation operation = (SyncDictionaryOperation)reader.ReadUInt8Unpacked();
                TKey key = default;
                TValue value = default;

                /* Add, Set.
                 * Use the Set code for add and set,
                 * especially so collection doesn't throw
                 * if entry has already been added. */
                if (operation == SyncDictionaryOperation.Add || operation == SyncDictionaryOperation.Set)
                {
                    key = reader.Read<TKey>();
                    value = reader.Read<TValue>();

                    if (canModifyValues)
                        collection[key] = value;
                }
                //Clear.
                else if (operation == SyncDictionaryOperation.Clear)
                {
                    if (canModifyValues)
                        collection.Clear();
                }
                //Remove.
                else if (operation == SyncDictionaryOperation.Remove)
                {
                    key = reader.Read<TKey>();

                    if (canModifyValues)
                        collection.Remove(key);
                }

                if (newChangeId)
                    InvokeOnChange(operation, key, value, false);
            }

            //If changes were made invoke complete after all have been read.
            if (newChangeId && changes > 0)
                InvokeOnChange(SyncDictionaryOperation.Complete, default, default, false);
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncDictionaryOperation operation, TKey key, TValue value, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, key, value, asServer);
                else
                    _serverOnChanges.Add(new(operation, key, value));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, key, value, asServer);
                else
                    _clientOnChanges.Add(new(operation, key, value));
            }
        }

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        [APIExclude]
        protected internal override void ResetState(bool asServer)
        {
            base.ResetState(asServer);

            if (base.CanReset(asServer))
            {
                _sendAll = false;
                _changed.Clear();
                Collection.Clear();
                _valuesChanged = false;

                foreach (KeyValuePair<TKey, TValue> item in _initialValues)
                    Collection[item.Key] = item.Value;
            }
        }

        /// <summary>
        /// Adds item.
        /// </summary>
        /// <param name="item">Item to add.</param>
        public void Add(KeyValuePair<TKey, TValue> item)
        {
            Add(item.Key, item.Value);
        }

        /// <summary>
        /// Adds key and value.
        /// </summary>
        /// <param name="key">Key to add.</param>
        /// <param name="value">Value for key.</param>
        public void Add(TKey key, TValue value)
        {
            Add(key, value, true);
        }

        private void Add(TKey key, TValue value, bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            Collection.Add(key, value);
            if (asServer)
                AddOperation(SyncDictionaryOperation.Add, key, value);
        }

        /// <summary>
        /// Clears all values.
        /// </summary>
        public void Clear()
        {
            Clear(true);
        }

        private void Clear(bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            Collection.Clear();
            if (asServer)
                AddOperation(SyncDictionaryOperation.Clear, default, default);
        }

        /// <summary>
        /// Returns if key exist.
        /// </summary>
        /// <param name="key">Key to use.</param>
        /// <returns>True if found.</returns>
        public bool ContainsKey(TKey key)
        {
            return Collection.ContainsKey(key);
        }

        /// <summary>
        /// Returns if item exist.
        /// </summary>
        /// <param name="item">Item to use.</param>
        /// <returns>True if found.</returns>
        public bool Contains(KeyValuePair<TKey, TValue> item)
        {
            return TryGetValue(item.Key, out TValue value) && EqualityComparer<TValue>.Default.Equals(value, item.Value);
        }

        /// <summary>
        /// Copies collection to an array.
        /// </summary>
        /// <param name="array">Array to copy to.</param>
        /// <param name="offset">Offset of array data is copied to.</param>
        public void CopyTo([NotNull] KeyValuePair<TKey, TValue>[] array, int offset)
        {
            if (offset <= -1 || offset >= array.Length)
            {
                base.NetworkManager.LogError($"Index is out of range.");
                return;
            }

            int remaining = array.Length - offset;
            if (remaining < Count)
            {
                base.NetworkManager.LogError($"Array is not large enough to copy data. Array is of length {array.Length}, index is {offset}, and number of values to be copied is {Count.ToString()}.");
                return;
            }

            int i = offset;
            foreach (KeyValuePair<TKey, TValue> item in Collection)
            {
                array[i] = item;
                i++;
            }
        }

        /// <summary>
        /// Removes a key.
        /// </summary>
        /// <param name="key">Key to remove.</param>
        /// <returns>True if removed.</returns>
        public bool Remove(TKey key)
        {
            if (!base.CanNetworkSetValues(true))
                return false;

            if (Collection.Remove(key))
            {
                AddOperation(SyncDictionaryOperation.Remove, key, default);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Removes an item.
        /// </summary>
        /// <param name="item">Item to remove.</param>
        /// <returns>True if removed.</returns>
        public bool Remove(KeyValuePair<TKey, TValue> item)
        {
            return Remove(item.Key);
        }

        /// <summary>
        /// Tries to get value from key.
        /// </summary>
        /// <param name="key">Key to use.</param>
        /// <param name="value">Variable to output to.</param>
        /// <returns>True if able to output value.</returns>
        public bool TryGetValue(TKey key, out TValue value)
        {
            return Collection.TryGetValueIL2CPP(key, out value);
        }

        /// <summary>
        /// Gets or sets value for a key.
        /// </summary>
        /// <param name="key">Key to use.</param>
        /// <returns>Value when using as Get.</returns>
        public TValue this[TKey key]
        {
            get => Collection[key];
            set
            {
                if (!base.CanNetworkSetValues(true))
                    return;

                Collection[key] = value;
                AddOperation(SyncDictionaryOperation.Set, key, value);
            }
        }

        /// <summary>
        /// Dirties the entire collection forcing a full send.
        /// </summary>
        public void DirtyAll()
        {
            if (!base.IsInitialized)
                return;
            if (!base.CanNetworkSetValues(log: true))
                return;

            if (base.Dirty())
                _sendAll = true;
        }

        /// <summary>
        /// Dirties an entry by key.
        /// </summary>
        /// <param name="key">Key to dirty.</param>
        public void Dirty(TKey key)
        {
            if (!base.IsInitialized)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            if (Collection.TryGetValueIL2CPP(key, out TValue value))
                AddOperation(SyncDictionaryOperation.Set, key, value);
        }

        /// <summary>
        /// Dirties an entry by value.
        /// This operation can be very expensive, will cause allocations, and may fail if your value cannot be compared.
        /// </summary>
        /// <param name="value">Value to dirty.</param>
        /// <returns>True if value was found and marked dirty.</returns>
        public bool Dirty(TValue value, EqualityComparer<TValue> comparer = null)
        {
            if (!base.IsInitialized)
                return false;
            if (!base.CanNetworkSetValues(true))
                return false;

            if (comparer == null)
                comparer = EqualityComparer<TValue>.Default;

            foreach (KeyValuePair<TKey, TValue> item in Collection)
            {
                if (comparer.Equals(item.Value, value))
                {
                    AddOperation(SyncDictionaryOperation.Set, item.Key, value);
                    return true;
                }
            }

            //Not found.
            return false;
        }

        /// <summary>
        /// Gets the IEnumerator for the collection.
        /// </summary>
        /// <returns></returns>
        public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() => Collection.GetEnumerator();

        /// <summary>
        /// Gets the IEnumerator for the collection.
        /// </summary>
        /// <returns></returns>
        IEnumerator IEnumerable.GetEnumerator() => Collection.GetEnumerator();
    }
}
#endif﻿#if !FISHNET_STABLE_SYNCTYPES
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using GameKit.Dependencies.Utilities;
using System.Collections;
using System.Collections.Generic;

namespace FishNet.Object.Synchronizing
{
    [System.Serializable]
    public class SyncHashSet<T> : SyncBase, ISet<T>
    {
        #region Types.
        /// <summary>
        /// Information needed to invoke a callback.
        /// </summary>
        private struct CachedOnChange
        {
            internal readonly SyncHashSetOperation Operation;
            internal readonly T Item;

            public CachedOnChange(SyncHashSetOperation operation, T item)
            {
                Operation = operation;
                Item = item;
            }
        }

        /// <summary>
        /// Information about how the collection has changed.
        /// </summary>
        private struct ChangeData
        {
            internal readonly SyncHashSetOperation Operation;
            internal readonly T Item;

            public ChangeData(SyncHashSetOperation operation, T item)
            {
                Operation = operation;

                Item = item;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Implementation from List<T>. Not used.
        /// </summary>
        [APIExclude]
        public bool IsReadOnly => false;

        /// <summary>
        /// Delegate signature for when SyncList changes.
        /// </summary>
        /// <param name="op">Type of change.</param>
        /// <param name="item">Item which was modified.</param>
        /// <param name="asServer">True if callback is occuring on the server.</param>
        [APIExclude]
        public delegate void SyncHashSetChanged(SyncHashSetOperation op, T item, bool asServer);

        /// <summary>
        /// Called when the SyncList changes.
        /// </summary>
        public event SyncHashSetChanged OnChange;
        /// <summary>
        /// Collection of objects.
        /// </summary>
        public HashSet<T> Collection;
        /// <summary>
        /// Number of objects in the collection.
        /// </summary>
        public int Count => Collection.Count;
        #endregion

        #region Private.
        /// <summary>
        /// ListCache for comparing.
        /// </summary>
        private static List<T> _cache = new();
        /// <summary>
        /// Values upon initialization.
        /// </summary>
        private HashSet<T> _initialValues;
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private List<ChangeData> _changed;
        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private List<CachedOnChange> _serverOnChanges;
        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private List<CachedOnChange> _clientOnChanges;
        /// <summary>
        /// Comparer to see if entries change when calling public methods.
        /// //Not used right now.
        /// </summary>
        private readonly IEqualityComparer<T> _comparer;
        /// <summary>
        /// True if values have changed since initialization.
        /// The only reasonable way to reset this during a Reset call is by duplicating the original list and setting all values to it on reset.
        /// </summary>
        private bool _valuesChanged;
        /// <summary>
        /// True to send all values in the next WriteDelta.
        /// </summary>
        private bool _sendAll;
        #endregion

        #region Constructors.
        public SyncHashSet(SyncTypeSettings settings = new()) : this(CollectionCaches<T>.RetrieveHashSet(), EqualityComparer<T>.Default, settings) { }
        public SyncHashSet(IEqualityComparer<T> comparer, SyncTypeSettings settings = new()) : this(CollectionCaches<T>.RetrieveHashSet(), (comparer == null) ? EqualityComparer<T>.Default : comparer, settings) { }

        public SyncHashSet(HashSet<T> collection, IEqualityComparer<T> comparer = null, SyncTypeSettings settings = new()) : base(settings)
        {
            _comparer = (comparer == null) ? EqualityComparer<T>.Default : comparer;
            Collection = (collection == null) ? CollectionCaches<T>.RetrieveHashSet() : collection;

            _initialValues = CollectionCaches<T>.RetrieveHashSet();
            _changed = CollectionCaches<ChangeData>.RetrieveList();
            _serverOnChanges = CollectionCaches<CachedOnChange>.RetrieveList();
            _clientOnChanges = CollectionCaches<CachedOnChange>.RetrieveList();
        }
        #endregion

        #region Deconstructor.
        ~SyncHashSet()
        {
            CollectionCaches<T>.StoreAndDefault(ref Collection);
            CollectionCaches<T>.StoreAndDefault(ref _initialValues);
            CollectionCaches<ChangeData>.StoreAndDefault(ref _changed);
            CollectionCaches<CachedOnChange>.StoreAndDefault(ref _serverOnChanges);
            CollectionCaches<CachedOnChange>.StoreAndDefault(ref _clientOnChanges);
        }
        #endregion

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Initialized()
        {
            base.Initialized();

            //Initialize collections if needed. OdinInspector can cause them to become deinitialized.
#if ODIN_INSPECTOR
            if (_initialValues == null) _initialValues = new();
            if (_changed == null) _changed = new();
            if (_serverOnChanges == null) _serverOnChanges = new();
            if (_clientOnChanges == null) _clientOnChanges = new();
#endif
            foreach (T item in Collection)
                _initialValues.Add(item);
        }

        /// <summary>
        /// Gets the collection being used within this SyncList.
        /// </summary>
        /// <returns></returns>
        public HashSet<T> GetCollection(bool asServer)
        {
            return Collection;
        }

        /// <summary>
        /// Adds an operation and invokes locally.
        /// </summary>
        private void AddOperation(SyncHashSetOperation operation, T item)
        {
            if (!base.IsInitialized)
                return;

            bool asServerInvoke = (!base.IsNetworkInitialized || base.NetworkBehaviour.IsServerStarted);

            if (asServerInvoke)
            {
                _valuesChanged = true;
                if (base.Dirty())
                {
                    ChangeData change = new(operation, item);
                    _changed.Add(change);
                }
            }

            InvokeOnChange(operation, item, asServerInvoke);
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<CachedOnChange> collection = (asServer) ? _serverOnChanges : _clientOnChanges;
            if (OnChange != null)
            {
                foreach (CachedOnChange item in collection)
                    OnChange.Invoke(item.Operation, item.Item, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Writes all changed values.
        /// </summary>
        /// <param name="writer"></param>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        protected internal override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            //If sending all then clear changed and write full.
            if (_sendAll)
            {
                _sendAll = false;
                _changed.Clear();
                WriteFull(writer);
            }
            else
            {
                base.WriteDelta(writer, resetSyncTick);

                //False for not full write.
                writer.WriteBoolean(false);

                writer.WriteInt32(_changed.Count);

                for (int i = 0; i < _changed.Count; i++)
                {
                    ChangeData change = _changed[i];
                    writer.WriteUInt8Unpacked((byte)change.Operation);

                    //Clear does not need to write anymore data so it is not included in checks.
                    if (change.Operation == SyncHashSetOperation.Add || change.Operation == SyncHashSetOperation.Remove || change.Operation == SyncHashSetOperation.Update)
                    {
                        writer.Write(change.Item);
                    }
                }

                _changed.Clear();
            }
        }

        /// <summary>
        /// Writes all values if not initial values.
        /// </summary>
        /// <param name="writer"></param>
        protected internal override void WriteFull(PooledWriter writer)
        {
            if (!_valuesChanged)
                return;

            base.WriteHeader(writer, false);
            //True for full write.
            writer.WriteBoolean(true);

            int count = Collection.Count;
            writer.WriteInt32(count);
            foreach (T item in Collection)
            {
                writer.WriteUInt8Unpacked((byte)SyncHashSetOperation.Add);
                writer.Write(item);
            }
        }

        /// <summary>
        /// Reads and sets the current values for server or client.
        /// </summary>
        [APIExclude]
        protected internal override void Read(PooledReader reader, bool asServer)
        {
            base.SetReadArguments(reader, asServer, out bool newChangeId, out bool asClientHost, out bool canModifyValues);

            //True to warn if this object was deinitialized on the server.
            bool deinitialized = (asClientHost && !base.OnStartServerCalled);
            if (deinitialized)
                base.NetworkManager.LogWarning($"SyncType {GetType().Name} received a Read but was deinitialized on the server. Client callback values may be incorrect. This is a ClientHost limitation.");

            ISet<T> collection = Collection;

            bool fullWrite = reader.ReadBoolean();

            //Clear collection since it's a full write.
            if (canModifyValues && fullWrite)
                collection.Clear();

            int changes = reader.ReadInt32();
            for (int i = 0; i < changes; i++)
            {
                SyncHashSetOperation operation = (SyncHashSetOperation)reader.ReadUInt8Unpacked();
                T next = default;

                //Add.
                if (operation == SyncHashSetOperation.Add)
                {
                    next = reader.Read<T>();

                    if (canModifyValues)
                        collection.Add(next);
                }
                //Clear.
                else if (operation == SyncHashSetOperation.Clear)
                {
                    if (canModifyValues)
                        collection.Clear();
                }
                //Remove.
                else if (operation == SyncHashSetOperation.Remove)
                {
                    next = reader.Read<T>();

                    if (canModifyValues)
                        collection.Remove(next);
                }
                //Updated.
                else if (operation == SyncHashSetOperation.Update)
                {
                    next = reader.Read<T>();

                    if (canModifyValues)
                    {
                        collection.Remove(next);
                        collection.Add(next);
                    }
                }

                if (newChangeId)
                    InvokeOnChange(operation, next, false);
            }

            //If changes were made invoke complete after all have been read.
            if (newChangeId && changes > 0)
                InvokeOnChange(SyncHashSetOperation.Complete, default, false);
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncHashSetOperation operation, T item, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, item, asServer);
                else
                    _serverOnChanges.Add(new(operation, item));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, item, asServer);
                else
                    _clientOnChanges.Add(new(operation, item));
            }
        }

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        protected internal override void ResetState(bool asServer)
        {
            base.ResetState(asServer);

            if (base.CanReset(asServer))
            {
                _sendAll = false;
                _changed.Clear();
                Collection.Clear();

                foreach (T item in _initialValues)
                    Collection.Add(item);
            }
        }

        /// <summary>
        /// Adds value.
        /// </summary>
        /// <param name="item"></param>
        public bool Add(T item)
        {
            return Add(item, true);
        }

        private bool Add(T item, bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return false;

            bool result = Collection.Add(item);
            //Only process if remove was successful.
            if (result && asServer)
                AddOperation(SyncHashSetOperation.Add, item);

            return result;
        }

        /// <summary>
        /// Adds a range of values.
        /// </summary>
        /// <param name="range"></param>
        public void AddRange(IEnumerable<T> range)
        {
            foreach (T entry in range)
                Add(entry, true);
        }

        /// <summary>
        /// Clears all values.
        /// </summary>
        public void Clear()
        {
            Clear(true);
        }

        private void Clear(bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            Collection.Clear();
            if (asServer)
                AddOperation(SyncHashSetOperation.Clear, default);
        }

        /// <summary>
        /// Returns if value exist.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Contains(T item)
        {
            return Collection.Contains(item);
        }

        /// <summary>
        /// Removes a value.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Remove(T item)
        {
            return Remove(item, true);
        }

        private bool Remove(T item, bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return false;

            bool result = Collection.Remove(item);
            //Only process if remove was successful.
            if (result && asServer)
                AddOperation(SyncHashSetOperation.Remove, item);

            return result;
        }

        /// <summary>
        /// Dirties the entire collection forcing a full send.
        /// </summary>
        public void DirtyAll()
        {
            if (!base.IsInitialized)
                return;
            if (!base.CanNetworkSetValues(log: true))
                return;

            if (base.Dirty())
                _sendAll = true;
        }

        /// <summary>
        /// Looks up obj in Collection and if found marks it's index as dirty.
        /// This operation can be very expensive, will cause allocations, and may fail if your value cannot be compared.
        /// </summary>
        /// <param name="obj">Object to lookup.</param>
        public void Dirty(T obj)
        {
            if (!base.IsInitialized)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            foreach (T item in Collection)
            {
                if (item.Equals(obj))
                {
                    AddOperation(SyncHashSetOperation.Update, obj);
                    return;
                }
            }

            //Not found.
            base.NetworkManager.LogError($"Could not find object within SyncHashSet, dirty will not be set.");
        }

        /// <summary>
        /// Returns Enumerator for collection.
        /// </summary>
        /// <returns></returns>
        public IEnumerator GetEnumerator() => Collection.GetEnumerator();

        [APIExclude]
        IEnumerator<T> IEnumerable<T>.GetEnumerator() => Collection.GetEnumerator();

        [APIExclude]
        IEnumerator IEnumerable.GetEnumerator() => Collection.GetEnumerator();

        public void ExceptWith(IEnumerable<T> other)
        {
            //Again, removing from self is a clear.
            if (other == Collection)
            {
                Clear();
            }
            else
            {
                foreach (T item in other)
                    Remove(item);
            }
        }

        public void IntersectWith(IEnumerable<T> other)
        {
            ISet<T> set;
            if (other is ISet<T> setA)
                set = setA;
            else
                set = new HashSet<T>(other);

            IntersectWith(set);
        }

        private void IntersectWith(ISet<T> other)
        {
            _cache.AddRange(Collection);

            int count = _cache.Count;
            for (int i = 0; i < count; i++)
            {
                T entry = _cache[i];
                if (!other.Contains(entry))
                    Remove(entry);
            }

            _cache.Clear();
        }

        public bool IsProperSubsetOf(IEnumerable<T> other)
        {
            return Collection.IsProperSubsetOf(other);
        }

        public bool IsProperSupersetOf(IEnumerable<T> other)
        {
            return Collection.IsProperSupersetOf(other);
        }

        public bool IsSubsetOf(IEnumerable<T> other)
        {
            return Collection.IsSubsetOf(other);
        }

        public bool IsSupersetOf(IEnumerable<T> other)
        {
            return Collection.IsSupersetOf(other);
        }

        public bool Overlaps(IEnumerable<T> other)
        {
            bool result = Collection.Overlaps(other);
            return result;
        }

        public bool SetEquals(IEnumerable<T> other)
        {
            return Collection.SetEquals(other);
        }

        public void SymmetricExceptWith(IEnumerable<T> other)
        {
            //If calling except on self then that is the same as a clear.
            if (other == Collection)
            {
                Clear();
            }
            else
            {
                foreach (T item in other)
                    Remove(item);
            }
        }

        public void UnionWith(IEnumerable<T> other)
        {
            if (other == Collection)
                return;

            foreach (T item in other)
                Add(item);
        }

        /// <summary>
        /// Adds an item.
        /// </summary>
        /// <param name="item"></param>
        void ICollection<T>.Add(T item)
        {
            Add(item, true);
        }

        /// <summary>
        /// Copies values to an array.
        /// </summary>
        /// <param name="array"></param>
        /// <param name="index"></param>
        public void CopyTo(T[] array, int index)
        {
            Collection.CopyTo(array, index);
        }
    }
}
#endif﻿#if !FISHNET_STABLE_SYNCTYPES
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections;
using System.Collections.Generic;

namespace FishNet.Object.Synchronizing
{
    [System.Serializable]
    public class SyncList<T> : SyncBase, IList<T>, IReadOnlyList<T>
    {
        #region Types.
        /// <summary>
        /// Information needed to invoke a callback.
        /// </summary>
        private struct CachedOnChange
        {
            internal readonly SyncListOperation Operation;
            internal readonly int Index;
            internal readonly T Previous;
            internal readonly T Next;

            public CachedOnChange(SyncListOperation operation, int index, T previous, T next)
            {
                Operation = operation;
                Index = index;
                Previous = previous;
                Next = next;
            }
        }

        /// <summary>
        /// Information about how the collection has changed.
        /// </summary>
        private struct ChangeData
        {
            internal readonly SyncListOperation Operation;
            internal readonly int Index;
            internal readonly T Item;

            public ChangeData(SyncListOperation operation, int index, T item)
            {
                Operation = operation;
                Index = index;
                Item = item;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Implementation from List<T>. Not used.
        /// </summary>
        [APIExclude]
        public bool IsReadOnly => false;

        /// <summary>
        /// Delegate signature for when SyncList changes.
        /// </summary>
        /// <param name="op"></param>
        /// <param name="index"></param>
        /// <param name="oldItem"></param>
        /// <param name="newItem"></param>
        [APIExclude]
        public delegate void SyncListChanged(SyncListOperation op, int index, T oldItem, T newItem, bool asServer);

        /// <summary>
        /// Called when the SyncList changes.
        /// </summary>
        public event SyncListChanged OnChange;
        /// <summary>
        /// Collection of objects.
        /// </summary>
        public List<T> Collection;
        /// <summary>
        /// Number of objects in the collection.
        /// </summary>
        public int Count => Collection.Count;
        #endregion

        #region Private.
        /// <summary>
        /// Values upon initialization.
        /// </summary>
        private List<T> _initialValues;
        /// <summary>
        /// Comparer to see if entries change when calling public methods.
        /// </summary>
        private readonly IEqualityComparer<T> _comparer;
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private List<ChangeData> _changed;
        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private List<CachedOnChange> _serverOnChanges;
        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private List<CachedOnChange> _clientOnChanges;
        /// <summary>
        /// True if values have changed since initialization.
        /// The only reasonable way to reset this during a Reset call is by duplicating the original list and setting all values to it on reset.
        /// </summary>
        private bool _valuesChanged;
        /// <summary>
        /// True to send all values in the next WriteDelta.
        /// </summary>
        private bool _sendAll;
        #endregion

        #region Constructors.
        public SyncList(SyncTypeSettings settings = new()) : this(CollectionCaches<T>.RetrieveList(), EqualityComparer<T>.Default, settings) { }
        public SyncList(IEqualityComparer<T> comparer, SyncTypeSettings settings = new()) : this(new(), (comparer == null) ? EqualityComparer<T>.Default : comparer, settings) { }

        public SyncList(List<T> collection, IEqualityComparer<T> comparer = null, SyncTypeSettings settings = new()) : base(settings)
        {
            _comparer = (comparer == null) ? EqualityComparer<T>.Default : comparer;
            Collection = (collection == null) ? CollectionCaches<T>.RetrieveList() : collection;

            _initialValues = CollectionCaches<T>.RetrieveList();
            _changed = CollectionCaches<ChangeData>.RetrieveList();
            _serverOnChanges = CollectionCaches<CachedOnChange>.RetrieveList();
            _clientOnChanges = CollectionCaches<CachedOnChange>.RetrieveList();
        }
        #endregion

        #region Deconstructor.
        ~SyncList()
        {
            CollectionCaches<T>.StoreAndDefault(ref Collection);
            CollectionCaches<T>.StoreAndDefault(ref _initialValues);
            CollectionCaches<ChangeData>.StoreAndDefault(ref _changed);
            CollectionCaches<CachedOnChange>.StoreAndDefault(ref _serverOnChanges);
            CollectionCaches<CachedOnChange>.StoreAndDefault(ref _clientOnChanges);
        }
        #endregion

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Initialized()
        {
            base.Initialized();

            //Initialize collections if needed. OdinInspector can cause them to become deinitialized.
#if ODIN_INSPECTOR
            if (_initialValues == null) _initialValues = new();
            if (_changed == null) _changed = new();
            if (_serverOnChanges == null) _serverOnChanges = new();
            if (_clientOnChanges == null) _clientOnChanges = new();
#endif

            foreach (T item in Collection)
                _initialValues.Add(item);
        }

        /// <summary>
        /// Gets the collection being used within this SyncList.
        /// </summary>
        /// <param name="asServer">True if returning the server value, false if client value. The values will only differ when running as host. While asServer is true the most current values on server will be returned, and while false the latest values received by client will be returned.</param>
        /// <returns></returns>
        public List<T> GetCollection(bool asServer)
        {
            return Collection;
        }

        /// <summary>
        /// Adds an operation and invokes locally.
        /// </summary>
        /// <param name="operation"></param>
        /// <param name="index"></param>
        /// <param name="prev"></param>
        /// <param name="next"></param>
        private void AddOperation(SyncListOperation operation, int index, T prev, T next)
        {
            if (!base.IsInitialized)
                return;

            /* asServer might be true if the client is setting the value
             * through user code. Typically synctypes can only be set
             * by the server, that's why it is assumed asServer via user code.
             * However, when excluding owner for the synctype the client should
             * have permission to update the value locally for use with
             * prediction. */
            bool asServerInvoke = (!base.IsNetworkInitialized || base.NetworkBehaviour.IsServerStarted);

            /* Only the adds asServer may set
             * this synctype as dirty and add
             * to pending changes. However, the event may still
             * invoke for clientside. */
            if (asServerInvoke)
            {
                /* Set as changed even if cannot dirty.
                 * Dirty is only set when there are observers,
                 * but even if there are not observers
                 * values must be marked as changed so when
                 * there are observers, new values are sent. */
                _valuesChanged = true;

                /* If unable to dirty then do not add to changed.
                 * A dirty may fail if the server is not started
                 * or if there's no observers. Changed doesn't need
                 * to be populated in this situations because clients
                 * will get the full collection on spawn. If we
                 * were to also add to changed clients would get the full
                 * collection as well the changed, which would double results. */
                if (base.Dirty())
                {
                    ChangeData change = new(operation, index, next);
                    _changed.Add(change);
                }
            }

            InvokeOnChange(operation, index, prev, next, asServerInvoke);
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<CachedOnChange> collection = (asServer) ? _serverOnChanges : _clientOnChanges;

            if (OnChange != null)
            {
                foreach (CachedOnChange item in collection)
                    OnChange.Invoke(item.Operation, item.Index, item.Previous, item.Next, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Writes all changed values.
        /// </summary>
        /// <param name="writer"></param>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        protected internal override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            //If sending all then clear changed and write full.
            if (_sendAll)
            {
                _sendAll = false;
                _changed.Clear();
                WriteFull(writer);
            }
            else
            {
                base.WriteDelta(writer, resetSyncTick);

                //False for not full write.
                writer.WriteBoolean(false);

                //Number of entries expected.
                writer.WriteInt32(_changed.Count);

                for (int i = 0; i < _changed.Count; i++)
                {
                    ChangeData change = _changed[i];
                    writer.WriteUInt8Unpacked((byte)change.Operation);

                    //Clear does not need to write anymore data so it is not included in checks.
                    if (change.Operation == SyncListOperation.Add)
                    {
                        writer.Write(change.Item);
                    }
                    else if (change.Operation == SyncListOperation.RemoveAt)
                    {
                        writer.WriteInt32(change.Index);
                    }
                    else if (change.Operation == SyncListOperation.Insert || change.Operation == SyncListOperation.Set)
                    {
                        writer.WriteInt32(change.Index);
                        writer.Write(change.Item);
                    }
                }

                _changed.Clear();
            }
        }

        /// <summary>
        /// Writes all values if not initial values.
        /// </summary>
        /// <param name="writer"></param>
        protected internal override void WriteFull(PooledWriter writer)
        {
            if (!_valuesChanged)
                return;

            base.WriteHeader(writer, false);
            //True for full write.
            writer.WriteBoolean(true);

            int count = Collection.Count;
            writer.WriteInt32(count);
            for (int i = 0; i < count; i++)
            {
                writer.WriteUInt8Unpacked((byte)SyncListOperation.Add);
                writer.Write(Collection[i]);
            }
        }

        /// <summary>
        /// Reads and sets the current values for server or client.
        /// </summary>
        [APIExclude]
        protected internal override void Read(PooledReader reader, bool asServer)
        {
            base.SetReadArguments(reader, asServer, out bool newChangeId, out bool asClientHost, out bool canModifyValues);

            //True to warn if this object was deinitialized on the server.
            bool deinitialized = (asClientHost && !base.OnStartServerCalled);
            if (deinitialized)
                base.NetworkManager.LogWarning($"SyncType {GetType().Name} received a Read but was deinitialized on the server. Client callback values may be incorrect. This is a ClientHost limitation.");

            List<T> collection = Collection;

            bool fullWrite = reader.ReadBoolean();
            //Clear collection since it's a full write.
            if (canModifyValues && fullWrite)
                collection.Clear();

            int changes = reader.ReadInt32();

            for (int i = 0; i < changes; i++)
            {
                SyncListOperation operation = (SyncListOperation)reader.ReadUInt8Unpacked();
                int index = -1;
                T prev = default;
                T next = default;

                //Add.
                if (operation == SyncListOperation.Add)
                {
                    next = reader.Read<T>();

                    if (canModifyValues)
                    {
                        index = collection.Count;
                        collection.Add(next);
                    }
                }
                //Clear.
                else if (operation == SyncListOperation.Clear)
                {
                    if (canModifyValues)
                        collection.Clear();
                }
                //Insert.
                else if (operation == SyncListOperation.Insert)
                {
                    index = reader.ReadInt32();
                    next = reader.Read<T>();

                    if (canModifyValues)
                        collection.Insert(index, next);
                }
                //RemoveAt.
                else if (operation == SyncListOperation.RemoveAt)
                {
                    index = reader.ReadInt32();

                    if (canModifyValues)
                    {
                        prev = collection[index];
                        collection.RemoveAt(index);
                    }
                }
                //Set
                else if (operation == SyncListOperation.Set)
                {
                    index = reader.ReadInt32();
                    next = reader.Read<T>();

                    if (canModifyValues)
                    {
                        prev = collection[index];
                        collection[index] = next;
                    }
                }

                if (newChangeId)
                    InvokeOnChange(operation, index, prev, next, false);
            }

            //If changes were made invoke complete after all have been read.
            if (newChangeId && changes > 0)
                InvokeOnChange(SyncListOperation.Complete, -1, default, default, false);
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncListOperation operation, int index, T prev, T next, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, index, prev, next, asServer);
                else
                    _serverOnChanges.Add(new(operation, index, prev, next));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, index, prev, next, asServer);
                else
                    _clientOnChanges.Add(new(operation, index, prev, next));
            }
        }

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        protected internal override void ResetState(bool asServer)
        {
            base.ResetState(asServer);
            
            if (base.CanReset(asServer))
            {
                _sendAll = false;
                _changed.Clear();
                Collection.Clear();

                foreach (T item in _initialValues)
                    Collection.Add(item);
            }
        }

        /// <summary>
        /// Adds value.
        /// </summary>
        /// <param name="item"></param>
        public void Add(T item)
        {
            Add(item, true);
        }

        private void Add(T item, bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            Collection.Add(item);
            if (asServer)
                AddOperation(SyncListOperation.Add, Collection.Count - 1, default, item);
        }

        /// <summary>
        /// Adds a range of values.
        /// </summary>
        /// <param name="range"></param>
        public void AddRange(IEnumerable<T> range)
        {
            foreach (T entry in range)
                Add(entry, true);
        }

        /// <summary>
        /// Clears all values.
        /// </summary>
        public void Clear()
        {
            Clear(true);
        }

        private void Clear(bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            Collection.Clear();
            if (asServer)
                AddOperation(SyncListOperation.Clear, -1, default, default);
        }

        /// <summary>
        /// Returns if value exist.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Contains(T item)
        {
            return (IndexOf(item) >= 0);
        }

        /// <summary>
        /// Copies values to an array.
        /// </summary>
        /// <param name="array"></param>
        /// <param name="index"></param>
        public void CopyTo(T[] array, int index)
        {
            Collection.CopyTo(array, index);
        }

        /// <summary>
        /// Gets the index of value.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public int IndexOf(T item)
        {
            for (int i = 0; i < Collection.Count; ++i)
            {
                if (_comparer.Equals(item, Collection[i]))
                    return i;
            }
            return -1;
        }

        /// <summary>
        /// Finds index using match.
        /// </summary>
        /// <param name="match"></param>
        /// <returns></returns>
        public int FindIndex(Predicate<T> match)
        {
            for (int i = 0; i < Collection.Count; ++i)
            {
                if (match(Collection[i]))
                    return i;
            }
            return -1;
        }

        /// <summary>
        /// Finds value using match.
        /// </summary>
        /// <param name="match"></param>
        /// <returns></returns>
        public T Find(Predicate<T> match)
        {
            int i = FindIndex(match);
            return (i != -1) ? Collection[i] : default;
        }

        /// <summary>
        /// Finds all values using match.
        /// </summary>
        /// <param name="match"></param>
        /// <returns></returns>
        public List<T> FindAll(Predicate<T> match)
        {
            List<T> results = new();
            for (int i = 0; i < Collection.Count; ++i)
            {
                if (match(Collection[i]))
                    results.Add(Collection[i]);
            }
            return results;
        }

        /// <summary>
        /// Inserts value at index.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="item"></param>
        public void Insert(int index, T item)
        {
            Insert(index, item, true);
        }

        private void Insert(int index, T item, bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            Collection.Insert(index, item);
            if (asServer)
                AddOperation(SyncListOperation.Insert, index, default, item);
        }

        /// <summary>
        /// Inserts a range of values.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="range"></param>
        public void InsertRange(int index, IEnumerable<T> range)
        {
            foreach (T entry in range)
            {
                Insert(index, entry);
                index++;
            }
        }

        /// <summary>
        /// Removes a value.
        /// </summary>
        /// <param name="item"></param>
        /// <returns></returns>
        public bool Remove(T item)
        {
            int index = IndexOf(item);
            bool result = index >= 0;
            if (result)
                RemoveAt(index);

            return result;
        }

        /// <summary>
        /// Removes value at index.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="asServer"></param>
        public void RemoveAt(int index)
        {
            RemoveAt(index, true);
        }

        private void RemoveAt(int index, bool asServer)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            T oldItem = Collection[index];
            Collection.RemoveAt(index);
            if (asServer)
                AddOperation(SyncListOperation.RemoveAt, index, oldItem, default);
        }

        /// <summary>
        /// Removes all values within the collection.
        /// </summary>
        /// <param name="match"></param>
        /// <returns></returns>
        public int RemoveAll(Predicate<T> match)
        {
            List<T> toRemove = new();
            for (int i = 0; i < Collection.Count; ++i)
            {
                if (match(Collection[i]))
                    toRemove.Add(Collection[i]);
            }

            foreach (T entry in toRemove)
                Remove(entry);

            return toRemove.Count;
        }

        /// <summary>
        /// Gets or sets value at an index.
        /// </summary>
        /// <param name="i"></param>
        /// <returns></returns>
        public T this[int i]
        {
            get => Collection[i];
            set => Set(i, value, true, true);
        }

        /// <summary>
        /// Dirties the entire collection forcing a full send.
        /// This will not invoke the callback on server.
        /// </summary>
        public void DirtyAll()
        {
            if (!base.IsInitialized)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            if (base.Dirty())
                _sendAll = true;
        }

        /// <summary>
        /// Looks up obj in Collection and if found marks it's index as dirty.
        /// While using this operation previous value will be the same as next.
        /// This operation can be very expensive, and may fail if your value cannot be compared.
        /// </summary>
        /// <param name="obj">Object to lookup.</param>
        public void Dirty(T obj)
        {
            int index = Collection.IndexOf(obj);
            if (index != -1)
                Dirty(index);
            else
                base.NetworkManager.LogError($"Could not find object within SyncList, dirty will not be set.");
        }

        /// <summary>
        /// Marks an index as dirty.
        /// While using this operation previous value will be the same as next.
        /// </summary>
        /// <param name="index"></param>
        public void Dirty(int index)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            T value = Collection[index];
            AddOperation(SyncListOperation.Set, index, value, value);
        }

        /// <summary>
        /// Sets value at index.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="value"></param>
        public void Set(int index, T value, bool force = true)
        {
            Set(index, value, true, force);
        }

        private void Set(int index, T value, bool asServer, bool force)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            bool sameValue = (!force && _comparer.Equals(Collection[index], value));
            if (!sameValue)
            {
                T prev = Collection[index];
                Collection[index] = value;
                if (asServer)
                    AddOperation(SyncListOperation.Set, index, prev, value);
            }
        }

        /// <summary>
        /// Returns Enumerator for collection.
        /// </summary>
        /// <returns></returns>
        public IEnumerator<T> GetEnumerator() => Collection.GetEnumerator();

        [APIExclude]
        IEnumerator<T> IEnumerable<T>.GetEnumerator() => Collection.GetEnumerator();

        [APIExclude]
        IEnumerator IEnumerable.GetEnumerator() => Collection.GetEnumerator();
    }
}
#endif﻿#if !FISHNET_STABLE_SYNCTYPES
using FishNet.Documenting;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using System.Collections.Generic;

namespace FishNet.Object.Synchronizing
{
    /// <summary>
    /// A SyncObject to efficiently synchronize Stopwatchs over the network.
    /// </summary>
    public class SyncStopwatch : SyncBase, ICustomSync
    {
        #region Type.
        /// <summary>
        /// Information about how the Stopwatch has changed.
        /// </summary>
        private struct ChangeData
        {
            public readonly SyncStopwatchOperation Operation;
            public readonly float Previous;

            public ChangeData(SyncStopwatchOperation operation, float previous)
            {
                Operation = operation;
                Previous = previous;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Delegate signature for when the Stopwatch operation occurs.
        /// </summary>
        /// <param name="op">Operation which was performed.</param>
        /// <param name="prev">Previous value of the Stopwatch. This will be -1f is the value is not available.</param>
        /// <param name="asServer">True if occurring on server.</param>
        public delegate void SyncTypeChanged(SyncStopwatchOperation op, float prev, bool asServer);

        /// <summary>
        /// Called when a Stopwatch operation occurs.
        /// </summary>
        public event SyncTypeChanged OnChange;
        /// <summary>
        /// How much time has passed since the Stopwatch started.
        /// </summary>
        public float Elapsed { get; private set; } = -1f;
        /// <summary>
        /// True if the SyncStopwatch is currently paused. Calls to Update(float) will be ignored when paused.
        /// </summary>
        public bool Paused { get; private set; }
        #endregion

        #region Private.
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private List<ChangeData> _changed = new();
        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private List<ChangeData> _serverOnChanges = new();
        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private List<ChangeData> _clientOnChanges = new();
        #endregion

        #region Constructors
        public SyncStopwatch(SyncTypeSettings settings = new()) : base(settings) { }
        #endregion

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Initialized()
        {
            base.Initialized();

            //Initialize collections if needed. OdinInspector can cause them to become deinitialized.
#if ODIN_INSPECTOR
            if (_changed == null) _changed = new();
            if (_serverOnChanges == null) _serverOnChanges = new();
            if (_clientOnChanges == null) _clientOnChanges = new();
#endif
        }

        /// <summary>
        /// Starts a Stopwatch. If called when a Stopwatch is already active then StopStopwatch will automatically be sent.
        /// </summary>
        /// <param name="remaining">Time in which the Stopwatch should start with.</param>
        /// <param name="sendElapsedOnStop">True to include remaining time when automatically sending StopStopwatch.</param>
        public void StartStopwatch(bool sendElapsedOnStop = true)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            if (Elapsed > 0f)
                StopStopwatch(sendElapsedOnStop);

            Elapsed = 0f;
            AddOperation(SyncStopwatchOperation.Start, 0f);
        }

        /// <summary>
        /// Pauses the Stopwatch. Calling while already paused will be result in no action.
        /// </summary>
        /// <param name="sendElapsed">True to send Remaining with this operation.</param>
        public void PauseStopwatch(bool sendElapsed = false)
        {
            if (Elapsed < 0f)
                return;
            if (Paused)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            Paused = true;
            float prev;
            SyncStopwatchOperation op;
            if (sendElapsed)
            {
                prev = Elapsed;
                op = SyncStopwatchOperation.PauseUpdated;
            }
            else
            {
                prev = -1f;
                op = SyncStopwatchOperation.Pause;
            }

            AddOperation(op, prev);
        }

        /// <summary>
        /// Unpauses the Stopwatch. Calling while already unpaused will be result in no action.
        /// </summary>
        public void UnpauseStopwatch()
        {
            if (Elapsed < 0f)
                return;
            if (!Paused)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            Paused = false;
            AddOperation(SyncStopwatchOperation.Unpause, -1f);
        }

        /// <summary>
        /// Stops and resets the Stopwatch. 
        /// </summary>
        public void StopStopwatch(bool sendElapsed = false)
        {
            if (Elapsed < 0f)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            float prev = (sendElapsed) ? -1f : Elapsed;
            StopStopwatch_Internal(true);
            SyncStopwatchOperation op = (sendElapsed) ? SyncStopwatchOperation.StopUpdated : SyncStopwatchOperation.Stop;
            AddOperation(op, prev);
        }

        /// <summary>
        /// Adds an operation to synchronize.
        /// </summary>
        private void AddOperation(SyncStopwatchOperation operation, float prev)
        {
            if (!base.IsInitialized)
                return;

            bool asServerInvoke = (!base.IsNetworkInitialized || base.NetworkBehaviour.IsServerStarted);

            if (asServerInvoke)
            {
                if (base.Dirty())
                {
                    ChangeData change = new(operation, prev);
                    _changed.Add(change);
                }
            }

            OnChange?.Invoke(operation, prev, asServerInvoke);
        }

        /// <summary>
        /// Writes all changed values.
        /// </summary>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        protected internal override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            base.WriteDelta(writer, resetSyncTick);
            writer.WriteInt32(_changed.Count);

            for (int i = 0; i < _changed.Count; i++)
            {
                ChangeData change = _changed[i];
                writer.WriteUInt8Unpacked((byte)change.Operation);
                if (change.Operation == SyncStopwatchOperation.Start)
                    WriteStartStopwatch(writer, 0f, false);
                //Pause and unpause updated need current value written.
                //Updated stop also writes current value.
                else if (change.Operation == SyncStopwatchOperation.PauseUpdated || change.Operation == SyncStopwatchOperation.StopUpdated)
                    writer.WriteSingle(change.Previous);
            }

            _changed.Clear();
        }

        /// <summary>
        /// Writes all values.
        /// </summary>
        protected internal override void WriteFull(PooledWriter writer)
        {
            //Only write full if a Stopwatch is running.
            if (Elapsed < 0f)
                return;

            base.WriteDelta(writer, false);

            //There will be 1 or 2 entries. If paused 2, if not 1.
            int entries = (Paused) ? 2 : 1;
            writer.WriteInt32(entries);
            //And the operations.
            WriteStartStopwatch(writer, Elapsed, true);
            if (Paused)
                writer.WriteUInt8Unpacked((byte)SyncStopwatchOperation.Pause);
        }

        /// <summary>
        /// Writers a start with elapsed time.
        /// </summary>
        /// <param name="elapsed"></param>
        private void WriteStartStopwatch(Writer w, float elapsed, bool includeOperationByte)
        {
            if (includeOperationByte)
                w.WriteUInt8Unpacked((byte)SyncStopwatchOperation.Start);

            w.WriteSingle(elapsed);
        }

        /// <summary>
        /// Reads and sets the current values for server or client.
        /// </summary>
        [APIExclude]
        protected internal override void Read(PooledReader reader, bool asServer)
        {
            base.SetReadArguments(reader, asServer, out bool newChangeId, out bool asClientHost, out bool canModifyValues);

            int changes = reader.ReadInt32();

            for (int i = 0; i < changes; i++)
            {
                SyncStopwatchOperation op = (SyncStopwatchOperation)reader.ReadUInt8Unpacked();
                if (op == SyncStopwatchOperation.Start)
                {
                    float elapsed = reader.ReadSingle();
                    
                    if (canModifyValues)
                        Elapsed = elapsed;
                    
                    if (newChangeId)
                        InvokeOnChange(op, elapsed, asServer);
                }
                else if (op == SyncStopwatchOperation.Pause)
                {
                    if (canModifyValues)
                        Paused = true;
                    
                    if (newChangeId)
                        InvokeOnChange(op, -1f, asServer);
                }
                else if (op == SyncStopwatchOperation.PauseUpdated)
                {
                    float prev = reader.ReadSingle();
                    
                    if (canModifyValues)
                        Paused = true;
                    
                    if (newChangeId)
                        InvokeOnChange(op, prev, asServer);
                }
                else if (op == SyncStopwatchOperation.Unpause)
                {
                    if (canModifyValues)
                        Paused = false;
                    
                    if (newChangeId)
                        InvokeOnChange(op, -1f, asServer);
                }
                else if (op == SyncStopwatchOperation.Stop)
                {
                    if (canModifyValues)
                        StopStopwatch_Internal(asServer);
                    
                    if (newChangeId)
                        InvokeOnChange(op, -1f, false);
                }
                else if (op == SyncStopwatchOperation.StopUpdated)
                {
                    float prev = reader.ReadSingle();
                    if (canModifyValues)
                        StopStopwatch_Internal(asServer);
                    
                    if (newChangeId)
                        InvokeOnChange(op, prev, asServer);
                }
            }

            if (newChangeId && changes > 0)
                InvokeOnChange(SyncStopwatchOperation.Complete, -1f, asServer);
        }

        /// <summary>
        /// Stops the Stopwatch and resets.
        /// </summary>
        private void StopStopwatch_Internal(bool asServer)
        {
            Paused = false;
            Elapsed = -1f;
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncStopwatchOperation operation, float prev, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, prev, asServer);
                else
                    _serverOnChanges.Add(new(operation, prev));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, prev, asServer);
                else
                    _clientOnChanges.Add(new(operation, prev));
            }
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<ChangeData> collection = (asServer) ? _serverOnChanges : _clientOnChanges;

            if (OnChange != null)
            {
                foreach (ChangeData item in collection)
                    OnChange.Invoke(item.Operation, item.Previous, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Adds delta from Remaining for server and client.
        /// </summary>
        /// <param name="delta">Value to remove from Remaining.</param>
        public void Update(float delta)
        {
            //Not enabled.
            if (Elapsed == -1f)
                return;
            if (Paused)
                return;

            Elapsed += delta;
        }

        /// <summary>
        /// Return the serialized type.
        /// </summary>
        /// <returns></returns>
        public object GetSerializedType() => null;
    }
}
#endif﻿#if !FISHNET_STABLE_SYNCTYPES
using FishNet.Documenting;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Object.Synchronizing
{
    /// <summary>
    /// A SyncObject to efficiently synchronize timers over the network.
    /// </summary>
    public class SyncTimer : SyncBase, ICustomSync
    {
        #region Type.
        /// <summary>
        /// Information about how the timer has changed.
        /// </summary>
        private struct ChangeData
        {
            public readonly SyncTimerOperation Operation;
            public readonly float Previous;
            public readonly float Next;

            public ChangeData(SyncTimerOperation operation, float previous, float next)
            {
                Operation = operation;
                Previous = previous;
                Next = next;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Delegate signature for when the timer operation occurs.
        /// </summary>
        /// <param name="op">Operation which was performed.</param>
        /// <param name="prev">Previous value of the timer. This will be -1f is the value is not available.</param>
        /// <param name="next">Value of the timer. This will be -1f is the value is not available.</param>
        /// <param name="asServer">True if occurring on server.</param>
        public delegate void SyncTypeChanged(SyncTimerOperation op, float prev, float next, bool asServer);

        /// <summary>
        /// Called when a timer operation occurs.
        /// </summary>
        public event SyncTypeChanged OnChange;

        /// <summary>
        /// Time remaining on the timer. When the timer is expired this value will be 0f.
        /// </summary>
        public float Remaining { get; private set; }

        /// <summary>
        /// How much time has passed since the timer started.
        /// </summary>
        public float Elapsed => (Duration - Remaining);

        /// <summary>
        /// Starting duration of the timer.
        /// </summary>
        public float Duration { get; private set; }

        /// <summary>
        /// True if the SyncTimer is currently paused. Calls to Update(float) will be ignored when paused.
        /// </summary>
        public bool Paused { get; private set; }
        #endregion

        #region Private.
        /// <summary>
        /// Changed data which will be sent next tick.
        /// </summary>
        private List<ChangeData> _changed = new();

        /// <summary>
        /// Server OnChange events waiting for start callbacks.
        /// </summary>
        private List<ChangeData> _serverOnChanges = new();

        /// <summary>
        /// Client OnChange events waiting for start callbacks.
        /// </summary>
        private List<ChangeData> _clientOnChanges = new();

        /// <summary>
        /// Last Time.unscaledTime the timer delta was updated.
        /// </summary>
        private float _updateTime;
        #endregion

        #region Constructors
        public SyncTimer(SyncTypeSettings settings = new()) : base(settings) { }
        #endregion

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Initialized()
        {
            base.Initialized();

            //Initialize collections if needed. OdinInspector can cause them to become deinitialized.
#if ODIN_INSPECTOR
            if (_changed == null) _changed = new();
            if (_serverOnChanges == null) _serverOnChanges = new();
            if (_clientOnChanges == null) _clientOnChanges = new();
#endif
        }

        /// <summary>
        /// Starts a timer. If called when a timer is already active then StopTimer will automatically be sent.
        /// </summary>
        /// <param name="remaining">Time in which the timer should start with.</param>
        /// <param name="sendRemainingOnStop">True to include remaining time when automatically sending StopTimer.</param>
        public void StartTimer(float remaining, bool sendRemainingOnStop = true)
        {
            if (!base.CanNetworkSetValues(true))
                return;

            if (Remaining > 0f)
                StopTimer(sendRemainingOnStop);

            Paused = false;
            Remaining = remaining;
            Duration = remaining;
            SetUpdateTime();
            AddOperation(SyncTimerOperation.Start, -1f, remaining);
        }

        /// <summary>
        /// Pauses the timer. Calling while already paused will be result in no action.
        /// </summary>
        /// <param name="sendRemaining">True to send Remaining with this operation.</param>
        public void PauseTimer(bool sendRemaining = false)
        {
            if (Remaining <= 0f)
                return;
            if (Paused)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            Paused = true;
            SyncTimerOperation op = (sendRemaining) ? SyncTimerOperation.PauseUpdated : SyncTimerOperation.Pause;
            AddOperation(op, Remaining, Remaining);
        }

        /// <summary>
        /// Unpauses the timer. Calling while already unpaused will be result in no action.
        /// </summary>
        public void UnpauseTimer()
        {
            if (Remaining <= 0f)
                return;
            if (!Paused)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            Paused = false;
            SetUpdateTime();
            AddOperation(SyncTimerOperation.Unpause, Remaining, Remaining);
        }

        /// <summary>
        /// Stops and resets the timer. 
        /// </summary>
        public void StopTimer(bool sendRemaining = false)
        {
            if (Remaining <= 0f)
                return;
            if (!base.CanNetworkSetValues(true))
                return;

            bool asServer = true;
            float prev = Remaining;
            StopTimer_Internal(asServer);
            SyncTimerOperation op = (sendRemaining) ? SyncTimerOperation.StopUpdated : SyncTimerOperation.Stop;
            AddOperation(op, prev, 0f);
        }

        /// <summary>
        /// Adds an operation to synchronize.
        /// </summary>
        private void AddOperation(SyncTimerOperation operation, float prev, float next)
        {
            if (!base.IsInitialized)
                return;

            bool asServerInvoke = (!base.IsNetworkInitialized || base.NetworkBehaviour.IsServerStarted);

            if (asServerInvoke)
            {
                if (base.Dirty())
                {
                    ChangeData change = new(operation, prev, next);
                    _changed.Add(change);
                }
            }

            OnChange?.Invoke(operation, prev, next, asServerInvoke);
        }

        /// <summary>
        /// Writes all changed values.
        /// </summary>
        ///<param name="resetSyncTick">True to set the next time data may sync.</param>
        protected internal override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            base.WriteDelta(writer, resetSyncTick);
            writer.WriteInt32(_changed.Count);

            for (int i = 0; i < _changed.Count; i++)
            {
                ChangeData change = _changed[i];
                writer.WriteUInt8Unpacked((byte)change.Operation);

                if (change.Operation == SyncTimerOperation.Start)
                {
                    WriteStartTimer(writer, false);
                }
                //Pause and unpause updated need current value written.
                //Updated stop also writes current value.
                else if (change.Operation == SyncTimerOperation.PauseUpdated || change.Operation == SyncTimerOperation.StopUpdated)
                {
                    writer.WriteSingle(change.Next);
                }
            }

            _changed.Clear();
        }

        /// <summary>
        /// Writes all values.
        /// </summary>
        protected internal override void WriteFull(PooledWriter writer)
        {
            //Only write full if a timer is running.
            if (Remaining <= 0f)
                return;

            base.WriteDelta(writer, false);
            //There will be 1 or 2 entries. If paused 2, if not 1.
            int entries = (Paused) ? 2 : 1;
            writer.WriteInt32(entries);
            //And the operations.
            WriteStartTimer(writer, true);
            if (Paused)
                writer.WriteUInt8Unpacked((byte)SyncTimerOperation.Pause);
        }

        /// <summary>
        /// Writes a StartTimer operation.
        /// </summary>
        /// <param name="w"></param>
        /// <param name="includeOperationByte"></param>
        private void WriteStartTimer(Writer w, bool includeOperationByte)
        {
            if (includeOperationByte)
                w.WriteUInt8Unpacked((byte)SyncTimerOperation.Start);
            w.WriteSingle(Remaining);
            w.WriteSingle(Duration);
        }

        /// <summary>
        /// Reads and sets the current values for server or client.
        /// </summary>
        [APIExclude]
        protected internal override void Read(PooledReader reader, bool asServer)
        {
            base.SetReadArguments(reader, asServer, out bool newChangeId, out bool asClientHost, out bool canModifyValues);

            int changes = reader.ReadInt32();
            //Has previous value if should invoke finished.
            float? finishedPrevious = null;

            for (int i = 0; i < changes; i++)
            {
                SyncTimerOperation op = (SyncTimerOperation)reader.ReadUInt8Unpacked();
                if (op == SyncTimerOperation.Start)
                {
                    float next = reader.ReadSingle();
                    float duration = reader.ReadSingle();

                    if (canModifyValues)
                    {
                        SetUpdateTime();
                        Paused = false;
                        Remaining = next;
                        Duration = duration;
                    }

                    if (newChangeId)
                    {
                        InvokeOnChange(op, -1f, next, asServer);
                        /* If next is 0 then that means the timer
                         * expired on the same tick it was started.
                         * This can be true depending on when in code
                         * the server starts the timer.
                         *
                         * When 0 also invoke finished. */
                        if (next == 0)
                            finishedPrevious = duration;
                    }
                }
                else if (op == SyncTimerOperation.Pause || op == SyncTimerOperation.PauseUpdated || op == SyncTimerOperation.Unpause)
                {
                    if (canModifyValues)
                        UpdatePauseState(op);
                }
                else if (op == SyncTimerOperation.Stop)
                {
                    float prev = Remaining;

                    if (canModifyValues)
                        StopTimer_Internal(asServer);

                    if (newChangeId)
                        InvokeOnChange(op, prev, 0f, false);
                }
                //
                else if (op == SyncTimerOperation.StopUpdated)
                {
                    float prev = Remaining;
                    float next = reader.ReadSingle();

                    if (canModifyValues)
                        StopTimer_Internal(asServer);

                    if (newChangeId)
                        InvokeOnChange(op, prev, next, asServer);
                }
            }

            //Updates a pause state with a pause or unpause operation.
            void UpdatePauseState(SyncTimerOperation op)
            {
                bool newPauseState = (op == SyncTimerOperation.Pause || op == SyncTimerOperation.PauseUpdated);

                float prev = Remaining;
                float next;
                //If updated time as well.
                if (op == SyncTimerOperation.PauseUpdated)
                {
                    next = reader.ReadSingle();
                    Remaining = next;
                }
                else
                {
                    next = Remaining;
                }

                Paused = newPauseState;
                if (!Paused)
                    SetUpdateTime();
                if (newChangeId)
                    InvokeOnChange(op, prev, next, asServer);
            }

            if (newChangeId && changes > 0)
                InvokeOnChange(SyncTimerOperation.Complete, -1f, -1f, false);
            if (finishedPrevious.HasValue)
                InvokeFinished(finishedPrevious.Value);
        }

        /// <summary>
        /// Stops the timer and resets.
        /// </summary>
        private void StopTimer_Internal(bool asServer)
        {
            Paused = false;
            Remaining = 0f;
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(SyncTimerOperation operation, float prev, float next, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(operation, prev, next, asServer);
                else
                    _serverOnChanges.Add(new(operation, prev, next));
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(operation, prev, next, asServer);
                else
                    _clientOnChanges.Add(new(operation, prev, next));
            }
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);
            List<ChangeData> collection = (asServer) ? _serverOnChanges : _clientOnChanges;

            if (OnChange != null)
            {
                foreach (ChangeData item in collection)
                    OnChange.Invoke(item.Operation, item.Previous, item.Next, asServer);
            }

            collection.Clear();
        }

        /// <summary>
        /// Sets updateTime to current values.
        /// </summary>
        private void SetUpdateTime()
        {
            _updateTime = Time.unscaledTime;
        }

        /// <summary>
        /// Removes time passed from Remaining since the last unscaled time using this method.
        /// </summary>
        public void Update()
        {
            float delta = (Time.unscaledTime - _updateTime);
            Update(delta);
        }

        /// <summary>
        /// Removes delta from Remaining for server and client.
        /// This also resets unscaledTime delta for Update().
        /// </summary>
        /// <param name="delta">Value to remove from Remaining.</param>
        public void Update(float delta)
        {
            //Not enabled.
            if (Remaining <= 0f)
                return;
            if (Paused)
                return;

            SetUpdateTime();
            if (delta < 0)
                delta *= -1f;
            float prev = Remaining;
            Remaining -= delta;
            //Still time left.
            if (Remaining > 0f)
                return;

            /* If here then the timer has
             * ended. Invoking the events is tricky
             * here because both the server and the client
             * would share the same value. Because of this check
             * if each socket is started and if so invoke for that
             * side. There's a chance down the road this may need to be improved
             * for some but at this time I'm unable to think of any
             * problems. */
            Remaining = 0f;
            InvokeFinished(prev);
        }

        /// <summary>
        /// Invokes SyncTimer finished a previous value.
        /// </summary>
        /// <param name="prev"></param>
        private void InvokeFinished(float prev)
        {
            if (base.NetworkManager.IsServerStarted)
                OnChange?.Invoke(SyncTimerOperation.Finished, prev, 0f, true);
            if (base.NetworkManager.IsClientStarted)
                OnChange?.Invoke(SyncTimerOperation.Finished, prev, 0f, false);
        }

        /// <summary>
        /// Return the serialized type.
        /// </summary>
        /// <returns></returns>
        public object GetSerializedType() => null;
    }
}
#endif﻿#if !FISHNET_STABLE_SYNCTYPES
using FishNet.CodeGenerating;
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Object.Helping;
using FishNet.Object.Synchronizing.Internal;
using FishNet.Serializing;
using FishNet.Serializing.Helping;
using System.Runtime.InteropServices;
using UnityEngine;

namespace FishNet.Object.Synchronizing
{
    internal interface ISyncVar { }

    [APIExclude]
    [System.Serializable]
    [StructLayout(LayoutKind.Auto, CharSet = CharSet.Auto)]
    public class SyncVar<T> : SyncBase, ISyncVar
    {
        #region Types.
        public struct InterpolationContainer
        {
            /// <summary>
            /// Value prior to setting new.
            /// </summary>
            public T LastValue;
            /// <summary>
            /// Tick when LastValue was set.
            /// </summary>
            public float UpdateTime;

            public void Update(T prevValue)
            {
                LastValue = prevValue;
                UpdateTime = Time.unscaledTime;
            }
        }

        /// <summary>
        /// Information needed to invoke a callback.
        /// </summary>
        private struct CachedOnChange
        {
            internal readonly T Previous;
            internal readonly T Next;

            public CachedOnChange(T previous, T next)
            {
                Previous = previous;
                Next = next;
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// Value interpolated between last received and current.
        /// </summary>
        /// <param name="useCurrentValue">True if to ignore interpolated calculations and use the current value.
        /// This can be useful if you are able to write this SyncVars values in update.
        /// </param>
        public T InterpolatedValue(bool useCurrentValue = false)
        {
            if (useCurrentValue)
                return _value;

            float diff = (Time.unscaledTime - _interpolator.UpdateTime);
            float percent = Mathf.InverseLerp(0f, base.Settings.SendRate, diff);

            return Interpolate(_interpolator.LastValue, _value, percent);
        }

        /// <summary>
        /// Gets and sets the current value for this SyncVar.
        /// </summary>
        public T Value
        {
            get => _value;
            set => SetValue(value, true);
        }
        ///// <summary>
        ///// Sets the current value for this SyncVar while sending it immediately.
        ///// </summary>
        //public T ValueRpc
        //{
        //    set => SetValue(value, true, true);
        //}
        ///// <summary>
        ///// Gets the current value for this SyncVar while marking it dirty. This could be useful to change properties or fields on a reference type SyncVar and have the SyncVar be dirtied after.
        ///// </summary>
        //public T ValueDirty
        //{
        //    get
        //    {
        //        base.Dirty();
        //        return _value;
        //    }
        //}
        ///// <summary>
        ///// Gets the current value for this SyncVar while sending it imediately. This could be useful to change properties or fields on a reference type SyncVar and have the SyncVar send after.
        ///// </summary>
        //public T ValueDirtyRpc
        //{
        //    get
        //    {
        //        base.Dirty(true);
        //        return _value;
        //    }
        //}
        /// <summary>
        /// Called when the SyncDictionary changes.
        /// </summary>
        public event OnChanged OnChange;

        public delegate void OnChanged(T prev, T next, bool asServer);
        #endregion

        #region Private.
        /// <summary>
        /// Server OnChange event waiting for start callbacks.
        /// </summary>
        private CachedOnChange? _serverOnChange;
        /// <summary>
        /// Client OnChange event waiting for start callbacks.
        /// </summary>
        private CachedOnChange? _clientOnChange;
        /// <summary>
        /// Value before the network is initialized on the containing object.
        /// </summary>
        private T _initialValue;
        /// <summary>
        /// Current value on the server, or client.
        /// </summary>
        [SerializeField]
        private T _value;
        /// <summary>
        /// Holds information about interpolating between values.
        /// </summary>
        private InterpolationContainer _interpolator = new();
        /// <summary>
        /// True if value was ever set after the SyncType initialized.
        /// This is true even if SetInitialValues was called at runtime.
        /// </summary>
        private bool _valueSetAfterInitialized;
        #endregion

        #region Constructors.
        public SyncVar(SyncTypeSettings settings = new()) : this(default(T), settings) { }
        public SyncVar(T initialValue, SyncTypeSettings settings = new()) : base(settings) => SetInitialValues(initialValue);
        #endregion

        /// <summary>
        /// Called when the SyncType has been registered, but not yet initialized over the network.
        /// </summary>
        protected override void Initialized()
        {
            base.Initialized();
            _initialValue = _value;
        }

        /// <summary>
        /// Sets initial values.
        /// Initial values are not automatically synchronized, as it is assumed clients and server already have them set to the specified value.
        /// When a SyncVar is reset, such as when the object despawns, current values are set to initial values.
        /// </summary>
        public void SetInitialValues(T value)
        {
            _initialValue = value;
            /* Only update current if a value has not been set already.
             * A value normally would not be set unless a SyncVar came through
             * as the object was enabling, such as if it started in a disabled state
             * and was later enabled. */
            if (!_valueSetAfterInitialized)
                UpdateValues(value);

            if (base.IsInitialized)
                _valueSetAfterInitialized = true;
        }

        /// <summary>
        /// Sets current and previous values.
        /// </summary>
        /// <param name="next"></param>
        private void UpdateValues(T next)
        {
            //If network initialized then update interpolator.
            if (base.IsNetworkInitialized)
                _interpolator.Update(_value);

            _value = next;
        }

        /// <summary>
        /// Sets current value and marks the SyncVar dirty when able to. Returns if able to set value.
        /// </summary>
        /// <param name="calledByUser">True if SetValue was called in response to user code. False if from automated code.</param>
        internal void SetValue(T nextValue, bool calledByUser, bool sendRpc = false)
        {
            /* IsInitialized is only set after the script containing this SyncVar
             * has executed our codegen in the beginning of awake, and after awake
             * user logic. When not set update the initial values */
            if (!base.IsInitialized)
            {
                SetInitialValues(nextValue);
                return;
            }
            else
            {
                _valueSetAfterInitialized = true;
            }

            /* If not client or server then set skipChecks
             * as true. When neither is true it's likely user is changing
             * value before object is initialized. This is allowed
             * but checks cannot be processed because they would otherwise
             * stop setting the value. */
            bool isNetworkInitialized = base.IsNetworkInitialized;

            //Object is deinitializing.
            if (isNetworkInitialized && CodegenHelper.NetworkObject_Deinitializing(this.NetworkBehaviour))
                return;

            //If being set by user code.
            if (calledByUser)
            {
                if (!base.CanNetworkSetValues(true))
                    return;
                /* We will only be this far if the network is not active yet,
                 * server is active, or client has setting permissions.
                 * We only need to set asServerInvoke to false if the network
                 * is initialized and the server is not active. */
                bool asServerInvoke = CanInvokeCallbackAsServer();

                /* If the network has not been network initialized then
                 * Value is expected to be set on server and client since
                 * it's being set before the object is initialized. */
                if (!isNetworkInitialized)
                {
                    T prev = _value;
                    UpdateValues(nextValue);
                    //Still call invoke because change will be cached for when the network initializes.
                    InvokeOnChange(prev, _value, asServer: true);
                }
                else
                {
                    if (Comparers.EqualityCompare(_value, nextValue))
                        return;

                    T prev = _value;
                    UpdateValues(nextValue);
                    InvokeOnChange(prev, _value, asServerInvoke);
                }

                TryDirty(asServerInvoke);
            }
            //Not called by user.
            else
            {
                /* Only perform the equality checks when not host.
                 *
                 * In the previous SyncVar version it was okay to call
                 * this on host because a separate clientHost value was kept for
                 * the client side, and that was compared against.
                 *
                 * In newer SyncVar(this one) a client side copy is
                 * not kept so when compariing against the current vlaue
                 * as clientHost, it will always return as matched.
                 *
                 * But it's impossible for clientHost to send a value
                 * and it not have changed, so this check is not needed. */

                // /* Previously clients were not allowed to set values
                //  * but this has been changed because clients may want
                //  * to update values locally while occasionally
                //  * letting the syncvar adjust their side. */
                // T prev = _value;
                // if (Comparers.EqualityCompare(prev, nextValue))
                //     return;

                T prev = _value;
                /* If also server do not update value.
                 * Server side has say of the current value. */
                /* Only update value if not server. We do not want
                 * clientHost overwriting servers current with what
                 * they just received.*/
                if (!base.NetworkManager.IsServerStarted)
                    UpdateValues(nextValue);

                InvokeOnChange(prev, nextValue, asServer: false);
            }


            /* Tries to dirty so update
             * is sent over network. This needs to be called
             * anytime the data changes because there is no way
             * to know if the user set the value on both server
             * and client or just one side. */
            void TryDirty(bool asServer)
            {
                //Cannot dirty when network is not initialized.
                if (!isNetworkInitialized)
                    return;

                if (asServer)
                    base.Dirty();
                //base.Dirty(sendRpc);
            }
        }

        /// <summary>
        /// Returns interpolated values between previous and current using a percentage.
        /// </summary>
        protected virtual T Interpolate(T previous, T current, float percent)
        {
            base.NetworkManager.LogError($"Type {typeof(T).FullName} does not support interpolation. Implement a supported type class or create your own. See class FloatSyncVar for an example.");
            return default;
        }

        /// <summary>
        /// True if callback can be invoked with asServer true.
        /// </summary>
        /// <returns></returns>
        private bool AsServerInvoke() => (!base.IsNetworkInitialized || base.NetworkBehaviour.IsServerStarted);

        /// <summary>
        /// Dirties the the syncVar for a full send.
        /// </summary>
        public void DirtyAll()
        {
            if (!base.IsInitialized)
                return;
            if (!base.CanNetworkSetValues(log: true))
                return;

            //Also set that values have changed since the user is forcing a sync.
            _valueSetAfterInitialized = true;

            base.Dirty();
            /* Invoke even if was unable to dirty. Dirtying only
             * becomes true if server is running, but also if there are
             * observers. Even if there are not observers we still want
             * to invoke for the server side. */
            //todo: this behaviour needs to be done for all synctypes with dirt/dirtyall.
            bool asServerInvoke = CanInvokeCallbackAsServer();
            InvokeOnChange(_value, _value, asServerInvoke);
        }

        /// <summary>
        /// Invokes OnChanged callback.
        /// </summary>
        private void InvokeOnChange(T prev, T next, bool asServer)
        {
            if (asServer)
            {
                if (base.NetworkBehaviour.OnStartServerCalled)
                    OnChange?.Invoke(prev, next, asServer);
                else
                    _serverOnChange = new CachedOnChange(prev, next);
            }
            else
            {
                if (base.NetworkBehaviour.OnStartClientCalled)
                    OnChange?.Invoke(prev, next, asServer);
                else
                    _clientOnChange = new CachedOnChange(prev, next);
            }
        }

        /// <summary>
        /// Called after OnStartXXXX has occurred.
        /// </summary>
        /// <param name="asServer">True if OnStartServer was called, false if OnStartClient.</param>
        [MakePublic]
        protected internal override void OnStartCallback(bool asServer)
        {
            base.OnStartCallback(asServer);

            if (OnChange != null)
            {
                CachedOnChange? change = (asServer) ? _serverOnChange : _clientOnChange;
                if (change != null)
                    InvokeOnChange(change.Value.Previous, change.Value.Next, asServer);
            }

            if (asServer)
                _serverOnChange = null;
            else
                _clientOnChange = null;
        }

        /// <summary>
        /// Writes current value.
        /// </summary>
        /// <param name="resetSyncTick">True to set the next time data may sync.</param>
        [MakePublic]
        protected internal override void WriteDelta(PooledWriter writer, bool resetSyncTick = true)
        {
            base.WriteDelta(writer, resetSyncTick);
            writer.Write(_value);
        }

        /// <summary>
        /// Writes current value if not initialized value.
        /// </summary>m>
        [MakePublic]
        protected internal override void WriteFull(PooledWriter obj0)
        {
            // /* If a class then skip comparer check.
            //  * InitialValue and Value will be the same reference.
            //  *
            //  * If a value then compare field changes, since the references
            //  * will not be the same. */
            // //Compare if a value type.
            // if (_isValueType)
            // {
            //     if (Comparers.EqualityCompare(_initialValue, _value))
            //         return;
            // }
            // else
            // {
            //     if (!_valueSetAfterInitialized)
            //         return;
            // }

            if (!_valueSetAfterInitialized)
                return;

            /* SyncVars only hold latest value, so just
             * write current delta. */
            WriteDelta(obj0, false);
        }

        /// <summary>
        /// Reads a SyncVar value.
        /// </summary>
        protected internal override void Read(PooledReader reader, bool asServer)
        {
            T value = reader.Read<T>();

            if (!ReadChangeId(reader))
                return;

            SetValue(value, false);
            //TODO this needs to separate invokes from setting values so that syncvar can be written like remainder of synctypes.
        }

        //SyncVars do not use changeId.
        [APIExclude]
        protected override bool ReadChangeId(Reader reader) => true;

        //SyncVars do not use changeId.
        [APIExclude]
        protected override void WriteChangeId(PooledWriter writer) { }

        /// <summary>
        /// Resets to initialized values.
        /// </summary>
        [MakePublic]
        protected internal override void ResetState(bool asServer)
        {
            base.ResetState(asServer);
            /* Only full reset under the following conditions:
             * asServer is true.
             * Is not network initialized.
             * asServer is false, and server is not started. */
            if (base.CanReset(asServer))
            {
                _value = _initialValue;
                _valueSetAfterInitialized = false;
            }
        }
    }
}
#endif﻿
namespace FishNet.Observing
{
    [System.Flags]
    public enum HostVisibilityUpdateTypes : byte
    {
        /// <summary>
        /// Include this flag to update manager.
        /// </summary>
        Manager = 1,
        /// <summary>
        /// Include this flag to update spawned.
        /// </summary>
        Spawned = 2,
    }

}
﻿using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing.Server;
using FishNet.Object;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using FishNet.Managing;
using UnityEngine;

namespace FishNet.Observing
{
    /// <summary>
    /// Controls which clients can see and get messages for an object.
    /// </summary>
    [DisallowMultipleComponent]
    [RequireComponent(typeof(NetworkObject))]
    [AddComponentMenu("FishNet/Component/NetworkObserver")]
    public sealed class NetworkObserver : MonoBehaviour
    {
        #region Types.
        /// <summary>
        /// How ObserverManager conditions are used.
        /// </summary>
        public enum ConditionOverrideType
        {
            /// <summary>
            /// Keep current conditions, add new conditions from manager.
            /// </summary>
            AddMissing = 1,
            /// <summary>
            /// Replace current conditions with manager conditions.
            /// </summary>
            UseManager = 2,
            /// <summary>
            /// Keep current conditions, ignore manager conditions.
            /// </summary>
            IgnoreManager = 3,
        }
        #endregion

        #region Internal.
        /// <summary>
        /// True if the ObserverManager had already added conditions for this component.
        /// </summary>
        internal bool ConditionsSetByObserverManager;
        #endregion

        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("How ObserverManager conditions are used.")]
        [SerializeField]
        private ConditionOverrideType _overrideType = ConditionOverrideType.IgnoreManager;
        /// <summary>
        /// How ObserverManager conditions are used.
        /// </summary>
        public ConditionOverrideType OverrideType
        {
            get => _overrideType;
            internal set => _overrideType = value;
        }

        /// <summary>
        /// 
        /// </summary>
        [Tooltip("True to update visibility for clientHost based on if they are an observer or not.")]
        [SerializeField]
        private bool _updateHostVisibility = true;
        /// <summary>
        /// True to update visibility for clientHost based on if they are an observer or not.
        /// </summary>
        public bool UpdateHostVisibility
        {
            get => _updateHostVisibility;
            private set => _updateHostVisibility = value;
        }
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Conditions connections must met to be added as an observer. Multiple conditions may be used.")]
        [SerializeField]
        internal List<ObserverCondition> _observerConditions = new();
        /// <summary>
        /// Conditions connections must met to be added as an observer. Multiple conditions may be used.
        /// </summary>
        public IReadOnlyList<ObserverCondition> ObserverConditions => _observerConditions;
        [APIExclude]
#if MIRROR
        public List<ObserverCondition> ObserverConditionsInternal
#else
        internal List<ObserverCondition> ObserverConditionsInternal
#endif
        {
            get => _observerConditions;
            set => _observerConditions = value;
        }
        #endregion

        #region Private.
        /// <summary>
        /// Conditions under this component which are timed.
        /// </summary>
        private List<ObserverCondition> _timedConditions;
        /// <summary>
        /// Connections which have all non-timed conditions met.
        /// </summary>
        private HashSet<NetworkConnection> _nonTimedMet;
        /// <summary>
        /// NetworkObject this belongs to.
        /// </summary>
        private NetworkObject _networkObject;
        /// <summary>
        /// Becomes true when registered with ServerObjects as Timed observers.
        /// </summary>
        private bool _registeredAsTimed;
        /// <summary>
        /// True if was initialized previously.
        /// </summary>
        private bool _conditionsInitializedPreviously;
        /// <summary>
        /// True if currently initialized.
        /// </summary>
        private bool _initialized;
        /// <summary>
        /// True if ParentNetworkObject was visible last iteration.
        /// This value will also be true if there is no ParentNetworkObject.
        /// </summary>
        private bool _lastParentVisible;
        /// <summary>
        /// ServerManager for this script.
        /// </summary>
        private ServerManager _serverManager;
        /// <summary>
        /// Becomes true if there are non-timed, normal conditions.
        /// </summary>
        private bool _hasNormalConditions;
        #endregion

        /// <summary>
        /// Deinitializes for reuse or clean up.
        /// </summary>
        /// <param name="destroyed"></param>
        internal void Deinitialize(bool destroyed)
        {
            _lastParentVisible = false;
            if (_nonTimedMet != null)
                _nonTimedMet.Clear();
            UnregisterTimedConditions();

            if (_serverManager != null)
                _serverManager.OnRemoteConnectionState -= ServerManager_OnRemoteConnectionState;

            if (_conditionsInitializedPreviously)
            {
                _hasNormalConditions = false;

                foreach (ObserverCondition item in _observerConditions)
                {
                    item.Deinitialize(destroyed);
                    /* Use GetInstanceId to ensure the object is actually
                     * instantiated. If Id is negative, then it's instantiated
                     * and not a reference to the original object. */
                    if (destroyed && item.GetInstanceID() < 0)
                        Destroy(item);
                }

                //Clean up lists.
                if (destroyed)
                {
                    _observerConditions.Clear();
                    CollectionCaches<ObserverCondition>.Store(_timedConditions);
                    CollectionCaches<NetworkConnection>.Store(_nonTimedMet);
                }
            }

            _serverManager = null;
            _networkObject = null;
            _initialized = false;
        }

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        internal void Initialize(NetworkObject networkObject)
        {
            if (_initialized)
                return;

            _networkObject = networkObject;
            _serverManager = _networkObject.ServerManager;
            _serverManager.OnRemoteConnectionState += ServerManager_OnRemoteConnectionState;

            bool observerFound = _conditionsInitializedPreviously;

            if (!_conditionsInitializedPreviously)
            {
                _conditionsInitializedPreviously = true;
                bool ignoringManager = (OverrideType == ConditionOverrideType.IgnoreManager);

                //Check to override SetHostVisibility.
                if (!ignoringManager)
                    UpdateHostVisibility = networkObject.ObserverManager.UpdateHostVisibility;

                /* Sort the conditions so that normal conditions are first.
                 * This prevents normal conditions from being skipped if a timed
                 * condition fails before the normal passed.
                 *
                 * Example: Let's say an object has a distance and scene condition, with
                 * the distance condition being first. Normal conditions are only checked
                 * as the change occurs, such as when the scene was loaded. So if the client
                 * loaded into the scene and they were not within the distance the condition
                 * iterations would skip remaining, which would be the scene condition. As
                 * result normal conditions (non timed) would never be met since they are only
                 * checked as-needed, in this case during a scene change.
                 *
                 * By moving normal conditions to the front they will always be checked first
                 * and timed can update at intervals per expectancy. This could also be resolved
                 * by simply not exiting early when a condition fails but that's going to
                 * cost hotpath performance where sorting is only done once. */

                //Initialize collections.
                _nonTimedMet = CollectionCaches<NetworkConnection>.RetrieveHashSet();
                //Caches for ordering.
                List<ObserverCondition> nonTimedConditions = CollectionCaches<ObserverCondition>.RetrieveList();
                List<ObserverCondition> timedConditions = CollectionCaches<ObserverCondition>.RetrieveList();
                
                foreach (ObserverCondition condition in _observerConditions)
                {
                    if (condition == null)
                        continue;

                    observerFound = true;

                    /* Make an instance of each condition so values are
                     * not overwritten when the condition exist more than
                     * once in the scene. Double-edged sword of using scriptable
                     * objects for conditions. */
                    ObserverCondition ocCopy = Instantiate(condition);

                    //Condition type.
                    ObserverConditionType oct = ocCopy.GetConditionType();
                    if (oct == ObserverConditionType.Timed)
                    {
                        timedConditions.AddOrdered(ocCopy);
                    }
                    else
                    {
                        _hasNormalConditions = true;
                        nonTimedConditions.AddOrdered(ocCopy);
                    }
                }

                //Add to condition collection as ordered now.
                _observerConditions.Clear();
                //Non timed.
                for (int i = 0; i < nonTimedConditions.Count; i++)
                    _observerConditions.Add(nonTimedConditions[i]);

                //Timed.
                _timedConditions = CollectionCaches<ObserverCondition>.RetrieveList();
                foreach (ObserverCondition timedCondition in timedConditions)
                {
                    _observerConditions.Add(timedCondition);
                    _timedConditions.Add(timedCondition);
                }

                //Store caches.
                CollectionCaches<ObserverCondition>.Store(nonTimedConditions);
                CollectionCaches<ObserverCondition>.Store(timedConditions);
            }

            if (observerFound)
            {
                //Initialize conditions.
                for (int i = 0; i < _observerConditions.Count; i++)
                    _observerConditions[i].Initialize(_networkObject);
                
                RegisterTimedConditions();
            }
            
            _initialized = true;
        }

        /// <summary>
        /// Returns a condition if found within Conditions.
        /// </summary>
        /// <returns></returns>
        public ObserverCondition GetObserverCondition<T>() where T : ObserverCondition
        {
            /* Do not bother setting local variables,
             * condition collections aren't going to be long
             * enough to make doing so worth while. */

            System.Type conditionType = typeof(T);
            for (int i = 0; i < _observerConditions.Count; i++)
            {
                if (_observerConditions[i].GetType() == conditionType)
                    return _observerConditions[i];
            }

            //Fall through, not found.
            return null;
        }

        /// <summary>
        /// Returns ObserverStateChange by comparing conditions for a connection.
        /// </summary>
        /// <returns>True if added to Observers.</returns>
        internal ObserverStateChange RebuildObservers(NetworkConnection connection, bool timedOnly)
        {
            if (!_initialized)
            {
                string goName = (gameObject == null) ? "Empty" : gameObject.name;
                NetworkManagerExtensions.LogError($"{GetType().Name} is not initialized on NetworkObject [{goName}]. RebuildObservers should not be called. If you are able to reproduce this error consistently please report this issue.");
                return ObserverStateChange.Unchanged;
            }

            bool currentlyAdded = (_networkObject.Observers.Contains(connection));

            //True if all conditions are met.
            bool allConditionsMet = true;
            /* If cnnection is owner then they can see the object. */
            bool notOwner = (connection != _networkObject.Owner);
            /* Only check conditions if not owner. Owner will always
             * have visibility. */
            if (notOwner)
            {
                bool parentVisible = true;
                if (_networkObject.CurrentParentNetworkBehaviour != null)
                    parentVisible = _networkObject.CurrentParentNetworkBehaviour.NetworkObject.Observers.Contains(connection);

                /* If parent is visible but was not previously
                 * then unset timedOnly to make sure all conditions
                 * are checked again. This ensures that the _nonTimedMet
                 * collection is updated. */
                if (parentVisible && !_lastParentVisible)
                    timedOnly = false;
                _lastParentVisible = parentVisible;

                //If parent is not visible no further checks are required.
                if (!parentVisible)
                {
                    allConditionsMet = false;
                }
                //Parent is visible, perform checks.
                else
                {
                    //Only need to check beyond this if conditions exist.
                    if (_observerConditions.Count > 0)
                    {
                        /* True if all conditions are timed or
                         * if connection has met non timed. */
                        bool startNonTimedMet = (!_hasNormalConditions || _nonTimedMet.Contains(connection));
                        /* If a timed update an1d nonTimed
                         * have not been met then there's
                         * no reason to check timed. */
                        if (timedOnly && !startNonTimedMet)
                        {
                            allConditionsMet = false;
                        }
                        else
                        {
                            //Becomes true if a non-timed condition fails.
                            bool nonTimedMet = true;

                            List<ObserverCondition> collection = (timedOnly) ? _timedConditions : _observerConditions;
                            for (int i = 0; i < collection.Count; i++)
                            {
                                ObserverCondition condition = collection[i];
                                /* If any observer returns removed then break
                                 * from loop and return removed. If one observer has
                                 * removed then there's no reason to iterate
                                 * the rest.
                                 *
                                 * A condition is automatically met if it's not enabled. */
                                bool notProcessed = false;
                                bool conditionMet = (!condition.GetIsEnabled() || condition.ConditionMet(connection, currentlyAdded, out notProcessed));

                                if (notProcessed)
                                    conditionMet = currentlyAdded;

                                //Condition not met.
                                if (!conditionMet)
                                {
                                    allConditionsMet = false;
                                    if (condition.GetConditionType() != ObserverConditionType.Timed)
                                        nonTimedMet = false;
                                    break;
                                }
                            }

                            //If nonTimedMet changed.
                            if (startNonTimedMet != nonTimedMet)
                            {
                                /* If the collection was iterated without breaks
                                 * then add to nontimed met. */
                                if (nonTimedMet)
                                    _nonTimedMet.Add(connection);
                                //If there were breaks not all conditions were checked.
                                else
                                    _nonTimedMet.Remove(connection);
                            }
                        }
                    }
                }
            }

            //If all conditions met.
            if (allConditionsMet)
                return ReturnPassedConditions(currentlyAdded);
            else
                return ReturnFailedCondition(currentlyAdded);
        }

        /// <summary>
        /// Registers timed observer conditions.
        /// </summary>
        private void RegisterTimedConditions()
        {
            if (_timedConditions == null || _timedConditions.Count == 0)
                return;
            if (_registeredAsTimed)
                return;
            _registeredAsTimed = true;

            if (_serverManager == null)
                return;
            _serverManager.Objects.AddTimedNetworkObserver(_networkObject);
        }

        /// <summary>
        /// Unregisters timed conditions.
        /// </summary>
        private void UnregisterTimedConditions()
        {
            if (_timedConditions == null || _timedConditions.Count == 0)
                return;
            if (!_registeredAsTimed)
                return;
            _registeredAsTimed = false;

            if (_serverManager == null)
                return;
            _serverManager.Objects.RemoveTimedNetworkObserver(_networkObject);
        }

        /// <summary>
        /// Returns an ObserverStateChange when a condition fails.
        /// </summary>
        /// <param name="currentlyAdded"></param>
        /// <returns></returns>
        private ObserverStateChange ReturnFailedCondition(bool currentlyAdded)
        {
            if (currentlyAdded)
                return ObserverStateChange.Removed;
            else
                return ObserverStateChange.Unchanged;
        }

        /// <summary>
        /// Returns an ObserverStateChange when all conditions pass.
        /// </summary>
        /// <param name="currentlyAdded"></param>
        /// <returns></returns>
        private ObserverStateChange ReturnPassedConditions(bool currentlyAdded)
        {
            if (currentlyAdded)
                return ObserverStateChange.Unchanged;
            else
                return ObserverStateChange.Added;
        }

        /// <summary>
        /// Called when a remote client state changes with the server.
        /// </summary>
        private void ServerManager_OnRemoteConnectionState(NetworkConnection conn, RemoteConnectionStateArgs arg2)
        {
            if (arg2.ConnectionState == RemoteConnectionState.Stopped)
                _nonTimedMet.Remove(conn);
        }

        /// <summary>
        /// Sets a new value for UpdateHostVisibility.
        /// This does not immediately update renderers.
        /// You may need to combine with NetworkObject.SetRenderersVisible(bool).
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetUpdateHostVisibility(bool value)
        {
            //Unchanged.
            if (value == UpdateHostVisibility)
                return;

            UpdateHostVisibility = value;
        }
    }
}﻿// using FishNet.Connection;
// using FishNet.Documenting;
// using FishNet.Managing.Server;
// using FishNet.Object;
// using FishNet.Transporting;
// using FishNet.Utility.Performance;
// using GameKit.Dependencies.Utilities;
// using System.Collections.Generic;
// using System.Runtime.CompilerServices;
// using FishNet.Managing.Observing;
// using UnityEngine;
// using UnityEngine.Serialization;
//
// namespace FishNet.Observing
// {
//     /// <summary>
//     /// Controls which clients can see and get messages for an object.
//     /// </summary>
//     [DisallowMultipleComponent]
//     [RequireComponent(typeof(NetworkObject))]
//     [AddComponentMenu("FishNet/Component/NetworkObserver")]
//     public sealed class NetworkObserver : MonoBehaviour
//     {
//         #region Types.
//         /// <summary>
//         /// How ObserverManager conditions are used.
//         /// </summary>
//         public enum ConditionOverrideType
//         {
//             /// <summary>
//             /// Keep current conditions, add new conditions from manager.
//             /// </summary>
//             AddMissing = 1,
//             /// <summary>
//             /// Replace current conditions with manager conditions.
//             /// </summary>
//             UseManager = 2,
//             /// <summary>
//             /// Keep current conditions, ignore manager conditions.
//             /// </summary>
//             IgnoreManager = 3,
//         }
//         #endregion
//
//         #region Serialized.
//         /// <summary>
//         /// 
//         /// </summary>
//         [Tooltip("How ObserverManager conditions are used.")]
//         [SerializeField]
//         private ConditionOverrideType _overrideType = ConditionOverrideType.IgnoreManager;
//         /// <summary>
//         /// How ObserverManager conditions are used.
//         /// </summary>
//         public ConditionOverrideType OverrideType
//         {
//             get => _overrideType;
//             internal set => _overrideType = value;
//         }
//
//         /// <summary>
//         /// 
//         /// </summary>
//         [Tooltip("True to update visibility for clientHost based on if they are an observer or not.")]
//         [SerializeField]
//         private bool _updateHostVisibility = true;
//         /// <summary>
//         /// True to update visibility for clientHost based on if they are an observer or not.
//         /// </summary>
//         public bool UpdateHostVisibility
//         {
//             get => _updateHostVisibility;
//             private set => _updateHostVisibility = value;
//         }
//         /// <summary>
//         /// 
//         /// </summary>
//         [Tooltip("Conditions connections must met to be added as an observer. Multiple conditions may be used.")]
//         [SerializeField]
//         internal List<ObserverCondition> _observerConditions = new();
//         /// <summary>
//         /// Conditions connections must met to be added as an observer. Multiple conditions may be used.
//         /// </summary>
//         public IReadOnlyList<ObserverCondition> ObserverConditions => _observerConditions;
//         [APIExclude]
// #if MIRROR
//         public List<ObserverCondition> ObserverConditionsInternal
// #else
//         internal List<ObserverCondition> ObserverConditionsInternal
// #endif
//         {
//             get => _observerConditions;
//             set => _observerConditions = value;
//         }
//         #endregion
//
//         #region Private.
//         /// <summary>
//         /// Becomes true if there are timed conditions.
//         /// </summary>
//         private bool _hasTimedConditions;
//         /// <summary>
//         /// Connections which have all non-timed conditions met.
//         /// </summary>
//         private HashSet<NetworkConnection> _nonTimedMet;
//         /// <summary>
//         /// NetworkObject this belongs to.
//         /// </summary>
//         private NetworkObject _networkObject;
//         /// <summary>
//         /// Becomes true when registered with ServerObjects as Timed observers.
//         /// </summary>
//         private bool _registeredAsTimed;
//         /// <summary>
//         /// True if was initialized previously.
//         /// </summary>
//         private bool _initializedPreviously;
//         /// <summary>
//         /// True if currently initialized.
//         /// </summary>
//         private bool _initialized;
//         /// <summary>
//         /// Last ObserverManager hash which initialized conditions.
//         /// </summary>
//         private uint _initializingHash = ObserverManager.UNSET_INITIALIZING_HASH
//         /// <summary>
//         /// True if ParentNetworkObject was visible last iteration.
//         /// This value will also be true if there is no ParentNetworkObject.
//         /// </summary>
//         private bool _lastParentVisible;
//         /// <summary>
//         /// ServerManager for this script.
//         /// </summary>
//         private ServerManager _serverManager;
//         /// <summary>
//         /// Becomes true if there are non-timed, normal conditions.
//         /// </summary>
//         private bool _hasNormalConditions;
//         /// <summary>
//         /// ObserverConditions which are referenced or instantiated from ObserverConditions.
//         /// </summary>
//         private List<ObserverCondition> _runtimeObserverConditions;
//         #endregion
//
//         /// <summary>
//         /// Deinitializes for reuse or clean up.
//         /// </summary>
//         /// <param name="destroyed"></param>
//         internal void Deinitialize(bool destroyed)
//         {
//             if (!_initialized)
//                 return;
//
//             Debug.Log($"Deinit called on {GetInstanceID()}. Destroyed? {destroyed}");
//
//             _lastParentVisible = false;
//             if (_nonTimedMet != null)
//                 _nonTimedMet.Clear();
//             UnregisterTimedConditions();
//
//             if (_serverManager != null)
//                 _serverManager.OnRemoteConnectionState -= ServerManager_OnRemoteConnectionState;
//
//             if (_initializedPreviously)
//             {
//                 _hasNormalConditions = false;
//
//                 foreach (ObserverCondition item in _observerConditions)
//                 {
//                     item.Deinitialize(destroyed);
//                     /* Use GetInstanceId to ensure the object is actually
//                      * instantiated. If Id is negative, then it's instantiated
//                      * and not a reference to the original object. */
//                     if (destroyed && item.GetInstanceID() < 0)
//                         Destroy(item);
//                 }
//
//                 //Clean up lists.
//                 if (destroyed)
//                     CollectionCaches<NetworkConnection>.Store(_nonTimedMet);
//             }
//
//             _serverManager = null;
//             _networkObject = null;
//             _initialized = false;
//         }
//
//         /// <summary>
//         /// Initializes this script for use.
//         /// </summary>
//         internal void Initialize(NetworkObject networkObject)
//         {
//             if (_initialized)
//                 return;
//
//             Debug.Log($"Init called on {GetInstanceID()}. Initialized previously? {_initializedPreviously}");
//             _networkObject = networkObject;
//             _serverManager = _networkObject.ServerManager;
//             _serverManager.OnRemoteConnectionState += ServerManager_OnRemoteConnectionState;
//
//             if (!_initializedPreviously)
//             {
//                 _initializedPreviously = true;
//                 bool ignoringManager = (OverrideType == ConditionOverrideType.IgnoreManager);
//
//                 //Check to override SetHostVisibility.
//                 if (!ignoringManager)
//                     UpdateHostVisibility = networkObject.ObserverManager.UpdateHostVisibility;
//
//                 /* Sort the conditions so that normal conditions are first.
//                  * This prevents normal conditions from being skipped if a timed
//                  * condition fails before the normal passed.
//                  *
//                  * Example: Let's say an object has a distance and scene condition, with
//                  * the distance condition being first. Normal conditions are only checked
//                  * as the change occurs, such as when the scene was loaded. So if the client
//                  * loaded into the scene and they were not within the distance the condition
//                  * iterations would skip remaining, which would be the scene condition. As
//                  * result normal conditions (non timed) would never be met since they are only
//                  * checked as-needed, in this case during a scene change.
//                  *
//                  * By moving normal conditions to the front they will always be checked first
//                  * and timed can update at intervals per expectancy. This could also be resolved
//                  * by simply not exiting early when a condition fails but that's going to
//                  * cost hotpath performance where sorting is only done once. */
//
//                 //Initialize collections.
//                 _nonTimedMet = CollectionCaches<NetworkConnection>.RetrieveHashSet();
//                 //Caches for ordering.
//                 List<ObserverCondition> nonTimedConditions = CollectionCaches<ObserverCondition>.RetrieveList();
//                 List<ObserverCondition> timedConditions = CollectionCaches<ObserverCondition>.RetrieveList();
//
//                 bool observerFound = false;
//                 foreach (ObserverCondition condition in _observerConditions)
//                 {
//                     if (condition == null)
//                         continue;
//
//                     observerFound = true;
//
//                     /* Make an instance of each condition so values are
//                      * not overwritten when the condition exist more than
//                      * once in the scene. Double-edged sword of using scriptable
//                      * objects for conditions. */
//                     ObserverCondition ocCopy = Instantiate(condition);
//
//                     //Condition type.
//                     ObserverConditionType oct = ocCopy.GetConditionType();
//                     if (oct == ObserverConditionType.Timed)
//                     {
//                         timedConditions.AddOrdered(ocCopy);
//                     }
//                     else
//                     {
//                         _hasNormalConditions = true;
//                         nonTimedConditions.AddOrdered(ocCopy);
//                     }
//                 }
//
//                 //Add to condition collection as ordered now.
//                 _observerConditions.Clear();
//                 //Non timed.
//                 for (int i = 0; i < nonTimedConditions.Count; i++)
//                     _observerConditions.Add(nonTimedConditions[i]);
//
//                 //Timed.
//                 _timedConditions = CollectionCaches<ObserverCondition>.RetrieveList();
//                 foreach (ObserverCondition timedCondition in timedConditions)
//                 {
//                     _observerConditions.Add(timedCondition);
//                     _timedConditions.Add(timedCondition);
//                 }
//
//                 //Store caches.
//                 CollectionCaches<ObserverCondition>.Store(nonTimedConditions);
//                 CollectionCaches<ObserverCondition>.Store(timedConditions);
//
//                 //No observers specified, do not need to take further action.
//                 if (!observerFound)
//                     return;
//             }
//
//             //Initialize conditions.
//             for (int i = 0; i < _observerConditions.Count; i++)
//                 _observerConditions[i].Initialize(_networkObject);
//
//             _initialized = true;
//
//             RegisterTimedConditions();
//         }
//
//         /// <summary>
//         /// Returns a condition if found within Conditions.
//         /// </summary>
//         /// <returns></returns>
//         public ObserverCondition GetObserverCondition<T>() where T : ObserverCondition
//         {
//             /* Do not bother setting local variables,
//              * condition collections aren't going to be long
//              * enough to make doing so worth while. */
//
//             System.Type conditionType = typeof(T);
//             for (int i = 0; i < _observerConditions.Count; i++)
//             {
//                 if (_observerConditions[i].GetType() == conditionType)
//                     return _observerConditions[i];
//             }
//
//             //Fall through, not found.
//             return null;
//         }
//
//         /// <summary>
//         /// Returns ObserverStateChange by comparing conditions for a connection.
//         /// </summary>
//         /// <returns>True if added to Observers.</returns>
//         internal ObserverStateChange RebuildObservers(NetworkConnection connection, bool timedOnly)
//         {
//             bool currentlyAdded = (_networkObject.Observers.Contains(connection));
//
//             //True if all conditions are met.
//             bool allConditionsMet = true;
//             /* If cnnection is owner then they can see the object. */
//             bool notOwner = (connection != _networkObject.Owner);
//             /* Only check conditions if not owner. Owner will always
//              * have visibility. */
//             if (notOwner)
//             {
//                 bool parentVisible = true;
//                 if (_networkObject.CurrentParentNetworkBehaviour != null)
//                     parentVisible = _networkObject.CurrentParentNetworkBehaviour.NetworkObject.Observers.Contains(connection);
//
//                 /* If parent is visible but was not previously
//                  * then unset timedOnly to make sure all conditions
//                  * are checked again. This ensures that the _nonTimedMet
//                  * collection is updated. */
//                 if (parentVisible && !_lastParentVisible)
//                     timedOnly = false;
//                 _lastParentVisible = parentVisible;
//
//                 //If parent is not visible no further checks are required.
//                 if (!parentVisible)
//                 {
//                     allConditionsMet = false;
//                 }
//                 //Parent is visible, perform checks.
//                 else
//                 {
//                     //Only need to check beyond this if conditions exist.
//                     if (_observerConditions.Count > 0)
//                     {
//                         /* True if all conditions are timed or
//                          * if connection has met non timed. */
//                         bool startNonTimedMet = (!_hasNormalConditions || _nonTimedMet.Contains(connection));
//                         /* If a timed update an1d nonTimed
//                          * have not been met then there's
//                          * no reason to check timed. */
//                         if (timedOnly && !startNonTimedMet)
//                         {
//                             allConditionsMet = false;
//                         }
//                         else
//                         {
//                             //Becomes true if a non-timed condition fails.
//                             bool nonTimedMet = true;
//
//                             List<ObserverCondition> collection = _runtimeObserverConditions;
//                             for (int i = 0; i < collection.Count; i++)
//                             {
//                                 ObserverCondition condition = collection[i];
//
//                                 if (timedOnly && condition.GetConditionType() != ObserverConditionType.Timed)
//                                     continue;
//                                 /* If any observer returns removed then break
//                                  * from loop and return removed. If one observer has
//                                  * removed then there's no reason to iterate
//                                  * the rest.
//                                  *
//                                  * A condition is automatically met if it's not enabled. */
//                                 bool notProcessed = false;
//                                 Debug.LogWarning($"Condition check {GetInstanceID()}     {condition.GetInstanceID()}. Type {condition.GetType()}");
//                                 bool conditionMet = (!condition.GetIsEnabled() || condition.ConditionMet(connection, currentlyAdded, out notProcessed));
//
//                                 if (notProcessed)
//                                     conditionMet = currentlyAdded;
//
//                                 //Condition not met.
//                                 if (!conditionMet)
//                                 {
//                                     allConditionsMet = false;
//                                     if (condition.GetConditionType() != ObserverConditionType.Timed)
//                                         nonTimedMet = false;
//                                     break;
//                                 }
//                             }
//
//                             //If nonTimedMet changed.
//                             if (startNonTimedMet != nonTimedMet)
//                             {
//                                 /* If the collection was iterated without breaks
//                                  * then add to nontimed met. */
//                                 if (nonTimedMet)
//                                     _nonTimedMet.Add(connection);
//                                 //If there were breaks not all conditions were checked.
//                                 else
//                                     _nonTimedMet.Remove(connection);
//                             }
//                         }
//                     }
//                 }
//             }
//
//             //If all conditions met.
//             if (allConditionsMet)
//                 return ReturnPassedConditions(currentlyAdded);
//             else
//                 return ReturnFailedCondition(currentlyAdded);
//         }
//
//         /// <summary>
//         /// Registers timed observer conditions.
//         /// </summary>
//         private void RegisterTimedConditions()
//         {
//             if (!_hasTimedConditions)
//                 return;
//             if (_registeredAsTimed)
//                 return;
//             
//             _registeredAsTimed = true;
//
//             if (_serverManager == null)
//                 return;
//             _serverManager.Objects.AddTimedNetworkObserver(_networkObject);
//         }
//
//         /// <summary>
//         /// Unregisters timed conditions.
//         /// </summary>
//         private void UnregisterTimedConditions()
//         {
//             if (!_hasTimedConditions)
//                 return;
//             if (!_registeredAsTimed)
//                 return;
//             _registeredAsTimed = false;
//
//             if (_serverManager == null)
//                 return;
//             _serverManager.Objects.RemoveTimedNetworkObserver(_networkObject);
//         }
//
//         /// <summary>
//         /// Returns an ObserverStateChange when a condition fails.
//         /// </summary>
//         /// <param name="currentlyAdded"></param>
//         /// <returns></returns>
//         private ObserverStateChange ReturnFailedCondition(bool currentlyAdded)
//         {
//             if (currentlyAdded)
//                 return ObserverStateChange.Removed;
//             else
//                 return ObserverStateChange.Unchanged;
//         }
//
//         /// <summary>
//         /// Returns an ObserverStateChange when all conditions pass.
//         /// </summary>
//         /// <param name="currentlyAdded"></param>
//         /// <returns></returns>
//         private ObserverStateChange ReturnPassedConditions(bool currentlyAdded)
//         {
//             if (currentlyAdded)
//                 return ObserverStateChange.Unchanged;
//             else
//                 return ObserverStateChange.Added;
//         }
//
//         /// <summary>
//         /// Called when a remote client state changes with the server.
//         /// </summary>
//         private void ServerManager_OnRemoteConnectionState(NetworkConnection conn, RemoteConnectionStateArgs arg2)
//         {
//             if (arg2.ConnectionState == RemoteConnectionState.Stopped)
//                 _nonTimedMet.Remove(conn);
//         }
//
//         /// <summary>
//         /// Updates current conditions to supplied values. Conditions are updated if forced or if the manager hash provided differs from what is stored.
//         /// </summary>
//         internal void SetObserverConditions(List<ObserverCondition> conditions, uint observerManagerHash, bool force = false)
//         {
//             //Already initialized for the observerManager!
//             if (observerManagerHash == _initializingHash && !force)
//                 return;
//             if (_overrideType == ConditionOverrideType.IgnoreManager)
//                 return;
//
//             DisposeOfRuntimeConditions();
//
//             //Caches for ordering.
//             List<ObserverCondition> nonTimedConditions = CollectionCaches<ObserverCondition>.RetrieveList();
//             List<ObserverCondition> timedConditions = CollectionCaches<ObserverCondition>.RetrieveList();
//
//             //Set new conditions.
//             foreach (ObserverCondition oc in conditions)
//             {
//                 if (oc == null)
//                     continue;
//
//                 /* Make an instance of each condition so values are
//                  * not overwritten when the condition exist more than
//                  * once in the scene. Double-edged sword of using scriptable
//                  * objects for conditions. */
//                 ObserverCondition ocCopy = (oc.IsConstant) ? oc : Instantiate(oc);
//
//                 //Condition type.
//                 ObserverConditionType oct = ocCopy.GetConditionType();
//                 if (oct == ObserverConditionType.Timed)
//                 {
//                     timedConditions.AddOrdered(ocCopy);
//                 }
//                 else
//                 {
//                     _hasNormalConditions = true;
//                     nonTimedConditions.AddOrdered(ocCopy);
//                 }
//             }
//
//             CollectionCaches<ObserverCondition>.StoreAndDefault(ref _runtimeObserverConditions);
//             _runtimeObserverConditions = CollectionCaches<ObserverCondition>.RetrieveList();
//
//             /* Add nonTimed first, as they're always checked first for performance. */
//             for (int i = 0; i < nonTimedConditions.Count; i++)
//                 _runtimeObserverConditions.Add(nonTimedConditions[i]);
//
//             /* Add timed into their own collection as well runtime collection.
//              * There are separate collections as timed are checked regularly so
//              * this prevents iterating over all conditions in a timed check. */
//             CollectionCaches<ObserverCondition>.StoreAndDefault(ref _timedConditions);
//             _timedConditions = CollectionCaches<ObserverCondition>.RetrieveList();
//             foreach (ObserverCondition timedCondition in timedConditions)
//             {
//                 _observerConditions.Add(timedCondition);
//                 _timedConditions.Add(timedCondition);
//             }
//
//             //Store caches.
//             CollectionCaches<ObserverCondition>.Store(nonTimedConditions);
//             CollectionCaches<ObserverCondition>.Store(timedConditions);
//         }
//
//         /// <summary>
//         /// Updates current conditions to supplied values. Conditions are updated if forced or if the manager hash provided differs from what is stored.
//         /// </summary>
//         public void UpdateObserverConditions(List<ObserverCondition> conditions, uint observerManagerHash, bool force = false)
//         {
//             //Already initialized for the observerManager!
//             if (observerManagerHash == _initializingHash && !force)
//                 return;
//
//             //Dispose of current instantiated conditions.
//             foreach (ObserverCondition oc in _observerConditions)
//             {
//                 //Constant are never initialized.
//                 if (oc.IsConstant)
//                     continue;
//                 /* Not constant, but isn't in instance.
//                  * Unity tells us only negative Ids are instantiated. */
//                 if (oc.GetInstanceID() >= 0)
//                     continue;
//
//                 oc.Deinitialize(destroyed: true);
//                 Destroy(oc);
//             }
//
//             _observerConditions.Clear();
//         }
//
//         /// <summary>
//         /// Destroys runtime ObserverConditions as needed and clears the collection.
//         /// </summary>
//         private void DisposeOfRuntimeConditions()
//         {
//             if (_runtimeObserverConditions == null)
//                 return;
//
//             foreach (ObserverCondition oc in _runtimeObserverConditions)
//             {
//                 //Constant are never initialized.
//                 if (oc.IsConstant)
//                     continue;
//                 /* Not constant, but isn't in instance.
//                  * Unity tells us only negative Ids are instantiated. */
//                 if (oc.GetInstanceID() >= 0)
//                     continue;
//
//                 oc.Deinitialize(destroyed: true);
//                 Destroy(oc);
//             }
//
//             _runtimeObserverConditions.Clear();
//         }
//
//         /// <summary>
//         /// Sets a new value for UpdateHostVisibility.
//         /// This does not immediately update renderers.
//         /// You may need to combine with NetworkObject.SetRenderersVisible(bool).
//         /// </summary>
//         /// <param name="value">New value.</param>
//         public void SetUpdateHostVisibility(bool value)
//         {
//             //Unchanged.
//             if (value == UpdateHostVisibility)
//                 return;
//
//             UpdateHostVisibility = value;
//         }
//     }
// }﻿using FishNet.Connection;
using FishNet.Managing.Server;
using FishNet.Object;
using System;
using GameKit.Dependencies.Utilities.Types;
using UnityEngine;

namespace FishNet.Observing
{
    /// <summary>
    /// Condition a connection must meet to be added as an observer.
    /// This class can be inherited from for custom conditions.
    /// </summary>
    public abstract class ObserverCondition : ScriptableObject, IOrderable
    {
        #region Public.
        /// <summary>
        /// NetworkObject this condition is for.
        /// </summary>
        [HideInInspector]
        public NetworkObject NetworkObject;
        #endregion

        #region Serialized.
        /// <summary>
        /// Order in which conditions are added to the NetworkObserver. Lower values will added first, resulting in the condition being checked first. Timed conditions will never check before non-timed conditions.
        /// </summary>
        public int Order => _addOrder;
        [Tooltip("Order in which conditions are added to the NetworkObserver. Lower values will added first, resulting in the condition being checked first. Timed conditions will never check before non-timed conditions.")]
        [SerializeField]
        [Range(sbyte.MinValue, sbyte.MaxValue)]
        private sbyte _addOrder;
        /// <summary>
        /// Setting this to true can save performance on conditions which do change settings or store data at runtime.
        /// This feature does not function yet, but you may set values now for future implementation.
        /// </summary>
        public bool IsConstant => _isConstant;
        [Tooltip("Setting this to true can save performance on conditions which do change settings or store data at runtime. This feature does not function yet but you may set values now for future implementation.")]
        [SerializeField]
        private bool _isConstant;
        #endregion

        #region Private.
        /// <summary>
        /// True if this condition is enabled.
        /// </summary>
        private bool _isEnabled = true;

        /// <summary>
        /// Gets the enabled state of this condition.
        /// </summary>
        /// <returns></returns>
        public bool GetIsEnabled() => _isEnabled;

        /// <summary>
        /// Sets the enabled state of this condition.
        /// If the state has changed observers will be rebuilt
        /// for this object.
        /// </summary>
        /// <param name="value"></param>
        public void SetIsEnabled(bool value)
        {
            if (value == GetIsEnabled())
                return;

            _isEnabled = value;
            //No object to rebuild for.
            if (NetworkObject == null)
                return;

            ServerObjects so = NetworkObject?.ServerManager?.Objects;
            if (so != null)
                so.RebuildObservers(NetworkObject);
        }
        #endregion

        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        /// <param name="networkObject">NetworkObject this condition is initializing for.</param>
        public virtual void Initialize(NetworkObject networkObject)
        {
            NetworkObject = networkObject;
        }

        /// <summary>
        /// Deinitializes this script.
        /// </summary>
        /// <param name="destroyed">True if the object is being destroyed, false if being despawned. An object may deinitialize for despawn, then destroy after.</param>
        public virtual void Deinitialize(bool destroyed)
        {
            NetworkObject = null;
        }

        /// <summary>
        /// Returns if the object which this condition resides should be visible to connection.
        /// </summary>
        /// <param name="connection">Connection which the condition is being checked for.</param>
        /// <param name="currentlyAdded">True if the connection currently has visibility of this object.</param>
        /// <param name="notProcessed">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param>
        public abstract bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed);

        /// <summary>
        /// Type of condition this is. Certain types are handled different, such as Timed which are checked for changes at timed intervals.
        /// </summary>
        /// <returns></returns>
        public abstract ObserverConditionType GetConditionType();
    }
}﻿
namespace FishNet.Observing
{
    /// <summary>
    /// How a condition is handled.
    /// This is intentionally not set as flags.
    /// </summary>
    public enum ObserverConditionType : byte
    {
        /// <summary>
        /// Condition is checked only when changed.
        /// </summary>
        Normal = 1,
        /// <summary>
        /// Condition requires checks at regular intervals. The intervals are handled internally.
        /// </summary>
        Timed = 2,
    }
}
﻿namespace FishNet.Observing
{
    /// <summary>
    /// States which observer(s) can change to.
    /// </summary>
    internal enum ObserverStateChange : byte
    {
        Unchanged = 0,
        Added = 1,
        Removed = 2
    }
}﻿using FishNet.Connection;
using FishNet.Object;
using FishNet.Observing;
using System;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Component.Observing
{
    /// <summary>
    /// When this observer condition is placed on an object, a client must be within the specified distance to view the object.
    /// </summary>
    [CreateAssetMenu(menuName = "FishNet/Observers/Distance Condition", fileName = "New Distance Condition")]
    public class DistanceCondition : ObserverCondition
    {
        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Maximum distance a client must be within this object to see it.")]
        [SerializeField]
        private float _maximumDistance = 100f;
        /// <summary>
        /// Maximum distance a client must be within this object to see it.
        /// </summary>
        [Obsolete("Use Get/SetMaximumDistance.")]
        public float MaximumDistance
        {
            get => GetMaximumDistance();
            set => SetMaximumDistance(value);
        }

        /// <summary>
        /// Maximum distance a client must be within this object to see it.
        /// </summary>
        /// <returns></returns>
        public float GetMaximumDistance() => _maximumDistance;
        /// <summary>
        /// Sets the maximum distance value.
        /// </summary>
        /// <param name="value">New value.</param>
        public void SetMaximumDistance(float value)
        {
            _maximumDistance = value;
            _sqrMaximumDistance = (_maximumDistance * _maximumDistance);

            float maxDistanceHide = (_maximumDistance * (1f + _hideDistancePercent));
            _sqrHideMaximumDistance = (maxDistanceHide * maxDistanceHide);
        }

        /// <summary>
        /// Additional percent of distance client must be until this object is hidden. For example, if distance was 100f and percent was 0.5f the client must be 150f units away before this object is hidden again. This can be useful for keeping objects from regularly appearing and disappearing.
        /// </summary>
        [Tooltip("Additional percent of distance client must be until this object is hidden. For example, if distance was 100f and percent was 0.5f the client must be 150f units away before this object is hidden again. This can be useful for keeping objects from regularly appearing and disappearing.")]
        [Range(0f, 1f)]
        [SerializeField]
        private float _hideDistancePercent = 0.1f;
        #endregion

        #region Private.
        /// <summary>
        /// MaximumDistance squared for faster checks.
        /// </summary>
        private float _sqrMaximumDistance;
        /// <summary>
        /// Distance to hide object at.
        /// </summary>
        private float _sqrHideMaximumDistance;
        #endregion

        private void Awake()
        {
            SetMaximumDistance(_maximumDistance);
        }

        /// <summary>
        /// Returns if the object which this condition resides should be visible to connection.
        /// </summary>
        /// <param name="connection">Connection which the condition is being checked for.</param>
        /// <param name="currentlyAdded">True if the connection currently has visibility of this object.</param>
        /// <param name="notProcessed">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param>
        public override bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed)
        {
            //If here then checks are being processed.
            notProcessed = false;

            float sqrMaximumDistance = (currentlyAdded) ? _sqrHideMaximumDistance : _sqrMaximumDistance;
            Vector3 thisPosition = NetworkObject.transform.position;
            foreach (NetworkObject nob in connection.Objects)
            {
                //If within distance.
                if (Vector3.SqrMagnitude(nob.transform.position - thisPosition) <= sqrMaximumDistance)
                    return true;
            }

            /* If here no client objects are within distance. */
            return false;
        }

        /// <summary>
        /// Type of condition this is. Certain types are handled different, such as Timed which are checked for changes at timed intervals.
        /// </summary>
        /// <returns></returns>
        public override ObserverConditionType GetConditionType() => ObserverConditionType.Timed;
    }
}﻿using FishNet.Connection;
using FishNet.Observing;
using UnityEngine;

namespace FishNet.Component.Observing
{
    [CreateAssetMenu(menuName = "FishNet/Observers/Host Only Condition", fileName = "New Host Only Condition")]
    public class HostOnlyCondition : ObserverCondition
    {
        public override bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed)
        {
            notProcessed = false;
            /* Only return true if connection is the local client.
             * This check only runs on the server, so if local client
             * is true then they must also be the server (clientHost). */
            return (base.NetworkObject.ClientManager.Connection == connection);
        }

        /// <summary>
        /// How a condition is handled.
        /// </summary>
        /// <returns></returns>
        public override ObserverConditionType GetConditionType() => ObserverConditionType.Normal;
    }
}
﻿using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Logging;
using FishNet.Managing.Server;
using FishNet.Object;
using FishNet.Observing;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Component.Observing
{
    /// <summary>
    /// When this observer condition is placed on an object, a client must be within the same match to view the object.
    /// </summary>
    [CreateAssetMenu(menuName = "FishNet/Observers/Match Condition", fileName = "New Match Condition")]
    public class MatchCondition : ObserverCondition
    {
        #region Types.
        /// <summary>
        /// MatchCondition collections used.
        /// </summary>
        public class ConditionCollections
        {
            public Dictionary<int, HashSet<NetworkConnection>> MatchConnections = new();
            public Dictionary<NetworkConnection, HashSet<int>> ConnectionMatches = new();
            public Dictionary<int, HashSet<NetworkObject>> MatchObjects = new();
            public Dictionary<NetworkObject, HashSet<int>> ObjectMatches = new();
        }
        #endregion

        #region Private.
        /// <summary>
        /// Collections for each NetworkManager instance.
        /// </summary>
        private static Dictionary<NetworkManager, ConditionCollections> _collections = new();
        #endregion

        #region Collections.
        /// <summary>
        /// Stores collections for a manager.
        /// </summary>
        /// <param name="manager"></param>
        internal static void StoreCollections(NetworkManager manager)
        {
            ConditionCollections cc;
            if (!_collections.TryGetValue(manager, out cc))
                return;

            foreach (HashSet<int> item in cc.ObjectMatches.Values)
                CollectionCaches<int>.Store(item);
            foreach (HashSet<NetworkConnection> item in cc.MatchConnections.Values)
                CollectionCaches<NetworkConnection>.Store(item);
            foreach (HashSet<NetworkObject> item in cc.MatchObjects.Values)
                CollectionCaches<NetworkObject>.Store(item);
            foreach (HashSet<int> item in cc.ConnectionMatches.Values)
                CollectionCaches<int>.Store(item);

            _collections.Remove(manager);
        }
        /// <summary>
        /// Gets condition collections for a NetowrkManager.
        /// </summary>
        private static ConditionCollections GetCollections(NetworkManager manager = null)
        {
            if (manager == null)
                manager = InstanceFinder.NetworkManager;

            ConditionCollections cc;
            if (!_collections.TryGetValue(manager, out cc))
            {
                cc = new();
                _collections[manager] = cc;
            }

            return cc;
        }

        /// <summary>
        /// Returns matches and connections in each match.
        /// </summary>
        /// <param name="manager">NetworkManager to use.</param>
        /// <returns></returns>
        public static Dictionary<int, HashSet<NetworkConnection>> GetMatchConnections(NetworkManager manager = null)
        {
            ConditionCollections cc = GetCollections(manager);
            return cc.MatchConnections;
        }
        /// <summary>
        /// Returns connections and the matches they are in.
        /// </summary>
        /// <param name="manager">NetworkManager to use.</param>
        /// <returns></returns>
        public static Dictionary<NetworkConnection, HashSet<int>> GetConnectionMatches(NetworkManager manager = null)
        {
            ConditionCollections cc = GetCollections(manager);
            return cc.ConnectionMatches;
        }
        /// <summary>
        /// Returns matches and objects within each match.
        /// </summary>
        /// <param name="manager">NetworkManager to use.</param>
        /// <returns></returns>
        public static Dictionary<int, HashSet<NetworkObject>> GetMatchObjects(NetworkManager manager = null)
        {
            ConditionCollections cc = GetCollections(manager);
            return cc.MatchObjects;
        }
        /// <summary>
        /// Returns objects and the matches they are in.
        /// </summary>
        /// <param name="manager">NetworkManager to use.</param>
        /// <returns></returns>
        public static Dictionary<NetworkObject, HashSet<int>> GetObjectMatches(NetworkManager manager = null)
        {
            ConditionCollections cc = GetCollections(manager);
            return cc.ObjectMatches;
        }
        #endregion

        #region Add to match NetworkConnection.
        /// <summary>
        /// Adds a connection to a match.
        /// </summary>
        private static bool AddToMatch(int match, NetworkConnection conn, NetworkManager manager, bool replaceMatch, bool rebuild)
        {
            Dictionary<int, HashSet<NetworkConnection>> matchConnections = GetMatchConnections(manager);

            if (replaceMatch)
                RemoveFromMatchesWithoutRebuild(conn, manager);

            /* Get current connections in match. This is where the conn
             * will be added to. If does not exist then make new
             * collection. */
            HashSet<NetworkConnection> matchConnValues;
            if (!matchConnections.TryGetValueIL2CPP(match, out matchConnValues))
            {
                matchConnValues = CollectionCaches<NetworkConnection>.RetrieveHashSet();
                matchConnections.Add(match, matchConnValues);
            }

            bool r = matchConnValues.Add(conn);
            AddToConnectionMatches(conn, match, manager);
            if (r && rebuild)
                GetServerObjects(manager).RebuildObservers();

            return r;
        }


        /// <summary>
        /// Adds a connection to a match.
        /// </summary>
        /// <param name="match">Match to add conn to.</param>
        /// <param name="conn">Connection to add to match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        /// <param name="replaceMatch">True to replace other matches with the new match.</param>
        public static void AddToMatch(int match, NetworkConnection conn, NetworkManager manager = null, bool replaceMatch = false)
        {
            AddToMatch(match, conn, manager, replaceMatch, true);
        }

        /// <summary>
        /// Updates a connection within ConnectionMatches to contain match.
        /// </summary>
        private static void AddToConnectionMatches(NetworkConnection conn, int match, NetworkManager manager)
        {
            Dictionary<NetworkConnection, HashSet<int>> connectionMatches = GetConnectionMatches(manager);

            HashSet<int> matches;
            if (!connectionMatches.TryGetValueIL2CPP(conn, out matches))
            {
                matches = CollectionCaches<int>.RetrieveHashSet();
                connectionMatches[conn] = matches;
            }

            matches.Add(match);
        }

        /// <summary>
        /// Adds connections to a match.
        /// </summary>
        /// <param name="match">Match to add conns to.</param>
        /// <param name="conns">Connections to add to match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        /// <param name="replaceMatch">True to replace other matches with the new match.</param>
        public static void AddToMatch(int match, NetworkConnection[] conns, NetworkManager manager = null, bool replaceMatch = false)
        {
            AddToMatch(match, conns.ToList(), manager, replaceMatch);
        }
        /// <summary>
        /// Adds connections to a match.
        /// </summary>
        /// <param name="match">Match to add conns to.</param>
        /// <param name="conns">Connections to add to match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        /// <param name="replaceMatch">True to replace other matches with the new match.</param>
        public static void AddToMatch(int match, List<NetworkConnection> conns, NetworkManager manager = null, bool replaceMatch = false)
        {
            bool added = false;
            foreach (NetworkConnection c in conns)
                added |= AddToMatch(match, c, manager, replaceMatch, false);

            if (added)
                GetServerObjects(manager).RebuildObservers();
        }
        #endregion

        #region Add to match NetworkObject.
        /// <summary>
        /// Adds an object to a match.
        /// </summary>
        private static bool AddToMatch(int match, NetworkObject nob, NetworkManager manager, bool replaceMatch, bool rebuild)
        {
            Dictionary<int, HashSet<NetworkObject>> matchObjects = GetMatchObjects(manager);
            Dictionary<NetworkObject, HashSet<int>> objectMatches = GetObjectMatches(manager);

            if (replaceMatch)
                RemoveFromMatchWithoutRebuild(nob, manager);

            HashSet<NetworkObject> matchObjectsValues;
            if (!matchObjects.TryGetValueIL2CPP(match, out matchObjectsValues))
            {
                matchObjectsValues = CollectionCaches<NetworkObject>.RetrieveHashSet();
                matchObjects.Add(match, matchObjectsValues);
            }
            bool added = matchObjectsValues.Add(nob);

            /* Also add to reverse dictionary. */
            HashSet<int> objectMatchesValues;
            if (!objectMatches.TryGetValueIL2CPP(nob, out objectMatchesValues))
            {
                objectMatchesValues = CollectionCaches<int>.RetrieveHashSet();
                objectMatches.Add(nob, objectMatchesValues);
            }
            objectMatchesValues.Add(match);

            if (added && rebuild)
                GetServerObjects(manager).RebuildObservers();

            return added;
        }
        /// <summary>
        /// Adds an object to a match.
        /// </summary>
        /// <param name="match">Match to add conn to.</param>
        /// <param name="nob">Connection to add to match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        /// <param name="replaceMatch">True to replace other matches with the new match.</param>
        public static void AddToMatch(int match, NetworkObject nob, NetworkManager manager = null, bool replaceMatch = false)
        {
            AddToMatch(match, nob, manager, replaceMatch, true);
        }
        /// <summary>
        /// Adds objects to a match.
        /// </summary>
        /// <param name="match">Match to add conns to.</param>
        /// <param name="nobs">Connections to add to match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        /// <param name="replaceMatch">True to replace other matches with the new match.</param>
        public static void AddToMatch(int match, NetworkObject[] nobs, NetworkManager manager = null, bool replaceMatch = false)
        {
            AddToMatch(match, nobs.ToList(), manager, replaceMatch);
        }
        /// <summary>
        /// Adds objects to a match.
        /// </summary>
        /// <param name="match">Match to add conns to.</param>
        /// <param name="nobs">Connections to add to match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        /// <param name="replaceMatch">True to replace other matches with the new match.</param>
        public static void AddToMatch(int match, List<NetworkObject> nobs, NetworkManager manager = null, bool replaceMatch = false)
        {
            //Remove from current matches.
            if (replaceMatch)
            {
                foreach (NetworkObject n in nobs)
                    RemoveFromMatchWithoutRebuild(n, manager);
            }

            bool added = false;
            //Add to matches.
            foreach (NetworkObject n in nobs)
                added |= AddToMatch(match, n, manager, replaceMatch, false);

            if (added)
                GetServerObjects(manager).RebuildObservers();
        }
        #endregion

        #region TryRemoveKey.
        /// <summary>
        /// Removes a key if values are empty, and caches values.
        /// </summary>
        private static void TryRemoveKey(Dictionary<int, HashSet<NetworkObject>> dict, int key, HashSet<NetworkObject> value)
        {
            bool isEmpty = true;
            if (value != null)
            {
                isEmpty = (value.Count == 0);
                if (isEmpty)
                    CollectionCaches<NetworkObject>.Store(value);
            }

            if (isEmpty)
                dict.Remove(key);
        }
        /// <summary>
        /// Removes a key if values are empty, and caches values.
        /// </summary>
        private static void TryRemoveKey(Dictionary<int, HashSet<NetworkObject>> dict, int key)
        {
            HashSet<NetworkObject> value;
            dict.TryGetValue(key, out value);
            TryRemoveKey(dict, key, value);
        }

        /// <summary>
        /// Removes a key if values are empty, and caches values.
        /// </summary>
        private static void TryRemoveKey(Dictionary<NetworkObject, HashSet<int>> dict, NetworkObject key, HashSet<int> value)
        {
            bool isEmpty = true;
            if (value != null)
            {
                isEmpty = (value.Count == 0);
                if (isEmpty)
                    CollectionCaches<int>.Store(value);
            }

            if (isEmpty)
                dict.Remove(key);
        }
        /// <summary>
        /// Removes a key if values are empty, and caches values.
        /// </summary>
        private static void TryRemoveKey(Dictionary<NetworkObject, HashSet<int>> dict, NetworkObject key)
        {
            HashSet<int> value;
            dict.TryGetValueIL2CPP(key, out value);
            TryRemoveKey(dict, key, value);
        }

        /// <summary>
        /// Removes a key if values are empty, and caches values.
        /// </summary>
        private static void TryRemoveKey(Dictionary<int, HashSet<NetworkConnection>> dict, int key, HashSet<NetworkConnection> value)
        {
            bool isEmpty = true;
            if (value != null)
            {
                isEmpty = (value.Count == 0);
                if (isEmpty)
                    CollectionCaches<NetworkConnection>.Store(value);
            }

            if (isEmpty)
                dict.Remove(key);
        }
        /// <summary>
        /// Removes a key if values are empty, and caches values.
        /// </summary>
        private static void TryRemoveKey(Dictionary<int, HashSet<NetworkConnection>> dict, int key)
        {
            HashSet<NetworkConnection> value;
            dict.TryGetValueIL2CPP(key, out value);
            TryRemoveKey(dict, key, value);
        }

        /// <summary>
        /// Removes a key if values are empty, and caches values.
        /// </summary>
        private static void TryRemoveKey(Dictionary<NetworkConnection, HashSet<int>> dict, NetworkConnection key, HashSet<int> value)
        {
            bool isEmpty = true;
            if (value != null)
            {
                isEmpty = (value.Count == 0);
                if (isEmpty)
                    CollectionCaches<int>.Store(value);
            }

            if (isEmpty)
                dict.Remove(key);
        }
        /// <summary>
        /// Removes a key and caches collections where needed.
        /// </summary>
        private static void TryRemoveKey(Dictionary<NetworkConnection, HashSet<int>> dict, NetworkConnection key)
        {
            HashSet<int> value;
            dict.TryGetValueIL2CPP(key, out value);
            TryRemoveKey(dict, key, value);
        }
        #endregion

        #region Remove from match NetworkConnection.
        /// <summary>
        /// Removes a connection from all matches without rebuilding observers.
        /// </summary>
        /// <param name="conn">Connection to remove from matches.</param>
        /// <param name="manager">NetworkManager connection belongs to. This is not currently used.</param>
        internal static bool RemoveFromMatchesWithoutRebuild(NetworkConnection conn, NetworkManager manager)
        {
            Dictionary<NetworkConnection, HashSet<int>> connectionMatches = GetConnectionMatches(manager);
            Dictionary<int, HashSet<NetworkConnection>> matchConnections = GetMatchConnections(manager);

            bool removed = false;
            //If found to be in a match.
            if (connectionMatches.TryGetValueIL2CPP(conn, out HashSet<int> connectionMatchesValues))
            {
                removed = (connectionMatchesValues.Count > 0);
                foreach (int m in connectionMatchesValues)
                {
                    HashSet<NetworkConnection> matchConnsValues;
                    //If match is found.
                    if (matchConnections.TryGetValue(m, out matchConnsValues))
                    {
                        matchConnsValues.Remove(conn);
                        TryRemoveKey(matchConnections, m, matchConnsValues);
                    }
                }

                //Clear matches connection is in.
                connectionMatchesValues.Clear();
                //Remove from connectionMatches.
                TryRemoveKey(connectionMatches, conn, connectionMatchesValues);
            }

            return removed;
        }

        /// <summary>
        /// Removes a connection from all matches.
        /// </summary>
        /// <param name="conn">NetworkConnection to remove.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        public static void RemoveFromMatch(NetworkConnection conn, NetworkManager manager)
        {
            bool removed = RemoveFromMatchesWithoutRebuild(conn, manager);
            if (removed)
                GetServerObjects(manager).RebuildObservers();
        }
        /// <summary>
        /// Removes a connection from a match.
        /// </summary>
        private static bool RemoveFromMatch(int match, NetworkConnection conn, NetworkManager manager, bool rebuild)
        {
            Dictionary<NetworkConnection, HashSet<int>> connectionMatches = GetConnectionMatches(manager);
            Dictionary<int, HashSet<NetworkConnection>> matchConnections = GetMatchConnections(manager);

            bool removed = false;
            HashSet<NetworkConnection> matchConnsValues;
            if (matchConnections.TryGetValueIL2CPP(match, out matchConnsValues))
            {
                removed |= matchConnsValues.Remove(conn);
                HashSet<int> connectionMatchesValues;
                if (connectionMatches.TryGetValueIL2CPP(conn, out connectionMatchesValues))
                {
                    connectionMatchesValues.Remove(match);
                    TryRemoveKey(connectionMatches, conn, connectionMatchesValues);
                }
                if (removed && rebuild)
                {
                    TryRemoveKey(matchConnections, match, matchConnsValues);
                    GetServerObjects(manager).RebuildObservers();
                }
            }

            return removed;
        }
        /// <summary>
        /// Removes a connection from a match.
        /// </summary>
        /// <param name="match">Match to remove conn from.</param>
        /// <param name="conn">Connection to remove from match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        
        public static bool RemoveFromMatch(int match, NetworkConnection conn, NetworkManager manager = null)
        {
            return RemoveFromMatch(match, conn, manager, true);
        }
        /// <summary>
        /// Removes connections from a match.
        /// </summary>
        /// <param name="match">Match to remove conns from.</param>
        /// <param name="conns">Connections to remove from match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        
        public static void RemoveFromMatch(int match, NetworkConnection[] conns, NetworkManager manager)
        {
            RemoveFromMatch(match, conns.ToList(), manager);
        }
        /// <summary>
        /// Removes connections from a match.
        /// </summary>
        /// <param name="match">Match to remove conns from.</param>
        /// <param name="conns">Connections to remove from match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        
        public static void RemoveFromMatch(int match, List<NetworkConnection> conns, NetworkManager manager)
        {
            bool removed = false;
            foreach (NetworkConnection c in conns)
                removed |= RemoveFromMatch(match, c, manager, false);

            if (removed)
                GetServerObjects(manager).RebuildObservers();
        }
        #endregion

        #region Remove from match NetworkObject.
        /// <summary>
        /// Removes a network object from any match without rebuilding observers.
        /// </summary>
        /// <param name="nob">NetworkObject to remove.</param>
        /// <param name="manager">Manager which the network object belongs to. This value is not yet used.</param>
        internal static bool RemoveFromMatchWithoutRebuild(NetworkObject nob, NetworkManager manager)
        {
            Dictionary<NetworkObject, HashSet<int>> objectMatches = GetObjectMatches(manager);
            Dictionary<int, HashSet<NetworkObject>> matchObjects = GetMatchObjects(manager);

            HashSet<int> objectMatchesValues;
            bool removed = false;
            //If found to be in a match.
            if (objectMatches.TryGetValueIL2CPP(nob, out objectMatchesValues))
            {
                removed = (objectMatchesValues.Count > 0);
                foreach (int m in objectMatchesValues)
                {
                    //If match is found.
                    if (matchObjects.TryGetValue(m, out HashSet<NetworkObject> matchObjectsValues))
                    {
                        matchObjectsValues.Remove(nob);
                        TryRemoveKey(matchObjects, m, matchObjectsValues);
                    }
                }

                //Since object is being removed from all matches this can be cleared.
                objectMatchesValues.Clear();
                TryRemoveKey(objectMatches, nob, objectMatchesValues);
            }

            return removed;
        }
        /// <summary>
        /// Removes nob from all matches.
        /// </summary>
        /// <param name="nob">NetworkObject to remove.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        public static bool RemoveFromMatch(NetworkObject nob, NetworkManager manager = null)
        {
            bool removed = RemoveFromMatchWithoutRebuild(nob, manager);
            if (removed)
                GetServerObjects(manager).RebuildObservers(nob);

            return removed;
        }
        /// <summary>
        /// Removes a network object from all matches.
        /// </summary>
        /// <param name="nobs">NetworkObjects to remove.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        public static void RemoveFromMatch(NetworkObject[] nobs, NetworkManager manager = null)
        {
            RemoveFromMatch(nobs.ToList(), manager);
        }
        /// <summary>
        /// Removes network objects from all matches.
        /// </summary>
        /// <param name="nobs">NetworkObjects to remove.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        public static void RemoveFromMatch(List<NetworkObject> nobs, NetworkManager manager = null)
        {
            bool removed = false;
            foreach (NetworkObject n in nobs)
                removed |= RemoveFromMatchWithoutRebuild(n, manager);

            if (removed)
                GetServerObjects(manager).RebuildObservers(nobs);
        }
        /// <summary>
        /// Removes a network object from a match.
        /// </summary>
        /// <param name="match">Match to remove conn from.</param>
        /// <param name="nob">NetworkObject to remove from match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        
        public static void RemoveFromMatch(int match, NetworkObject nob, NetworkManager manager = null)
        {
            Dictionary<int, HashSet<NetworkObject>> matchObjects = GetMatchObjects(manager);
            Dictionary<NetworkObject, HashSet<int>> objectMatches = GetObjectMatches(manager);

            HashSet<NetworkObject> matchObjectsValues;
            if (matchObjects.TryGetValueIL2CPP(match, out matchObjectsValues))
            {
                bool removed = matchObjectsValues.Remove(nob);

                if (removed)
                {
                    /* Check if nob is still in matches. If not then remove
                     * nob from ObjectMatches. */
                    HashSet<int> objectMatchesValues;
                    if (objectMatches.TryGetValueIL2CPP(nob, out objectMatchesValues))
                    {
                        objectMatchesValues.Remove(match);
                        TryRemoveKey(objectMatches, nob, objectMatchesValues);
                    }

                    TryRemoveKey(matchObjects, match, matchObjectsValues);
                    GetServerObjects(manager).RebuildObservers(nob);
                }
            }
        }
        /// <summary>
        /// Removes network objects from a match.
        /// </summary>
        /// <param name="match">Match to remove conns from.</param>
        /// <param name="nobs">NetworkObjects to remove from match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        
        public static void RemoveFromMatch(int match, NetworkObject[] nobs, NetworkManager manager = null)
        {
            Dictionary<int, HashSet<NetworkObject>> matchObjects = GetMatchObjects(manager);
            Dictionary<NetworkObject, HashSet<int>> objectMatches = GetObjectMatches(manager);

            if (matchObjects.TryGetValueIL2CPP(match, out HashSet<NetworkObject> matchObjectsValues))
            {
                bool removed = false;
                for (int i = 0; i < nobs.Length; i++)
                {
                    NetworkObject n = nobs[i];
                    removed |= matchObjectsValues.Remove(n);
                    objectMatches.Remove(n);
                }

                if (removed)
                {
                    TryRemoveKey(matchObjects, match, matchObjectsValues);
                    GetServerObjects(manager).RebuildObservers(nobs);
                }
            }
        }
        /// <summary>
        /// Removes network objects from a match.
        /// </summary>
        /// <param name="match">Match to remove conns from.</param>
        /// <param name="nobs">NetworkObjects to remove from match.</param>
        /// <param name="manager">NetworkManager to rebuild observers on. If null InstanceFinder.NetworkManager will be used.</param>
        
        public static void RemoveFromMatch(int match, List<NetworkObject> nobs, NetworkManager manager = null)
        {
            Dictionary<int, HashSet<NetworkObject>> matchObjects = GetMatchObjects(manager);
            Dictionary<NetworkObject, HashSet<int>> objectMatches = GetObjectMatches(manager);

            if (matchObjects.TryGetValueIL2CPP(match, out HashSet<NetworkObject> matchObjectsValues))
            {
                bool removed = false;
                for (int i = 0; i < nobs.Count; i++)
                {
                    NetworkObject n = nobs[i];
                    removed |= matchObjectsValues.Remove(n);
                    objectMatches.Remove(n);
                }

                if (removed)
                {
                    TryRemoveKey(matchObjects, match, matchObjectsValues);
                    GetServerObjects(manager).RebuildObservers(nobs);
                }
            }
        }
        #endregion

        /// <summary>
        /// Returns if the object which this condition resides should be visible to connection.
        /// </summary>
        /// <param name="connection">Connection which the condition is being checked for.</param>
        /// <param name="currentlyAdded">True if the connection currently has visibility of this object.</param>
        /// <param name="notProcessed">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param>
        public override bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed)
        {
            //If here then checks are being processed.
            notProcessed = false;
            NetworkConnection owner = base.NetworkObject.Owner;
            /* If object is owned then check if owner
            * and connection share a match. */
            if (owner.IsValid)
            {
                Dictionary<NetworkConnection, HashSet<int>> connectionMatches = GetConnectionMatches(base.NetworkObject.NetworkManager);
                //Output owner matches.
                HashSet<int> ownerMatches;
                /* This objects owner is not in a match so treat it like
                 * a networkobject without an owner. Objects not in matches
                 * are visible to everyone. */
                if (!connectionMatches.TryGetValueIL2CPP(owner, out ownerMatches))
                {
                    return true;
                }
                /* Owner is in a match. See if connection is in any of
                 * the same matches. */
                else
                {
                    //If conn is not in any matches then they cannot see this object, as it is.
                    if (!connectionMatches.TryGetValue(connection, out HashSet<int> connMatches))
                    {
                        return false;
                    }
                    //See if conn is in any of the same matches.
                    else
                    {
                        foreach (int m in connMatches)
                        {
                            if (ownerMatches.Contains(m))
                                return true;
                        }
                    }

                    //Fall through, not found.
                    return false;
                }
            }
            /* If no owner see if the object is in a match and if so
             * then compare that. */
            else
            {
                Dictionary<NetworkObject, HashSet<int>> objectMatches = GetObjectMatches(base.NetworkObject.NetworkManager);
                Dictionary<NetworkConnection, HashSet<int>> connectionMatches = GetConnectionMatches(base.NetworkObject.NetworkManager);

                //Object isn't in a match. Is visible with no owner.
                HashSet<int> objectMatchesValues;
                if (!objectMatches.TryGetValueIL2CPP(base.NetworkObject, out objectMatchesValues))
                    return true;
                /* See if connection is in any of same matches as the object.
                 * If connection isn't in a match then it fails as at this point
                 * object would be, but not conn. */
                if (!connectionMatches.TryGetValueIL2CPP(connection, out HashSet<int> connectionMatchesValues))
                    return false;

                //Compare for same matches.
                foreach (int cM in connectionMatchesValues)
                {
                    if (objectMatchesValues.Contains(cM))
                        return true;
                }

                //Fall through, not in any of the matches.
                return false;
            }
        }

        /// <summary>
        /// Returns which ServerObjects to rebuild observers on.
        /// </summary>
        /// <param name="nm"></param>
        /// <returns></returns>
        private static ServerObjects GetServerObjects(NetworkManager manager)
        {
            return (manager == null) ? InstanceFinder.ServerManager.Objects : manager.ServerManager.Objects;
        }

        /// <summary>
        /// How a condition is handled.
        /// </summary>
        /// <returns></returns>
        public override ObserverConditionType GetConditionType() => ObserverConditionType.Normal;
    }
}
﻿using FishNet.Connection;
using FishNet.Observing;
using UnityEngine;

namespace FishNet.Component.Observing
{
    /// <summary>
    /// This condition makes an object only visible to the owner.
    /// </summary>
    [CreateAssetMenu(menuName = "FishNet/Observers/Owner Only Condition", fileName = "New Owner Only Condition")]
    public class OwnerOnlyCondition : ObserverCondition
    {

        /// <summary>
        /// Returns if the object which this condition resides should be visible to connection.
        /// </summary>
        /// <param name="connection">Connection which the condition is being checked for.</param>
        /// <param name="currentlyAdded">True if the connection currently has visibility of this object.</param>
        /// <param name="notProcessed">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param>
        public override bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed)
        {
            notProcessed = false;
            /* Returning false immediately indicates no connection will
             * meet this condition. */
            return false;
        }

        /// <summary>
        /// How a condition is handled.
        /// </summary>
        /// <returns></returns>
        public override ObserverConditionType GetConditionType() => ObserverConditionType.Normal;

    }
}
﻿using FishNet.Connection;
using FishNet.Observing;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Component.Observing
{

    /// <summary>
    /// When this observer condition is placed on an object, a client must be within the same scene to view the object.
    /// </summary>
    [CreateAssetMenu(menuName = "FishNet/Observers/Scene Condition", fileName = "New Scene Condition")]
    public class SceneCondition : ObserverCondition
    {
        /// <summary>
        /// Returns if the object which this condition resides should be visible to connection.
        /// </summary>
        /// <param name="connection">Connection which the condition is being checked for.</param>
        /// <param name="currentlyAdded">True if the connection currently has visibility of this object.</param>
        /// <param name="notProcessed">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param>
        public override bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed)
        {
            notProcessed = false;

            if (base.NetworkObject == null || connection == null)
                return false;
            /* When there is no owner only then is the gameobject
             * scene checked. That's the only way to know at this point. */
            return connection.Scenes.Contains(base.NetworkObject.gameObject.scene);
        }

        /// <summary>
        /// How a condition is handled.
        /// </summary>
        /// <returns></returns>
        public override ObserverConditionType GetConditionType() => ObserverConditionType.Normal;

    }
}
﻿using FishNet.Connection;
using FishNet.Observing;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Component.Observing
{
    /// <summary>
    /// When this observer condition is placed on an object, a client must be within the specified grid accuracy to view the object.
    /// </summary>
    [CreateAssetMenu(menuName = "FishNet/Observers/Grid Condition", fileName = "New Grid Condition")]
    public class GridCondition : ObserverCondition
    {        
        /// <summary>
        /// Returns if the object which this condition resides should be visible to connection.
        /// </summary>
        /// <param name="connection">Connection which the condition is being checked for.</param>
        /// <param name="currentlyAdded">True if the connection currently has visibility of this object.</param>
        /// <param name="notProcessed">True if the condition was not processed. This can be used to skip processing for performance. While output as true this condition result assumes the previous ConditionMet value.</param>
        
        public override bool ConditionMet(NetworkConnection connection, bool currentlyAdded, out bool notProcessed)
        {
            //If here then checks are being processed.
            notProcessed = false;

            return connection.HashGridEntry.NearbyEntries.Contains(base.NetworkObject.HashGridEntry);
        }

        /// <summary>
        /// How a condition is handled.
        /// </summary>
        /// <returns></returns>
        public override ObserverConditionType GetConditionType() => ObserverConditionType.Timed;
    }
}
﻿using FishNet.Managing;
using FishNet.Object;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Component.Observing
{
    public class GridEntry
    {
        /// <summary>
        /// Position on the grid.
        /// </summary>
        public Vector2Int Position;
        /// <summary>
        /// This grid entry as well those neighboring it.
        /// </summary>
        public HashSet<GridEntry> NearbyEntries;

        public GridEntry()
        {
        }

        public GridEntry(HashSet<GridEntry> nearby)
        {
            NearbyEntries = nearby;
        }

        public void SetValues(Vector2Int position, HashSet<GridEntry> nearby)
        {
            Position = position;
            NearbyEntries = nearby;
        }

        public void SetValues(HashSet<GridEntry> nearby)
        {
            NearbyEntries = nearby;
        }

        public void SetValues(Vector2Int position)
        {
            Position = position;
        }

        public void Reset()
        {
            Position = Vector2Int.zero;
            NearbyEntries.Clear();
        }
    }

    public class HashGrid : MonoBehaviour
    {
        #region Types.

        public enum GridAxes : byte
        {
            XY = 0,
            YZ = 1,
            XZ = 2,
        }

        #endregion

        #region Internal.

        /// <summary>
        /// Value for when grid position is not set.
        /// </summary>
        internal static Vector2Int UnsetGridPosition = (Vector2Int.one * int.MaxValue);
        /// <summary>
        /// An empty grid entry.
        /// </summary>
        internal static GridEntry EmptyGridEntry = new(new());

        #endregion

        #region Serialized.

        /// <summary>
        /// Axes of world space to base the grid on.
        /// </summary>
        [Tooltip("Axes of world space to base the grid on.")] [SerializeField]
        private GridAxes _gridAxes = GridAxes.XY;
        /// <summary>
        /// Accuracy of the grid. Objects will be considered nearby if they are within this number of units. Lower values may be more expensive.
        /// </summary>
        [Tooltip("Accuracy of the grid. Objects will be considered nearby if they are within this number of units. Lower values may be more expensive.")] [Range(1, ushort.MaxValue)] [SerializeField]
        private ushort _accuracy = 10;

        #endregion

        /// <summary>
        /// Half of accuracy.
        /// </summary>
        private int _halfAccuracy;
        /// <summary>
        /// Cache of List<GridEntry>.
        /// </summary>
        private Stack<HashSet<GridEntry>> _gridEntryHashSetCache = new();
        /// <summary>
        /// Cache of GridEntrys.
        /// </summary>
        private Stack<GridEntry> _gridEntryCache = new();
        /// <summary>
        /// All grid entries.
        /// </summary>
        private Dictionary<Vector2Int, GridEntry> _gridEntries = new();
        /// <summary>
        /// NetworkManager this is used with.
        /// </summary>
        private NetworkManager _networkManager;

        private void Awake()
        {
            _networkManager = GetComponentInParent<NetworkManager>();

            if (_networkManager == null)
            {
                _networkManager.LogError($"NetworkManager not found on object or within parent of {gameObject.name}. The {GetType().Name} must be placed on or beneath a NetworkManager.");
                return;
            }

            //Make sure there is only one per networkmanager.
            if (!_networkManager.HasInstance<HashGrid>())
            {
                _halfAccuracy = Mathf.CeilToInt((float)_accuracy / 2f);
                _networkManager.RegisterInstance(this);
            }
            else
            {
                Destroy(this);
            }
        }

        /// <summary>
        /// Sets out values to be used when creating a new GridEntry.
        /// </summary>
        private void OutputNewGridCollections(out GridEntry gridEntry, out HashSet<GridEntry> gridEntries)
        {
            const int cacheCount = 100;


            if (!_gridEntryHashSetCache.TryPop(out gridEntries))
            {
                BuildGridEntryHashSetCache();
                gridEntries = new();
            }

            if (!_gridEntryCache.TryPop(out gridEntry))
            {
                BuildGridEntryCache();
                gridEntry = new();
            }

            void BuildGridEntryHashSetCache()
            {
                for (int i = 0; i < cacheCount; i++)
                    _gridEntryHashSetCache.Push(new());
            }

            void BuildGridEntryCache()
            {
                for (int i = 0; i < cacheCount; i++)
                    _gridEntryCache.Push(new());
            }
        }

        /// <summary>
        /// Creates a GridEntry for position and inserts it into GridEntries.
        /// </summary>
        private GridEntry CreateGridEntry(Vector2Int position)
        {
            //Make this into a stack that populates a number of entries when empty. also populate with some in awake.
            GridEntry newEntry;
            HashSet<GridEntry> nearby;
            OutputNewGridCollections(out newEntry, out nearby);
            newEntry.SetValues(position, nearby);
            //Add to grid.
            _gridEntries[position] = newEntry;

            //Get neighbors.
            int endX = (position.x + 1);
            int endY = (position.y + 1);
            int iterations = 0;
            for (int x = (position.x - 1); x <= endX; x++)
            {
                for (int y = (position.y - 1); y <= endY; y++)
                {
                    iterations++;
                    if (_gridEntries.TryGetValue(new(x, y), out GridEntry foundEntry))
                    {
                        nearby.Add(foundEntry);
                        foundEntry.NearbyEntries.Add(newEntry);
                    }
                }
            }

            return newEntry;
        }

        /// <summary>
        /// Gets grid positions and neighbors for a NetworkObject.
        /// </summary>
        internal void GetNearbyHashGridPositions(NetworkObject nob, ref HashSet<Vector2Int> collection)
        {
            Vector2Int position = GetHashGridPosition(nob);
            //Get neighbors.
            int endX = (position.x + 1);
            int endY = (position.y + 1);
            for (int x = (position.x - 1); x < endX; x++)
            {
                for (int y = (position.y - 1); y < endY; y++)
                    collection.Add(new(x, y));
            }
        }

        /// <summary>
        /// Gets the grid position to use for a NetworkObjects current position.
        /// </summary>
        internal Vector2Int GetHashGridPosition(NetworkObject nob)
        {
            Vector3 position = nob.transform.position;
            float fX;
            float fY;
            if (_gridAxes == GridAxes.XY)
            {
                fX = position.x;
                fY = position.y;
            }
            else if (_gridAxes == GridAxes.XZ)
            {
                fX = position.x;
                fY = position.z;
            }
            else if (_gridAxes == GridAxes.YZ)
            {
                fX = position.y;
                fY = position.z;
            }
            else
            {
                _networkManager.LogError($"GridAxes of {_gridAxes.ToString()} is not handled.");
                return default;
            }

            return new(
                (int)fX / _halfAccuracy
                , (int)fY / _halfAccuracy
            );
        }


        /// <summary>
        /// Gets a GridEntry for a NetworkObject, creating the entry if needed.
        /// </summary>
        
        internal GridEntry GetGridEntry(NetworkObject nob)
        {
            Vector2Int pos = GetHashGridPosition(nob);
            return GetGridEntry(pos);
        }

        /// <summary>
        /// Gets a GridEntry for position, creating the entry if needed.
        /// </summary>
        internal GridEntry GetGridEntry(Vector2Int position)
        {
            GridEntry result;
            if (!_gridEntries.TryGetValue(position, out result))
                result = CreateGridEntry(position);

            return result;
        }
    }
}namespace FishNet.Serializing
{
    /// <summary>
    /// How to pack data when using serialization.
    /// </summary>
    public enum AutoPackType
    {
        /// <summary>
        /// Data will not be compressed.
        /// </summary>
        Unpacked = 0,
        /// <summary>
        /// Data will be compressed to use the least amount of data possible.
        /// </summary>
        Packed = 1,
        /// <summary>
        /// Data will be compressed but not as much as Packed.
        /// </summary>
        PackedLess = 2
    }
}
namespace FishNet.Serializing
{
    [System.Flags]
    public enum DeltaSerializerOption : ulong
    {
        Unset = 0,
        FullSerialize = 1,
        RootSerialize = 2,
    }

    public static class DeltaSerializerOptionExtensions
    {
        public static bool FastContains(this DeltaSerializerOption whole, DeltaSerializerOption part) => (whole & part) == part;

    }
}using System.Runtime.CompilerServices;

namespace FishNet.Serializing
{
    /// <summary>
    /// This is for internal use and may change at any time.
    /// </summary>
    [System.Flags]
    public enum DeltaVector2Type : byte
    {
        /// <summary>
        /// This is unused.
        /// </summary>
        Unset = 0,
        /// <summary>
        /// Contains X as 1 byte.
        /// </summary>
        XUInt8 = 1,
        /// <summary>
        /// Contains X as 2 bytes.
        /// </summary>
        XUInt16 = 2,
        /// <summary>
        /// Contains X as 4 bytes.
        /// </summary>
        XUInt32 = 4,
        /// <summary>
        /// Contains Z as 1 byte.
        /// </summary>
        YUInt8 = 8,
        /// <summary>
        /// Contains Z as 2 bytes.
        /// </summary>
        YUInt16 = 16,
        /// <summary>
        /// Contains Z as 4 bytes.
        /// </summary>
        YUInt32 = 32,
        /// <summary>
        /// Contains Y as 1 byte.
        /// </summary>
        XNextIsLarger = 64,
        /// <summary>
        /// Contains Y as 4 bytes.
        /// </summary>
        YNextIsLarger = 128,
    }

    /// <summary>
    /// This is for internal use and may change at any time.
    /// </summary>
    [System.Flags]
    public enum DeltaVector3Type : ushort
    {
        /// <summary>
        /// This is unused.
        /// </summary>
        Unset = 0,
        /// <summary>
        /// Contains X as 1 byte.
        /// </summary>
        XInt8 = 1,
        /// <summary>
        /// Contains X as 2 bytes.
        /// </summary>
        XInt16 = 2,
        /// <summary>
        /// Contains X as 4 bytes.
        /// </summary>
        XInt32 = 4,
        /// <summary>
        /// Contains Z as 1 byte.
        /// </summary>
        ZInt8 = 8,
        /// <summary>
        /// Contains Z as 2 bytes.
        /// </summary>
        ZInt16 = 16,
        /// <summary>
        /// Contains Z as 4 bytes.
        /// </summary>
        ZInt32 = 32,
        /// <summary>
        /// Contains Y as 1 byte.
        /// </summary>
        YInt8 = 64,
        /// <summary>
        /// Contains Y as 2 bytes.
        /// </summary>
        YInt32 = 128,
    }
    
    [System.Flags]
    internal enum DeltaWholeType : byte
    {
        /// <summary>
        /// Indicates there is no compression. This can also be used to initialize the enum.
        /// </summary>
        Unset = 0,
        /// <summary>
        /// Data is written as a byte.
        /// </summary>
        UInt8 = 1,
        /// <summary>
        /// Data is written as a ushort.
        /// </summary>
        UInt16 = 2,
        /// <summary>
        /// Data is written as a uint.
        /// </summary>
        UInt32 = 4,
        /// <summary>
        /// Data is written as a ulong.
        /// </summary>
        UInt64 = 8,
        /// <summary>
        /// data is written as two ulong.
        /// </summary>
        UInt128 = 16,
        /// <summary>
        /// When set this indicates the new value is larger than the previous.
        /// When not set, indicates new value is smaller than the previous.
        /// </summary>
        NextValueIsLarger = 32,
    }
    
    /// <summary>
    /// This is for internal use and may change at any time.
    /// </summary>
    [System.Flags]
    public enum UDeltaPrecisionType : byte
    {
        /// <summary>
        /// Indicates there is no compression. This can also be used to initialize the enum.
        /// </summary>
        Unset = 0,
        /// <summary>
        /// Data is written as a byte.
        /// </summary>
        UInt8 = 1,
        /// <summary>
        /// Data is written as a ushort.
        /// </summary>
        UInt16 = 2,
        /// <summary>
        /// Data is written as a uint.
        /// </summary>
        UInt32 = 4,
        /// <summary>
        /// Data is written as a ulong.
        /// </summary>
        UInt64 = 8,
        /// <summary>
        /// data is written as two ulong.
        /// </summary>
        UInt128 = 16,
        /// <summary>
        /// When set this indicates the new value is larger than the previous.
        /// When not set, indicates new value is smaller than the previous.
        /// </summary>
        NextValueIsLarger = 128,
    }
 
    /// <summary>
    /// This is for internal use and may change at any time.
    /// </summary>
    public static class DeltaTypeExtensions
    {
        public static bool FastContains(this UDeltaPrecisionType whole, UDeltaPrecisionType part) => (whole & part) == part;
        
        public static bool FastContains(this UDeltaPrecisionType whole, UDeltaPrecisionType part, int shift) => FastContains((int)whole, (int)part, shift);

        public static bool FastContains(this DeltaVector3Type whole, DeltaVector3Type part) => (whole & part) == part;
        
        public static bool FastContains(this DeltaVector3Type whole, DeltaVector3Type part, int shift) => FastContains((int)whole, (int)part, shift);
        
        public static bool FastContains(this DeltaVector2Type whole, DeltaVector2Type part) => (whole & part) == part;

        private static bool FastContains(int whole, int part, int shift)
        {
            int intPart = part >> shift;
            return (whole & intPart) == intPart;
        }
    }

}using FishNet.Documenting;
using FishNet.Utility;
using System;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.GENERATED_ASSEMBLY_NAME)]
namespace FishNet.Serializing
{

    /// <summary>
    /// Used to read generic types.
    /// </summary>
    [APIExclude]
    public static class GenericDeltaReader<T>
    {
        public static Func<Reader, T, T> Read { get; internal set; }
        /// <summary>
        /// True if this type has a custom writer.
        /// </summary>
        internal static bool HasCustomSerializer;

        public static void SetRead(Func<Reader, T, T> value)
        {
            /* If a custom serializer has already been set then exit method
             * to not overwrite serializer. */
            if (HasCustomSerializer)
                return;

            bool isGenerated = value.Method.Name.StartsWith(UtilityConstants.GeneratedReaderPrefix);
            /* If generated then see if a regular custom writer exists. If so
             * then do not set a serializer to a generated one. */
            //TODO Make it so DefaultDeltaReader methods are picked up by codegen.
            if (isGenerated && GenericReader<T>.HasCustomSerializer)
                return;
            
            //Set has custom serializer if value being used is not a generated method.
            HasCustomSerializer = !isGenerated;
            Read = value;
        }
    }

}using FishNet.Documenting;
using FishNet.Serializing;
using FishNet.Utility;
using System;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.GENERATED_ASSEMBLY_NAME)]
namespace FishNet.Serializing
{

    /// <summary>
    /// Used to write generic types.
    /// </summary>
    [APIExclude]
    public static class GenericDeltaWriter<T>
    {
        public static Func<Writer, T, T, DeltaSerializerOption, bool> Write { get; internal set; }
        /// <summary>
        /// True if this type has a custom writer.
        /// </summary>
        internal static bool HasCustomSerializer;

        public static void SetWrite(Func<Writer, T, T, DeltaSerializerOption, bool> value)
        {
            /* If a custom serializer has already been set then exit method
             * to not overwrite serializer. */
            if (HasCustomSerializer)
                return;

            bool isGenerated = value.Method.Name.StartsWith(UtilityConstants.GeneratedWriterPrefix);
            /* If generated then see if a regular custom writer exists. If so
             * then do not set a serializer to a generated one. */
            //TODO Make it so DefaultDeltaWriter methods are picked up by codegen.
            if (isGenerated && GenericWriter<T>.HasCustomSerializer)
                return;

            //Set has custom serializer if value being used is not a generated method.
            HasCustomSerializer = !isGenerated;
            Write = value;
        }
    }

}
using FishNet.Documenting;
using FishNet.Utility;
using System;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.GENERATED_ASSEMBLY_NAME)]
//Required for internal tests.
[assembly: InternalsVisibleTo(UtilityConstants.TEST_ASSEMBLY_NAME)]
namespace FishNet.Serializing
{
    /// <summary>
    /// Used to read generic types.
    /// </summary>
    [APIExclude]
    public static class GenericReader<T>
    {
        public static Func<Reader, T> Read { get; set; }        
        /// <summary>
        /// True if this type has a custom writer.
        /// </summary>
        internal static bool HasCustomSerializer;

        public static void SetRead(Func<Reader, T> value)
        {
            /* If a custom serializer has already been set then exit method
             * to not overwrite serializer. */
            if (HasCustomSerializer)
                return;

            bool isGenerated = value.Method.Name.StartsWith(UtilityConstants.GeneratedReaderPrefix);

            //If not generated then unset any generated delta serializer.
            if (!isGenerated && GenericDeltaReader<T>.HasCustomSerializer)
                GenericDeltaReader<T>.Read = null;
            
            //Set has custom serializer if value being used is not a generated method.
            HasCustomSerializer = !isGenerated;
            Read = value;
        }

    }
}
using FishNet.Documenting;
using FishNet.Utility;
using System;
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo(UtilityConstants.GENERATED_ASSEMBLY_NAME)]

namespace FishNet.Serializing
{
    /// <summary>
    /// Used to write generic types.
    /// </summary>
    [APIExclude]
    public static class GenericWriter<T>
    {
        public static Action<Writer, T> Write { get; private set; }
        /// <summary>
        /// True if this type has a custom writer.
        /// </summary>
        internal static bool HasCustomSerializer;

        public static void SetWrite(Action<Writer, T> value)
        {
            /* If a custom serializer has already been set then exit method
             * to not overwrite serializer. */
            if (HasCustomSerializer)
                return;

            bool isGenerated = value.Method.Name.StartsWith(UtilityConstants.GeneratedWriterPrefix);

            //If not generated then unset any generated delta serializer.
            if (!isGenerated && GenericDeltaWriter<T>.HasCustomSerializer)
                GenericDeltaWriter<T>.Write = null;

            //Set has custom serializer if value being used is not a generated method.
            HasCustomSerializer = !isGenerated;
            Write = value;
        }
    }
}#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.CodeGenerating;
using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Object;
using FishNet.Object.Prediction;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using FishNet.Utility;
using FishNet.Utility.Performance;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using UnityEngine;

[assembly: InternalsVisibleTo(UtilityConstants.GENERATED_ASSEMBLY_NAME)]
//Required for internal tests.
[assembly: InternalsVisibleTo(UtilityConstants.TEST_ASSEMBLY_NAME)]

namespace FishNet.Serializing
{
    /// <summary>
    /// Reads data from a buffer.
    /// </summary>
    public partial class Reader
    {
        #region Types.
        public enum DataSource
        {
            Unset = 0,
            Server = 1,
            Client = 2,
        }
        #endregion

        #region Public.
        /// <summary>
        /// Which part of the network the data came from.
        /// </summary>
        public DataSource Source = DataSource.Unset;

        /// <summary>
        /// Capacity of the buffer.
        /// </summary>
        public int Capacity => _buffer.Length;

        /// <summary>
        /// NetworkManager for this reader. Used to lookup objects.
        /// </summary>
        public NetworkManager NetworkManager;

        /// <summary>
        /// Offset within the buffer when the reader was created.
        /// </summary>
        public int Offset { get; private set; }

        /// <summary>
        /// Position for the next read.
        /// </summary>
        public int Position;

        /// <summary>
        /// Total number of bytes available within the buffer.
        /// </summary>
        public int Length { get; private set; }

        /// <summary>
        /// Bytes remaining to be read. This value is Length - Position.
        /// </summary>
        public int Remaining => ((Length + Offset) - Position);
        #endregion

        #region Internal.
        /// <summary>
        /// NetworkConnection that this data came from.
        /// Value may not always be set.
        /// </summary>
        public NetworkConnection NetworkConnection { get; private set; }
#if DEVELOPMENT
        /// <summary>
        /// Last NetworkObject parsed.
        /// </summary>
        public static NetworkObject LastNetworkObject { get; private set; }

        /// <summary>
        /// Last NetworkBehaviour parsed. 
        /// </summary>
        public static NetworkBehaviour LastNetworkBehaviour { get; private set; }
#endif
        #endregion

        #region Private.
        /// <summary>
        /// Data being read.
        /// </summary>
        private byte[] _buffer;
        /// <summary>
        /// Used to convert bytes to a string.
        /// </summary>
        private static readonly UTF8Encoding _encoding = new(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true);
        /// <summary>
        /// Used to convert bytes to a GUID.
        /// </summary>
        private static readonly byte[] _guidBuffer = new byte[16];
        #endregion

        public Reader() { }

        public Reader(byte[] bytes, NetworkManager networkManager, NetworkConnection networkConnection = null, DataSource source = DataSource.Unset)
        {
            Initialize(bytes, networkManager, networkConnection, source);
        }

        public Reader(ArraySegment<byte> segment, NetworkManager networkManager, NetworkConnection networkConnection = null, DataSource source = DataSource.Unset)
        {
            Initialize(segment, networkManager, networkConnection, source);
        }

        /// <summary>
        /// Outputs reader to string.
        /// </summary>
        /// <returns></returns>
        public override string ToString() => ToString(0, Length);

        /// <summary>
        /// Outputs reader to string starting at an index.
        /// </summary>
        /// <returns></returns>
        public string ToString(int offset, int length)
        {
            return $"Position: {Position:0000}, Length: {Length:0000}, Buffer: {BitConverter.ToString(_buffer, offset, length)}.";
        }

        /// <summary>
        /// Outputs reader to string.
        /// </summary>
        /// <returns></returns>
        public string RemainingToString()
        {
            string buffer = (Remaining > 0) ? BitConverter.ToString(_buffer, Position, Remaining) : "null";
            return $"Remaining: {Remaining}, Length: {Length}, Buffer: {buffer}.";
        }

        /// <summary>
        /// Returns remaining data as an ArraySegment.
        /// </summary>
        /// <returns></returns>
        public ArraySegment<byte> GetRemainingData()
        {
            if (Remaining == 0)
                return default;
            else
                return new(_buffer, Position, Remaining);
        }

        /// <summary>
        /// Initializes this reader with data.
        /// </summary>
        public void Initialize(ArraySegment<byte> segment, NetworkManager networkManager, DataSource source = DataSource.Unset)
        {
            Initialize(segment, networkManager, null, source);
        }

        /// <summary>
        /// Initializes this reader with data.
        /// </summary>
        public void Initialize(ArraySegment<byte> segment, NetworkManager networkManager, NetworkConnection networkConnection = null, DataSource source = DataSource.Unset)
        {
            _buffer = segment.Array;
            if (_buffer == null)
                _buffer = new byte[0];

            Position = segment.Offset;
            Offset = segment.Offset;
            Length = segment.Count;

            NetworkManager = networkManager;
            NetworkConnection = networkConnection;
            Source = source;
        }

        /// <summary>
        /// Initializes this reader with data.
        /// </summary>
        public void Initialize(byte[] bytes, NetworkManager networkManager, DataSource source = DataSource.Unset)
        {
            Initialize(new ArraySegment<byte>(bytes), networkManager, null, source);
        }

        /// <summary>
        /// Initializes this reader with data.
        /// </summary>
        public void Initialize(byte[] bytes, NetworkManager networkManager, NetworkConnection networkConnection = null, DataSource source = DataSource.Unset)
        {
            Initialize(new ArraySegment<byte>(bytes), networkManager, networkConnection, source);
        }

        /// <summary>
        /// Reads length. This method is used to make debugging easier.
        /// </summary>
        internal int ReadLength()
        {
            return ReadInt32();
        }

        /// <summary>
        /// Reads a packetId.
        /// </summary>
        internal PacketId ReadPacketId()
        {
            return (PacketId)ReadUInt16Unpacked();
        }

        /// <summary>
        /// Returns a ushort without advancing the reader.
        /// </summary>
        /// <returns></returns>
        internal PacketId PeekPacketId()
        {
            int currentPosition = Position;
            PacketId result = ReadPacketId();
            Position = currentPosition;
            return result;
        }

        /// <summary>
        /// Returns the next byte to be read.
        /// </summary>
        /// <returns></returns>
        internal byte PeekUInt8()
        {
            return _buffer[Position];
        }

        /// <summary>
        /// Skips a number of bytes in the reader.
        /// </summary>
        /// <param name="value">Number of bytes to skip.</param>
        public void Skip(int value)
        {
            if (value < 1 || Remaining < value)
                return;

            Position += value;
        }

        /// <summary>
        /// Clears remaining bytes to be read.
        /// </summary>
        public void Clear()
        {
            if (Remaining > 0)
                Skip(Remaining);
        }

        /// <summary>
        /// Returns the buffer as an ArraySegment.
        /// </summary>
        /// <returns></returns>
        public ArraySegment<byte> GetArraySegmentBuffer()
        {
            return new(_buffer, Offset, Length);
        }

        [Obsolete("Use GetBuffer.")] //Remove V5
        public byte[] GetByteBuffer() => GetBuffer();

        /// <summary>
        /// Returns the buffer as bytes. This does not trim excessive bytes.
        /// </summary>
        /// <returns></returns>
        public byte[] GetBuffer()
        {
            return _buffer;
        }

        [Obsolete("Use GetBufferAllocated().")] //Remove V5
        public byte[] GetByteBufferAllocated() => GetBufferAllocated();

        /// <summary>
        /// Returns the buffer as bytes and allocates into a new array.
        /// </summary>
        /// <returns></returns>
        [Obsolete("Use GetBufferAllocated().")] //Remove V5
        public byte[] GetBufferAllocated()
        {
            byte[] result = new byte[Length];
            Buffer.BlockCopy(_buffer, Offset, result, 0, Length);
            return result;
        }

        /// <summary>
        /// BlockCopies data from the reader to target and advances reader.
        /// </summary>
        /// <param name="target"></param>
        /// <param name="targetOffset"></param>
        /// <param name="count"></param>
        public void BlockCopy(ref byte[] target, int targetOffset, int count)
        {
            Buffer.BlockCopy(_buffer, Position, target, targetOffset, count);
            Position += count;
        }

        [Obsolete("Use ReadUInt8Unpacked.")] //Remove in V5.
        public byte ReadByte() => ReadUInt8Unpacked();

        /// <summary>
        /// Reads a byte.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public byte ReadUInt8Unpacked()
        {
            byte r = _buffer[Position];
            Position += 1;
            return r;
        }

        [Obsolete("Use ReadUInt8ArrayAllocated.")]
        public byte[] ReadBytesAllocated(int count) => ReadUInt8ArrayAllocated(count);

        [Obsolete("Use ReadUInt8Array.")]
        public void ReadBytes(ref byte[] buffer, int count) => ReadUInt8Array(ref buffer, count);

        /// <summary>
        /// Read bytes from position into target.
        /// </summary>
        /// <param name="buffer">Buffer to read bytes into.</param>
        /// <param name="count">Number of bytes to read.</param>
        public void ReadUInt8Array(ref byte[] buffer, int count)
        {
            if (buffer == null)
                NetworkManager.LogError($"Buffer cannot be null.");
            else if (count > buffer.Length)
                NetworkManager.LogError($"Count of {count} exceeds target length of {buffer.Length}.");
            else
                BlockCopy(ref buffer, 0, count);
        }

        /// <summary>
        /// Creates an ArraySegment by reading a number of bytes from position.
        /// </summary>
        /// <param name="count"></param>
        /// <returns></returns>
        public ArraySegment<byte> ReadArraySegment(int count)
        {
            if (count < 0)
            {
                NetworkManager.Log($"ArraySegment count cannot be less than 0.");
                //Purge renaming and return default.
                Position += Remaining;
                return default;
            }

            ArraySegment<byte> result = new(_buffer, Position, count);
            Position += count;
            return result;
        }

        [Obsolete("Use ReadInt8Unpacked.")] //Remove in V5.
        public sbyte ReadSByte() => ReadInt8Unpacked();

        /// <summary>
        /// Reads a sbyte.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public sbyte ReadInt8Unpacked() => (sbyte)ReadUInt8Unpacked();

        /// <summary>
        /// Reads a char.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public char ReadChar() => (char)ReadUInt16();

        /// <summary>
        /// Reads a boolean.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public bool ReadBoolean()
        {
            byte result = ReadUInt8Unpacked();
            return (result == 1) ? true : false;
        }

        /// <summary>
        /// Reads an int16.
        /// </summary>
        /// <returns></returns>
        public ushort ReadUInt16Unpacked()
        {
            ushort result = 0;
            result |= _buffer[Position++];
            result |= (ushort)(_buffer[Position++] << 8);

            return result;
        }

        /// <summary>
        /// Reads an int16.
        /// </summary>
        /// <returns></returns>
        //todo: should be using ReadPackedWhole but something relying on unpacked short/ushort is being written packed, corrupting packets.
        [DefaultReader]
        public ushort ReadUInt16() => ReadUInt16Unpacked();

        /// <summary>
        /// Reads a uint16.
        /// </summary>
        /// <returns></returns>
        //todo: should be using ReadPackedWhole but something relying on unpacked short/ushort is being written packed, corrupting packets.
        public short ReadInt16Unpacked() => (short)ReadUInt16Unpacked();

        /// <summary>
        /// Reads a uint16.
        /// </summary>
        /// <returns></returns>
        //todo: should be using ReadPackedWhole but something relying on unpacked short/ushort is being written packed, corrupting packets.
        [DefaultReader]
        public short ReadInt16() => (short)ReadUInt16Unpacked();

        /// <summary>
        /// Reads an int32.
        /// </summary>
        /// <returns></returns> 
        public uint ReadUInt32Unpacked()
        {
            uint result = 0;
            result |= _buffer[Position++];
            result |= (uint)_buffer[Position++] << 8;
            result |= (uint)_buffer[Position++] << 16;
            result |= (uint)_buffer[Position++] << 24;

            return result;
        }

        /// <summary>
        /// Reads an int32.
        /// </summary>
        /// <returns></returns> 
        [DefaultReader]
        public uint ReadUInt32() => (uint)ReadUnsignedPackedWhole();

        /// <summary>
        /// Reads a uint32.
        /// </summary>
        /// <returns></returns>
        public int ReadInt32Unpacked() => (int)ReadUInt32Unpacked();

        /// <summary>
        /// Reads a uint32.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public int ReadInt32() => (int)ReadSignedPackedWhole();

        /// <summary>
        /// Reads a uint64.
        /// </summary>
        /// <returns></returns>
        public long ReadInt64Unpacked() => (long)ReadUInt64Unpacked();

        /// <summary>
        /// Reads a uint64.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public long ReadInt64() => (long)ReadSignedPackedWhole();

        /// <summary>
        /// Reads an int64.
        /// </summary>
        /// <returns></returns>
        public ulong ReadUInt64Unpacked()
        {
            ulong result = 0;
            result |= _buffer[Position++];
            result |= (ulong)_buffer[Position++] << 8;
            result |= (ulong)_buffer[Position++] << 16;
            result |= (ulong)_buffer[Position++] << 24;
            result |= (ulong)_buffer[Position++] << 32;
            result |= (ulong)_buffer[Position++] << 40;
            result |= (ulong)_buffer[Position++] << 48;
            result |= (ulong)_buffer[Position++] << 56;

            return result;
        }

        /// <summary>
        /// Reads an int64.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public ulong ReadUInt64() => ReadUnsignedPackedWhole();

        /// <summary>
        /// Reads a single.
        /// </summary>
        /// <returns></returns>
        public float ReadSingleUnpacked()
        {
            UIntFloat converter = new();
            converter.UIntValue = ReadUInt32Unpacked();
            return converter.FloatValue;
        }

        /// <summary>
        /// Reads a single.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public float ReadSingle() => ReadSingleUnpacked();

        /// <summary>
        /// Reads a double.
        /// </summary>
        /// <returns></returns>
        public double ReadDoubleUnpacked()
        {
            UIntDouble converter = new();
            converter.LongValue = ReadUInt64Unpacked();
            return converter.DoubleValue;
        }

        /// <summary>
        /// Reads a double.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public double ReadDouble() => ReadDoubleUnpacked();

        /// <summary>
        /// Reads a decimal.
        /// </summary>
        /// <returns></returns>
        public decimal ReadDecimalUnpacked()
        {
            UIntDecimal converter = new();
            converter.LongValue1 = ReadUInt64Unpacked();
            converter.LongValue2 = ReadUInt64Unpacked();
            return converter.DecimalValue;
        }

        /// <summary>
        /// Reads a decimal.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public decimal ReadDecimal() => ReadDecimalUnpacked();
        
        [Obsolete("use ReadStringAllocated.")]
        public string ReadString() => ReadStringAllocated();
        /// <summary>
        /// Reads a string.
        /// </summary>
        /// <returns></returns>  
        [DefaultReader]
        public string ReadStringAllocated()
        {
            int length = ReadInt32();
            //Null string.
            if (length == Writer.UNSET_COLLECTION_SIZE_VALUE)
                return null;

            if (length == 0)
                return string.Empty;
            if (!CheckAllocationAttack(length))
                return string.Empty;

            ArraySegment<byte> data = ReadArraySegment(length);
            return data.Array.ToString(data.Offset, data.Count);
        }

        [Obsolete("Use ReadUInt8ArrayAndSizeAllocated.")]
        public byte[] ReadBytesAndSizeAllocated() => ReadUInt8ArrayAndSizeAllocated();

        /// <summary>
        /// Creates a byte array and reads bytes and size into it.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public byte[] ReadUInt8ArrayAndSizeAllocated()
        {
            int size = ReadInt32();
            if (size == Writer.UNSET_COLLECTION_SIZE_VALUE)
                return null;

            return ReadUInt8ArrayAllocated(size);
        }

        [Obsolete("Use ReadUInt8ArrayAndSize.")]
        public int ReadBytesAndSize(ref byte[] target) => ReadUInt8ArrayAndSize(ref target);

        /// <summary>
        /// Reads bytes and size and copies results into target. Returns UNSET if null was written.
        /// </summary>
        /// <returns>Bytes read.</returns>
        public int ReadUInt8ArrayAndSize(ref byte[] target)
        {
            int size = ReadInt32();
            if (size > 0)
                ReadUInt8Array(ref target, size);

            return size;
        }

        /// <summary>
        /// Reads bytes and size and returns as an ArraySegment.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public ArraySegment<byte> ReadArraySegmentAndSize()
        {
            int size = ReadInt32();
            /* UNSET would be written for null. But since
             * ArraySegments cannot be null return default if
             * length is unset or 0. */
            if (size == Writer.UNSET_COLLECTION_SIZE_VALUE)
                return default;

            return ReadArraySegment(size);
        }

        /// <summary>
        /// Reads a Vector2.
        /// </summary>
        /// <returns></returns>
        public Vector2 ReadVector2Unpacked() => new(ReadSingleUnpacked(), ReadSingleUnpacked());

        /// <summary>
        /// Reads a Vector2.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Vector2 ReadVector2() => ReadVector2Unpacked();

        /// <summary>
        /// Reads a Vector3.
        /// </summary>
        /// <returns></returns>
        public Vector3 ReadVector3Unpacked() => new(ReadSingleUnpacked(), ReadSingleUnpacked(), ReadSingleUnpacked());

        /// <summary>
        /// Reads a Vector3.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Vector3 ReadVector3() => ReadVector3Unpacked();

        /// <summary>
        /// Reads a Vector4.
        /// </summary>
        /// <returns></returns>
        public Vector4 ReadVector4Unpacked() => new(ReadSingleUnpacked(), ReadSingleUnpacked(), ReadSingleUnpacked(), ReadSingleUnpacked());

        /// <summary>
        /// Reads a Vector4.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Vector4 ReadVector4() => ReadVector4Unpacked();

        /// <summary>
        /// Reads a Vector2Int.
        /// </summary>
        /// <returns></returns>
        public Vector2Int ReadVector2IntUnpacked() => new(ReadInt32Unpacked(), ReadInt32Unpacked());

        /// <summary>
        /// Reads a Vector2Int.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Vector2Int ReadVector2Int() => new((int)ReadSignedPackedWhole(), (int)ReadSignedPackedWhole());

        /// <summary>
        /// Reads a Vector3Int.
        /// </summary>
        /// <returns></returns>      
        public Vector3Int ReadVector3IntUnpacked() => new(ReadInt32Unpacked(), ReadInt32Unpacked(), ReadInt32Unpacked());

        /// <summary>
        /// Reads a Vector3Int.
        /// </summary>
        /// <returns></returns>      
        [DefaultReader]
        public Vector3Int ReadVector3Int() => new((int)ReadSignedPackedWhole(), (int)ReadSignedPackedWhole(), (int)ReadSignedPackedWhole());

        /// <summary>
        /// Reads a color.
        /// </summary>
        /// <returns></returns>
        public Color ReadColorUnpacked()
        {
            float r = ReadSingleUnpacked();
            float g = ReadSingleUnpacked();
            float b = ReadSingleUnpacked();
            float a = ReadSingleUnpacked();

            return new(r, g, b, a);
        }

        /// <summary>
        /// Reads a color.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Color ReadColor()
        {
            float r = (float)(ReadUInt8Unpacked() / 100f);
            float g = (float)(ReadUInt8Unpacked() / 100f);
            float b = (float)(ReadUInt8Unpacked() / 100f);
            float a = (float)(ReadUInt8Unpacked() / 100f);

            return new(r, g, b, a);
        }

        /// <summary>
        /// Reads a Color32.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Color32 ReadColor32() => new(ReadUInt8Unpacked(), ReadUInt8Unpacked(), ReadUInt8Unpacked(), ReadUInt8Unpacked());

        /// <summary>
        /// Reads a Quaternion.
        /// </summary>
        /// <returns></returns>
        public Quaternion ReadQuaternionUnpacked() => new(ReadSingleUnpacked(), ReadSingleUnpacked(), ReadSingleUnpacked(), ReadSingleUnpacked());

        /// <summary>
        /// Reads a Quaternion.
        /// </summary>
        /// <returns></returns>
        public Quaternion ReadQuaternion64()
        {
            ulong result = ReadUInt64Unpacked();
            return Quaternion64Compression.Decompress(result);
        }

        /// <summary>
        /// Reads a Quaternion.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Quaternion ReadQuaternion32()
        {
            return Quaternion32Compression.Decompress(this);
        }

        /// <summary>
        /// Reads a Quaternion.
        /// </summary>
        /// <returns></returns>
        internal Quaternion ReadQuaternion(AutoPackType autoPackType)
        {
            switch (autoPackType)
            {
                case AutoPackType.Packed:
                    return ReadQuaternion32();
                case AutoPackType.PackedLess:
                    return ReadQuaternion64();
                default:
                    return ReadQuaternionUnpacked();
            }
        }

        /// <summary>
        /// Reads a Rect.
        /// </summary>
        /// <returns></returns>
        public Rect ReadRectUnpacked() => new(ReadSingleUnpacked(), ReadSingleUnpacked(), ReadSingleUnpacked(), ReadSingleUnpacked());

        /// <summary>
        /// Reads a Rect.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Rect ReadRect() => ReadRectUnpacked();

        /// <summary>
        /// Plane.
        /// </summary>
        /// <returns></returns>
        public Plane ReadPlaneUnpacked() => new(ReadVector3Unpacked(), ReadSingleUnpacked());

        /// <summary>
        /// Plane.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Plane ReadPlane() => ReadPlaneUnpacked();

        /// <summary>
        /// Reads a Ray.
        /// </summary>
        /// <returns></returns>
        public Ray ReadRayUnpacked()
        {
            Vector3 position = ReadVector3Unpacked();
            Vector3 direction = ReadVector3Unpacked();
            return new(position, direction);
        }

        /// <summary>
        /// Reads a Ray.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Ray ReadRay() => ReadRayUnpacked();

        /// <summary>
        /// Reads a Ray.
        /// </summary>
        /// <returns></returns>
        public Ray2D ReadRay2DUnpacked()
        {
            Vector3 position = ReadVector2Unpacked();
            Vector2 direction = ReadVector2Unpacked();
            return new(position, direction);
        }

        /// <summary>
        /// Reads a Ray.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Ray2D ReadRay2D() => ReadRay2DUnpacked();

        /// <summary>
        /// Reads a Matrix4x4.
        /// </summary>
        /// <returns></returns>
        public Matrix4x4 ReadMatrix4x4Unpacked()
        {
            Matrix4x4 result = new()
            {
                m00 = ReadSingleUnpacked(),
                m01 = ReadSingleUnpacked(),
                m02 = ReadSingleUnpacked(),
                m03 = ReadSingleUnpacked(),
                m10 = ReadSingleUnpacked(),
                m11 = ReadSingleUnpacked(),
                m12 = ReadSingleUnpacked(),
                m13 = ReadSingleUnpacked(),
                m20 = ReadSingleUnpacked(),
                m21 = ReadSingleUnpacked(),
                m22 = ReadSingleUnpacked(),
                m23 = ReadSingleUnpacked(),
                m30 = ReadSingleUnpacked(),
                m31 = ReadSingleUnpacked(),
                m32 = ReadSingleUnpacked(),
                m33 = ReadSingleUnpacked()
            };

            return result;
        }

        /// <summary>
        /// Reads a Matrix4x4.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Matrix4x4 ReadMatrix4x4() => ReadMatrix4x4Unpacked();

        /// <summary>
        /// Creates a new byte array and reads bytes into it.
        /// </summary>
        /// <param name="count"></param>
        /// <returns></returns>
        public byte[] ReadUInt8ArrayAllocated(int count)
        {
            if (count < 0)
            {
                NetworkManager.Log($"Bytes count cannot be less than 0.");
                //Purge renaming and return default.
                Position += Remaining;
                return default;
            }


            byte[] bytes = new byte[count];
            ReadUInt8Array(ref bytes, count);
            return bytes;
        }

        /// <summary>
        /// Reads a Guid.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public System.Guid ReadGuid()
        {
            byte[] buffer = _guidBuffer;
            ReadUInt8Array(ref buffer, 16);
            return new(buffer);
        }

        /// <summary>
        /// Reads a tick without packing.
        /// </summary>
        public uint ReadTickUnpacked() => ReadUInt32Unpacked();

        /// <summary>
        /// Reads a GameObject.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public GameObject ReadGameObject()
        {
            byte writtenType = ReadUInt8Unpacked();

            GameObject result;
            //Do nothing for 0, as it indicates null.
            if (writtenType == 0)
            {
                result = null;
            }
            //1 indicates a networkObject.
            else if (writtenType == 1)
            {
                NetworkObject nob = ReadNetworkObject();
                result = (nob == null) ? null : nob.gameObject;
            }
            //2 indicates a networkBehaviour.
            else if (writtenType == 2)
            {
                NetworkBehaviour nb = ReadNetworkBehaviour();
                result = (nb == null) ? null : nb.gameObject;
            }
            else
            {
                result = null;
                NetworkManager.LogError($"Unhandled ReadGameObject type of {writtenType}.");
            }

            return result;
        }

        /// <summary>
        /// Reads a Transform.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public Transform ReadTransform()
        {
            NetworkObject nob = ReadNetworkObject();
            return (nob == null) ? null : nob.transform;
        }

        /// <summary>
        /// Reads a NetworkObject.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public NetworkObject ReadNetworkObject() => ReadNetworkObject(out _);

        /// <summary>
        /// Reads a NetworkObject.
        /// </summary>
        /// <returns></returns>
        public NetworkObject ReadNetworkObject(bool logException) => ReadNetworkObject(out _, null, logException);

        /// <summary>
        /// Reads a NetworkObject.
        /// </summary>
        /// <param name="readSpawningObjects">Objects which have been read to be spawned this tick, but may not have spawned yet.</param>
        /// <returns></returns>
        public NetworkObject ReadNetworkObject(out int objectOrPrefabId, HashSet<int> readSpawningObjects = null, bool logException = true)
        {
#if DEVELOPMENT
            LastNetworkBehaviour = null;
#endif
            objectOrPrefabId = ReadNetworkObjectId();

            bool isSpawned;
            /* UNSET indicates that the object
             * is null or no PrefabId is set.
             * PrefabIds are set in Awake within
             * the NetworkManager so that should
             * never happen so long as nob isn't null. */
            if (objectOrPrefabId == NetworkObject.UNSET_OBJECTID_VALUE)
                return null;
            else
                isSpawned = ReadBoolean();

            bool isServer = NetworkManager.ServerManager.Started;
            bool isClient = NetworkManager.ClientManager.Started;

            NetworkObject result;
            //Is spawned.
            if (isSpawned)
            {
                result = null;
                /* Try to get the object client side first if client
                 * is running. When acting as a host generally the object
                 * will be available in the server and client list
                 * but there can be occasions where the server side
                 * deinitializes the object, making it unavailable, while
                 * it is still available in the client side. Since FishNet doesn't
                 * use a fake host connection like some lesser solutions the client
                 * has to always be treated as it's own entity. */
                if (isClient)
                    NetworkManager.ClientManager.Objects.Spawned.TryGetValueIL2CPP(objectOrPrefabId, out result);
                //If not found on client and server is running then try server.
                if (result == null && isServer)
                    NetworkManager.ServerManager.Objects.Spawned.TryGetValueIL2CPP(objectOrPrefabId, out result);

                if (result == null && !isServer)
                {
                    if (logException && (readSpawningObjects == null || !readSpawningObjects.Contains(objectOrPrefabId)))
                        NetworkManager.LogWarning($"Spawned NetworkObject was expected to exist but does not for Id {objectOrPrefabId}. This may occur if you sent a NetworkObject reference which does not exist, be it destroyed or if the client does not have visibility.");
                }
            }
            //Not spawned.
            else
            {
                //Only look up asServer if not client, otherwise use client.
                bool asServer = !isClient;
                //Look up prefab.
                result = NetworkManager.GetPrefab(objectOrPrefabId, asServer);
            }

#if DEVELOPMENT
            LastNetworkObject = result;
#endif
            return result;
        }

        /// <summary>
        /// Reads a NetworkObjectId and nothing else.
        /// </summary>
        /// <returns></returns>
        public int ReadNetworkObjectId() => (int)ReadSignedPackedWhole();

        /// <summary>
        /// Reads the Id for a NetworkObject and outputs spawn settings.
        /// </summary>
        /// <returns></returns>
        internal int ReadNetworkObjectForSpawn(out int initializeOrder, out ushort collectionid)
        {
            int objectId = ReadNetworkObjectId();
            collectionid = ReadUInt16();
            initializeOrder = ReadInt32();

            return objectId;
        }

        /// <summary>
        /// Reads the Id for a NetworkObject and outputs despawn settings.
        /// </summary>
        /// <returns></returns>
        internal int ReadNetworkObjectForDespawn(out DespawnType dt)
        {
            int objectId = ReadNetworkObjectId();
            dt = (DespawnType)ReadUInt8Unpacked();
            return objectId;
        }

        /// <summary>
        /// Reads a NetworkBehaviourId and ObjectId.
        /// </summary>
        /// <returns></returns>
        internal byte ReadNetworkBehaviourId(out int objectId)
        {
            objectId = ReadNetworkObjectId();
            if (objectId != NetworkObject.UNSET_OBJECTID_VALUE)
                return ReadUInt8Unpacked();
            else
                return 0;
        }

        /// <summary>
        /// Reads a NetworkBehaviour.
        /// </summary>
        /// <param name="readSpawningObjects">Objects which have been read to be spawned this tick, but may not have spawned yet.</param>
        /// <returns></returns>
        public NetworkBehaviour ReadNetworkBehaviour(out int objectId, out byte componentIndex, HashSet<int> readSpawningObjects = null, bool logException = true)
        {
            NetworkObject nob = ReadNetworkObject(out objectId, readSpawningObjects, logException);
            componentIndex = ReadUInt8Unpacked();

            NetworkBehaviour result;
            if (nob == null)
            {
                result = null;
            }
            else
            {
                if (componentIndex >= nob.NetworkBehaviours.Count)
                {
                    NetworkManager.LogError($"ComponentIndex of {componentIndex} is out of bounds on {nob.gameObject.name} [id {nob.ObjectId}]. This may occur if you have modified your gameObject/prefab without saving it, or the scene.");
                    result = null;
                }
                else
                {
                    result = nob.NetworkBehaviours[componentIndex];
                }
            }

#if DEVELOPMENT
            LastNetworkBehaviour = result;
#endif
            return result;
        }

        /// <summary>
        /// Reads a NetworkBehaviour.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public NetworkBehaviour ReadNetworkBehaviour()
        {
            return ReadNetworkBehaviour(out _, out _);
        }

        public NetworkBehaviour ReadNetworkBehaviour(bool logException)
        {
            return ReadNetworkBehaviour(out _, out _, null, logException);
        }

        /// <summary>
        /// Reads a NetworkBehaviourId.
        /// </summary>
        public byte ReadNetworkBehaviourId() => ReadUInt8Unpacked();

        /// <summary>
        /// Reads a DateTime.
        /// </summary>
        /// <param name="dt"></param>
        [DefaultReader]
        public DateTime ReadDateTime()
        {
            long value = (long)ReadSignedPackedWhole();
            DateTime result = DateTime.FromBinary(value);
            return result;
        }

        /// <summary>
        /// Reads a transport channel.
        /// </summary>
        /// <param name="channel"></param>
        [DefaultReader]
        public Channel ReadChannel()
        {
            return (Channel)ReadUInt8Unpacked();
        }

        /// <summary>
        /// Reads the Id for a NetworkConnection.
        /// </summary>
        /// <returns></returns>
        public int ReadNetworkConnectionId() => (int)ReadSignedPackedWhole();

        /// <summary>
        /// Reads a LayerMask.
        /// </summary>
        /// <returns></returns>
        [DefaultReader]
        public LayerMask ReadLayerMask()
        {
            int layerValue = (int)ReadSignedPackedWhole();
            return (LayerMask)layerValue;
        }

        /// <summary>
        /// Reads a NetworkConnection.
        /// </summary>
        /// <param name="conn"></param>
        [DefaultReader]
        public NetworkConnection ReadNetworkConnection()
        {
            int value = ReadNetworkConnectionId();
            if (value == NetworkConnection.UNSET_CLIENTID_VALUE)
            {
                return FishNet.Managing.NetworkManager.EmptyConnection;
            }
            else
            {
                //Prefer server.
                if (NetworkManager.IsServerStarted)
                {
                    NetworkConnection result;
                    if (NetworkManager.ServerManager.Clients.TryGetValueIL2CPP(value, out result))
                    {
                        return result;
                    }
                    //If also client then try client side data.
                    else if (NetworkManager.IsClientStarted)
                    {
                        //If found in client collection then return.
                        if (NetworkManager.ClientManager.Clients.TryGetValueIL2CPP(value, out result))
                            return result;
                        /* Otherwise make a new instance.
                         * We do not know if this is for the server or client so
                         * initialize it either way. Connections rarely come through
                         * without being in server/client side collection. */
                        else
                            return new(NetworkManager, value, -1, true);
                    }
                    //Only server and not found.
                    else
                    {
                        NetworkManager.LogWarning($"Unable to find connection for read Id {value}. An empty connection will be returned.");
                        return FishNet.Managing.NetworkManager.EmptyConnection;
                    }
                }
                //Try client side, will only be able to fetch against local connection.
                else
                {
                    //If value is self then return self.
                    if (value == NetworkManager.ClientManager.Connection.ClientId)
                        return NetworkManager.ClientManager.Connection;
                    //Try client side dictionary.
                    else if (NetworkManager.ClientManager.Clients.TryGetValueIL2CPP(value, out NetworkConnection result))
                        return result;
                    /* Otherwise make a new instance.
                     * We do not know if this is for the server or client so
                     * initialize it either way. Connections rarely come through
                     * without being in server/client side collection. */
                    else
                        return new(NetworkManager, value, -1, true);
                }
            }
        }

        /// <summary>
        /// Reads TransformProperties.
        /// </summary>
        [DefaultReader]
        public TransformProperties ReadTransformProperties()
        {
            Vector3 position = ReadVector3();
            Quaternion rotation = ReadQuaternion32();
            Vector3 scale = ReadVector3();

            return new(position, rotation, scale);
        }

        /// <summary>
        /// Checks if the size could possibly be an allocation attack.
        /// </summary>
        /// <param name="size"></param>
        private bool CheckAllocationAttack(int size)
        {
            /* Possible attacks. Impossible size, or size indicates
             * more elements in collection or more bytes needed
             * than what bytes are available. */
            if (size != Writer.UNSET_COLLECTION_SIZE_VALUE && size < 0)
            {
                NetworkManager.LogError($"Size of {size} is invalid.");
                return false;
            }

            if (size > Remaining)
            {
                NetworkManager.LogError($"Read size of {size} is larger than remaining data of {Remaining}.");
                return false;
            }

            //Checks pass.
            return true;
        }

        /// <summary>
        /// Reads a state update packet.
        /// </summary>
        /// <param name="tick"></param>
        internal void ReadStateUpdatePacket(out uint clientTick)
        {
            clientTick = ReadTickUnpacked();
        }

        #region Packed readers.
        /// <summary>
        /// ZigZag decode an integer. Move the sign bit back to the left.
        /// </summary>
        public ulong ZigZagDecode(ulong value)
        {
            ulong sign = value << 63;
            if (sign > 0)
                return ~(value >> 1) | sign;
            return value >> 1;
        }

        /// <summary>
        /// Reads a packed whole number and applies zigzag decoding.
        /// </summary>
        public long ReadSignedPackedWhole() => (long)ZigZagDecode(ReadUnsignedPackedWhole());

        /// <summary>
        /// Reads a packed whole number.
        /// </summary>
        public ulong ReadUnsignedPackedWhole()
        {
            int shift = 0;
            ulong value = 0;
            /* Maximum number of bytes for ulong.
             * Prevents endless loop. Should not be neccessary but is a nice precaution. */
            int maximumIterations = 10;
            int iterations = 0;
            int bufferLength = GetBuffer().Length;


            while (iterations < maximumIterations)
            {
                if (Position >= bufferLength)
                {
                    NetworkManager.LogError($"Read position of {Position} is beyond reader's buffer length of {bufferLength}.");
                    return 0;
                }

                byte currentByte = _buffer[Position++];
                value |= (ulong)(currentByte & 0x7F) << shift;

                if ((currentByte & 0x80) == 0)
                    break;

                shift += 7;
                iterations++;
            }

            return value;
        }
        #endregion

        #region Generators.
        /// <summary>
        /// Reads a reconcile.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        internal T ReadReconcile<T>() => Read<T>();

        /// <summary>
        /// Reads a replicate along with it's past replicates into a collection.
        /// </summary>
        internal List<ReplicateDataContainer<T>> ReadReplicate<T>(uint tick) where T : IReplicateData, new()
        {
            List<ReplicateDataContainer<T>> collection = CollectionCaches<ReplicateDataContainer<T>>.RetrieveList();

            //Number of entries written.
            int count = (int)ReadUInt8Unpacked();
            if (count <= 0)
            {
                NetworkManager.Log($"Replicate count cannot be 0 or less.");
                //Purge renaming and return default.
                Position += Remaining;
                return collection;
            }
            /* Subtract count total minus 1
             * from starting tick. This sets the tick to what the first entry would be.
             * EG packet came in as tick 100, so that was passed as tick.
             * if there are 3 replicates then 2 would be subtracted (count - 1).
             * The new tick would be 98.
             * Ticks would be assigned to read values from oldest to
             * newest as 98, 99, 100. Which is the correct result. In order for this to
             * work properly past replicates cannot skip ticks. This will be ensured
             * in another part of the code. */
            tick -= (uint)(count - 1);

            for (int i = 0; i < count; i++)
            {
                ReplicateDataContainer<T> value = ReadReplicateData<T>(tick + (uint)i);
                //Assign to collection.
                collection.Add(value);
            }

            return collection;
        }

        /// <summary>
        /// Reads a ReplicateData and applies tick and channel.
        /// </summary>
        private ReplicateDataContainer<T> ReadReplicateData<T>(uint tick) where T : IReplicateData, new()
        {
            T data = Read<T>();
            Channel c = ReadChannel();
            return new(data, c, tick, isCreated: true);
        }

        /// <summary>
        /// Reads a collection using a collection from caches.
        /// </summary>
        public Dictionary<TKey, TValue> ReadDictionary<TKey, TValue>()
        {
            int count = (int)ReadSignedPackedWhole();

            //Null collection.
            if (count == Writer.UNSET_COLLECTION_SIZE_VALUE)
                return null;

            Dictionary<TKey, TValue> collection = CollectionCaches<TKey, TValue>.RetrieveDictionary();
            ReadDictionary<TKey, TValue>(count, collection);

            return collection;
        }

        /// <summary>
        /// Reads a collection.
        /// </summary>
        [Obsolete("Use ReadDictionary.")]
        public Dictionary<TKey, TValue> ReadDictionaryAllocated<TKey, TValue>() => ReadDictionary<TKey, TValue>();

        /// <summary>
        /// Reads into collection and returns item count read.
        /// </summary>
        /// <param name="collection"></param>
        /// <param name="allowNullification">True to allow the referenced collection to be nullified when receiving a null collection read.</param>
        /// <returns>Number of values read into the collection. UNSET is returned if the collection were read as null.</returns>
        public int ReadDictionary<TKey, TValue>(ref Dictionary<TKey, TValue> collection, bool allowNullification = false)
        {
            int count = (int)ReadSignedPackedWhole();

            //Null collection.
            if (count == Writer.UNSET_COLLECTION_SIZE_VALUE)
            {
                if (allowNullification)
                    collection = null;

                return count;
            }

            ReadDictionary<TKey, TValue>(count, collection);

            return count;
        }

        /// <summary>
        /// Reads into a collection.
        /// </summary>
        private void ReadDictionary<TKey, TValue>(int count, Dictionary<TKey, TValue> collection)
        {
            if (count < 0)
            {
                NetworkManager.LogError($"Collection count cannot be less than 0.");
                //Purge renaming and return default.
                Position += Remaining;

                return;
            }

            if (collection == null)
                collection = new(count);
            else
                collection.Clear();

            for (int i = 0; i < count; i++)
            {
                TKey key = Read<TKey>();
                TValue value = Read<TValue>();
                collection.Add(key, value);
            }
        }

        /// <summary>
        /// Reads a collection using a collection from caches.
        /// </summary>
        public List<T> ReadList<T>()
        {
            int count = (int)ReadSignedPackedWhole();

            //Null collection.
            if (count == Writer.UNSET_COLLECTION_SIZE_VALUE)
                return null;

            List<T> result = CollectionCaches<T>.RetrieveList();
            ReadList(count, result);

            return result;
        }

        /// <summary>
        /// Reads a collection with allocations.
        /// </summary>
        [Obsolete("Use ReadList.")]
        public List<T> ReadListAllocated<T>() => ReadList<T>();

        /// <summary>
        /// Reads into collection and returns item count read.
        /// </summary>
        /// <param name="collection"></param>
        /// <param name="allowNullification">True to allow the referenced collection to be nullified when receiving a null collection read.</param>
        /// <returns>Number of values read into the collection. UNSET is returned if the collection were read as null.</returns>
        public int ReadList<T>(ref List<T> collection, bool allowNullification = false)
        {
            int count = (int)ReadSignedPackedWhole();

            //Null collection.
            if (count == Writer.UNSET_COLLECTION_SIZE_VALUE)
            {
                if (allowNullification)
                    collection = null;

                return count;
            }

            ReadList<T>(count, collection);

            return count;
        }

        /// <summary>
        /// Reads into a collection.
        /// </summary>
        private void ReadList<T>(int count, List<T> collection)
        {
            if (count < 0)
            {
                NetworkManager.LogError($"List count cannot be less than 0.");
                //Purge renaming and return default.
                Position += Remaining;

                return;
            }

            if (collection == null)
                collection = new(count);
            else
                collection.Clear();


            for (int i = 0; i < count; i++)
                collection.Add(Read<T>());
        }

        /// <summary>
        /// Reads a collection.
        /// </summary>
        public T[] ReadArrayAllocated<T>()
        {
            T[] result = null;
            ReadArray(ref result);

            return result;
        }

        /// <summary>
        /// Reads into collection and returns amount read.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="collection"></param>
        /// <returns></returns>
        public int ReadArray<T>(ref T[] collection)
        {
            int count = (int)ReadSignedPackedWhole();

            if (count == Writer.UNSET_COLLECTION_SIZE_VALUE)
                return 0;

            if (count == 0)
            {
                if (collection == null)
                    collection = new T[0];

                return 0;
            }

            if (count < 0)
            {
                NetworkManager.Log($"Array count cannot be less than 0.");
                //Purge renaming and return default.
                Position += Remaining;
                return default;
            }

            //Initialize buffer if not already done.
            if (collection == null)
                collection = new T[count];
            else if (collection.Length < count)
                Array.Resize(ref collection, count);

            for (int i = 0; i < count; i++)
                collection[i] = Read<T>();

            return count;
        }

        /// <summary>
        /// Reads any supported type as packed.
        /// </summary>
        public T Read<T>()
        {
            Func<Reader, T> del = GenericReader<T>.Read;

            if (del == null)
            {
                NetworkManager.LogError($"Read method not found for {typeof(T).FullName}. Use a supported type or create a custom serializer.");
                return default;
            }
            else
            {
                return del.Invoke(this);
            }
        }
        #endregion
    }
}using System;
using FishNet.CodeGenerating;
using System.Runtime.CompilerServices;
using FishNet.Managing;
using FishNet.Object;
using FishNet.Object.Prediction;
using FishNet.Serializing.Helping;
using UnityEngine;

namespace FishNet.Serializing
{
    public partial class Reader
    {
        internal double DOUBLE_ACCURACY => Writer.DOUBLE_ACCURACY;
        internal decimal DECIMAL_ACCURACY => Writer.DECIMAL_ACCURACY;

        #region Other.
        /// <summary>
        /// Reads a boolean.
        /// </summary>
        [DefaultDeltaReader]
        public bool ReadDeltaBoolean(bool valueA)
        {
            return !valueA;
        }
        #endregion

        #region Whole values.
        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public sbyte ReadDeltaInt8(sbyte valueA) => (sbyte)ReadDifference8_16_32(valueA);

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public byte ReadDeltaUInt8(byte valueA) => (byte)ReadDifference8_16_32(valueA);

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public short ReadDeltaInt16(short valueA) => (short)ReadDifference8_16_32(valueA);

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public ushort ReadDeltaUInt16(ushort valueA) => (ushort)ReadDifference8_16_32(valueA);

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public int ReadDeltaInt32(int valueA) => (int)ReadDifference8_16_32(valueA);

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public uint ReadDeltaUInt32(uint valueA) => (uint)ReadDifference8_16_32(valueA);

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public long ReadDeltaInt64(long valueA) => (long)ReadDeltaUInt64((ulong)valueA);

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public ulong ReadDeltaUInt64(ulong valueA)
        {
            bool bLargerThanA = ReadBoolean();
            ulong diff = ReadUnsignedPackedWhole();

            return (bLargerThanA) ? (valueA + diff) : (valueA - diff);
        }

        /// <summary>
        /// Returns a new result by reading and applying a difference to a value.
        /// </summary>
        [DefaultDeltaReader]
        private long ReadDifference8_16_32(long valueA)
        {
            long diff = ReadSignedPackedWhole();
            return (valueA + diff);
        }
        #endregion

        #region Single.
        /// <summary>
        /// Reads a value.
        /// </summary>
        public float ReadDeltaSingle(UDeltaPrecisionType dpt, bool unsigned)
        {
            if (dpt.FastContains(UDeltaPrecisionType.UInt8))
            {
                if (unsigned)
                    return (ReadUInt8Unpacked() / (float)DOUBLE_ACCURACY);
                else
                    return (ReadInt8Unpacked() / (float)DOUBLE_ACCURACY);
            }
            else if (dpt.FastContains(UDeltaPrecisionType.UInt16))
            {
                if (unsigned)
                    return (ReadUInt16Unpacked() / (float)DOUBLE_ACCURACY);
                else
                    return (ReadInt16Unpacked() / (float)DOUBLE_ACCURACY);
            }
            //Everything else is unpacked.
            else
            {
                return ReadSingleUnpacked();
            }
        }

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        public float ReadDeltaSingle(UDeltaPrecisionType dpt, float valueA, bool unsigned)
        {
            float diff = ReadDeltaSingle(dpt, unsigned);

            if (unsigned)
            {
                bool bLargerThanA = dpt.FastContains(UDeltaPrecisionType.NextValueIsLarger);
                return (bLargerThanA) ? (valueA + diff) : (valueA - diff);
            }
            else
            {
                return (valueA + diff);
            }
        }

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        public float ReadDeltaSingle(float valueA)
        {
            const bool unsigned = false;
            UDeltaPrecisionType dpt = (UDeltaPrecisionType)ReadUInt8Unpacked();

            return ReadDeltaSingle(dpt, valueA, unsigned);
        }

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public float ReadUDeltaSingle(float valueA)
        {
            const bool unsigned = true;
            UDeltaPrecisionType dpt = (UDeltaPrecisionType)ReadUInt8Unpacked();

            return ReadDeltaSingle(dpt, valueA, unsigned);
        }
        #endregion

        #region Double.
        /// <summary>
        /// Reads a value.
        /// </summary>
        public double ReadDeltaDouble(UDeltaPrecisionType dpt, bool unsigned)
        {
            if (dpt.FastContains(UDeltaPrecisionType.UInt8))
            {
                if (unsigned)
                    return (ReadUInt8Unpacked() / DOUBLE_ACCURACY);
                else
                    return (ReadInt8Unpacked() / DOUBLE_ACCURACY);
            }
            else if (dpt.FastContains(UDeltaPrecisionType.UInt16))
            {
                if (unsigned)
                    return (ReadUInt16Unpacked() / DOUBLE_ACCURACY);
                else
                    return (ReadInt16Unpacked() / DOUBLE_ACCURACY);
            }
            else if (dpt.FastContains(UDeltaPrecisionType.UInt32))
            {
                if (unsigned)
                    return (ReadUInt32Unpacked() / DOUBLE_ACCURACY);
                else
                    return (ReadInt32Unpacked() / DOUBLE_ACCURACY);
            }
            //Unpacked.
            else if (dpt.FastContains(UDeltaPrecisionType.Unset))
            {
                return ReadDoubleUnpacked();
            }
            else
            {
                NetworkManager.LogError($"Unhandled precision type of {dpt}.");
                return 0d;
            }
        }

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        public double ReadDeltaDouble(UDeltaPrecisionType dpt, double valueA, bool unsigned)
        {
            double diff = ReadDeltaDouble(dpt, unsigned);
            //8.

            if (unsigned)
            {
                bool bLargerThanA = dpt.FastContains(UDeltaPrecisionType.NextValueIsLarger);
                return (bLargerThanA) ? (valueA + diff) : (valueA - diff);
            }
            else
            {
                return (valueA + diff);
            }
        }

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        public double ReadDeltaDouble(double valueA)
        {
            const bool unsigned = false;
            UDeltaPrecisionType dpt = (UDeltaPrecisionType)ReadUInt8Unpacked();

            return ReadDeltaDouble(dpt, valueA, unsigned);
        }

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public double ReadUDeltaDouble(double valueA)
        {
            const bool unsigned = true;
            UDeltaPrecisionType dpt = (UDeltaPrecisionType)ReadUInt8Unpacked();

            return ReadDeltaDouble(dpt, valueA, unsigned);
        }
        #endregion

        #region Decimal.
        /// <summary>
        /// Reads a value.
        /// </summary>
        public decimal ReadDeltaDecimal(UDeltaPrecisionType dpt, bool unsigned)
        {
            if (dpt.FastContains(UDeltaPrecisionType.UInt8))
            {
                if (unsigned)
                    return (ReadUInt8Unpacked() / DECIMAL_ACCURACY);
                else
                    return (ReadInt8Unpacked() / DECIMAL_ACCURACY);
            }
            else if (dpt.FastContains(UDeltaPrecisionType.UInt16))
            {
                if (unsigned)
                    return (ReadUInt16Unpacked() / DECIMAL_ACCURACY);
                else
                    return (ReadInt16Unpacked() / DECIMAL_ACCURACY);
            }
            else if (dpt.FastContains(UDeltaPrecisionType.UInt32))
            {
                if (unsigned)
                    return (ReadUInt32Unpacked() / DECIMAL_ACCURACY);
                else
                    return (ReadInt32Unpacked() / DECIMAL_ACCURACY);
            }
            else if (dpt.FastContains(UDeltaPrecisionType.UInt64))
            {
                if (unsigned)
                    return (ReadUInt64Unpacked() / DECIMAL_ACCURACY);
                else
                    return (ReadInt64Unpacked() / DECIMAL_ACCURACY);
            }
            //Unpacked.
            else if (dpt.FastContains(UDeltaPrecisionType.Unset))
            {
                return ReadDecimalUnpacked();
            }
            else
            {
                NetworkManager.LogError($"Unhandled precision type of {dpt}.");
                return 0m;
            }
        }

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        public decimal ReadDeltaDecimal(UDeltaPrecisionType dpt, decimal valueA, bool unsigned)
        {
            decimal diff = ReadDeltaDecimal(dpt, unsigned);

            if (unsigned)
            {
                bool bLargerThanA = dpt.FastContains(UDeltaPrecisionType.NextValueIsLarger);
                return (bLargerThanA) ? (valueA + diff) : (valueA - diff);
            }
            else
            {
                return (valueA + diff);
            }
        }

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public decimal ReadDeltaDecimal(decimal valueA)
        {
            const bool unsigned = false;
            UDeltaPrecisionType dpt = (UDeltaPrecisionType)ReadUInt8Unpacked();

            return ReadDeltaDecimal(dpt, valueA, unsigned);
        }

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public decimal ReadUDeltaDecimal(decimal valueA)
        {
            const bool unsigned = true;
            UDeltaPrecisionType dpt = (UDeltaPrecisionType)ReadUInt8Unpacked();

            return ReadDeltaDecimal(dpt, valueA, unsigned);
        }
        #endregion

        #region FishNet Types.
        /// <summary>
        /// Reads a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaReader]
        public NetworkBehaviour WriteDeltaNetworkBehaviour(NetworkBehaviour valueA)
        {
            return ReadNetworkBehaviour();
        }
        #endregion

        #region Unity.
        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// (not really for Quaternion).
        /// </summary>
        [DefaultDeltaReader]
        public Quaternion ReadDeltaQuaternion(Quaternion valueA, float precision = Writer.QUATERNION_PRECISION) => QuaternionDeltaPrecisionCompression.Decompress(this, valueA, precision);

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public Vector2 ReadDeltaVector2(Vector2 valueA)
        {
            byte allFlags = ReadUInt8Unpacked();

            if ((allFlags & 1) == 1)
                valueA.x = ReadUDeltaSingle(valueA.x);
            if ((allFlags & 2) == 2)
                valueA.y = ReadUDeltaSingle(valueA.y);

            return valueA;
        }

        /// <summary>
        /// Reads a difference, appending it onto a value.
        /// </summary>
        [DefaultDeltaReader]
        public Vector3 ReadDeltaVector3(Vector3 valueA)
        {
            byte allFlags = ReadUInt8Unpacked();

            if ((allFlags & 1) == 1)
                valueA.x = ReadUDeltaSingle(valueA.x);
            if ((allFlags & 2) == 2)
                valueA.y = ReadUDeltaSingle(valueA.y);
            if ((allFlags & 4) == 4)
                valueA.z = ReadUDeltaSingle(valueA.z);

            return valueA;
        }
        #endregion

        #region Prediction.
        /// <summary>
        /// Reads a reconcile.
        /// </summary>
        internal T ReadDeltaReconcile<T>(T lastReconcile) => ReadDelta(lastReconcile);

        /// <summary>
        /// Reads a replicate.
        /// </summary>
        internal int ReadDeltaReplicate<T>(T lastReadReplicate, ref T[] collection, uint tick) where T : IReplicateData
        {
            int startRemaining = Remaining;

            //Number of entries written.
            int count = (int)ReadUInt8Unpacked();
            if (collection == null || collection.Length < count)
                collection = new T[count];

            /* Subtract count total minus 1
             * from starting tick. This sets the tick to what the first entry would be.
             * EG packet came in as tick 100, so that was passed as tick.
             * if there are 3 replicates then 2 would be subtracted (count - 1).
             * The new tick would be 98.
             * Ticks would be assigned to read values from oldest to
             * newest as 98, 99, 100. Which is the correct result. In order for this to
             * work properly past replicates cannot skip ticks. This will be ensured
             * in another part of the code. */
            tick -= (uint)(count - 1);

            uint lastReadTick = lastReadReplicate.GetTick();

            T prev = lastReadReplicate;
            for (int i = 0; i < count; i++)
            {
                //Tick read is for.
                uint readTick = (tick + (uint)i);
                /* If readTick is equal or lesser than lastReadReplicate
                 * then there is no reason to process the data other than getting
                 * it out of the reader. */
                if (readTick <= lastReadTick)
                {
                    ReadDelta(prev);
                }
                else
                {
                    T value = ReadDelta(prev);
                    //Apply tick.
                    value.SetTick(readTick);
                    //Assign to collection.
                    collection[i] = value;
                    //Update previous.
                    prev = value;
                }
            }

            return count;
        }
        #endregion

        #region Generic.
        /// <summary>
        /// Reads a delta of any time.
        /// </summary>
        public T ReadDelta<T>(T prev)
        {
            Func<Reader, T, T> del = GenericDeltaReader<T>.Read;

            if (del == null)
            {
                NetworkManager.LogError($"Read delta method not found for {typeof(T).FullName}. Use a supported type or create a custom serializer.");
                return default;
            }
            else
            {
                return del.Invoke(this, prev);
            }
        }
        #endregion
    }
}using FishNet.Connection;
using FishNet.Documenting;
using FishNet.Object;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using System;
using UnityEngine;

namespace FishNet.Serializing
{
    /// <summary>
    /// Extensions to Read methods. Used by Read<T>.
    /// </summary>
    [APIExclude]
    public static class ReaderExtensions
    {
    }
}
using FishNet.Managing;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using GameKit.Dependencies.Utilities;

namespace FishNet.Serializing
{
    /// <summary>
    /// Reader which is reused to save on garbage collection and performance.
    /// </summary>
    public sealed class PooledReader : Reader//, IResettable
    {
        public PooledReader() { } 
        internal PooledReader(byte[] bytes, NetworkManager networkManager, Reader.DataSource source = Reader.DataSource.Unset) : base(bytes, networkManager, null, source) { }
        internal PooledReader(ArraySegment<byte> segment, NetworkManager networkManager, Reader.DataSource source = Reader.DataSource.Unset) : base(segment, networkManager, null, source) { }
        public void Store() => ReaderPool.Store(this);
        
        [Obsolete("Use Clear instead.")]
        public void ResetState() => base.Clear();
        [Obsolete("This does not function.")]
        public void InitializeState() { }
    }

    /// <summary>
    /// Collection of PooledReader. Stores and gets PooledReader.
    /// </summary>
    public static class ReaderPool
    {
        #region Private.
        /// <summary>
        /// Pool of readers.
        /// </summary>
        private static readonly Stack<PooledReader> _pool = new();
        #endregion

        /// <summary>
        /// Get the next reader in the pool
        /// <para>If pool is empty, creates a new Reader</para>
        /// </summary>
        
        public static PooledReader Retrieve(byte[] bytes, NetworkManager networkManager, Reader.DataSource source = Reader.DataSource.Unset)
        {
            return Retrieve(new ArraySegment<byte>(bytes), networkManager, source);
        }

        /// <summary>
        /// Get the next reader in the pool or creates a new one if none are available.
        /// </summary>
        public static PooledReader Retrieve(ArraySegment<byte> segment, NetworkManager networkManager, Reader.DataSource source = Reader.DataSource.Unset)
        {
            PooledReader result;
            if (_pool.TryPop(out result))
                result.Initialize(segment, networkManager, source);
            else
                result = new(segment, networkManager, source);

            return result;
        }


        /// <summary>
        /// Puts reader back into pool
        /// </summary>
        public static void Store(PooledReader reader)
        {
            _pool.Push(reader);
        }

        /// <summary>
        /// Puts reader back into pool if not null, and nullifies source reference.
        /// </summary>
        public static void StoreAndDefault(ref PooledReader reader)
        {
            if (reader != null)
            {
                _pool.Push(reader);
                reader = null;
            }
        }
    }
}
//Remove in V5﻿using System.Collections.Generic;
using UnityEngine.SceneManagement;

namespace FishNet.Serializing.Helping
{
	internal sealed class SceneHandleEqualityComparer : EqualityComparer<Scene>
	{
		public override bool Equals(Scene a, Scene b)
		{
			return (a.handle == b.handle);
		}

        public override int GetHashCode(Scene obj)
        {
			return obj.handle;
        }
    }
}
namespace FishNet.Serializing
{
    [System.Serializable]
    internal class TransformPackingData
    {
        public AutoPackType Position = AutoPackType.Packed;
        public AutoPackType Rotation = AutoPackType.Packed;
        public AutoPackType Scale = AutoPackType.Packed;
    }
}
using FishNet.CodeGenerating;
using FishNet.Connection;
using FishNet.Managing;
using FishNet.Object;
using FishNet.Object.Prediction;
using FishNet.Serializing.Helping;
using FishNet.Transporting;
using FishNet.Utility;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Text;
using GameKit.Dependencies.Utilities.Types;
using UnityEngine;

[assembly: InternalsVisibleTo(UtilityConstants.GENERATED_ASSEMBLY_NAME)]

namespace FishNet.Serializing
{
    /// <summary>
    /// Writes data to a buffer.
    /// </summary>
    public partial class Writer
    {
        #region Public.
        /// <summary>
        /// Capacity of the buffer.
        /// </summary>
        public int Capacity => _buffer.Length;

        /// <summary>
        /// Current write position.
        /// </summary>
        public int Position;

        /// <summary>
        /// Number of bytes writen to the buffer.
        /// </summary>
        public int Length;

        /// <summary>
        /// NetworkManager associated with this writer. May be null.
        /// </summary>
        public NetworkManager NetworkManager;
        #endregion

        #region Private.
        /// <summary>
        /// Buffer to prevent new allocations. This will grow as needed.
        /// </summary>
        private byte[] _buffer = new byte[64];
        #endregion

        #region Const.
        /// <summary>
        /// Replicate data is default of T.
        /// </summary>
        internal const byte REPLICATE_DEFAULT_BYTE = 0;

        /// <summary>
        /// Replicate data is the same as the previous.
        /// </summary>
        internal const byte REPLICATE_DUPLICATE_BYTE = 1;

        /// <summary>
        /// Replicate data is different from the previous.
        /// </summary>
        internal const byte REPLICATE_UNIQUE_BYTE = 2;

        /// <summary>
        /// Replicate data is repeating for every entry.
        /// </summary>
        internal const byte REPLICATE_REPEATING_BYTE = 3;

        /// <summary>
        /// All datas in the replicate are default.
        /// </summary>
        internal const byte REPLICATE_ALL_DEFAULT_BYTE = 4;

        /// <summary>
        /// Value used when a collection is unset, as in null.
        /// </summary>
        public const int UNSET_COLLECTION_SIZE_VALUE = -1;
        #endregion

        /// <summary>
        /// Outputs writer to string.
        /// </summary>
        /// <returns></returns>
        public override string ToString() => ToString(0, Length);

        /// <summary>
        /// Outputs writer to string starting at an index.
        /// </summary>
        /// <returns></returns>
        public string ToString(int offset, int length)
        {
            return $"Position: {Position:0000}, Length: {Length:0000}, Buffer: {BitConverter.ToString(_buffer, offset, length)}.";
        }

        [Obsolete("Use Clear(NetworkManager) instead.")]
        public void Reset(NetworkManager newManager = null) => Clear(newManager);

        /// <summary>
        /// Resets written data.
        /// </summary>
        public void Clear()
        {
            Length = 0;
            Position = 0;
        }

        /// <summary>
        /// Resets written data and sets the NetworkManager.
        /// </summary>
        public void Clear(NetworkManager newManager)
        {
            Clear();
            NetworkManager = newManager;
        }

        /// <summary>
        /// Ensures the buffer Capacity is of minimum count.
        /// </summary>
        /// <param name="count"></param>
        public void EnsureBufferCapacity(int count)
        {
            if (Capacity < count)
                Array.Resize(ref _buffer, count);
        }

        /// <summary>
        /// Ensure a number of bytes to be available in the buffer from current position.
        /// </summary>
        /// <param name="count"></param>
        public void EnsureBufferLength(int count)
        {
            if (Position + count > _buffer.Length)
            {
                int nextSize = (_buffer.Length * 2) + count;
                Array.Resize(ref _buffer, nextSize);
            }
        }

        /// <summary>
        /// Returns the buffer. The returned value will be the full buffer, even if not all of it is used.
        /// </summary>
        /// <returns></returns>
        public byte[] GetBuffer()
        {
            return _buffer;
        }

        /// <summary>
        /// Returns the used portion of the buffer as an ArraySegment.
        /// </summary>
        /// <returns></returns>
        public ArraySegment<byte> GetArraySegment()
        {
            return new(_buffer, 0, Length);
        }

        /// <summary>
        /// Reserves a number of bytes from current position.
        /// </summary>
        /// <param name="count"></param>
        [Obsolete("Use Skip.")]
        public void Reserve(int count) => Skip(count);

        /// <summary>
        /// Skips a number of bytes from current position.
        /// </summary>
        /// <param name="count"></param>
        public void Skip(int count)
        {
            EnsureBufferLength(count);
            Position += count;
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Sets size variables back an amount.
        /// </summary>
        /// <param name="count"></param>
        internal void Remove(int count)
        {
            Position -= count;
            Length -= count;
        }
        
        /// <summary>
        /// Sends a packetId.
        /// </summary>
        /// <param name="pid"></param>
        internal void WritePacketIdUnpacked(PacketId pid)
        {
            WriteUInt16Unpacked((ushort)pid);
        }

        /// <summary>
        /// Inserts a packetId.
        /// </summary>
        internal void InsertPacketIdUnpacked(PacketId packetId, int index)
        {
            ushort pId = (ushort)packetId;
            InsertUInt16Unpacked(pId, index);
        }

        /// <summary>
        /// Inserts value at index within the buffer.
        /// This method does not perform error checks nor increases Length, Position.
        /// </summary>
        [Obsolete("Use InsertUInt8Unpacked.")]
        public void FastInsertUInt8Unpacked(byte value, int index) => InsertUInt8Unpacked(value, index);

        /// <summary>
        /// Inserts value at index within the buffer.
        /// This method does not perform error checks nor increases Length, Position.
        /// </summary>
        public void InsertUInt8Unpacked(byte value, int index)
        {
            _buffer[index] = value;
        }

        /// <summary>
        /// Inserts value at index within the buffer.
        /// This method does not perform error checks nor increases Length, Position.
        /// </summary>
        public void InsertUInt16Unpacked(ushort value, int index)
        {
            _buffer[index++] = (byte)value;
            _buffer[index] = (byte)(value >> 8);
        }

        /// <summary>
        /// Inserts value at index within the buffer.
        /// This method does not perform error checks nor increases Length, Position.
        /// </summary>
        public void InsertInt32Unpacked(int value, int index) => InsertUInt32Unpacked((uint)value, index);

        /// <summary>
        /// Inserts value at index within the buffer.
        /// This method does not perform error checks nor increases Length, Position.
        /// </summary>
        public void InsertUInt32Unpacked(uint value, int index)
        {
            _buffer[index++] = (byte)value;
            _buffer[index++] = (byte)(value >> 8);
            _buffer[index++] = (byte)(value >> 16);
            _buffer[index] = (byte)(value >> 24);
        }

        [Obsolete("Use WriteUInt8Unpacked.")]
        public void WriteByte(byte value) => WriteUInt8Unpacked(value);

        /// <summary>
        /// Writes a byte.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteUInt8Unpacked(byte value)
        {
            EnsureBufferLength(1);
            _buffer[Position++] = value;

            Length = Math.Max(Length, Position);
        }

        [Obsolete("Use WriteUInt8Array.")]
        public void WriteBytes(byte[] value, int offset, int count) => WriteUInt8Array(value, offset, count);

        /// <summary>
        /// Writes bytes.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        public void WriteUInt8Array(byte[] value, int offset, int count)
        {
            EnsureBufferLength(count);
            Buffer.BlockCopy(value, offset, _buffer, Position, count);
            Position += count;
            Length = Math.Max(Length, Position);
        }

        [Obsolete("Use WriteUInt8ArrayAndSize.")]
        public void WriteBytesAndSize(byte[] value, int offset, int count) => WriteUInt8ArrayAndSize(value, offset, count);

        /// <summary>
        /// Writes bytes and length of bytes.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="offset"></param>
        /// <param name="count"></param>
        public void WriteUInt8ArrayAndSize(byte[] value, int offset, int count)
        {
            if (value == null)
            {
                WriteInt32(Writer.UNSET_COLLECTION_SIZE_VALUE);
            }
            else
            {
                WriteInt32(count);
                WriteUInt8Array(value, offset, count);
            }
        }

        [Obsolete("Use WriteUInt8ArrayAndSize.")]
        public void WriteBytesAndSize(byte[] value) => WriteUInt8ArrayAndSize(value);

        /// <summary>
        /// Writes all bytes in value and length of bytes.
        /// </summary>
        /// <param name="value"></param>
        public void WriteUInt8ArrayAndSize(byte[] value)
        {
            int size = (value == null) ? 0 : value.Length;
            // buffer might be null, so we can't use .Length in that case
            WriteUInt8ArrayAndSize(value, 0, size);
        }

        [Obsolete("Use WriteInt8Unpacked.")]
        public void WriteSByte(sbyte value) => WriteInt8Unpacked(value);

        /// <summary>
        /// Writes a sbyte.
        /// </summary>
        [DefaultWriter]
        public void WriteInt8Unpacked(sbyte value) => WriteUInt8Unpacked((byte)value);

        /// <summary>
        /// Writes a char.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteChar(char value)
        {
            EnsureBufferLength(2);
            _buffer[Position++] = (byte)value;
            _buffer[Position++] = (byte)(value >> 8);
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes a boolean.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteBoolean(bool value)
        {
            EnsureBufferLength(1);
            _buffer[Position++] = (value) ? (byte)1 : (byte)0;
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes a uint16 unpacked.
        /// </summary>
        /// <param name="value"></param>
        public void WriteUInt16Unpacked(ushort value)
        {
            EnsureBufferLength(2);
            _buffer[Position++] = (byte)value;
            _buffer[Position++] = (byte)(value >> 8);
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes a uint16.
        /// </summary>
        /// <param name="value"></param>
        //todo: should be using WritePackedWhole but something relying on unpacked short/ushort is being written packed, corrupting packets.
        [DefaultWriter]
        public void WriteUInt16(ushort value) => WriteUInt16Unpacked(value);

        /// <summary>
        /// Writes a int16 unpacked.
        /// </summary>
        /// <param name="value"></param>
        //todo: should be WritePackedWhole but something relying on unpacked short/ushort is being written packed, corrupting packets.
        public void WriteInt16Unpacked(short value) => WriteUInt16Unpacked((ushort)value);

        /// <summary>
        /// Writes a int16.
        /// </summary>
        /// <param name="value"></param>
        //todo: should be WritePackedWhole but something relying on unpacked short/ushort is being written packed, corrupting packets.
        [DefaultWriter]
        public void WriteInt16(short value) => WriteUInt16Unpacked((ushort)value);

        /// <summary>
        /// Writes a int32.
        /// </summary>
        /// <param name="value"></param>
        public void WriteInt32Unpacked(int value) => WriteUInt32Unpacked((uint)value);

        /// <summary>
        /// Writes an int32.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteInt32(int value) => WriteSignedPackedWhole(value);

        /// <summary>
        /// Writes value to dst without error checking.
        /// </summary>
        internal static void WriteUInt32Unpacked(byte[] dst, uint value, ref int position)
        {
            dst[position++] = (byte)value;
            dst[position++] = (byte)(value >> 8);
            dst[position++] = (byte)(value >> 16);
            dst[position++] = (byte)(value >> 24);
        }

        /// <summary>
        /// Writes a uint32.
        /// </summary>
        /// <param name="value"></param>
        public void WriteUInt32Unpacked(uint value)
        {
            EnsureBufferLength(4);
            WriteUInt32Unpacked(_buffer, value, ref Position);
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes a uint32.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteUInt32(uint value) => WriteUnsignedPackedWhole(value);

        /// <summary>
        /// Writes a uint64.
        /// </summary>
        /// <param name="value"></param>
        public void WriteUInt64Unpacked(ulong value)
        {
            EnsureBufferLength(8);
            _buffer[Position++] = (byte)value;
            _buffer[Position++] = (byte)(value >> 8);
            _buffer[Position++] = (byte)(value >> 16);
            _buffer[Position++] = (byte)(value >> 24);
            _buffer[Position++] = (byte)(value >> 32);
            _buffer[Position++] = (byte)(value >> 40);
            _buffer[Position++] = (byte)(value >> 48);
            _buffer[Position++] = (byte)(value >> 56);
            Length = Math.Max(Position, Length);
        }

        /// <summary>
        /// Writes a uint64.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteUInt64(ulong value) => WriteUnsignedPackedWhole(value);

        /// <summary>
        /// Writes a int64.
        /// </summary>
        /// <param name="value"></param>
        public void WriteInt64Unpacked(long value) => WriteUInt64((ulong)value);

        /// <summary>
        /// Writes an int64.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteInt64(long value) => WriteSignedPackedWhole(value);

        /// <summary>
        /// Writes a single (float).
        /// </summary>
        /// <param name="value"></param>
        public void WriteSingleUnpacked(float value)
        {
            EnsureBufferLength(4);
            UIntFloat converter = new() { FloatValue = value };
            WriteUInt32Unpacked(converter.UIntValue);
        }

        /// <summary>
        /// Writes a single (float).
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteSingle(float value) => WriteSingleUnpacked(value);

        /// <summary>
        /// Writes a double.
        /// </summary>
        /// <param name="value"></param>
        public void WriteDoubleUnpacked(double value)
        {
            UIntDouble converter = new() { DoubleValue = value };
            WriteUInt64Unpacked(converter.LongValue);
        }

        /// <summary>
        /// Writes a double.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteDouble(double value) => WriteDoubleUnpacked(value);

        /// <summary>
        /// Writes a decimal.
        /// </summary>
        /// <param name="value"></param>
        public void WriteDecimalUnpacked(decimal value)
        {
            UIntDecimal converter = new() { DecimalValue = value };
            WriteUInt64Unpacked(converter.LongValue1);
            WriteUInt64Unpacked(converter.LongValue2);
        }

        /// <summary>
        /// Writes a decimal.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteDecimal(decimal value) => WriteDecimalUnpacked(value);

        /// <summary>
        /// Writes a string.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteString(string value)
        {
            if (value == null)
            {
                WriteInt32(Writer.UNSET_COLLECTION_SIZE_VALUE);
                return;
            }
            
            byte[] buffer = Strings.Buffer;
            int length = value.ToBytes(ref buffer);
            
            WriteInt32(length);

            //Nothing to write.
            if (length == 0)
                return;

            WriteUInt8Array(buffer, 0, length);
        }

        /// <summary>
        /// Writes a byte ArraySegment and it's size.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteArraySegmentAndSize(ArraySegment<byte> value) => WriteUInt8ArrayAndSize(value.Array, value.Offset, value.Count);

        /// <summary>
        /// Writes an ArraySegment without size.
        /// </summary>
        /// <param name="value"></param>
        public void WriteArraySegment(ArraySegment<byte> value) => WriteUInt8Array(value.Array, value.Offset, value.Count);

        /// <summary>
        /// Writes a Vector2.
        /// </summary>
        /// <param name="value"></param>
        public void WriteVector2Unpacked(Vector2 value)
        {
            WriteSingleUnpacked(value.x);
            WriteSingleUnpacked(value.y);
        }

        /// <summary>
        /// Writes a Vector2.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteVector2(Vector2 value) => WriteVector2Unpacked(value);

        /// <summary>
        /// Writes a Vector3
        /// </summary>
        /// <param name="value"></param>
        public void WriteVector3Unpacked(Vector3 value)
        {
            WriteSingleUnpacked(value.x);
            WriteSingleUnpacked(value.y);
            WriteSingleUnpacked(value.z);
        }

        /// <summary>
        /// Writes a Vector3
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteVector3(Vector3 value) => WriteVector3Unpacked(value);

        /// <summary>
        /// Writes a Vector4.
        /// </summary>
        /// <param name="value"></param>
        public void WriteVector4Unpacked(Vector4 value)
        {
            WriteSingleUnpacked(value.x);
            WriteSingleUnpacked(value.y);
            WriteSingleUnpacked(value.z);
            WriteSingleUnpacked(value.w);
        }

        /// <summary>
        /// Writes a Vector4.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteVector4(Vector4 value) => WriteVector4Unpacked(value);

        /// <summary>
        /// Writes a Vector2Int.
        /// </summary>
        /// <param name="value"></param>
        public void WriteVector2IntUnpacked(Vector2Int value)
        {
            WriteInt32Unpacked(value.x);
            WriteInt32Unpacked(value.y);
        }

        /// <summary>
        /// Writes a Vector2Int.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteVector2Int(Vector2Int value)
        {
            WriteSignedPackedWhole(value.x);
            WriteSignedPackedWhole(value.y);
        }

        /// <summary>
        /// Writes a Vector3Int.
        /// </summary>
        /// <param name="value"></param>
        public void WriteVector3IntUnpacked(Vector3Int value)
        {
            WriteInt32Unpacked(value.x);
            WriteInt32Unpacked(value.y);
            WriteInt32Unpacked(value.z);
        }

        /// <summary>
        /// Writes a Vector3Int.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteVector3Int(Vector3Int value)
        {
            WriteSignedPackedWhole(value.x);
            WriteSignedPackedWhole(value.y);
            WriteSignedPackedWhole(value.z);
        }

        /// <summary>
        /// Writes a Color.
        /// </summary>
        /// <param name="value"></param>
        public void WriteColorUnpacked(Color value)
        {
            WriteSingleUnpacked(value.r);
            WriteSingleUnpacked(value.g);
            WriteSingleUnpacked(value.b);
            WriteSingleUnpacked(value.a);
        }

        /// <summary>
        /// Writes a Color.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteColor(Color value)
        {
            EnsureBufferLength(4);
            _buffer[Position++] = (byte)(value.r * 100f);
            _buffer[Position++] = (byte)(value.g * 100f);
            _buffer[Position++] = (byte)(value.b * 100f);
            _buffer[Position++] = (byte)(value.a * 100f);
            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes a Color32.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteColor32(Color32 value)
        {
            EnsureBufferLength(4);
            _buffer[Position++] = value.r;
            _buffer[Position++] = value.g;
            _buffer[Position++] = value.b;
            _buffer[Position++] = value.a;

            Length = Math.Max(Length, Position);
        }

        /// <summary>
        /// Writes a Quaternion.
        /// </summary>
        /// <param name="value"></param>
        public void WriteQuaternionUnpacked(Quaternion value)
        {
            WriteSingleUnpacked(value.x);
            WriteSingleUnpacked(value.y);
            WriteSingleUnpacked(value.z);
            WriteSingleUnpacked(value.w);
        }

        /// <summary>
        /// Writes a Quaternion.
        /// </summary>
        /// <param name="value"></param>
        public void WriteQuaternion64(Quaternion value)
        {
            ulong result = Quaternion64Compression.Compress(value);
            WriteUInt64Unpacked(result);
        }

        /// <summary>
        /// Writes a Quaternion.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteQuaternion32(Quaternion value)
        {
            Quaternion32Compression.Compress(this, value);
        }

        /// <summary>
        /// Reads a Quaternion.
        /// </summary>
        /// <returns></returns>
        internal void WriteQuaternion(Quaternion value, AutoPackType autoPackType)
        {
            switch (autoPackType)
            {
                case AutoPackType.Packed:
                    WriteQuaternion32(value);
                    ;
                    break;
                case AutoPackType.PackedLess:
                    WriteQuaternion64(value);
                    break;
                default:
                    WriteQuaternionUnpacked(value);
                    break;
            }
        }

        /// <summary>
        /// Writes a rect.
        /// </summary>
        /// <param name="value"></param>
        public void WriteRectUnpacked(Rect value)
        {
            WriteSingleUnpacked(value.xMin);
            WriteSingleUnpacked(value.yMin);
            WriteSingleUnpacked(value.width);
            WriteSingleUnpacked(value.height);
        }

        /// <summary>
        /// Writes a rect.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteRect(Rect value) => WriteRectUnpacked(value);

        /// <summary>
        /// Writes a plane.
        /// </summary>
        /// <param name="value"></param>
        public void WritePlaneUnpacked(Plane value)
        {
            WriteVector3Unpacked(value.normal);
            WriteSingleUnpacked(value.distance);
        }

        /// <summary>
        /// Writes a plane.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WritePlane(Plane value) => WritePlaneUnpacked(value);

        /// <summary>
        /// Writes a Ray.
        /// </summary>
        /// <param name="value"></param>
        public void WriteRayUnpacked(Ray value)
        {
            WriteVector3Unpacked(value.origin);
            WriteVector3Unpacked(value.direction);
        }

        /// <summary>
        /// Writes a Ray.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteRay(Ray value) => WriteRayUnpacked(value);

        /// <summary>
        /// Writes a Ray2D.
        /// </summary>
        /// <param name="value"></param>
        public void WriteRay2DUnpacked(Ray2D value)
        {
            WriteVector2Unpacked(value.origin);
            WriteVector2Unpacked(value.direction);
        }

        /// <summary>
        /// Writes a Ray2D.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteRay2D(Ray2D value) => WriteRay2DUnpacked(value);

        /// <summary>
        /// Writes a Matrix4x4.
        /// </summary>
        /// <param name="value"></param>
        public void WriteMatrix4x4Unpacked(Matrix4x4 value)
        {
            WriteSingleUnpacked(value.m00);
            WriteSingleUnpacked(value.m01);
            WriteSingleUnpacked(value.m02);
            WriteSingleUnpacked(value.m03);
            WriteSingleUnpacked(value.m10);
            WriteSingleUnpacked(value.m11);
            WriteSingleUnpacked(value.m12);
            WriteSingleUnpacked(value.m13);
            WriteSingleUnpacked(value.m20);
            WriteSingleUnpacked(value.m21);
            WriteSingleUnpacked(value.m22);
            WriteSingleUnpacked(value.m23);
            WriteSingleUnpacked(value.m30);
            WriteSingleUnpacked(value.m31);
            WriteSingleUnpacked(value.m32);
            WriteSingleUnpacked(value.m33);
        }

        /// <summary>
        /// Writes a Matrix4x4.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteMatrix4x4(Matrix4x4 value) => WriteMatrix4x4Unpacked(value);

        /// <summary>
        /// Writes a Guid.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteGuidAllocated(System.Guid value)
        {
            byte[] data = value.ToByteArray();
            WriteUInt8Array(data, 0, data.Length);
        }

        /// <summary>
        /// Writes a tick without packing.
        /// </summary>
        /// <param name="value"></param>
        public void WriteTickUnpacked(uint value) => WriteUInt32Unpacked(value);

        /// <summary>
        /// Writes a GameObject. GameObject must be spawned over the network already or be a prefab with a NetworkObject attached.
        /// </summary>
        /// <param name="go"></param>
        [DefaultWriter]
        public void WriteGameObject(GameObject go)
        {
            //There needs to be a header to indicate if null, nob, or nb.
            if (go == null)
            {
                WriteUInt8Unpacked(0);
            }
            else
            {
                //Try to write the NetworkObject first.
                if (go.TryGetComponent(out NetworkObject nob))
                {
                    WriteUInt8Unpacked(1);
                    WriteNetworkObject(nob);
                }
                //If there was no nob try to write a NetworkBehaviour.
                else if (go.TryGetComponent(out NetworkBehaviour nb))
                {
                    WriteUInt8Unpacked(2);
                    WriteNetworkBehaviour(nb);
                }
                //Object cannot be serialized so write null.
                else
                {
                    WriteUInt8Unpacked(0);
                    NetworkManager.LogError($"GameObject {go.name} cannot be serialized because it does not have a NetworkObject nor NetworkBehaviour.");
                }
            }
        }

        /// <summary>
        /// Writes a Transform. Transform must be spawned over the network already or be a prefab with a NetworkObject attached.
        /// </summary>
        /// <param name="t"></param>
        [DefaultWriter]
        public void WriteTransform(Transform t)
        {
            if (t == null)
            {
                WriteNetworkObject(null);
            }
            else
            {
                NetworkObject nob = t.GetComponent<NetworkObject>();
                WriteNetworkObject(nob);
            }
        }

        /// <summary>
        /// Writes a NetworkObject.ObjectId.
        /// </summary>
        /// <param name="nob"></param>
        public void WriteNetworkObjectId(NetworkObject nob)
        {
            int id = (nob == null) ? NetworkObject.UNSET_OBJECTID_VALUE : nob.ObjectId;
            WriteNetworkObjectId(id);
        }

        /// <summary>
        /// Writes a NetworkObject while optionally including the initialization order.
        /// </summary>
        [DefaultWriter]
        public void WriteNetworkObject(NetworkObject nob)
        {
            if (nob == null)
            {
                WriteNetworkObjectId(NetworkObject.UNSET_OBJECTID_VALUE);
            }
            else
            {
                bool spawned = nob.IsSpawned;

                if (spawned)
                    WriteNetworkObjectId(nob.ObjectId);
                else
                    WriteNetworkObjectId(nob.PrefabId);

                /* Spawned is written after because it's only needed if nob
                 * is not null. If it were written before it would also have
                 * to be written when nob == null.*/
                WriteBoolean(spawned);
            }
        }

        /// <summary>
        /// Writes a spawned networkObject.
        /// </summary>
        internal void WriteSpawnedNetworkObject(NetworkObject nob)
        {
            WriteNetworkObjectId(nob.ObjectId);
            WriteUInt16(nob.SpawnableCollectionId);
            WriteInt32(nob.GetInitializeOrder());
        }

        /// <summary>
        /// Writes a NetworkObject for a despawn message.
        /// </summary>
        /// <param name="nob"></param>
        /// <param name="dt"></param>
        internal void WriteNetworkObjectForDespawn(NetworkObject nob, DespawnType dt)
        {
            WriteNetworkObjectId(nob.ObjectId);
            WriteUInt8Unpacked((byte)dt);
        }

        /// <summary>
        /// Writes an objectId.
        /// </summary>
        public void WriteNetworkObjectId(int objectId) => WriteSignedPackedWhole(objectId);

        /// <summary>
        /// Writes a NetworkBehaviour.
        /// </summary>
        /// <param name="nb"></param>
        [DefaultWriter]
        public void WriteNetworkBehaviour(NetworkBehaviour nb)
        {
            if (nb == null)
            {
                WriteNetworkObject(null);
                WriteUInt8Unpacked(0);
            }
            else
            {
                WriteNetworkObject(nb.NetworkObject);
                WriteUInt8Unpacked(nb.ComponentIndex);
            }
        }

        /// <summary>
        /// Writes a NetworkBehaviourId.
        /// </summary>
        public void WriteNetworkBehaviourId(NetworkBehaviour nb)
        {
            if (nb == null)
                WriteUInt8Unpacked(NetworkBehaviour.UNSET_NETWORKBEHAVIOUR_ID);
            else
                WriteUInt8Unpacked(nb.ComponentIndex);
        }

        /// <summary>
        /// Writes a DateTime.
        /// </summary>
        [DefaultWriter]
        public void WriteDateTime(DateTime dt) => WriteSignedPackedWhole(dt.ToBinary());

        /// <summary>
        /// Writes a transport channel.
        /// </summary>
        /// <param name="channel"></param>
        [DefaultWriter]
        public void WriteChannel(Channel channel) => WriteUInt8Unpacked((byte)channel);

        /// <summary>
        /// Writers a LayerMask.
        /// </summary>
        /// <param name="value"></param>
        [DefaultWriter]
        public void WriteLayerMask(LayerMask value) => WriteSignedPackedWhole(value.value);

        /// <summary>
        /// Writes a NetworkConnection.
        /// </summary>
        /// <param name="connection"></param>
        [DefaultWriter]
        public void WriteNetworkConnection(NetworkConnection connection)
        {
            int value = (connection == null) ? NetworkConnection.UNSET_CLIENTID_VALUE : connection.ClientId;
            WriteNetworkConnectionId(value);
        }

        /// <summary>
        /// Writes TransformProperties.
        /// </summary>
        [DefaultWriter]
        public void WriteTransformProperties(TransformProperties value)
        {
            WriteVector3(value.Position);
            WriteQuaternion32(value.Rotation);
            WriteVector3(value.Scale);
        }

        /// <summary>
        /// Writes a short for a connectionId.
        /// </summary>
        /// <returns></returns>
        public void WriteNetworkConnectionId(int id) => WriteSignedPackedWhole(id);

        /// <summary>
        /// Writes a dictionary.
        /// </summary>
        public void WriteDictionary<TKey, TValue>(Dictionary<TKey, TValue> dict)
        {
            if (dict == null)
            {
                WriteSignedPackedWhole(Writer.UNSET_COLLECTION_SIZE_VALUE);
                return;
            }
            else
            {
                WriteSignedPackedWhole(dict.Count);
            }

            foreach (KeyValuePair<TKey, TValue> item in dict)
            {
                Write(item.Key);
                Write(item.Value);
            }
        }

        /// <summary>
        /// Writes a list.
        /// </summary>
        /// <param name="value">Collection to write.</param>
        public void WriteList<T>(List<T> value)
        {
            int count = (value == null) ? 0 : value.Count;
            WriteList(value, 0, count);
        }

        /// <summary>
        /// Writes a state update packet.
        /// </summary>
        /// <param name="tick"></param>
        internal void WriteStateUpdatePacket(uint lastPacketTick) => WriteTickUnpacked(lastPacketTick);

        #region Packed writers.
        /// <summary>
        /// ZigZag encode an integer. Move the sign bit to the right.
        /// </summary>
        public ulong ZigZagEncode(ulong value)
        {
            if (value >> 63 > 0)
                return ~(value << 1) | 1;
            return value << 1;
        }

        /// <summary>
        /// Writes a packed whole number.
        /// </summary>
        /// <param name="value"></param>
        public void WriteSignedPackedWhole(long value) => WriteUnsignedPackedWhole(ZigZagEncode((ulong)value));

        /// <summary>
        /// Writes a packed whole number.
        /// </summary>
        /// <param name="value"></param>
        /// <summary>
        /// Writes a packed whole number.
        /// </summary>
        /// <param name="value"> </param>
        public void WriteUnsignedPackedWhole(ulong value)
        {
            EnsureBufferLength(9);
            while (value > 127)
            {
                _buffer[Position++] = (byte)((value & 0x7F) | 0x80);
                value >>= 7;
            }

            _buffer[Position++] = (byte)(value & 0x7F);
            Length = Math.Max(Length, Position);
        }
        #endregion

        #region Generators.
        /// <summary>
        /// Writes a list.
        /// </summary>
        /// <param name="value">Collection to write.</param>
        /// <param name="offset">Offset to begin at.</param>
        /// <param name="count">Entries to write.</param>
        public void WriteList<T>(List<T> value, int offset, int count)
        {
            if (value == null)
            {
                WriteSignedPackedWhole(Writer.UNSET_COLLECTION_SIZE_VALUE);
            }
            else
            {
                //Make sure values cannot cause out of bounds.
                if ((offset + count > value.Count))
                    count = 0;

                WriteSignedPackedWhole(count);
                for (int i = 0; i < count; i++)
                    Write(value[i + offset]);
            }
        }

        /// <summary>
        /// Writes a list.
        /// </summary>
        /// <param name="value">Collection to write.</param>
        /// <param name="offset">Offset to begin at.</param>
        public void WriteList<T>(List<T> value, int offset)
        {
            int count = (value == null) ? 0 : value.Count;
            WriteList(value, offset, count - offset);
        }


        /// <summary>
        /// Writes an array.
        /// </summary>
        /// <param name="value">Collection to write.</param>
        public void WriteArray<T>(T[] value)
        {
            int count = (value == null) ? 0 : value.Length;
            WriteArray(value, 0, count);
        }

        /// <summary>
        /// Writes an array.
        /// </summary>
        /// <param name="value">Collection to write.</param>
        /// <param name="offset">Offset to begin at.</param>
        public void WriteArray<T>(T[] value, int offset)
        {
            int count = (value == null) ? 0 : value.Length;
            WriteArray(value, offset, count - offset);
        }
        
        /// <summary>
        /// Writes an array.
        /// </summary>
        /// <param name="value">Collection to write.</param>
        /// <param name="offset">Offset to begin at.</param>
        /// <param name="count">Entries to write.</param>
        public void WriteArray<T>(T[] value, int offset, int count)
        {
            if (value == null)
            {
                WriteSignedPackedWhole(Writer.UNSET_COLLECTION_SIZE_VALUE);
            }
            else
            {
                //If theres no values, or offset exceeds count then write 0 for count.
                if (value.Length == 0 || (offset >= count))
                {
                    WriteSignedPackedWhole(0);
                }
                else
                {
                    WriteSignedPackedWhole(count);
                    for (int i = offset; i < count; i++)
                        Write(value[i]);
                }
            }
        }
        /// <summary>
        /// Writes a reconcile.
        /// </summary>
        internal void WriteReconcile<T>(T data)
        {
            Write(data);
        }

        /// <summary>
        /// Writes a replication to the server.
        /// </summary>
        internal void WriteReplicate<T>(RingBuffer<ReplicateDataContainer<T>> values, int offset) where T : IReplicateData, new()
        {
            /* COUNT
             *
             * Each Entry:
             * 0 if the same as previous.
             * 1 if default. */
            int collectionCount = values.Count;
            //Replicate list will never be null, no need to write null check.
            //Number of entries being written.
            byte count = (byte)(collectionCount - offset);
            WriteUInt8Unpacked(count);

            for (int i = offset; i < collectionCount; i++)
                WriteReplicateDataContainer<T>(values[i]);
        }

        internal void WriteReplicate<T>(BasicQueue<ReplicateDataContainer<T>> values, int redundancyCount) where T : IReplicateData, new()
        {
            /* COUNT
             *
             * Each Entry:
             * 0 if the same as previous.
             * 1 if default. */
            int collectionCount = values.Count;
            //Replicate list will never be null, no need to write null check.
            //Number of entries being written.
            byte count = (byte)redundancyCount;
            WriteUInt8Unpacked(count);

            for (int i = (collectionCount - redundancyCount); i < collectionCount; i++)
                WriteReplicateDataContainer<T>(values[i]);
        }
        
        /// <summary>
        /// Reads a ReplicateData and applies tick and channel.
        /// </summary>
        private void WriteReplicateDataContainer<T>(ReplicateDataContainer<T> value) where T : IReplicateData , new()
        {
            Write<T>(value.Data);
            WriteChannel(value.Channel);
        }


        /// <summary>
        /// Writes any supported type using packing.
        /// </summary>
        public void Write<T>(T value)
        {
            Action<Writer, T> del = GenericWriter<T>.Write;
            if (del == null)
                NetworkManager.LogError($"Write method not found for {typeof(T).FullName}. Use a supported type or create a custom serializer.");
            else
                del.Invoke(this, value);
        }
        #endregion
    }
}using System;
using System.Collections.Generic;
using System.Linq;
using FishNet.CodeGenerating;
using System.Runtime.CompilerServices;
using FishNet.Component.Transforming;
using FishNet.Managing;
using FishNet.Object;
using FishNet.Object.Prediction;
using FishNet.Serializing.Helping;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Serializing
{
    public partial class Writer
    {
        #region Types.
        [System.Flags]
        internal enum UnsignedVector3DeltaFlag : int
        {
            Unset = 0,
            More = (1 << 0),
            X1 = (1 << 1),
            NextXIsLarger = (1 << 2),
            Y1 = (1 << 3),
            NextYIsLarger = (1 << 4),
            Z1 = (1 << 5),
            NextZIsLarger = (1 << 6),
            X2 = (1 << 8),
            X4 = (1 << 9),
            Y2 = (1 << 10),
            Y4 = (1 << 11),
            Z2 = (1 << 12),
            Z4 = (1 << 13),
        }
        #endregion

        

        /// <summary>
        /// Used to insert length for delta flags.
        /// </summary>
        private ReservedLengthWriter _reservedLengthWriter = new();

        private const double LARGEST_DELTA_PRECISION_INT8 = (sbyte.MaxValue / DOUBLE_ACCURACY);
        private const double LARGEST_DELTA_PRECISION_INT16 = (short.MaxValue / DOUBLE_ACCURACY);
        private const double LARGEST_DELTA_PRECISION_INT32 = (int.MaxValue / DOUBLE_ACCURACY);
        private const double LARGEST_DELTA_PRECISION_INT64 = (long.MaxValue / DOUBLE_ACCURACY);

        private const double LARGEST_DELTA_PRECISION_UINT8 = (byte.MaxValue / DOUBLE_ACCURACY);
        private const double LARGEST_DELTA_PRECISION_UINT16 = (ushort.MaxValue / DOUBLE_ACCURACY);
        private const double LARGEST_DELTA_PRECISION_UINT32 = (uint.MaxValue / DOUBLE_ACCURACY);
        private const double LARGEST_DELTA_PRECISION_UINT64 = (ulong.MaxValue / DOUBLE_ACCURACY);
        internal const double DOUBLE_ACCURACY = 1000d;
        internal const double DOUBLE_ACCURACY_PRECISION = (1f / DOUBLE_ACCURACY);
        internal const decimal DECIMAL_ACCURACY = 1000m;
        
        internal const float QUATERNION_PRECISION = 0.0001f;

        #region Other.
        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        public bool WriteDeltaBoolean(bool valueA, bool valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            bool valuesMatch = (valueA == valueB);
            if (valuesMatch && option == DeltaSerializerOption.Unset)
                return false;

            WriteBoolean(valueB);

            return true;
        }
        #endregion

        #region Whole values.
        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        public bool WriteDeltaInt8(sbyte valueA, sbyte valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset) => WriteDifference8_16_32(valueA, valueB, option);

        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        public bool WriteDeltaUInt8(byte valueA, byte valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset) => WriteDifference8_16_32(valueA, valueB, option);

        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        public bool WriteDeltaInt16(short valueA, short valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset) => WriteDifference8_16_32(valueA, valueB, option);

        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        public bool WriteDeltaUInt16(ushort valueA, ushort valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset) => WriteDifference8_16_32(valueA, valueB, option);

        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        public bool WriteDeltaInt32(int valueA, int valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset) => WriteDifference8_16_32(valueA, valueB, option);

        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        public bool WriteDeltaUInt32(uint valueA, uint valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset) => WriteDifference8_16_32(valueA, valueB, option);

        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        public bool WriteDeltaInt64(long valueA, long valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset) => WriteDeltaUInt64((ulong)valueA, (ulong)valueB, option);

        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        public bool WriteDeltaUInt64(ulong valueA, ulong valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            bool unchangedValue = (valueA == valueB);
            if (unchangedValue && option == DeltaSerializerOption.Unset) return false;

            bool bLargerThanA = (valueB > valueA);
            ulong next = (bLargerThanA) ? (valueB - valueA) : (valueA - valueB);

            WriteBoolean(bLargerThanA);
            WriteUnsignedPackedWhole(next);

            return true;
        }

        /// <summary>
        /// Writes the difference between two values for signed and unsigned shorts and ints.
        /// </summary>
        private bool WriteDifference8_16_32(long valueA, long valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            bool unchangedValue = (valueA == valueB);
            if (unchangedValue && option == DeltaSerializerOption.Unset) return false;

            long next = (valueB - valueA);
            WriteSignedPackedWhole(next);

            return true;
        }
        #endregion

        #region Single.
        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        public bool WriteUDeltaSingle(float valueA, float valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            UDeltaPrecisionType dpt = GetUDeltaPrecisionType(valueA, valueB, out float unsignedDifference);

            if (dpt == UDeltaPrecisionType.Unset && option == DeltaSerializerOption.Unset)
                return false;

            WriteUInt8Unpacked((byte)dpt);
            WriteDeltaSingle(dpt, unsignedDifference, unsigned: true);

            return true;
        }

        /// <summary>
        /// Writes a delta value using a compression type.
        /// </summary>
        private void WriteDeltaSingle(UDeltaPrecisionType dpt, float value, bool unsigned)
        {
            if (dpt.FastContains(UDeltaPrecisionType.UInt8))
            {
                if (unsigned)
                    WriteUInt8Unpacked((byte)Math.Floor(value * DOUBLE_ACCURACY));
                else
                    WriteInt8Unpacked((sbyte)Math.Floor(value * DOUBLE_ACCURACY));
            }
            else if (dpt.FastContains(UDeltaPrecisionType.UInt16))
            {
                if (unsigned)
                    WriteUInt16Unpacked((ushort)Math.Floor(value * DOUBLE_ACCURACY));
                else
                    WriteInt16Unpacked((short)Math.Floor(value * DOUBLE_ACCURACY));
            }
            //Anything else is unpacked.
            else
            {
                WriteSingleUnpacked(value);
            }
        }

        /// <summary>
        /// Returns DeltaPrecisionType for the difference of two values.
        /// Value returned should be written as signed.
        /// </summary>
        public UDeltaPrecisionType GetSDeltaPrecisionType(float valueA, float valueB, out float signedDifference)
        {
            signedDifference = (valueB - valueA);
            float posValue = (signedDifference < 0f) ? (signedDifference * -1f) : signedDifference;

            return GetDeltaPrecisionType(posValue, unsigned: false);
        }

        /// <summary>
        /// Returns DeltaPrecisionType for the difference of two values.
        /// </summary>
        public UDeltaPrecisionType GetUDeltaPrecisionType(float valueA, float valueB, out float unsignedDifference)
        {
            bool bIsLarger = (valueB > valueA);
            if (bIsLarger)
                unsignedDifference = (valueB - valueA);
            else
                unsignedDifference = (valueA - valueB);

            UDeltaPrecisionType result = GetDeltaPrecisionType(unsignedDifference, unsigned: true);
            //If result is set then set if bIsLarger.
            if (bIsLarger && result != UDeltaPrecisionType.Unset)
                result |= UDeltaPrecisionType.NextValueIsLarger;

            return result;
        }

        /// <summary>
        /// Returns DeltaPrecisionType for a value.
        /// </summary>
        public UDeltaPrecisionType GetDeltaPrecisionType(float positiveValue, bool unsigned)
        {
            if (unsigned)
            {
                return positiveValue switch
                {
                    < (float)DOUBLE_ACCURACY_PRECISION => UDeltaPrecisionType.Unset,
                    < (float)LARGEST_DELTA_PRECISION_UINT8 => UDeltaPrecisionType.UInt8,
                    < (float)LARGEST_DELTA_PRECISION_UINT16 => UDeltaPrecisionType.UInt16,
                    < (float)LARGEST_DELTA_PRECISION_UINT32 => UDeltaPrecisionType.UInt32,
                    _ => UDeltaPrecisionType.Unset,
                };
            }
            else
            {
                return positiveValue switch
                {
                    < (float)(DOUBLE_ACCURACY_PRECISION / 2d) => UDeltaPrecisionType.Unset,
                    < (float)LARGEST_DELTA_PRECISION_INT8 => UDeltaPrecisionType.UInt8,
                    < (float)LARGEST_DELTA_PRECISION_INT16 => UDeltaPrecisionType.UInt16,
                    < (float)LARGEST_DELTA_PRECISION_INT32 => UDeltaPrecisionType.UInt32,
                    _ => UDeltaPrecisionType.Unset,
                };
            }
        }
        #endregion

        #region Double.
        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        public bool WriteUDeltaDouble(double valueA, double valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            UDeltaPrecisionType dpt = GetUDeltaPrecisionType(valueA, valueB, out double positiveDifference);

            if (dpt == UDeltaPrecisionType.Unset && option == DeltaSerializerOption.Unset) return false;

            WriteUInt8Unpacked((byte)dpt);
            WriteDeltaDouble(dpt, positiveDifference, unsigned: true);

            return true;
        }

        /// <summary>
        /// Writes a double using DeltaPrecisionType.
        /// </summary>
        private void WriteDeltaDouble(UDeltaPrecisionType dpt, double value, bool unsigned)
        {
            if (dpt.FastContains(UDeltaPrecisionType.UInt8))
            {
                if (unsigned)
                    WriteUInt8Unpacked((byte)Math.Floor(value * DOUBLE_ACCURACY));
                else
                    WriteInt8Unpacked((sbyte)Math.Floor(value * DOUBLE_ACCURACY));
            }
            else if (dpt.FastContains(UDeltaPrecisionType.UInt16))
            {
                if (unsigned)
                    WriteUInt16Unpacked((ushort)Math.Floor(value * DOUBLE_ACCURACY));
                else
                    WriteInt16Unpacked((short)Math.Floor(value * DOUBLE_ACCURACY));
            }
            else if (dpt.FastContains(UDeltaPrecisionType.UInt32))
            {
                if (unsigned)
                    WriteUInt32Unpacked((uint)Math.Floor(value * DOUBLE_ACCURACY));
                else
                    WriteInt32Unpacked((int)Math.Floor(value * DOUBLE_ACCURACY));
            }
            else if (dpt.FastContains(UDeltaPrecisionType.Unset))
            {
                WriteDoubleUnpacked(value);
            }
            else
            {
                NetworkManagerExtensions.LogError($"Unhandled precision type of {dpt}.");
            }
        }

        /// <summary>
        /// Returns DeltaPrecisionType for the difference of two values.
        /// </summary>
        public UDeltaPrecisionType GetSDeltaPrecisionType(double valueA, double valueB, out double signedDifference)
        {
            signedDifference = (valueB - valueA);
            double posValue = (signedDifference < 0d) ? (signedDifference * -1d) : signedDifference;

            return GetDeltaPrecisionType(posValue, unsigned: false);
        }

        /// <summary>
        /// Returns DeltaPrecisionType for the difference of two values.
        /// </summary>
        public UDeltaPrecisionType GetUDeltaPrecisionType(double valueA, double valueB, out double unsignedDifference)
        {
            bool bIsLarger = (valueB > valueA);
            if (bIsLarger)
                unsignedDifference = (valueB - valueA);
            else
                unsignedDifference = (valueA - valueB);

            UDeltaPrecisionType result = GetDeltaPrecisionType(unsignedDifference, unsigned: true);
            if (bIsLarger && result != UDeltaPrecisionType.Unset)
                result |= UDeltaPrecisionType.NextValueIsLarger;

            return result;
        }

        /// <summary>
        /// Returns DeltaPrecisionType for a value.
        /// </summary>
        public UDeltaPrecisionType GetDeltaPrecisionType(double positiveValue, bool unsigned)
        {
            if (unsigned)
            {
                return positiveValue switch
                {
                    < LARGEST_DELTA_PRECISION_UINT8 => UDeltaPrecisionType.UInt8,
                    < LARGEST_DELTA_PRECISION_UINT16 => UDeltaPrecisionType.UInt16,
                    < LARGEST_DELTA_PRECISION_UINT32 => UDeltaPrecisionType.UInt32,
                    _ => UDeltaPrecisionType.Unset,
                };
            }
            else
            {
                return positiveValue switch
                {
                    < LARGEST_DELTA_PRECISION_INT8 => UDeltaPrecisionType.UInt8,
                    < LARGEST_DELTA_PRECISION_INT16 => UDeltaPrecisionType.UInt16,
                    < LARGEST_DELTA_PRECISION_INT32 => UDeltaPrecisionType.UInt32,
                    _ => UDeltaPrecisionType.Unset,
                };
            }
        }
        #endregion

        #region Decimal
        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        public bool WriteUDeltaDecimal(decimal valueA, decimal valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            UDeltaPrecisionType dpt = GetUDeltaPrecisionType(valueA, valueB, out decimal positiveDifference);

            if (dpt == UDeltaPrecisionType.Unset && option == DeltaSerializerOption.Unset) return false;

            WriteUInt8Unpacked((byte)dpt);
            WriteDeltaDecimal(dpt, positiveDifference, unsigned: true);

            return true;
        }

        /// <summary>
        /// Writes a double using DeltaPrecisionType.
        /// </summary>
        private void WriteDeltaDecimal(UDeltaPrecisionType dpt, decimal value, bool unsigned)
        {
            if (dpt.FastContains(UDeltaPrecisionType.UInt8))
            {
                if (unsigned)
                    WriteUInt8Unpacked((byte)Math.Floor(value * DECIMAL_ACCURACY));
                else
                    WriteInt8Unpacked((sbyte)Math.Floor(value * DECIMAL_ACCURACY));
            }
            else if (dpt.FastContains(UDeltaPrecisionType.UInt16))
            {
                if (unsigned)
                    WriteUInt16Unpacked((ushort)Math.Floor(value * DECIMAL_ACCURACY));
                else
                    WriteInt16Unpacked((short)Math.Floor(value * DECIMAL_ACCURACY));
            }
            else if (dpt.FastContains(UDeltaPrecisionType.UInt32))
            {
                if (unsigned)
                    WriteUInt32Unpacked((uint)Math.Floor(value * DECIMAL_ACCURACY));
                else
                    WriteInt32Unpacked((int)Math.Floor(value * DECIMAL_ACCURACY));
            }
            else if (dpt.FastContains(UDeltaPrecisionType.UInt64))
            {
                if (unsigned)
                    WriteUInt64Unpacked((ulong)Math.Floor(value * DECIMAL_ACCURACY));
                else
                    WriteInt64Unpacked((long)Math.Floor(value * DECIMAL_ACCURACY));
            }
            else if (dpt.FastContains(UDeltaPrecisionType.Unset))
            {
                WriteDecimalUnpacked(value);
            }
            else
            {
                NetworkManagerExtensions.LogError($"Unhandled precision type of {dpt}.");
            }
        }

        /// <summary>
        /// Returns DeltaPrecisionType for the difference of two values.
        /// </summary>
        public UDeltaPrecisionType GetSDeltaPrecisionType(decimal valueA, decimal valueB, out decimal signedDifference)
        {
            signedDifference = (valueB - valueA);
            decimal posValue = (signedDifference < 0m) ? (signedDifference * -1m) : signedDifference;

            return GetDeltaPrecisionType(posValue, unsigned: false);
        }

        /// <summary>
        /// Returns DeltaPrecisionType for the difference of two values.
        /// </summary>
        public UDeltaPrecisionType GetUDeltaPrecisionType(decimal valueA, decimal valueB, out decimal unsignedDifference)
        {
            bool bIsLarger = (valueB > valueA);
            if (bIsLarger)
                unsignedDifference = (valueB - valueA);
            else
                unsignedDifference = (valueA - valueB);

            UDeltaPrecisionType result = GetDeltaPrecisionType(unsignedDifference, unsigned: true);
            if (bIsLarger && result != UDeltaPrecisionType.Unset)
                result |= UDeltaPrecisionType.NextValueIsLarger;

            return result;
        }

        /// <summary>
        /// Returns DeltaPrecisionType for a value.
        /// </summary>
        public UDeltaPrecisionType GetDeltaPrecisionType(decimal positiveValue, bool unsigned)
        {
            if (unsigned)
            {
                return positiveValue switch
                {
                    < (decimal)LARGEST_DELTA_PRECISION_UINT8 => UDeltaPrecisionType.UInt8,
                    < (decimal)LARGEST_DELTA_PRECISION_UINT16 => UDeltaPrecisionType.UInt16,
                    < (decimal)LARGEST_DELTA_PRECISION_UINT32 => UDeltaPrecisionType.UInt32,
                    < (decimal)LARGEST_DELTA_PRECISION_UINT64 => UDeltaPrecisionType.UInt64,
                    _ => UDeltaPrecisionType.Unset,
                };
            }
            else
            {
                return positiveValue switch
                {
                    < (decimal)LARGEST_DELTA_PRECISION_INT8 => UDeltaPrecisionType.UInt8,
                    < (decimal)LARGEST_DELTA_PRECISION_INT16 => UDeltaPrecisionType.UInt16,
                    < (decimal)LARGEST_DELTA_PRECISION_INT32 => UDeltaPrecisionType.UInt32,
                    < (decimal)LARGEST_DELTA_PRECISION_INT64 => UDeltaPrecisionType.UInt64,
                    _ => UDeltaPrecisionType.Unset,
                };
            }
        }
        #endregion

        #region FishNet Types.
        /// <summary>
        /// Writes a delta value.
        /// </summary>
        /// <returns>True if written.</returns>
        [DefaultDeltaWriter]
        public bool WriteDeltaNetworkBehaviour(NetworkBehaviour valueA, NetworkBehaviour valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            bool unchangedValue = (valueA == valueB);
            if (unchangedValue && option == DeltaSerializerOption.Unset) return false;

            WriteNetworkBehaviour(valueB);
            return true;
        }
        #endregion

        #region Unity.
        /// <summary>
        /// Writes delta position, rotation, and scale of a transform.
        /// </summary>
        public bool WriteDeltaTransformProperties(TransformProperties valueA, TransformProperties valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            int startPosition = Position;
            Skip(1);

            byte allFlags = 0;

            if (WriteDeltaVector3(valueA.Position, valueB.Position))
                allFlags |= 1;
            if (WriteDeltaQuaternion(valueA.Rotation, valueB.Rotation))
                allFlags |= 2;
            if (WriteDeltaVector3(valueA.Scale, valueB.Scale))
                allFlags |= 4;

            if (allFlags != 0 || option != DeltaSerializerOption.Unset)
            {
                InsertUInt8Unpacked(allFlags, startPosition);
                return true;
            }
            else
            {
                Position = startPosition;
                return false;
            }
        }
        
        /// <summary>
        /// Writes a delta quaternion.
        /// </summary>
        [DefaultDeltaWriter]
        public bool WriteDeltaQuaternion(Quaternion valueA, Quaternion valueB, float precision = QUATERNION_PRECISION, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            bool changed = (option != DeltaSerializerOption.Unset || IsQuaternionChanged(valueA, valueB));

            if (!changed)
                return false;
            
            QuaternionDeltaPrecisionCompression.Compress(this, valueA, valueB, precision);
            
            return true;
        }

        /// <summary>
        /// Returns if quaternion values differ.
        /// </summary>
        private bool IsQuaternionChanged(Quaternion valueA, Quaternion valueB)
        {
            const float minimumChange = 0.0025f;

            if (Mathf.Abs(valueA.x - valueB.x) > minimumChange)
                return true;
            else if (Mathf.Abs(valueA.y - valueB.y) > minimumChange)
                return true;
            else if (Mathf.Abs(valueA.z - valueB.z) > minimumChange)
                return true;
            else if (Mathf.Abs(valueA.w - valueB.w) > minimumChange)
                return true;

            return false;
        }

        /// <summary>
        /// Writes a delta value.
        /// </summary>
        [DefaultDeltaWriter]
        public bool WriteDeltaVector2(Vector2 valueA, Vector2 valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            //TODO Fit as many flags into a byte as possible for pack levels of each axis rather than 1 per axis.
            byte allFlags = 0;

            int startPosition = Position;
            Skip(1);

            if (WriteUDeltaSingle(valueA.x, valueB.x))
                allFlags += 1;
            if (WriteUDeltaSingle(valueA.y, valueB.y))
                allFlags += 2;

            if (allFlags != 0 || option != DeltaSerializerOption.Unset)
            {
                InsertUInt8Unpacked(allFlags, startPosition);
                return true;
            }

            Position = startPosition;
            return false;
        }

        [DefaultDeltaWriter]
        public bool WriteDeltaVector3(Vector3 valueA, Vector3 valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            //TODO Fit as many flags into a byte as possible for pack levels of each axis rather than 1 per axis.
            byte allFlags = 0;

            int startPosition = Position;
            Skip(1);

            if (WriteUDeltaSingle(valueA.x, valueB.x))
                allFlags += 1;
            if (WriteUDeltaSingle(valueA.y, valueB.y))
                allFlags += 2;
            if (WriteUDeltaSingle(valueA.z, valueB.z))
                allFlags += 4;

            if (allFlags != 0 || option != DeltaSerializerOption.Unset)
            {
                InsertUInt8Unpacked(allFlags, startPosition);
                return true;
            }

            Position = startPosition;
            return false;
        }

        /// <summary>
        /// Writes a delta value.
        /// </summary>
        //[DefaultDeltaWriter]
        public bool WriteDeltaVector3_New(Vector3 valueA, Vector3 valueB, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            UnsignedVector3DeltaFlag flags = UnsignedVector3DeltaFlag.Unset;

            //Get precision type and out values.
            UDeltaPrecisionType xDpt = GetUDeltaPrecisionType(valueA.x, valueB.x, out float xUnsignedDifference);
            UDeltaPrecisionType yDpt = GetUDeltaPrecisionType(valueA.y, valueB.y, out float yUnsignedDifference);
            UDeltaPrecisionType zDpt = GetUDeltaPrecisionType(valueA.z, valueB.z, out float zUnsignedDifference);

            byte unsetDpt = (byte)UDeltaPrecisionType.Unset;
            bool flagsAreUnset = ((byte)xDpt == unsetDpt && (byte)yDpt > unsetDpt && (byte)zDpt > unsetDpt);

            //No change, can exit early.
            if (flagsAreUnset && option == DeltaSerializerOption.Unset)
                return false;

            //No change but must write there's no change.
            if (flagsAreUnset && option != DeltaSerializerOption.Unset)
            {
                WriteUInt8Unpacked((byte)UnsignedVector3DeltaFlag.Unset);
                return true;
            }

            /* If here there is change. */
            int startPosition = Position;

            /* If x, y, or z dpt doesn't contain uint8 then it must contain a higher value.
             * We already exited early if all values were unset, so there's no reason to
             * check for unset here. */
            bool areFlagsMultipleBytes = (!xDpt.FastContains(UDeltaPrecisionType.UInt8) || !yDpt.FastContains(UDeltaPrecisionType.UInt8) || !zDpt.FastContains(UDeltaPrecisionType.UInt8));

            if (areFlagsMultipleBytes)
            {
                Skip(2);
                flags |= UnsignedVector3DeltaFlag.More;
            }
            else
            {
                Skip(1);
            }

            //Write X.
            if (xDpt != UDeltaPrecisionType.Unset)
            {
                flags |= GetShiftedFlag(xDpt, shift: 0);
                WriteDeltaSingle(xDpt, xUnsignedDifference, unsigned: true);
            }

            //Write Y.
            if (yDpt != UDeltaPrecisionType.Unset)
            {
                flags |= GetShiftedFlag(yDpt, shift: 2);
                WriteDeltaSingle(yDpt, yUnsignedDifference, unsigned: true);
            }

            //Write Z.
            if (zDpt != UDeltaPrecisionType.Unset)
            {
                flags |= GetShiftedFlag(zDpt, shift: 4);
                WriteDeltaSingle(zDpt, zUnsignedDifference, unsigned: true);
            }

            //Returns flags to add onto delta flags using precisionType and shift.
            UnsignedVector3DeltaFlag GetShiftedFlag(UDeltaPrecisionType precisionType, int shift)
            {
                int result;
                if (precisionType.FastContains(UDeltaPrecisionType.UInt8))
                {
                    result = ((int)UnsignedVector3DeltaFlag.X1 << shift);
                    //   Debug.Log($"Axes {axes}. X1 {(int)UnsignedVector3DeltaFlag.X1}. Shifted {result}. Shift {shift}.");
                }
                else if (precisionType.FastContains(UDeltaPrecisionType.UInt16))
                    result = ((int)UnsignedVector3DeltaFlag.X2 << shift);
                else
                    result = ((int)UnsignedVector3DeltaFlag.X4 << shift);

                if (precisionType.FastContains(UDeltaPrecisionType.NextValueIsLarger))
                    result |= ((int)UnsignedVector3DeltaFlag.NextXIsLarger << shift);

                return (UnsignedVector3DeltaFlag)result;
            }

            /* Do another check for if one byte or two, then write flags. */

            //Multiple bytes.
            if (areFlagsMultipleBytes)
            {
                int flagsValue = (int)flags;

                int firstByte = (flagsValue & 0xff);
                InsertUInt8Unpacked((byte)firstByte, startPosition);
                int secondByte = (flagsValue >> 8);
                InsertUInt8Unpacked((byte)secondByte, startPosition + 1);
            }
            //One byte.
            else
            {
                InsertUInt8Unpacked((byte)flags, startPosition);
            }

            return true;
        }
        #endregion

        #region Prediction.
        /// <summary>
        /// Writes a delta reconcile.
        /// </summary>
        internal void WriteDeltaReconcile<T>(T lastReconcile, T value, DeltaSerializerOption option = DeltaSerializerOption.Unset) => WriteDelta(lastReconcile, value, option);

        /// <summary>
        /// Writes a delta replicate using a list.
        /// </summary>
        internal void WriteDeltaReplicate<T>(List<T> values, int offset, DeltaSerializerOption option = DeltaSerializerOption.Unset) where T : IReplicateData
        {
            int collectionCount = values.Count;
            //Replicate list will never be null, no need to write null check.
            //Number of entries being written.
            byte count = (byte)(collectionCount - offset);
            WriteUInt8Unpacked(count);

            T prev;
            //Set previous if not full and if enough room in the collection to go back.
            if (option != DeltaSerializerOption.FullSerialize && collectionCount > count)
                prev = values[offset - 1];
            else
                prev = default;

            for (int i = offset; i < collectionCount; i++)
            {
                T v = values[i];
                WriteDelta(prev, v, option);

                prev = v;
                //After the first loop the deltaOption can be set to root, if not already.
                option = DeltaSerializerOption.RootSerialize;
            }
        }

        /// <summary>
        /// Writes a delta replicate using a BasicQueue.
        /// </summary>
        internal void WriteDeltaReplicate<T>(BasicQueue<T> values, int redundancyCount, DeltaSerializerOption option = DeltaSerializerOption.Unset) where T : IReplicateData
        {
            int collectionCount = values.Count;
            //Replicate list will never be null, no need to write null check.
            //Number of entries being written.
            byte count = (byte)redundancyCount;
            WriteUInt8Unpacked(count);

            int offset = (collectionCount - redundancyCount);
            T prev;
            //Set previous if not full and if enough room in the collection to go back.
            if (option != DeltaSerializerOption.FullSerialize && collectionCount > count)
                prev = values[offset - 1];
            else
                prev = default;

            for (int i = offset; i < collectionCount; i++)
            {
                T v = values[i];
                WriteDelta(prev, v, option);

                prev = v;
                //After the first loop the deltaOption can be set to root, if not already.
                option = DeltaSerializerOption.RootSerialize;
            }
        }
        #endregion

        #region Generic.
        public bool WriteDelta<T>(T prev, T next, DeltaSerializerOption option = DeltaSerializerOption.Unset)
        {
            Func<Writer, T, T, DeltaSerializerOption, bool> del = GenericDeltaWriter<T>.Write;

            if (del == null)
            {
                NetworkManager.LogError($"Write delta method not found for {typeof(T).FullName}. Use a supported type or create a custom serializer.");

                return false;
            }
            else
            {
                return del.Invoke(this, prev, next, option);
            }
        }
        #endregion
    }
}//using FishNet.CodeGenerating; //Remove on V5
//using FishNet.Connection;
//using FishNet.Documenting;
//using FishNet.Object;
//using FishNet.Serializing.Helping;
//using FishNet.Transporting;
//using System;
//using System.Collections.Generic;
//using UnityEngine;

//namespace FishNet.Serializing
//{

//    /// <summary>
//    /// Extensions to Write methods. Used by Write<T>.
//    /// </summary>
//    [APIExclude]
//    public static class WriterExtensions
//    {

//        /// <summary>
//        /// Types which are are set to auto pack by default.
//        /// </summary>
//        internal static HashSet<System.Type> DefaultPackedTypes = new HashSet<System.Type>();

//        static WriterExtensions()
//        {
//            DefaultPackedTypes.Add(typeof(short));
//            DefaultPackedTypes.Add(typeof(ushort));
//            DefaultPackedTypes.Add(typeof(int));
//            DefaultPackedTypes.Add(typeof(uint));
//            DefaultPackedTypes.Add(typeof(long));
//            DefaultPackedTypes.Add(typeof(ulong));
//            DefaultPackedTypes.Add(typeof(Color));
//            DefaultPackedTypes.Add(typeof(Quaternion));
//            DefaultPackedTypes.Add(typeof(Vector2Int));
//            DefaultPackedTypes.Add(typeof(Vector3Int));
//            DefaultPackedTypes.Add(typeof(Quaternion));
//        }


//        //public static void WriteDictionary<TKey, TValue>(this Writer writer, Dictionary<TKey, TValue> dict) => writer.WriteDictionary(dict);
//        //public static void WriteByte(this Writer writer, byte value) => writer.WriteByte(value);
//        //
//        //public static void WriteBytes(this Writer writer, byte[] buffer, int offset, int count) => writer.WriteBytes(buffer, offset, count);
//        //
//        //public static void WriteBytesAndSize(this Writer writer, byte[] buffer, int offset, int count) => writer.WriteBytesAndSize(buffer, offset, count);
//        //public static void WriteBytesAndSize(this Writer writer, byte[] value) => writer.WriteBytesAndSize(value);

//        //public static void WriteSByte(this Writer writer, sbyte value) => writer.WriteSByte(value);
//        //public static void WriteChar(this Writer writer, char value) => writer.WriteChar(value);
//        //public static void WriteBoolean(this Writer writer, bool value) => writer.WriteBoolean(value);
//        //public static void WriteUInt16(this Writer writer, ushort value) => writer.WriteUInt16(value);
//        //public static void WriteInt16(this Writer writer, short value) => writer.WriteInt16(value);
//        //public static void WriteInt32(this Writer writer, int value, AutoPackType packType = AutoPackType.Packed) => writer.WriteInt32(value, packType);
//        //public static void WriteUInt32(this Writer writer, uint value, AutoPackType packType = AutoPackType.Packed) => writer.WriteUInt32(value, packType);
//        //public static void WriteInt64(this Writer writer, long value, AutoPackType packType = AutoPackType.Packed) => writer.WriteInt64(value, packType);
//        //public static void WriteUInt64(this Writer writer, ulong value, AutoPackType packType = AutoPackType.Packed) => writer.WriteUInt64(value, packType);
//        //public static void WriteSingle(this Writer writer, float value, AutoPackType packType = AutoPackType.Unpacked) => writer.WriteSingle(value, packType);
//        //public static void WriteDouble(this Writer writer, double value) => writer.WriteDouble(value);
//        //public static void WriteDecimal(this Writer writer, decimal value) => writer.WriteDecimal(value);
//        //public static void WriteString(this Writer writer, string value) => writer.WriteString(value);
//        //public static void WriteArraySegmentAndSize(this Writer writer, ArraySegment<byte> value) => writer.WriteArraySegmentAndSize(value);
//        //
//        //public static void WriteArraySegment(this Writer writer, ArraySegment<byte> value) => writer.WriteArraySegment(value);
//        //public static void WriteVector2(this Writer writer, Vector2 value) => writer.WriteVector2(value);
//        //public static void WriteVector3(this Writer writer, Vector3 value) => writer.WriteVector3(value);
//        //public static void WriteVector4(this Writer writer, Vector4 value) => writer.WriteVector4(value);
//        //public static void WriteVector2Int(this Writer writer, Vector2Int value, AutoPackType packType = AutoPackType.Packed) => writer.WriteVector2Int(value, packType);
//        //public static void WriteVector3Int(this Writer writer, Vector3Int value, AutoPackType packType = AutoPackType.Packed) => writer.WriteVector3Int(value, packType);
//        //public static void WriteColor(this Writer writer, Color value, AutoPackType packType) => writer.WriteColor(value, packType);
//        //public static void WriteColor32(this Writer writer, Color32 value) => writer.WriteColor32(value);
//        //public static void WriteQuaternion(this Writer writer, Quaternion value, AutoPackType packType = AutoPackType.Packed) => writer.WriteQuaternion(value, packType);
//        //public static void WriteRect(this Writer writer, Rect value) => writer.WriteRect(value);
//        //public static void WritePlane(this Writer writer, Plane value) => writer.WritePlane(value);
//        //public static void WriteRay(this Writer writer, Ray value) => writer.WriteRay(value);
//        //public static void WriteRay2D(this Writer writer, Ray2D value) => writer.WriteRay2D(value);
//        //public static void WriteMatrix4x4(this Writer writer, Matrix4x4 value) => writer.WriteMatrix4x4(value);
//        //public static void WriteGuidAllocated(this Writer writer, System.Guid value) => writer.WriteGuidAllocated(value);
//        //public static void WriteGameObject(this Writer writer, GameObject value) => writer.WriteGameObject(value);
//        //public static void WriteTransform(this Writer writer, Transform value) => writer.WriteTransform(value);
//        //public static void WriteNetworkObject(this Writer writer, NetworkObject value) => writer.WriteNetworkObject(value);
//        //public static void WriteNetworkBehaviour(this Writer writer, NetworkBehaviour value) => writer.WriteNetworkBehaviour(value);
//        //public static void WriteChannel(this Writer writer, Channel value) => writer.WriteChannel(value);
//        //public static void WriteNetworkConnection(this Writer writer, NetworkConnection value) => writer.WriteNetworkConnection(value);
//        //
//        //public static void Write<T>(this Writer writer, T value) => writer.Write<T>(value);

//    }
//}
using FishNet.Managing;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using GameKit.Dependencies.Utilities;

namespace FishNet.Serializing
{
    /// <summary>
    /// Writer which is reused to save on garbage collection and performance.
    /// </summary>
    public sealed class PooledWriter : Writer
    {
        public void Store() => WriterPool.Store(this);
        public void StoreLength() => WriterPool.StoreLength(this);

        [Obsolete("Use Clear instead.")]
        public void ResetState() => base.Clear();
        [Obsolete("This does not function.")]
        public void InitializeState() { }
    }

    /// <summary>
    /// Collection of PooledWriter. Stores and gets PooledWriter.
    /// </summary>
    public static class WriterPool
    {
        #region Private.
        /// <summary>
        /// Pool of writers where length is the minimum and increased at runtime.
        /// </summary>
        private static readonly Stack<PooledWriter> _pool = new();
        /// <summary>
        /// Pool of writers where length is of minimum key and may be increased at runtime.
        /// </summary>
        private static readonly Dictionary<int, Stack<PooledWriter>> _lengthPool = new();
        #endregion

        #region Const.
        /// <summary>
        /// Length of each bracket when using the length based writer pool.
        /// </summary>
        internal const int LENGTH_BRACKET = 1000;
        #endregion

        /// <summary>
        /// Gets a writer from the pool.
        /// </summary>
        public static PooledWriter Retrieve(NetworkManager networkManager)
        {
            PooledWriter result;
            if (!_pool.TryPop(out result))
                result = new();

            result.Clear(networkManager);
            return result;
        }
        /// Gets a writer from the pool.
        /// </summary>
        
        public static PooledWriter Retrieve()
        {
            return Retrieve(null);
        }

        /// <summary>
        /// Gets the next writer in the pool of minimum length.
        /// </summary>
        /// <param name="length">Minimum length the writer buffer must be.</param>
        
        public static PooledWriter Retrieve(int length)
        {
            return Retrieve(null, length);
        }
        /// <summary>
        /// Gets the next writer in the pool of minimum length.
        /// </summary>
        /// <param name="length">Minimum length the writer buffer must be.</param>
        
        public static PooledWriter Retrieve(NetworkManager networkManager, int length)
        {
            /* The index returned will be for writers which have
             * length as a minimum capacity.
             * EG: if length is 1200 / 1000 (length_bracket) result
             * will be index 1. Index 0 will be up to 1000, while
             * index 1 will be up to 2000. */
            int index = GetDictionaryIndex(length);
            Stack<PooledWriter> stack;
            PooledWriter result;
            //There is already one pooled.
            if (_lengthPool.TryGetValue(index, out stack) && stack.TryPop(out result))
            {
                result.Clear(networkManager);
            }
            //Not pooled yet or failed to pop.
            else
            {
                //Get any ol' writer.
                result = Retrieve(networkManager);
                /* Ensure length to fill it's bracket.
                 * Increase index by 1 since 0 index would
                 * just return 0 as the capacity. */
                int requiredCapacity = (index + 1) * LENGTH_BRACKET;
                result.EnsureBufferCapacity(requiredCapacity);
            }

            return result;
        }

        /// <summary>
        /// Returns a writer to the appropriate length pool.
        /// Writers must be a minimum of 1000 bytes in length to be sorted by length.
        /// Writers which do not meet the minimum will be resized to 1000 bytes.
        /// </summary>
        public static void StoreLength(PooledWriter writer)
        {
            int index = GetDictionaryIndex(writer);
            Stack<PooledWriter> stack;
            if (!_lengthPool.TryGetValue(index, out stack))
            {
                stack = new();
                _lengthPool[index] = stack;
            }

            stack.Push(writer);
        }

        /// <summary>
        /// Returns a writer to the pool.
        /// </summary>
        public static void Store(PooledWriter writer)
        {
            _pool.Push(writer);
        }

        /// <summary>
        /// Puts writer back into pool if not null, and nullifies source reference.
        /// </summary>
        public static void StoreAndDefault(ref PooledWriter writer)
        {
            if (writer != null)
            {
                _pool.Push(writer);
                writer = null;
            }
        }
        #region Dictionary indexes.
        /// <summary>
        /// Gets which index to use for length when retrieving a writer.
        /// </summary>
        private static int GetDictionaryIndex(int length)
        {
            /* The index returned will be for writers which have
            * length as a minimum capacity.
            * EG: if length is 1200 / 1000 (length_bracket) result
            * will be index 1. Index 0 will be up to 1000, while
            * index 1 will be up to 2000. So to accomodate 1200
            * length index 1 must be used as 0 has a maximum of 1000. */

            /* Examples if length_bracket is 1000, using floor:
             * 800 / 1000 = 0.
             * 1200 / 1000 = 1.
             * 1000 / 1000 = 1. But has 0 remainder so is reduced by 1, resulting in 0.
             */
            int index = UnityEngine.Mathf.FloorToInt(length / LENGTH_BRACKET);
            if (index > 0 && length % LENGTH_BRACKET == 0)
                index--;

            //UnityEngine.Debug.Log($"Returning length {length} from index {index}");
            return index;
        }

        /// <summary>
        /// Gets which index to use for length when storing a writer.
        /// </summary>
        private static int GetDictionaryIndex(PooledWriter writer)
        {
            int capacity = writer.Capacity;
            /* If capacity is less than 1000 then the writer
             * does not meet the minimum length bracket. This should never
             * be the case unless the user perhaps manually calls this method. */
            if (capacity < LENGTH_BRACKET)
            {
                capacity = LENGTH_BRACKET;
                writer.EnsureBufferCapacity(LENGTH_BRACKET);
            }

            /* Since capacity is set to minimum of length_bracket
             * capacity / length_bracket will always be at least 1.
             * 
             * Here are some result examples using floor:
             * 1000 / 1000 = 1.
             * 1200 / 1000 = 1.
             * 2400 / 1000 = 2.
             */
            int index = UnityEngine.Mathf.FloorToInt(capacity / LENGTH_BRACKET);
            /* As mentioned the index will always be a minimum of 1. Because of this
             * we can safely reduce index by 1 and it not be negative.
             * This reduction also ensures the writer ends up in the proper pool.
             * Since index 0 ensures minimum of 1000, 1000-1999 would go there.
             * Just as 2000-2999 would go into 1. */
            index--;

            //UnityEngine.Debug.Log($"Storing capacity {capacity} at index {index}");
            return index;
        }
        #endregion

    }
}
//Remove on V5﻿using FishNet.Connection;
using FishNet.Managing;
using FishNet.Serializing;
using FishNet.Transporting;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;

namespace FishNet.Broadcast.Helping
{

    internal static class BroadcastsSerializers
    {
        /// <summary>
        /// Writes a broadcast to writer.
        /// </summary>
        internal static PooledWriter WriteBroadcast<T>(NetworkManager networkManager, PooledWriter writer, T message, ref Channel channel)
        {
            writer.WritePacketIdUnpacked(PacketId.Broadcast);
            writer.WriteUInt16(typeof(T).FullName.GetStableHashU16());
            //Write data to a new writer.
            PooledWriter dataWriter = WriterPool.Retrieve();
            dataWriter.Write(message);
            //Write length of data.
            writer.WriteInt32(dataWriter.Length);
            //Write data.
            writer.WriteArraySegment(dataWriter.GetArraySegment());
            //Update channel to reliable if needed.
            networkManager.TransportManager.CheckSetReliableChannel(writer.Length, ref channel);

            dataWriter.Store();

            return writer;
        }
    }

    internal static class BroadcastExtensions
    {
        /// <summary>
        /// Gets the key for a broadcast type.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="broadcastType"></param>
        /// <returns></returns>
        internal static ushort GetKey<T>()
        {
            return typeof(T).FullName.GetStableHashU16();
        }
    }

    /// <summary>
    /// Implemented by server and client broadcast handlers.
    /// </summary>
    public abstract class BroadcastHandlerBase
    {
        /// <summary>
        /// Current index when iterating invokes.
        /// This value will be -1 when not iterating.
        /// </summary>
        protected int IteratingIndex;

        public abstract void RegisterHandler(object obj);
        public abstract void UnregisterHandler(object obj);
        public virtual void InvokeHandlers(PooledReader reader, Channel channel) { }
        public virtual void InvokeHandlers(NetworkConnection conn, PooledReader reader, Channel channel) { }
        public virtual bool RequireAuthentication => false;
    }

    /// <summary>
    /// Handles broadcasts received on server, from clients.
    /// </summary>
    internal class ClientBroadcastHandler<T> : BroadcastHandlerBase
    {
        /// <summary>
        /// Action handlers for the broadcast.
        /// </summary>
        private List<Action<NetworkConnection, T, Channel>> _handlers = new();
        /// <summary>
        /// True to require authentication for the broadcast type.
        /// </summary>
        private bool _requireAuthentication;

        public ClientBroadcastHandler(bool requireAuthentication)
        {
            _requireAuthentication = requireAuthentication;
        }

        /// <summary>
        /// Invokes handlers after reading broadcast.
        /// </summary>
        /// <returns>True if a rebuild was required.</returns>
        public override void InvokeHandlers(NetworkConnection conn, PooledReader reader, Channel channel)
        {
            T result = reader.Read<T>();
            for (base.IteratingIndex = 0; base.IteratingIndex < _handlers.Count; base.IteratingIndex++)
            {
                Action<NetworkConnection, T, Channel> item = _handlers[base.IteratingIndex];
                if (item != null)
                {
                    item.Invoke(conn, result, channel);
                }
                else
                {
                    _handlers.RemoveAt(base.IteratingIndex);
                    base.IteratingIndex--;
                }
            }

            base.IteratingIndex = -1;
        }

        /// <summary>
        /// Adds a handler for this type.
        /// </summary>
        public override void RegisterHandler(object obj)
        {
            Action<NetworkConnection, T, Channel> handler = (Action<NetworkConnection, T, Channel>)obj;
            _handlers.AddUnique(handler);
        }

        /// <summary>
        /// Removes a handler from this type.
        /// </summary>
        /// <param name="handler"></param>
        public override void UnregisterHandler(object obj)
        {
            Action<NetworkConnection, T, Channel> handler = (Action<NetworkConnection, T, Channel>)obj;
            int indexOf = _handlers.IndexOf(handler);
            //Not registered.
            if (indexOf == -1)
                return;

            /* Has already been iterated over, need to subtract
            * 1 from iteratingIndex to accomodate
            * for the entry about to be removed. */
            if (base.IteratingIndex >= 0 && (indexOf <= base.IteratingIndex))
                base.IteratingIndex--;

            //Remove entry.
            _handlers.RemoveAt(indexOf);
        }

        /// <summary>
        /// True to require authentication for the broadcast type.
        /// </summary>
        public override bool RequireAuthentication => _requireAuthentication;
    }



    /// <summary>
    /// Handles broadcasts received on client, from server.
    /// </summary>
    internal class ServerBroadcastHandler<T> : BroadcastHandlerBase
    {
        /// <summary>
        /// Action handlers for the broadcast.
        /// Even though List lookups are slower this allows easy adding and removing of entries during iteration.
        /// </summary>
        private List<Action<T, Channel>> _handlers = new();

        /// <summary>
        /// Invokes handlers after reading broadcast.
        /// </summary>
        /// <returns>True if a rebuild was required.</returns>
        public override void InvokeHandlers(PooledReader reader, Channel channel)
        {
            T result = reader.Read<T>();
            for (base.IteratingIndex = 0; base.IteratingIndex < _handlers.Count; base.IteratingIndex++)
            {
                Action<T, Channel> item = _handlers[base.IteratingIndex];
                if (item != null)
                {
                    item.Invoke(result, channel);
                }
                else
                {
                    _handlers.RemoveAt(base.IteratingIndex);
                    base.IteratingIndex--;
                }
            }

            base.IteratingIndex = -1;
        }

        /// <summary>
        /// Adds a handler for this type.
        /// </summary>
        public override void RegisterHandler(object obj)
        {
            Action<T, Channel> handler = (Action<T, Channel>)obj;
            _handlers.AddUnique(handler);
        }

        /// <summary>
        /// Removes a handler from this type.
        /// </summary>
        /// <param name="handler"></param>
        public override void UnregisterHandler(object obj)
        {
            Action<T, Channel> handler = (Action<T, Channel>)obj;
            int indexOf = _handlers.IndexOf(handler);
            //Not registered.
            if (indexOf == -1)
                return;

            /* Has already been iterated over, need to subtract
            * 1 from iteratingIndex to accomodate
            * for the entry about to be removed. */
            if (base.IteratingIndex >= 0 && (indexOf <= base.IteratingIndex))
                base.IteratingIndex--;

            //Remove entry.
            _handlers.RemoveAt(indexOf);
        }

        /// <summary>
        /// True to require authentication for the broadcast type.
        /// </summary>
        public override bool RequireAuthentication => false;
    }

}﻿using System;
using System.Collections.Generic;
using UnityEngine.SceneManagement;

namespace FishNet.Serializing.Helping
{

    public class PublicPropertyComparer<T>
    {
        /// <summary>
        /// Compare if T is default.
        /// </summary>
        public static Func<T, bool> IsDefault { get; set; }
        /// <summary>
        /// Compare if T is the same as T2.
        /// </summary>
        public static Func<T, T, bool> Compare { get; set; }
    }
     

    public class Comparers
    {
        /// <summary>
        /// Returns if A equals B using EqualityCompare.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <returns></returns>
        public static bool EqualityCompare<T>(T a, T b)
        {
            return EqualityComparer<T>.Default.Equals(a, b);
        }

        public static bool IsDefault<T>(T t)
        {
            return t.Equals(default(T));
        }

        public static bool IsEqualityCompareDefault<T>(T a)
        {
            return EqualityComparer<T>.Default.Equals(a, default(T));
        }
    }


    internal class SceneComparer : IEqualityComparer<Scene>
    {
        public bool Equals(Scene a, Scene b)
        {
            if (!a.IsValid() || !b.IsValid())
                return false;

            if (a.handle != 0 || b.handle != 0)
                return (a.handle == b.handle);

            return (a.name == b.name);
        }

        public int GetHashCode(Scene obj)
        {
            return obj.GetHashCode();
        }
    }

}
﻿using System;
using UnityEngine;

namespace FishNet.Serializing.Helping
{
    public static class Quaternion32Compression
    {
        private const float Maximum = +1.0f / 1.414214f;

        private const int BitsPerAxis = 10;
        private const int LargestComponentShift = BitsPerAxis * 3;
        private const int AShift = BitsPerAxis * 2;
        private const int BShift = BitsPerAxis * 1;
        private const int IntScale = (1 << (BitsPerAxis - 1)) - 1;
        private const int IntMask = (1 << BitsPerAxis) - 1;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="quaternion"></param>
        /// <param name="axesFlippingEnabled">True to flip the smaller values when the largest axes is negative. Doing this saves a byte but the rotation numeric values will be reversed when decompressed.</param>
        public static void Compress(Writer writer, Quaternion quaternion, bool axesFlippingEnabled = true)
        {
            const float precision = 0.00098f;
            
            float absX = Mathf.Abs(quaternion.x);
            float absY = Mathf.Abs(quaternion.y);
            float absZ = Mathf.Abs(quaternion.z);
            float absW = Mathf.Abs(quaternion.w);
            
            ComponentType largestComponent = ComponentType.X;
            float largestAbs = absX;
            float largest = quaternion.x;

            if (absY > largestAbs)
            {
                largestAbs = absY;
                largestComponent = ComponentType.Y;
                largest = quaternion.y;
            }
            if (absZ > largestAbs)
            {
                largestAbs = absZ;
                largestComponent = ComponentType.Z;
                largest = quaternion.z;
            }
            if (absW > largestAbs)
            {
                largestComponent = ComponentType.W;
                largest = quaternion.w;
            }
            
            bool largestIsNegative = (largest < 0);

            //If not flipping axes and any values are less than precision then 0 them out.
            if (!axesFlippingEnabled)
            {
                if (absX < precision)
                    quaternion.x = 0f;
                if (absY < precision)
                    quaternion.y = 0f;
                if (absZ < precision)  
                    quaternion.z = 0f;
                if (absW < precision)
                    quaternion.w = 0f;
            }

            float a = 0;
            float b = 0;
            float c = 0;
            switch (largestComponent)
            {
                case ComponentType.X:
                    a = quaternion.y;
                    b = quaternion.z;
                    c = quaternion.w;
                    break;
                case ComponentType.Y:
                    a = quaternion.x;
                    b = quaternion.z;
                    c = quaternion.w;
                    break;
                case ComponentType.Z:
                    a = quaternion.x;
                    b = quaternion.y;
                    c = quaternion.w;
                    break;
                case ComponentType.W:
                    a = quaternion.x;
                    b = quaternion.y;
                    c = quaternion.z;
                    break;
            }
            
            //If it's okay to flip when largest is negative.
            if (largestIsNegative && axesFlippingEnabled)
            {
                a = -a;
                b = -b;
                c = -c;
            }

            uint integerA = ScaleToUint(a);
            uint integerB = ScaleToUint(b);
            uint integerC = ScaleToUint(c);

            if (!axesFlippingEnabled)
                writer.WriteBoolean((largest < 0f));

            uint result = (((uint)largestComponent) << LargestComponentShift) | (integerA << AShift) | (integerB << BShift) | integerC;
            writer.WriteUInt32Unpacked(result);
        }

        private static uint ScaleToUint(float v)
        {
            float normalized = v / Maximum;
            return (uint)Mathf.RoundToInt(normalized * IntScale) & IntMask;
        }

        private static float ScaleToFloat(uint v)
        {
            float unscaled = v * Maximum / IntScale;

            if (unscaled > Maximum)
                unscaled -= Maximum * 2;
            return unscaled;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="reader"></param>
        /// <param name="axesFlippingEnabled">True if the smaller values were flipped during compression when the largest axes was negative.</param>
        /// <returns></returns>
        public static Quaternion Decompress(Reader reader, bool axesFlippingEnabled = true)
        {
            bool largestIsNegative = (axesFlippingEnabled) ? false : reader.ReadBoolean();
            uint compressed = reader.ReadUInt32Unpacked();

            var largestComponentType = (ComponentType)(compressed >> LargestComponentShift);
            uint integerA = (compressed >> AShift) & IntMask;
            uint integerB = (compressed >> BShift) & IntMask;
            uint integerC = compressed & IntMask;

            float a = ScaleToFloat(integerA);
            float b = ScaleToFloat(integerB);
            float c = ScaleToFloat(integerC);

            Quaternion rotation;
            switch (largestComponentType)
            {
                case ComponentType.X:
                    // (?) y z w
                    rotation.y = a;
                    rotation.z = b;
                    rotation.w = c;
                    rotation.x = Mathf.Sqrt(1 - rotation.y * rotation.y - rotation.z * rotation.z - rotation.w * rotation.w);

                    if (largestIsNegative)
                        rotation.x *= -1f;
                    break;
                case ComponentType.Y:
                    // x (?) z w
                    rotation.x = a;
                    rotation.z = b;
                    rotation.w = c;
                    rotation.y = Mathf.Sqrt(1 - rotation.x * rotation.x - rotation.z * rotation.z - rotation.w * rotation.w);

                    if (largestIsNegative)
                        rotation.y *= -1f;
                    break;
                case ComponentType.Z:
                    // x y (?) w
                    rotation.x = a;
                    rotation.y = b;
                    rotation.w = c;
                    rotation.z = Mathf.Sqrt(1 - rotation.x * rotation.x - rotation.y * rotation.y - rotation.w * rotation.w);

                    if (largestIsNegative)
                        rotation.z *= -1f;
                    break;
                case ComponentType.W:
                    // x y z (?)
                    rotation.x = a;
                    rotation.y = b;
                    rotation.z = c;
                    rotation.w = Mathf.Sqrt(1 - rotation.x * rotation.x - rotation.y * rotation.y - rotation.z * rotation.z);

                    if (largestIsNegative)
                        rotation.w *= -1f;
                    break;
                default:
                    // Should never happen!
                    throw new ArgumentOutOfRangeException("Unknown rotation component type: " + largestComponentType);
            }

            return rotation;
        }
    }
}﻿
using System;
using UnityEngine;

namespace FishNet.Serializing.Helping
{
    /// <summary>
    /// Credit to https://github.com/viliwonka
    /// https://github.com/FirstGearGames/FishNet/pull/23
    /// </summary>
    public static class Quaternion64Compression
    {
        // 64 bit quaternion compression
        // [4 bits] largest component
        // [21 bits] higher res  
        // [21 bits] higher res
        // [20 bits] higher res
        // sum is 64 bits
        private const float Maximum = +1.0f / 1.414214f;
        private const int BitsPerAxis_H = 21; // higher res, 21 bits
        private const int BitsPerAxis_L = 20; // lower res, 20 bits
        private const int LargestComponentShift = BitsPerAxis_H * 2 + BitsPerAxis_L * 1;
        private const int AShift = BitsPerAxis_H + BitsPerAxis_L;
        private const int BShift = BitsPerAxis_L;
        private const int IntScale_H = (1 << (BitsPerAxis_H - 1)) - 1;
        private const int IntMask_H = (1 << BitsPerAxis_H) - 1;
        private const int IntScale_L = (1 << (BitsPerAxis_L - 1)) - 1;
        private const int IntMask_L = (1 << BitsPerAxis_L) - 1;

        public static ulong Compress(Quaternion quaternion)
        {
            float absX = Mathf.Abs(quaternion.x);
            float absY = Mathf.Abs(quaternion.y);
            float absZ = Mathf.Abs(quaternion.z);
            float absW = Mathf.Abs(quaternion.w);

            ComponentType largestComponent = ComponentType.X;
            float largestAbs = absX;
            float largest = quaternion.x;

            if (absY > largestAbs)
            {
                largestAbs = absY;
                largestComponent = ComponentType.Y;
                largest = quaternion.y;
            }
            if (absZ > largestAbs)
            {
                largestAbs = absZ;
                largestComponent = ComponentType.Z;
                largest = quaternion.z;
            }
            if (absW > largestAbs)
            {
                largestComponent = ComponentType.W;
                largest = quaternion.w;
            }

            float a = 0;
            float b = 0;
            float c = 0;

            switch (largestComponent)
            {
                case ComponentType.X:
                    a = quaternion.y;
                    b = quaternion.z;
                    c = quaternion.w;
                    break;
                case ComponentType.Y:
                    a = quaternion.x;
                    b = quaternion.z;
                    c = quaternion.w;
                    break;
                case ComponentType.Z:
                    a = quaternion.x;
                    b = quaternion.y;
                    c = quaternion.w;
                    break;
                case ComponentType.W:
                    a = quaternion.x;
                    b = quaternion.y;
                    c = quaternion.z;
                    break;
            }

            if (largest < 0)
            {
                a = -a;
                b = -b;
                c = -c;
            }

            ulong integerA = ScaleToUint_H(a);
            ulong integerB = ScaleToUint_H(b);
            ulong integerC = ScaleToUint_L(c);

            return (((ulong)largestComponent) << LargestComponentShift) | (integerA << AShift) | (integerB << BShift) | integerC;
        }

        private static ulong ScaleToUint_H(float v)
        {
            float normalized = v / Maximum;
            return (ulong)Mathf.RoundToInt(normalized * IntScale_H) & IntMask_H;
        }

        private static ulong ScaleToUint_L(float v)
        {
            float normalized = v / Maximum;
            return (ulong)Mathf.RoundToInt(normalized * IntScale_L) & IntMask_L;
        }

        private static float ScaleToFloat_H(ulong v)
        {
            float unscaled = v * Maximum / IntScale_H;

            if (unscaled > Maximum)
                unscaled -= Maximum * 2;
            return unscaled;
        }

        private static float ScaleToFloat_L(ulong v)
        {
            float unscaled = v * Maximum / IntScale_L;

            if (unscaled > Maximum)
                unscaled -= Maximum * 2;
            return unscaled;
        }

        public static Quaternion Decompress(ulong compressed)
        {
            var largestComponentType = (ComponentType)(compressed >> LargestComponentShift);
            ulong integerA = (compressed >> AShift) & IntMask_H;
            ulong integerB = (compressed >> BShift) & IntMask_H;
            ulong integerC = compressed & IntMask_L;

            float a = ScaleToFloat_H(integerA);
            float b = ScaleToFloat_H(integerB);
            float c = ScaleToFloat_L(integerC);

            Quaternion rotation;
            switch (largestComponentType)
            {
                case ComponentType.X:
                    // (?) y z w
                    rotation.y = a;
                    rotation.z = b;
                    rotation.w = c;
                    rotation.x = Mathf.Sqrt(1 - rotation.y * rotation.y
                                               - rotation.z * rotation.z
                                               - rotation.w * rotation.w);
                    break;
                case ComponentType.Y:
                    // x (?) z w
                    rotation.x = a;
                    rotation.z = b;
                    rotation.w = c;
                    rotation.y = Mathf.Sqrt(1 - rotation.x * rotation.x
                                               - rotation.z * rotation.z
                                               - rotation.w * rotation.w);
                    break;
                case ComponentType.Z:
                    // x y (?) w
                    rotation.x = a;
                    rotation.y = b;
                    rotation.w = c;
                    rotation.z = Mathf.Sqrt(1 - rotation.x * rotation.x
                                               - rotation.y * rotation.y
                                               - rotation.w * rotation.w);
                    break;
                case ComponentType.W:
                    // x y z (?)
                    rotation.x = a;
                    rotation.y = b;
                    rotation.z = c;
                    rotation.w = Mathf.Sqrt(1 - rotation.x * rotation.x
                                               - rotation.y * rotation.y
                                               - rotation.z * rotation.z);
                    break;
                default:
                    // Should never happen!
                    throw new ArgumentOutOfRangeException("Unknown rotation component type: " +
                                                          largestComponentType);
            }

            return rotation;
        }


    }
}
﻿namespace FishNet.Serializing.Helping
{
    public enum ComponentType : uint
    {
        X = 0,
        Y = 1,
        Z = 2,
        W = 3
    }

}﻿using System;
using System.Collections.Generic;
using System.Linq;
using FishNet.Managing;
using UnityEngine;

namespace FishNet.Serializing.Helping
{
    [System.Flags]
    internal enum QuaternionDeltaPrecisionFlag : byte
    {
        Unset = 0,
        
        /* Its probably safe to discard '-IsNegative'
         * and replace with a single 'largest is negative'.
         * Doing this would still use the same amount of bytes
         * though, and would require a refactor on this and the delta
         * compression class. */
        NextAIsLarger = (1 << 0),
        NextBIsLarger = (1 << 1),
        NextCIsLarger = (1 << 2),
        NextDIsNegative = (1 << 3),
        
        LargestIsX = (1 << 4),
        LargestIsY = (1 << 5),
        LargestIsZ = (1 << 6),
        //This flag can be discarded via refactor if we need it later.
        LargestIsW = (1 << 7),
    }

    internal static class QuaternionDeltaPrecisionFlagExtensions
    {
        /// <summary>
        /// Returns if whole contains part.
        /// </summary>
        internal static bool FastContains(this QuaternionDeltaPrecisionFlag whole, QuaternionDeltaPrecisionFlag part) => (whole & part) == part;
    }

    public static class QuaternionDeltaPrecisionCompression
    {
        /// <summary>
        /// Write a compressed a delta Quaternion using a variable precision.
        /// </summary>
        public static void Compress(Writer writer, Quaternion valueA, Quaternion valueB, float precision = 0.001f)
        {
            uint multiplier = (uint)Mathf.RoundToInt(1f / precision);

            //Position where the next byte is to be written.
            int startPosition = writer.Position;
            //Skip one byte so the flags can be inserted after everything else is writteh.
            writer.Skip(1);

            QuaternionDeltaPrecisionFlag flags = QuaternionDeltaPrecisionFlag.Unset;
            long largestUValue = -1;

            /* This becomes true if the largest difference is negative on valueB.
             * EG: if Y is the largest and value.Y is < 0f then largestIsNegative becomes true. */
            bool largestIsNegative = false;

            /* Set next is larger values, and output differneces. */
            bool xIsLarger = GetNextIsLarger(valueA.x, valueB.x, multiplier, out uint xDifference);
            UpdateLargestValues(xDifference, valueB.x, QuaternionDeltaPrecisionFlag.LargestIsX);

            bool yIsLarger = GetNextIsLarger(valueA.y, valueB.y, multiplier, out uint yDifference);
            UpdateLargestValues(yDifference, valueB.y, QuaternionDeltaPrecisionFlag.LargestIsY);

            bool zIsLarger = GetNextIsLarger(valueA.z, valueB.z, multiplier, out uint zDifference);
            UpdateLargestValues(zDifference, valueB.z, QuaternionDeltaPrecisionFlag.LargestIsZ);

            bool wIsLarger = GetNextIsLarger(valueA.w, valueB.w, multiplier, out uint wDifference);
            UpdateLargestValues(wDifference, valueB.w, QuaternionDeltaPrecisionFlag.LargestIsW);
            
            //If flags are unset something went wrong. This should never be possible.
            if (flags == QuaternionDeltaPrecisionFlag.Unset)
            {
                //Write that flags are unset and error.
                writer.InsertUInt8Unpacked((byte)flags, startPosition);
                NetworkManagerExtensions.LogError($"Flags should not be unset.");
                return;
            }

            //Updates largest values and flags.
            void UpdateLargestValues(uint checkedValue, float fValue, QuaternionDeltaPrecisionFlag newFlag)
            {
                if (checkedValue > largestUValue)
                {
                    largestUValue = checkedValue;
                    flags = newFlag;
                    largestIsNegative = (fValue < 0f);
                }
            }

            /* Write all but largest. */

            //X is largest.
            if (flags == QuaternionDeltaPrecisionFlag.LargestIsX)
                WriteValues(yDifference, yIsLarger, zDifference, zIsLarger, wDifference, wIsLarger);
            //Y is largest.
            else if (flags == QuaternionDeltaPrecisionFlag.LargestIsY)
                WriteValues(xDifference, xIsLarger, zDifference, zIsLarger, wDifference, wIsLarger);
            //Z is largest.
            else if (flags == QuaternionDeltaPrecisionFlag.LargestIsZ)
                WriteValues(xDifference, xIsLarger, yDifference, yIsLarger, wDifference, wIsLarger);
            //W is largest.
            else if (flags == QuaternionDeltaPrecisionFlag.LargestIsW)
                WriteValues(xDifference, xIsLarger, yDifference, yIsLarger, zDifference, zIsLarger);

            /* This must be set after values are written since the enum
             * checks above use ==, rather than a bit comparer. */
            if (largestIsNegative)
                flags |= QuaternionDeltaPrecisionFlag.NextDIsNegative;

            void WriteValues(uint aValue, bool aIsLarger, uint bValue, bool bIsLarger, uint cValue, bool cIsLarger)
            {
                writer.WriteUnsignedPackedWhole(aValue);
                if (aIsLarger)
                    flags |= QuaternionDeltaPrecisionFlag.NextAIsLarger;

                writer.WriteUnsignedPackedWhole(bValue);
                if (bIsLarger)
                    flags |= QuaternionDeltaPrecisionFlag.NextBIsLarger;

                writer.WriteUnsignedPackedWhole(cValue);
                if (cIsLarger)
                    flags |= QuaternionDeltaPrecisionFlag.NextCIsLarger;
            }
            
            //Insert flags.
            writer.InsertUInt8Unpacked((byte)flags, startPosition);
        }

        /// <summary>
        /// Write a compressed a delta Quaternion using a variable precision.
        /// </summary>
        public static Quaternion Decompress(Reader reader, Quaternion valueA, float precision = 0.001f)
        {
            uint multiplier = (uint)Mathf.RoundToInt(1f / precision);

            QuaternionDeltaPrecisionFlag flags = (QuaternionDeltaPrecisionFlag)reader.ReadUInt8Unpacked();

            //Unset flags mean something went wrong in writing.
            if (flags == QuaternionDeltaPrecisionFlag.Unset)
            {
                NetworkManagerExtensions.LogError($"Unset flags were returned.");
                return default;
            }

            /* These values will be in order of X Y Z W.
             * Whichever value is the highest will be left out.
             *
             * EG: if Y was the highest then the following will be true...
             * a = X
             * b = Z
             * c = W */
            uint aWholeDifference = (uint)reader.ReadUnsignedPackedWhole();
            uint bWholeDifference = (uint)reader.ReadUnsignedPackedWhole();
            uint cWholeDifference = (uint)reader.ReadUnsignedPackedWhole();

            //Debug.Log($"Read  {aWholeDifference}, {bWholeDifference}, {cWholeDifference}. ValueA {valueA}");

            float aFloatDifference = (float)aWholeDifference / multiplier;
            float bFloatDifference = (float)bWholeDifference / multiplier;
            float cFloatDifference = (float)cWholeDifference / multiplier;

            //Invert differences as needed so they can all be added onto the previous value as negative or positive.
            if (!flags.FastContains(QuaternionDeltaPrecisionFlag.NextAIsLarger))
                aFloatDifference *= -1f;
            if (!flags.FastContains(QuaternionDeltaPrecisionFlag.NextBIsLarger))
                bFloatDifference *= -1f;
            if (!flags.FastContains(QuaternionDeltaPrecisionFlag.NextCIsLarger))
                cFloatDifference *= -1f;

            float nextA;
            float nextB;
            float nextC;

            /* Add onto the previous value. */
            if (flags.FastContains(QuaternionDeltaPrecisionFlag.LargestIsX))
            {
                nextA = valueA.y + aFloatDifference;
                nextB = valueA.z + bFloatDifference;
                nextC = valueA.w + cFloatDifference;
            }
            else if (flags.FastContains(QuaternionDeltaPrecisionFlag.LargestIsY))
            {
                nextA = valueA.x + aFloatDifference;
                nextB = valueA.z + bFloatDifference;
                nextC = valueA.w + cFloatDifference;
            }
            else if (flags.FastContains(QuaternionDeltaPrecisionFlag.LargestIsZ))
            {
                nextA = valueA.x + aFloatDifference;
                nextB = valueA.y + bFloatDifference;
                nextC = valueA.w + cFloatDifference;
            }
            /* We do not really need the 'largest is W' since we know if
             * the other 3 are not the largest, then the remaining must be.
             * We have the available packing to use though, so use them
             * for now. */
            else if (flags.FastContains(QuaternionDeltaPrecisionFlag.LargestIsW))
            {
                nextA = valueA.x + aFloatDifference;
                nextB = valueA.y + bFloatDifference;
                nextC = valueA.z + cFloatDifference;
            }
            else
            {
                NetworkManagerExtensions.LogError($"Largest axes was not handled. Flags {flags}.");
                return default;
            }

            float abcMagnitude = GetMagnitude(nextA, nextB, nextC);

            float nextD = 1f - abcMagnitude;
            /* NextD should always be positive. But depending on precision
             * the calculated result could be negative due to missing decimals.
             * When negative make positive so nextD will normalize properly. */
            if (nextD < 0f)
                nextD *= -1f;

            nextD = (float)Math.Sqrt(nextD);

            //Get magnitude of all values.
            static float GetMagnitude(float a, float b, float c, float d = 0f) => (a * a + b * b + c * c + d * d);

            if (nextD >= 0f && flags.FastContains(QuaternionDeltaPrecisionFlag.NextDIsNegative))
                nextD *= -1f;

            if (!TryNormalize())
                return default;

            //Normalizes next values.
            bool TryNormalize()
            {
                float magnitude = (float)Math.Sqrt(GetMagnitude(nextA, nextB, nextC, nextD));
                if (magnitude < float.Epsilon)
                {
                    NetworkManagerExtensions.LogError($"Magnitude cannot be normalized.");
                    return false;
                }

                nextA /= magnitude;
                nextB /= magnitude;
                nextC /= magnitude;
                nextD /= magnitude;

                return true;
            }

            /* Add onto the previous value. */
            if (flags.FastContains(QuaternionDeltaPrecisionFlag.LargestIsX))
                return new Quaternion(nextD, nextA, nextB, nextC);
            else if (flags.FastContains(QuaternionDeltaPrecisionFlag.LargestIsY))
                return new Quaternion(nextA, nextD, nextB, nextC);
            else if (flags.FastContains(QuaternionDeltaPrecisionFlag.LargestIsZ))
                return new Quaternion(nextA, nextB, nextD, nextC);
            else if (flags.FastContains(QuaternionDeltaPrecisionFlag.LargestIsW))
                return new Quaternion(nextA, nextB, nextC, nextD);
            else
                NetworkManagerExtensions.LogError($"Unhandled Largest flag. Received flags are {flags}.");

            return default;
        }

        /// <summary>
        /// Returns if the next value is larger than the previous, and returns unsigned result with multiplier applied.
        /// </summary>
        private static bool GetNextIsLarger(float a, float b, uint lMultiplier, out uint multipliedUResult)
        {
            //Set is b is larger.
            bool bIsLarger = (b > a);

            //Get multiplied u value.
            float value = (bIsLarger) ? (b - a) : (a - b);
            multipliedUResult = (uint)Mathf.RoundToInt(value * lMultiplier);

            return bIsLarger;
        }
    }
}﻿using System;
using FishNet.Managing;
using UnityEngine;

namespace FishNet.Serializing.Helping
{
    [System.Flags]
    internal enum QuaternionPrecisionFlag : byte
    {
        Unset = 0,
        
        /* Its probably safe to discard '-IsNegative'
         * and replace with a single 'largest is negative'.
         * Doing this would still use the same amount of bytes
         * though, and would require a refactor on this and the delta
         * compression class. */
        AIsNegative = (1 << 0),
        BIsNegative = (1 << 1),
        CIsNegative = (1 << 2),
        DIsNegative = (1 << 3),
        
        LargestIsX = (1 << 4),
        LargestIsY = (1 << 5),
        LargestIsZ = (1 << 6),
        //This flag can be discarded via refactor if we need it later.
        LargestIsW = (1 << 7),
    }

    internal static class QuaternionPrecisionFlagExtensions
    {
        /// <summary>
        /// Returns if whole contains part.
        /// </summary>
        internal static bool FastContains(this QuaternionPrecisionFlag whole, QuaternionPrecisionFlag part) => (whole & part) == part;
    }

    public static class QuaternionPrecisionCompression
    {
        /// <summary>
        /// Write a compressed a delta Quaternion using a variable precision.
        /// </summary>
        public static void Compress(Writer writer, Quaternion value, float precision = 0.001f)
        {
            /* When using 0.001f or less accurate precision use the classic
             * compression. This saves about a byte by send. */
            if (precision >= 0.001f) 
            {
                Quaternion32Compression.Compress(writer, value, axesFlippingEnabled: false);
                return;
            }
            
            //Position where the next byte is to be written.
            int startPosition = writer.Position;

            //Skip one byte so the flags can be inserted after everything else is writteh.
            writer.Skip(1);

            QuaternionPrecisionFlag flags = QuaternionPrecisionFlag.Unset;
            float largestAxesValue = float.MinValue;

            //Find out which value is the largest.
            UpdateLargestValues(Math.Abs(value.x), QuaternionPrecisionFlag.LargestIsX);
            UpdateLargestValues(Math.Abs(value.y), QuaternionPrecisionFlag.LargestIsY);
            UpdateLargestValues(Math.Abs(value.z), QuaternionPrecisionFlag.LargestIsZ);
            UpdateLargestValues(Math.Abs(value.w), QuaternionPrecisionFlag.LargestIsW);
            
            //Updates largest values and flags.
            void UpdateLargestValues(float checkedValue, QuaternionPrecisionFlag newFlag)
            {
                if (checkedValue > largestAxesValue)
                {
                    largestAxesValue = checkedValue;
                    flags = newFlag;
                }
            }

            /* Write all but largest. */

            //X is largest.
            if (flags == QuaternionPrecisionFlag.LargestIsX)
                WriteValuesAndSetPositives(value.y, value.z, value.w, value.x);
            //Y is largest.
            else if (flags == QuaternionPrecisionFlag.LargestIsY)
                WriteValuesAndSetPositives(value.x, value.z, value.w, value.y);
            //Z is largest.
            else if (flags == QuaternionPrecisionFlag.LargestIsZ)
                WriteValuesAndSetPositives(value.x, value.y, value.w, value.z);
            //W is largest.
            else if (flags == QuaternionPrecisionFlag.LargestIsW)
                WriteValuesAndSetPositives(value.x, value.y, value.z, value.w);

            void WriteValuesAndSetPositives(float aValue, float bValue, float cValue, float largestAxes)
            {
                uint multiplier = (uint)Mathf.RoundToInt(1f / precision);

                uint aUint = (uint)Mathf.RoundToInt(Math.Abs(aValue) * multiplier);
                uint bUint = (uint)Mathf.RoundToInt(Math.Abs(bValue) * multiplier);
                uint cUint = (uint)Mathf.RoundToInt(Math.Abs(cValue) * multiplier);
                
                writer.WriteUnsignedPackedWhole(aUint);
                writer.WriteUnsignedPackedWhole(bUint);
                writer.WriteUnsignedPackedWhole(cUint);
                
                /* Update sign on values. */
                if (aValue < 0f)
                    flags |= QuaternionPrecisionFlag.AIsNegative;
                if (bValue < 0f)
                    flags |= QuaternionPrecisionFlag.BIsNegative;
                if (cValue<= 0f)
                    flags |= QuaternionPrecisionFlag.CIsNegative;
                if (largestAxes < 0f)
                    flags |= QuaternionPrecisionFlag.DIsNegative;
            }
      
            //Insert flags.
            writer.InsertUInt8Unpacked((byte)flags, startPosition);
        }
        
        /// <summary>
        /// Write a compressed a delta Quaternion using a variable precision.
        /// </summary>
        public static Quaternion Decompress(Reader reader, float precision = 0.001f)
        {
            /* When using 0.001f or less accurate precision use the classic
             * compression. This saves about a byte by send. */
            if (precision >= 0.001f) 
                return Quaternion32Compression.Decompress(reader, axesFlippingEnabled: false);

            uint multiplier = (uint)Mathf.RoundToInt(1f / precision);

            QuaternionPrecisionFlag flags = (QuaternionPrecisionFlag)reader.ReadUInt8Unpacked();

            //Unset flags mean something went wrong in writing.
            if (flags == QuaternionPrecisionFlag.Unset)
            {
                NetworkManagerExtensions.LogError($"Unset flags were returned.");
                return default;
            }

            /* These values will be in order of X Y Z W.
             * Whichever value is the highest will be left out.
             *
             * EG: if Y was the highest then the following will be true...
             * a = X
             * b = Z
             * c = W */
            float aValue = (float)reader.ReadUnsignedPackedWhole() / (float)multiplier;
            float bValue = (float)reader.ReadUnsignedPackedWhole() / (float)multiplier;
            float cValue = (float)reader.ReadUnsignedPackedWhole() / (float)multiplier;

            //Make values negative if needed.
            if (flags.FastContains(QuaternionPrecisionFlag.AIsNegative))
                aValue *= -1f;
            if (flags.FastContains(QuaternionPrecisionFlag.BIsNegative))
                bValue *= -1f;
            if (flags.FastContains(QuaternionPrecisionFlag.CIsNegative))
                cValue *= -1f;

            float abcMagnitude = GetMagnitude(aValue, bValue, cValue);

            float dValue = 1f - abcMagnitude;
            /* NextD should always be positive. But depending on precision
             * the calculated result could be negative due to missing decimals.
             * When negative make positive so dValue will normalize properly. */
            if (dValue < 0f)
                dValue *= -1f;

            dValue = (float)Math.Sqrt(dValue);

            //Get magnitude of all values.
            static float GetMagnitude(float a, float b, float c, float d = 0f) => (a * a + b * b + c * c + d * d);

            if (dValue >= 0f && flags.FastContains(QuaternionPrecisionFlag.DIsNegative))
                dValue *= -1f;

            if (!TryNormalize())
                return default;

            //Normalizes next values.
            bool TryNormalize()
            {
                float magnitude = (float)Math.Sqrt(GetMagnitude(aValue, bValue, cValue, dValue));
                if (magnitude < float.Epsilon)
                {
                    NetworkManagerExtensions.LogError($"Magnitude cannot be normalized.");
                    return false;
                }

                aValue /= magnitude;
                bValue /= magnitude;
                cValue /= magnitude;
                dValue /= magnitude;

                return true;
            }

            /* Add onto the previous value. */
            if (flags.FastContains(QuaternionPrecisionFlag.LargestIsX))
                return new Quaternion(dValue, aValue, bValue, cValue);
            else if (flags.FastContains(QuaternionPrecisionFlag.LargestIsY))
                return new Quaternion(aValue, dValue, bValue, cValue);
            else if (flags.FastContains(QuaternionPrecisionFlag.LargestIsZ))
                return new Quaternion(aValue, bValue, dValue, cValue);
            else if (flags.FastContains(QuaternionPrecisionFlag.LargestIsW))
                return new Quaternion(aValue, bValue, cValue, dValue);
            else
                NetworkManagerExtensions.LogError($"Unhandled Largest flag. Received flags are {flags}.");

            return default;
        }
    }
}﻿using System.Runtime.CompilerServices;
using FishNet.Managing;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Serializing.Helping
{
    /// <summary>
    /// Used to reserve bytes in a writer for length, then inserts length after data has been written.
    /// Reserved values are always written as unsigned.
    /// </summary>
    internal class ReservedLengthWriter : IResettable
    {
        private Writer _writer;
        private int _startPosition;
        private byte _reservedBytes;

        /// <summary>
        /// Number of bytes currently written.
        /// </summary>
        public int Length
        {
            get { return (_writer == null) ? 0 : (_writer.Position - _startPosition); }
        }

        public void Initialize(Writer writer, byte reservedBytes)
        {
            _writer = writer;
            _reservedBytes = reservedBytes;
            writer.Skip(reservedBytes);
            _startPosition = writer.Position;
        }

        /// <summary>
        /// Writes the amount of data written to the reserved space.
        /// This also resets the state of this object.
        /// </summary>
        public void WriteLength()
        {
            WriteLength((uint)Length);

            ResetState();
        }

        /// <summary>
        /// Writes the amount of data written to the reserved space. If no data was written the reserved amount is removed.
        /// This also resets the state of this object.
        /// Returns if length was written.
        /// </summary>
        public bool WriteLengthOrRemove(uint written)
        {
            if (written == 0)
                _writer.Remove(_reservedBytes);
            else
                WriteLength(written);

            ResetState();

            return (written > 0);
        }

        /// <summary>
        /// Writes the amount of data written to the reserved space. This overrides Length normally written.
        /// This also resets the state of this object.
        /// </summary>
        public void WriteLength(uint written)
        {
            switch (_reservedBytes)
            {
                case 1:
                    _writer.InsertUInt8Unpacked((byte)written, _startPosition - _reservedBytes);
                    break;
                case 2:
                    _writer.InsertUInt16Unpacked((ushort)written, _startPosition - _reservedBytes);
                    break;
                case 4:
                    _writer.InsertUInt32Unpacked((uint)written, _startPosition - _reservedBytes);
                    break;
                default:
                    string errorMsg = $"Reserved bytes value of {_reservedBytes} is unhandled.";
                    if (_writer != null)
                        _writer.NetworkManager.LogError(errorMsg);
                    else
                        NetworkManagerExtensions.LogError(errorMsg);
                    break;
            }

            ResetState();
        }

        /// <summary>
        /// Writes the amount of data written to the reserved space. If no data was written the reserved amount is removed.
        /// This also resets the state of this object.
        /// </summary>
        public bool WriteLengthOrRemove()
        {
            //Insert written amount.
            int written = (_writer.Position - _startPosition);

            if (written == 0)
                _writer.Remove(_reservedBytes);
            else
                WriteLength((uint)written);

            ResetState();

            return (written > 0);
        }

        /// <summary>
        /// Returns a length read based on a reserved byte count.
        /// </summary>
        /// <param name="resetPosition">True to reset to position before read.</param>
        public static uint ReadLength(PooledReader reader, byte reservedBytes, bool resetPosition = false)
        {
            uint result;
            switch (reservedBytes)
            {
                case 1:
                    result = reader.ReadUInt8Unpacked();
                    break;
                case 2:
                    result = reader.ReadUInt16Unpacked();
                    break;
                case 4:
                    result = reader.ReadUInt32Unpacked();
                    break;
                default:
                    string errorMsg = $"Reserved bytes value of {reservedBytes} is unhandled.";
                    if (reader != null)
                        reader.NetworkManager.LogError(errorMsg);
                    else
                        NetworkManagerExtensions.LogError(errorMsg);
                    return 0;
            }

            if (resetPosition)
                reader.Position -= (int)result;

            return result;
        }

        public void ResetState()
        {
            _writer = null;
            _startPosition = 0;
            _reservedBytes = 0;
        }

        public void InitializeState() { }
    }

    internal static class ReservedWritersExtensions
    {
        /// <summary>
        /// Stores to a cache.
        /// </summary>
        public static void Store(this ReservedLengthWriter rlw) => ResettableObjectCaches<ReservedLengthWriter>.Store(rlw);

        /// <summary>
        /// Retrieves from a cache.
        /// </summary>
        /// <returns></returns>
        public static ReservedLengthWriter Retrieve() => ResettableObjectCaches<ReservedLengthWriter>.Retrieve();
    }
}﻿using System.Runtime.InteropServices;

namespace FishNet.Serializing.Helping
{
    [StructLayout(LayoutKind.Explicit)]
    internal struct UIntFloat
    {
        [FieldOffset(0)]
        public float FloatValue;

        [FieldOffset(0)]
        public uint UIntValue;
    }

    [StructLayout(LayoutKind.Explicit)]
    internal struct UIntDouble
    {
        [FieldOffset(0)]
        public double DoubleValue;

        [FieldOffset(0)]
        public ulong LongValue;
    }

    [StructLayout(LayoutKind.Explicit)]
    internal struct UIntDecimal
    {
        [FieldOffset(0)]
        public ulong LongValue1;

        [FieldOffset(8)]
        public ulong LongValue2;

        [FieldOffset(0)]
        public decimal DecimalValue;
    }

}
namespace FishNet.Serializing
{

    public partial class Reader
    {
        /// <summary>
        /// Reads a substream. Start reading from it with StartReading method.
        /// </summary>
        /// <returns>Returns SubStream</returns>
        public SubStream ReadSubStream()
        {
            // read length of subStream
            int streamLength = ReadInt32();

            // if length is -1, it is invalid
            if (streamLength == SubStream.UNINITIALIZED_LENGTH)
            {
                // returns Uninitialized SubStream
                return SubStream.GetUninitialized();
            }

            return SubStream.CreateFromReader(this, streamLength);
        }
    }

}using System;
using FishNet.Managing;
using GameKit.Dependencies.Utilities;

namespace FishNet.Serializing
{

    /// <summary>
    /// Special reader/writer buffer struct that can be used in Fishnet RPCs or Broadcasts, as arguments or part of structs
    ///
    /// Use cases:
    ///     - replacement for stream sort of
    ///     - instead of always allocating some arrays T[] and sending that over RPCs/Broadcast, you can use SubStream
    ///     - you can pass SubStream into objects via reference 'ref', and those objects write/read state, useful for dynamic length reconcile (items, inventory, buffs, etc...)
    ///     - sending data inside OnServerSpawn to clients via TargetRPC
    ///     - instead of writting custom serializers for big struct, you can use SubStream inside RPCs/Broadcasts
    /// 
    /// Pros:
    ///     - reading is zero copy, reads directly from FishNet buffers
    ///     - everything is pooled
    ///     - ease of use
    ///     - SubStream can also be left uninitialized (default)
    ///     - Can work safely with multiple receivers in Broadcasts, as long as you read data in the same order
    /// Cons:
    ///     - no reading over length protection, you have to know how much data you are reading, due to buffer being red can be larger than substreams buffer
    ///     - writing buffers are also pooled, but there is a copy (since you write into it, then what is written is copied into fishnet internal buffer, but it's byte copy (fast)
    ///     - have to use Dispose() to return buffers to pool, or it may result in memory leak
    ///     - reading in multiple receiver methods (for same client) in Broadcasts, you have extra deserialization processing per each method
    ///     - might be unsafe to use this to send from clients (undefined data length), but so is sending T[] or List<T> from clients
    ///     - not to be used for IReplicateData/input structs, because underlying reading buffer may be changed where as IReplicateData structs are stored internally in replay buffer (substream buffer is not)
    /// 
    /// Note:
    ///     - If you write/read custom structs ONLY via SubStream, automatic serializer will not pick those up. Mark those custom structs with [FishNet.CodeGenerating.IncludeSerialization].
    ///     Codegen detects only custom structs that are used in RPC/Broadcast methods, not in SubStream.
    ///     
    /// </summary>
    public struct SubStream : IResettable
    {
        /// <summary>
        /// Is Substream initialized (can be read from or written to)
        /// </summary>
        public bool Initialized { get; private set; }

        /// <summary>
        /// Returns Length of substream data
        /// </summary>
        public int Length
        {
            get
            {
                if (_writer != null)
                    return _writer.Length;
                if (_reader != null)
                    return _reader.Length;

                return UNINITIALIZED_LENGTH;
            }
        }

        /// <summary>
        /// Returns remaining bytes to read from substream
        /// </summary>
        public int Remaining => (_reader != null) ? _reader.Remaining : UNINITIALIZED_LENGTH;

        /// <summary>
        /// Returns NetworkManager that Substream was initialized with
        /// </summary>
        public NetworkManager NetworkManager
        {
            get
            {
                if (_writer != null)
                    return _writer.NetworkManager;
                if (_reader != null)
                    return _reader.NetworkManager;

                return null;
            }
        }

        private PooledReader _reader;
        private int _startPosition;
        private PooledWriter _writer;
        private bool _disposed;

        /// <summary>
        /// Length to use when SubStream is not initialized.
        /// </summary>
        public const int UNINITIALIZED_LENGTH = -1;

        /// <summary>
        /// Creates SubStream for writing, use this before sending into RPC or Broadcast
        /// </summary>
        /// <param name="manager">Need to include network manager for handling of networked IDs</param>
        /// <param name="minimumLength">Minimum expected length of data, that will be written</param>
        /// <returns>Returns writer of SubStream</returns>
        public static SubStream StartWriting(NetworkManager manager, out PooledWriter writer, int minimumLength = 0)
        {
            if (minimumLength == 0)
                writer = WriterPool.Retrieve(manager);
            else
                writer = WriterPool.Retrieve(manager, minimumLength);

            SubStream stream = new()
            {
                _writer = writer,
                Initialized = true,
            };

            return stream;
        }

        /// <summary>
        /// Starts reading from substream via Reader class. Do not forget do Dispose() after reading
        /// </summary>
        /// <param name="reader">Reader to read data from</param>
        /// <returns>Returns true, if SubStream is initialized else false</returns>
        public bool StartReading(out Reader reader)
        {
            if (Initialized)
            {
                // reset reader, in case we are reading in multiple broadcasts delegates/events
                _reader.Position = _startPosition;
                reader = _reader;
                return true;
            }
            reader = null;
            return false;
        }

        public static SubStream CreateFromReader(Reader originalReader, int subStreamLength)
        {
            if (subStreamLength < 0)
            {
                NetworkManagerExtensions.LogError("SubStream length cannot be less than 0");
                return default;
            }

            byte[] originalReaderBuffer = originalReader.GetBuffer();

            // inherits reading buffer directly from fishnet reader
            ArraySegment<byte> arraySegment = new(originalReaderBuffer, originalReader.Position, subStreamLength);

            PooledReader newReader = ReaderPool.Retrieve(arraySegment, originalReader.NetworkManager);

            // advance original reader by length of substream data
            originalReader.Skip(subStreamLength);

            return new()
            {
                _startPosition = newReader.Position,
                _reader = newReader,
                _writer = null,
                _disposed = false,
                Initialized = true,
            };
        }

        /// <summary>
        /// Resets reader to start position, so you can read data again from start of substream.
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        public void ResetReaderToStartPosition()
        {
            if (_reader != null)
                _reader.Position = _startPosition;
            else
                NetworkManager.LogError("SubStream was not initialized as reader!");
        }

        /// <summary>
        /// Used internally to get writer of SubStream
        /// </summary>
        /// <exception cref="ArgumentException"></exception>
        internal PooledWriter GetWriter()
        {
            if (!Initialized)
                NetworkManager.LogError("SubStream was not initialized, it has to be initialized properly either localy or remotely!");
            else if (_writer == null)
                NetworkManager.LogError($"GetWriter() requires SubStream to be initialized as writer! You have to create SubStream with {nameof(StartWriting)}()!");

            return _writer;
        }

        internal PooledReader GetReader()
        {
            if (!Initialized)
                NetworkManager.LogError("SubStream was not initialized, it has to be initialized properly either localy or remotely!");
            if (_reader == null)
                NetworkManager.LogError($"GetReader() requires SubStream to be initialized as reader!");

            return _reader;
        }

        /// <summary>
        /// Returns uninitialized SubStream. Can send safely over network, but cannot be read from (StartReading will return false).
        /// You can also use 'var stream = default;' instead.
        /// </summary>
        /// <returns>Empty SubStream</returns>
        internal static SubStream GetUninitialized()
        {
            return new()
            {
                Initialized = false,
            };
        }

        /// <summary>
        /// Do not forget to call this after:
        /// - you stopped writing to Substream AND already sent it via RPCs/Broadcasts
        /// - you stoped reading from it inside RPCs/Broadcast receive event
        /// - if you use it in Reconcile method, you have dispose SubStream inside Dispose() of IReconcileData struct
        /// </summary>
        public void ResetState()
        {
            if (!_disposed) // dispose reader only once
            {
                _disposed = true;

                if (_reader != null)
                {
                    _reader.Store();
                    _reader = null;
                }
            }

            if (_writer != null)
            {
                if (_writer.Length < WriterPool.LENGTH_BRACKET) // 1000 is LENGTH_BRACKET
                    _writer.Store();
                else
                    _writer.StoreLength();

                _writer = null;
            }
        }

        public void InitializeState() { }
    }

}
namespace FishNet.Serializing
{

    public partial class Writer
    {
        /// <summary>
        /// Writes a SubStream.
        /// </summary>
        /// <param name="value">Substream</param>
        public void WriteSubStream(SubStream value)
        {
            // Uninitialized substream, write Length as -1
            if (!value.Initialized)
            {
                WriteInt32(SubStream.UNINITIALIZED_LENGTH);
            }
            else
            {
                PooledWriter bufferWriter = value.GetWriter();

                // Write length and data
                WriteInt32(bufferWriter.Length);
                WriteUInt8Array(bufferWriter.GetBuffer(), 0, bufferWriter.Length);
            }
        }
    }

}#if UNITYMATHEMATICS

using Unity.Mathematics;

namespace FishNet.Serializing {

    public partial class Writer {

        public void Writebool2(bool2 value) {

            byte b = 0;

            if (value.x)
                b |= 1;
            if (value.y)
                b |= 2;

            WriteUInt8Unpacked(b);
        }

        public void Writebool3(bool3 value) {

            byte b = 0;

            if (value.x)
                b |= 1;
            if (value.y)
                b |= 2;
            if (value.z)
                b |= 4;

            WriteUInt8Unpacked(b);
        }

        public void Writebool4(bool4 value) {
            byte b = 0;

            if (value.x)
                b |= 1;
            if (value.y)
                b |= 2;
            if (value.z)
                b |= 4;
            if (value.w)
                b |= 8;

            WriteUInt8Unpacked(b);
        }

        public void Writebool2x2(bool2x2 value) {

            byte b = 0;

            if (value.c0.x)
                b |= 1;
            if (value.c0.y)
                b |= 2;
            if (value.c1.x)
                b |= 4;
            if (value.c1.y)
                b |= 8;

            WriteUInt8Unpacked(b);
        }

        public void Writebool2x3(bool2x3 value) {
            byte b = 0;

            if (value.c0.x)
                b |= 1;
            if (value.c0.y)
                b |= 2;
            if (value.c1.x)
                b |= 4;
            if (value.c1.y)
                b |= 8;
            if (value.c2.x)
                b |= 16;
            if (value.c2.y)
                b |= 32;

            WriteUInt8Unpacked(b);
        }

        public void Writebool2x4(bool2x4 value) {
            byte b = 0;

            if (value.c0.x)
                b |= 1;
            if (value.c0.y)
                b |= 2;
            if (value.c1.x)
                b |= 4;
            if (value.c1.y)
                b |= 8;
            if (value.c2.x)
                b |= 16;
            if (value.c2.y)
                b |= 32;
            if (value.c3.x)
                b |= 64;
            if (value.c3.y)
                b |= 128;

            WriteUInt8Unpacked(b);
        }

        public void Writebool3x2(bool3x2 value) {
            byte b = 0;

            if (value.c0.x)
                b |= 1;
            if (value.c0.y)
                b |= 2;
            if (value.c0.z)
                b |= 4;
            if (value.c1.x)
                b |= 8;
            if (value.c1.y)
                b |= 16;
            if (value.c1.z)
                b |= 32;

            WriteUInt8Unpacked(b);
        }

        public void Writebool3x3(bool3x3 value) {
            ushort s = 0;

            if (value.c0.x)
                s |= 1;
            if (value.c0.y)
                s |= 2;
            if (value.c0.z)
                s |= 4;
            if (value.c1.x)
                s |= 8;
            if (value.c1.y)
                s |= 16;
            if (value.c1.z)
                s |= 32;
            if (value.c2.x)
                s |= 64;
            if (value.c2.y)
                s |= 128;
            if (value.c2.z)
                s |= 256;

            WriteUInt16(s);
        }

        public void Writebool3x4(bool3x4 value) {
            ushort s = 0;

            if (value.c0.x)
                s |= 1;
            if (value.c0.y)
                s |= 2;
            if (value.c0.z)
                s |= 4;
            if (value.c1.x)
                s |= 8;
            if (value.c1.y)
                s |= 16;
            if (value.c1.z)
                s |= 32;
            if (value.c2.x)
                s |= 64;
            if (value.c2.y)
                s |= 128;
            if (value.c2.z)
                s |= 256;
            if (value.c3.x)
                s |= 512;
            if (value.c3.y)
                s |= 1024;
            if (value.c3.z)
                s |= 2048;

            WriteUInt16(s);
        }

        public void Writebool4x2(bool4x2 value) {
            byte b = 0;

            if (value.c0.x)
                b |= 1;
            if (value.c0.y)
                b |= 2;
            if (value.c0.z)
                b |= 4;
            if (value.c0.w)
                b |= 8;
            if (value.c1.x)
                b |= 16;
            if (value.c1.y)
                b |= 32;
            if (value.c1.z)
                b |= 64;
            if (value.c1.w)
                b |= 128;

            WriteUInt8Unpacked(b);
        }

        public void Writebool4x3(bool4x3 value) {
            ushort s = 0;

            if (value.c0.x)
                s |= 1;
            if (value.c0.y)
                s |= 2;
            if (value.c0.z)
                s |= 4;
            if (value.c0.w)
                s |= 8;
            if (value.c1.x)
                s |= 16;
            if (value.c1.y)
                s |= 32;
            if (value.c1.z)
                s |= 64;
            if (value.c1.w)
                s |= 128;
            if (value.c2.x)
                s |= 256;
            if (value.c2.y)
                s |= 512;
            if (value.c2.z)
                s |= 1024;
            if (value.c2.w)
                s |= 2048;

            WriteUInt16(s);
        }

        public void Writebool4x4(bool4x4 value) {
            ushort s = 0;

            if (value.c0.x)
                s |= 1;
            if (value.c0.y)
                s |= 2;
            if (value.c0.z)
                s |= 4;
            if (value.c0.w)
                s |= 8;
            if (value.c1.x)
                s |= 16;
            if (value.c1.y)
                s |= 32;
            if (value.c1.z)
                s |= 64;
            if (value.c1.w)
                s |= 128;
            if (value.c2.x)
                s |= 256;
            if (value.c2.y)
                s |= 512;
            if (value.c2.z)
                s |= 1024;
            if (value.c2.w)
                s |= 2048;
            if (value.c3.x)
                s |= 4096;
            if (value.c3.y)
                s |= 8192;
            if (value.c3.z)
                s |= 16384;
            if (value.c3.w)
                s |= 32768;

            WriteUInt16(s);
        }
    }

    public partial class Reader { 
        public bool2 Readbool2() {

            byte b = ReadUInt8Unpacked();

            return new bool2() { x = (b & 1) != 0, y = (b & 2) != 0 };
        }

        public bool3 Readbool3() {

            byte b = ReadUInt8Unpacked();

            return new bool3() {
                x = (b & 1) != 0,
                y = (b & 2) != 0,
                z = (b & 4) != 0
            };
        }

        public bool4 Readbool4() {
            byte b = ReadUInt8Unpacked();

            return new bool4 {
                x = (b & 1) != 0,
                y = (b & 2) != 0,
                z = (b & 4) != 0,
                w = (b & 8) != 0
            };
        }

        public bool2x2 Readbool2x2() {
            byte b = ReadUInt8Unpacked();

            bool2x2 value = default;

            value.c0.x = (b & 1) != 0;
            value.c0.y = (b & 2) != 0;
            value.c1.x = (b & 4) != 0;
            value.c1.y = (b & 8) != 0;

            return value;
        }

        public bool2x3 Readbool2x3() {
            byte b = ReadUInt8Unpacked();

            bool2x3 value = default;

            value.c0.x = (b & 1) != 0;
            value.c0.y = (b & 2) != 0;
            value.c1.x = (b & 4) != 0;
            value.c1.y = (b & 8) != 0;
            value.c2.x = (b & 16) != 0;
            value.c2.y = (b & 32) != 0;

            return value;
        }

        public bool2x4 Readbool2x4() {
            byte b = ReadUInt8Unpacked();

            bool2x4 value = default;

            value.c0.x = (b & 1) != 0;
            value.c0.y = (b & 2) != 0;
            value.c1.x = (b & 4) != 0;
            value.c1.y = (b & 8) != 0;
            value.c2.x = (b & 16) != 0;
            value.c2.y = (b & 32) != 0;
            value.c3.x = (b & 64) != 0;
            value.c3.y = (b & 128) != 0;

            return value;
        }

        public bool3x2 Readbool3x2() {
            byte b = ReadUInt8Unpacked();

            bool3x2 value = default;

            value.c0.x = (b & 1) != 0;
            value.c0.y = (b & 2) != 0;
            value.c0.z = (b & 4) != 0;
            value.c1.x = (b & 8) != 0;
            value.c1.y = (b & 16) != 0;
            value.c1.z = (b & 32) != 0;

            return value;
        }

        public bool3x3 Readbool3x3() {
            ushort s = ReadUInt16();

            bool3x3 value = default;
            value.c0.x = (s & 1) != 0;
            value.c0.y = (s & 2) != 0;
            value.c0.z = (s & 4) != 0;
            value.c1.x = (s & 8) != 0;
            value.c1.y = (s & 16) != 0;
            value.c1.z = (s & 32) != 0;
            value.c2.x = (s & 64) != 0;
            value.c2.y = (s & 128) != 0;
            value.c2.z = (s & 256) != 0;

            return value;
        }

        public bool3x4 Readbool3x4() {
            ushort s = ReadUInt16();

            bool3x4 value = default;

            value.c0.x = (s & 1) != 0;
            value.c0.y = (s & 2) != 0;
            value.c0.z = (s & 4) != 0;
            value.c1.x = (s & 8) != 0;
            value.c1.y = (s & 16) != 0;
            value.c1.z = (s & 32) != 0;
            value.c2.x = (s & 64) != 0;
            value.c2.y = (s & 128) != 0;
            value.c2.z = (s & 256) != 0;
            value.c3.x = (s & 512) != 0;
            value.c3.y = (s & 1024) != 0;
            value.c3.z = (s & 2048) != 0;

            return value;
        }

        public bool4x2 Readbool4x2() {
            byte b = ReadUInt8Unpacked();

            bool4x2 value = default;

            value.c0.x = (b & 1) != 0;
            value.c0.y = (b & 2) != 0;
            value.c0.z = (b & 4) != 0;
            value.c0.w = (b & 8) != 0;
            value.c1.x = (b & 16) != 0;
            value.c1.y = (b & 32) != 0;
            value.c1.z = (b & 64) != 0;
            value.c1.w = (b & 128) != 0;

            return value;
        }

        public bool4x3 Readbool4x3() {
            ushort s = ReadUInt16();

            bool4x3 value = default;

            value.c0.x = (s & 1) != 0;
            value.c0.y = (s & 2) != 0;
            value.c0.z = (s & 4) != 0;
            value.c0.w = (s & 8) != 0;
            value.c1.x = (s & 16) != 0;
            value.c1.y = (s & 32) != 0;
            value.c1.z = (s & 64) != 0;
            value.c1.w = (s & 128) != 0;
            value.c2.x = (s & 256) != 0;
            value.c2.y = (s & 512) != 0;
            value.c2.z = (s & 1024) != 0;
            value.c2.w = (s & 2048) != 0;

            return value;
        }

        public bool4x4 Readbool4x4() {
            ushort s = ReadUInt16();

            bool4x4 value = default;

            value.c0.x = (s & 1) != 0;
            value.c0.y = (s & 2) != 0;
            value.c0.z = (s & 4) != 0;
            value.c0.w = (s & 8) != 0;
            value.c1.x = (s & 16) != 0;
            value.c1.y = (s & 32) != 0;
            value.c1.z = (s & 64) != 0;
            value.c1.w = (s & 128) != 0;
            value.c2.x = (s & 256) != 0;
            value.c2.y = (s & 512) != 0;
            value.c2.z = (s & 1024) != 0;
            value.c2.w = (s & 2048) != 0;
            value.c3.x = (s & 4096) != 0;
            value.c3.y = (s & 8192) != 0;
            value.c3.z = (s & 16384) != 0;
            value.c3.w = (s & 32768) != 0;

            return value;
        }
    }
}

#endif#if UNITYMATHEMATICS

using System.Runtime.CompilerServices;

using Unity.Mathematics;

namespace FishNet.Serializing {

    public partial class Writer {

        
        public void Writedouble2(double2 value) {
            WriteDouble(value.x);
            WriteDouble(value.y);
        }

        
        public void Writedouble3(double3 value) {
            WriteDouble(value.x);
            WriteDouble(value.y);
            WriteDouble(value.z);
        }


        
        public void Writedouble4(double4 value) {
            WriteDouble(value.x);
            WriteDouble(value.y);
            WriteDouble(value.z);
            WriteDouble(value.w);
        }

        public void Writedouble2x2(double2x2 value) {
            Writedouble2(value.c0);
            Writedouble2(value.c1);
        }

        public void Writedouble2x3(double2x3 value) {
            Writedouble2(value.c0);
            Writedouble2(value.c1);
            Writedouble2(value.c2);
        }

        public void Writedouble2x4(double2x4 value) {
            Writedouble2(value.c0);
            Writedouble2(value.c1);
            Writedouble2(value.c2);
            Writedouble2(value.c3);
        }

        public void Writedouble3x2(double3x2 value) {
            Writedouble3(value.c0);
            Writedouble3(value.c1);
        }

        public void Writedouble4x2(double4x2 value) {
            Writedouble4(value.c0);
            Writedouble4(value.c1);
        }

        public void Writedouble3x4(double3x4 value) {
            Writedouble3(value.c0);
            Writedouble3(value.c1);
            Writedouble3(value.c2);
            Writedouble3(value.c3);
        }

        public void Writedouble4x3(double4x3 value) {
            Writedouble4(value.c0);
            Writedouble4(value.c1);
            Writedouble4(value.c2);
        }

        public void Writedouble3x3(double3x3 value) {
            Writedouble3(value.c0);
            Writedouble3(value.c1);
            Writedouble3(value.c2);
        }
        public void Writedouble4x4(double4x4 value) {
            Writedouble4(value.c0);
            Writedouble4(value.c1);
            Writedouble4(value.c2);
            Writedouble4(value.c3);
        }

    }

    public partial class Reader {

        
        public double2 Readdouble2() {
            return new double2 {
                x = ReadDouble(),
                y = ReadDouble()
            };
        }

        
        public double3 Readdouble3() {
            return new double3() {
                x = ReadDouble(),
                y = ReadDouble(),
                z = ReadDouble()
            };
        }

        
        public double4 Readdouble4() {
            return new double4() {
                x = ReadDouble(),
                y = ReadDouble(),
                z = ReadDouble(),
                w = ReadDouble()
            };
        }

        public double2x2 Readdouble2x2() {
            return new double2x2() { 
                c0 = Readdouble2(), 
                c1 = Readdouble2() 
            };
        }


        public double2x3 Readdouble2x3() {
            return new double2x3() {
                c0 = Readdouble2(),
                c1 = Readdouble2(),
                c2 = Readdouble2()
            };
        }

        public double2x4 Readdouble2x4() {
            return new double2x4() {
                c0 = Readdouble2(),
                c1 = Readdouble2(),
                c2 = Readdouble2(),
                c3 = Readdouble2()
            };
        }

        public double3x2 Readdouble3x2() {
            return new double3x2() {
                c0 = Readdouble3(),
                c1 = Readdouble3()
            };
        }

        public double4x2 Readdouble4x2() {
            return new double4x2() {
                c0 = Readdouble4(),
                c1 = Readdouble4()
            };
        }

        public double3x4 Readdouble3x4() {
            return new double3x4() {
                c0 = Readdouble3(),
                c1 = Readdouble3(),
                c2 = Readdouble3(),
                c3 = Readdouble3()
            };
        }


        public double4x3 Readdouble4x3() {
            return new double4x3() {
                c0 = Readdouble4(),
                c1 = Readdouble4(),
                c2 = Readdouble4()
            };
        }
        public double3x3 Readdouble3x3() {
            return new double3x3() {
                c0 = Readdouble3(),
                c1 = Readdouble3(),
                c2 = Readdouble3()
            };
        }


        public double4x4 Readdouble4x4() {
            return new double4x4() {
                c0 = Readdouble4(),
                c1 = Readdouble4(),
                c2 = Readdouble4(),
                c3 = Readdouble4()
            };
        }

    }
}

#endif#if UNITYMATHEMATICS

using System.Runtime.CompilerServices;

using Unity.Mathematics;

namespace FishNet.Serializing {

    public partial class Writer {

        
        public void Writefloat2(float2 value) {
            WriteSingle(value.x);
            WriteSingle(value.y);
        }

        
        public void Writefloat3(float3 value) {
            WriteSingle(value.x);
            WriteSingle(value.y);
            WriteSingle(value.z);
        }

        
        public void Writefloat4(float4 value) {
            WriteSingle(value.x);
            WriteSingle(value.y);
            WriteSingle(value.z);
            WriteSingle(value.w);
        }

        public void Writefloat2x2(float2x2 value) {
            Writefloat2(value.c0);
            Writefloat2(value.c1);
        }

        public void Writefloat2x3(float2x3 value) {
            Writefloat2(value.c0);
            Writefloat2(value.c1);
            Writefloat2(value.c2);
        }

        public void Writefloat2x4(float2x4 value) {
            Writefloat2(value.c0);
            Writefloat2(value.c1);
            Writefloat2(value.c2);
            Writefloat2(value.c3);
        }

        public void Writefloat3x2(float3x2 value) {
            Writefloat3(value.c0);
            Writefloat3(value.c1);
        }

        public void Writefloat3x3(float3x3 value) {
            Writefloat3(value.c0);
            Writefloat3(value.c1);
            Writefloat3(value.c2);
        }

        public void Writefloat3x4(float3x4 value) {
            Writefloat3(value.c0);
            Writefloat3(value.c1);
            Writefloat3(value.c2);
            Writefloat3(value.c3);
        }

        public void Writefloat4x2(float4x2 value) {
            Writefloat4(value.c0);
            Writefloat4(value.c1);
        }

        public void Writefloat4x3(float4x3 value) {
            Writefloat4(value.c0);
            Writefloat4(value.c1);
            Writefloat4(value.c2);
        }

        public void Writefloat4x4(float4x4 value) {
            Writefloat4(value.c0);
            Writefloat4(value.c1);
            Writefloat4(value.c2);
            Writefloat4(value.c3);
        }

    }

    public partial class Reader {

        
        public float2 Readfloat2() {
            return new float2 {
                x = ReadSingle(),
                y = ReadSingle()
            };
        }

        
        public float3 Readfloat3() {
            return new float3() {
                x = ReadSingle(),
                y = ReadSingle(),
                z = ReadSingle()
            };
        }

        
        public float4 Readfloat4() {
            return new float4() {
                x = ReadSingle(),
                y = ReadSingle(),
                z = ReadSingle(),
                w = ReadSingle()
            };
        }

        public float2x2 Readfloat2x2() {
            return new float2x2() { 
                c0 = Readfloat2(), 
                c1 = Readfloat2() };
        }

        public float2x3 Readfloat2x3() {
            return new float2x3() {
                c0 = Readfloat2(),
                c1 = Readfloat2(),
                c2 = Readfloat2()
            };
        }

        public float2x4 Readfloat2x4() {
            return new float2x4() {
                c0 = Readfloat2(),
                c1 = Readfloat2(),
                c2 = Readfloat2(),
                c3 = Readfloat2()
            };
        }

        public float3x2 Readfloat3x2() {
            return new float3x2() {
                c0 = Readfloat3(),
                c1 = Readfloat3()
            };
        }

        public float3x3 Readfloat3x3() {
            return new float3x3() {
                c0 = Readfloat3(),
                c1 = Readfloat3(),
                c2 = Readfloat3()
            };
        }

        public float3x4 Readfloat3x4() {
            return new float3x4() {
                c0 = Readfloat3(),
                c1 = Readfloat3(),
                c2 = Readfloat3(),
                c3 = Readfloat3()
            };
        }

        public float4x2 Readfloat4x2() {
            return new float4x2() {
                c0 = Readfloat4(),
                c1 = Readfloat4()
            };
        }

        public float4x3 Readfloat4x3() {
            return new float4x3() {
                c0 = Readfloat4(),
                c1 = Readfloat4(),
                c2 = Readfloat4()
            };
        }

        public float4x4 Readfloat4x4() {
            return new float4x4() {
                c0 = Readfloat4(),
                c1 = Readfloat4(),
                c2 = Readfloat4(),
                c3 = Readfloat4()
            };
        }

    }
}


#endif#if UNITYMATHEMATICS

using System.Runtime.CompilerServices;

using Unity.Mathematics;

namespace FishNet.Serializing {

    public partial class Writer {

        
        public void Writehalf(half value) {
            WriteUInt16(value.value);
        }

        
        public void Writehalf2(half2 value) {
            WriteUInt16(value.x.value);
            WriteUInt16(value.y.value);
        }

        
        public void Writehalf3(half3 value) {
            WriteUInt16(value.x.value);
            WriteUInt16(value.y.value);
            WriteUInt16(value.z.value);
        }

        
        public void Writehalf4(half4 value) {

            WriteUInt16(value.x.value);
            WriteUInt16(value.y.value);
            WriteUInt16(value.z.value);
            WriteUInt16(value.w.value);
        }
    }

    public partial class Reader {

        
        public half Readhalf() { 
            return new half { value = ReadUInt16() };
        }

        
        public half2 Readhalf2() {

            half2 h = default;

            h.x.value = ReadUInt16();
            h.y.value = ReadUInt16();

            return h;
        }

        
        public half3 Readhalf3() {

            half3 h = default;
            
            h.x.value = ReadUInt16();
            h.y.value = ReadUInt16();
            h.z.value = ReadUInt16();

            return h;
        }

        
        public half4 Readhalf4() {

            half4 h = default;

            h.x.value = ReadUInt16();
            h.y.value = ReadUInt16();
            h.z.value = ReadUInt16();
            h.w.value = ReadUInt16();

            return h;
        }
    }
}

#endif#if UNITYMATHEMATICS

using System.Runtime.CompilerServices;
using Unity.Mathematics;

namespace FishNet.Serializing {

    public partial class Writer {

        
        public void Writeint2(int2 value) {
            WriteInt32(value.x);
            WriteInt32(value.y);
        }

        
        public void Writeint3(int3 value) {
            WriteInt32(value.x);
            WriteInt32(value.y);
            WriteInt32(value.z);
        }

        
        public void Writeint4(int4 value) {
            WriteInt32(value.x);
            WriteInt32(value.y);
            WriteInt32(value.z);
            WriteInt32(value.w);
        }

        public void Writeint2x2(int2x2 value) {
            Writeint2(value.c0);
            Writeint2(value.c1);
        }

        public void Writeint2x3(int2x3 value) {
            Writeint2(value.c0);
            Writeint2(value.c1);
            Writeint2(value.c2);
        }

        public void Writeint2x4(int2x4 value) {
            Writeint2(value.c0);
            Writeint2(value.c1);
            Writeint2(value.c2);
            Writeint2(value.c3);
        }

        public void Writeint3x2(int3x2 value) {
            Writeint3(value.c0);
            Writeint3(value.c1);
        }

        public void Writeint3x3(int3x3 value) {
            Writeint3(value.c0);
            Writeint3(value.c1);
            Writeint3(value.c2);
        }

        public void Writeint3x4(int3x4 value) {
            Writeint3(value.c0);
            Writeint3(value.c1);
            Writeint3(value.c2);
            Writeint3(value.c3);
        }

        public void Writeint4x2(int4x2 value) {
            Writeint4(value.c0);
            Writeint4(value.c1);
        }

        public void Writeint4x3(int4x3 value) {
            Writeint4(value.c0);
            Writeint4(value.c1);
            Writeint4(value.c2);
        }

        public void Writeint4x4(int4x4 value) {
            Writeint4(value.c0);
            Writeint4(value.c1);
            Writeint4(value.c2);
            Writeint4(value.c3);
        }

    }

    public partial class Reader {

        
        public int2 Readint2() {
            return new int2 {
                x = ReadInt32(),
                y = ReadInt32()
            };
        }

        
        public int3 Readint3() {
            return new int3() {
                x = ReadInt32(),
                y = ReadInt32(),
                z = ReadInt32()
            };
        }

        
        public int4 Readint4() {
            return new int4() {
                x = ReadInt32(),
                y = ReadInt32(),
                z = ReadInt32(),
                w = ReadInt32()
            };
        }

        public int2x2 Readint2x2() {
            return new int2x2() { 
                c0 = Readint2(), 
                c1 = Readint2() };
        }

        public int2x3 Readint2x3() {
            return new int2x3() {
                c0 = Readint2(),
                c1 = Readint2(),
                c2 = Readint2()
            };
        }

        public int2x4 Readint2x4() {
            return new int2x4() {
                c0 = Readint2(),
                c1 = Readint2(),
                c2 = Readint2(),
                c3 = Readint2()
            };
        }

        public int3x2 Readint3x2() {
            return new int3x2() {
                c0 = Readint3(),
                c1 = Readint3()
            };
        }

        public int3x3 Readint3x3() {
            return new int3x3() {
                c0 = Readint3(),
                c1 = Readint3(),
                c2 = Readint3()
            };
        }

        public int3x4 Readint3x4() {
            return new int3x4() {
                c0 = Readint3(),
                c1 = Readint3(),
                c2 = Readint3(),
                c3 = Readint3()
            };
        }

        public int4x2 Readint4x2() {
            return new int4x2() {
                c0 = Readint4(),
                c1 = Readint4()
            };
        }

        public int4x3 Readint4x3() {
            return new int4x3() {
                c0 = Readint4(),
                c1 = Readint4(),
                c2 = Readint4()
            };
        }

        public int4x4 Readint4x4() {
            return new int4x4() {
                c0 = Readint4(),
                c1 = Readint4(),
                c2 = Readint4(),
                c3 = Readint4()
            };
        }

    }
}

#endif#if UNITYMATHEMATICS

using System.Runtime.CompilerServices;
using Unity.Mathematics;
using Unity.Mathematics.Geometry;

namespace FishNet.Serializing {

    public partial class Writer {

        
        public void Writequaternion(quaternion value) {
            Writefloat4(value.value);
        }

        
        public void Writerandom(Unity.Mathematics.Random random) {
            WriteUInt32(random.state);
        }

        public void WriteRigidTransform(RigidTransform value) {

            Writequaternion(value.rot);
            Writefloat3(value.pos);
        }
#if UNITYMATHEMATICS_131
        public void WriteAffineTransform(AffineTransform value) {

            Writefloat3x3(value.rs);
            Writefloat3(value.t);
        }
#endif

#if UNITYMATHEMATICS_132

        public void ReadMinMaxAABB(MinMaxAABB minMaxAABB) {
            Writefloat3(minMaxAABB.Min);
            Writefloat3(minMaxAABB.Max);
        }

#endif
    }

    public partial class Reader {

        
        public quaternion Readquaternion() {
            return new quaternion(Readfloat4());
        }

        
        public Random Readrandom() {
            return new Random() { state = ReadUInt32() };
        }

        public RigidTransform ReadRigidTransform() {
            return new RigidTransform() {
                rot = Readquaternion(),
                pos = Readfloat3(),
            };
        }

#if UNITYMATHEMATICS_131
        public AffineTransform ReadAffineTransform() {

            return new AffineTransform() {
                rs = Readfloat3x3(),
                t = Readfloat3(),
            };
        }
#endif

#if UNITYMATHEMATICS_132

        public MinMaxAABB ReadMinMaxAABB() {
            return new MinMaxAABB() {

                Min = Readfloat3(),
                Max = Readfloat3()
            };
        }
#endif
    }
}

#endif#if UNITYMATHEMATICS

using System.Runtime.CompilerServices;
using Unity.Mathematics;

namespace FishNet.Serializing {

    public partial class Writer {

        
        public void Writeuint2(uint2 value) {
            WriteUInt32(value.x);
            WriteUInt32(value.y);
        }

        
        public void Writeuint3(uint3 value) {
            WriteUInt32(value.x);
            WriteUInt32(value.y);
            WriteUInt32(value.z);
        }

        
        public void Writeuint4(uint4 value) {
            WriteUInt32(value.x);
            WriteUInt32(value.y);
            WriteUInt32(value.z);
            WriteUInt32(value.w);
        }

        public void Writeuint2x2(uint2x2 value) {
            Writeuint2(value.c0);
            Writeuint2(value.c1);
        }

        public void Writeuint2x3(uint2x3 value) {
            Writeuint2(value.c0);
            Writeuint2(value.c1);
            Writeuint2(value.c2);
        }

        public void Writeuint2x4(uint2x4 value) {
            Writeuint2(value.c0);
            Writeuint2(value.c1);
            Writeuint2(value.c2);
            Writeuint2(value.c3);
        }

        public void Writeuint3x2(uint3x2 value) {
            Writeuint3(value.c0);
            Writeuint3(value.c1);
        }

        public void Writeuint3x3(uint3x3 value) {
            Writeuint3(value.c0);
            Writeuint3(value.c1);
            Writeuint3(value.c2);
        }

        public void Writeuint3x4(uint3x4 value) {
            Writeuint3(value.c0);
            Writeuint3(value.c1);
            Writeuint3(value.c2);
            Writeuint3(value.c3);
        }

        public void Writeuint4x2(uint4x2 value) {
            Writeuint4(value.c0);
            Writeuint4(value.c1);
        }

        public void Writeuint4x3(uint4x3 value) {
            Writeuint4(value.c0);
            Writeuint4(value.c1);
            Writeuint4(value.c2);
        }

        public void Writeuint4x4(uint4x4 value) {
            Writeuint4(value.c0);
            Writeuint4(value.c1);
            Writeuint4(value.c2);
            Writeuint4(value.c3);
        }

    }

    public partial class Reader {

        
        public uint2 Readuint2() {
            return new uint2 {
                x = ReadUInt32(),
                y = ReadUInt32()
            };
        }

        
        public uint3 Readuint3() {
            return new uint3() {
                x = ReadUInt32(),
                y = ReadUInt32(),
                z = ReadUInt32()
            };
        }

        
        public uint4 Readuint4() {
            return new uint4() {
                x = ReadUInt32(),
                y = ReadUInt32(),
                z = ReadUInt32(),
                w = ReadUInt32()
            };
        }

        public uint2x2 Readuint2x2() {
            return new uint2x2() { 
                c0 = Readuint2(), 
                c1 = Readuint2() };
        }

        public uint2x3 Readuint2x3() {
            return new uint2x3() {
                c0 = Readuint2(),
                c1 = Readuint2(),
                c2 = Readuint2()
            };
        }

        public uint2x4 Readuint2x4() {
            return new uint2x4() {
                c0 = Readuint2(),
                c1 = Readuint2(),
                c2 = Readuint2(),
                c3 = Readuint2()
            };
        }

        public uint3x2 Readuint3x2() {
            return new uint3x2() {
                c0 = Readuint3(),
                c1 = Readuint3()
            };
        }

        public uint3x3 Readuint3x3() {
            return new uint3x3() {
                c0 = Readuint3(),
                c1 = Readuint3(),
                c2 = Readuint3()
            };
        }

        public uint3x4 Readuint3x4() {
            return new uint3x4() {
                c0 = Readuint3(),
                c1 = Readuint3(),
                c2 = Readuint3(),
                c3 = Readuint3()
            };
        }

        public uint4x2 Readuint4x2() {
            return new uint4x2() {
                c0 = Readuint4(),
                c1 = Readuint4()
            };
        }

        public uint4x3 Readuint4x3() {
            return new uint4x3() {
                c0 = Readuint4(),
                c1 = Readuint4(),
                c2 = Readuint4()
            };
        }

        public uint4x4 Readuint4x4() {
            return new uint4x4() {
                c0 = Readuint4(),
                c1 = Readuint4(),
                c2 = Readuint4(),
                c3 = Readuint4()
            };
        }

    }
}

#endif﻿namespace FishNet.Transporting
{
    /// <summary>
    /// Channel which data is sent or received.
    /// </summary>
    public enum Channel : byte
    {
        /// <summary>
        /// Data will be sent ordered reliable.
        /// </summary>
        Reliable = 0,
        /// <summary>
        /// Data will be sent unreliable.
        /// </summary>
        Unreliable = 1
    }


}﻿namespace FishNet.Transporting
{

    /// <summary>
    /// States the local connection can be in.
    /// </summary>
    [System.Flags]
    public enum LocalConnectionState : int
    {
        /// <summary>
        /// Connection is fully stopped.
        /// </summary>
        Stopped = (1 << 0),
        /// <summary>
        /// Connection is stopping.
        /// </summary>
        Stopping = (1 << 1),
        /// <summary>
        /// Connection is starting but not yet established.
        /// </summary>
        Starting = (1 << 2),
        /// <summary>
        /// Connection is established.
        /// </summary>
        Started = (1 << 3),
        
        // StoppedError = (1 << 4),
        // StoppedClosed = (1 << 5),
    }

    public static class LocalConnectionStateExtensions 
    {
        /// <summary>
        /// True if the connection state is stopped or stopping.
        /// </summary>
        public static bool IsStoppedOrStopping(this LocalConnectionState connectionState) => (connectionState == LocalConnectionState.Stopped || connectionState == LocalConnectionState.Stopping);
        /// <summary>
        /// True if the connection state is started or starting.
        /// </summary>
        public static bool IsStartedOrStarting(this LocalConnectionState connectionState) => (connectionState == LocalConnectionState.Started || connectionState == LocalConnectionState.Starting);
    }

    /// <summary>
    /// States a remote client can be in.
    /// </summary>
    public enum RemoteConnectionState : byte
    {
        /// <summary>
        /// Connection is fully stopped.
        /// </summary>
        Stopped = 0,
        /// <summary>
        /// Connection is established.
        /// </summary>
        Started = 2,
    }


}﻿using System;
using System.Collections.Generic;

namespace FishNet.Transporting
{

    /// <summary>
    /// Container for connected clients state for a client.
    /// </summary>
    public struct ConnectedClientsArgs
    {
        /// <summary>
        /// Collection of client ids connected to the server.
        /// </summary>
        public List<int> ClientIds { get; private set; }

        public ConnectedClientsArgs(List<int> clientIds)
        {
            ClientIds = clientIds;
        }
    }



    /// <summary>
    /// Container about data received on the server.
    /// </summary>
    public struct ServerReceivedDataArgs
    {
        /// <summary>
        /// Data received.
        /// </summary>
        public ArraySegment<byte> Data;
        /// <summary>
        /// Channel data was received on.
        /// </summary>
        public Channel Channel;
        /// <summary>
        /// ConnectionId from which client sent data, if data was received on the server.
        /// </summary>
        public int ConnectionId;
        /// <summary>
        /// Index of the transport that is for.
        /// This is primarily used when supporting multiple transports.
        /// </summary>
        public int TransportIndex;
        /// <summary>
        /// Delegate to invoke after data is processed.
        /// </summary>
        /// <returns></returns>
        public Action FinalizeMethod;

        public ServerReceivedDataArgs(ArraySegment<byte> data, Channel channel, int connectionId, int transportIndex)
        {
            Data = data;
            Channel = channel;
            ConnectionId = connectionId;
            TransportIndex = transportIndex;
            FinalizeMethod = null;
        }
        public ServerReceivedDataArgs(ArraySegment<byte> data, Channel channel, int connectionId, int transportIndex, Action finalizeMethod)
        {
            Data = data;
            Channel = channel;
            ConnectionId = connectionId;
            TransportIndex = transportIndex;
            FinalizeMethod = finalizeMethod;
        }
    }


    /// <summary>
    /// Container about data received on the local client.
    /// </summary>
    public struct ClientReceivedDataArgs
    {
        /// <summary>
        /// Data received.
        /// </summary>
        public ArraySegment<byte> Data;
        /// <summary>
        /// Channel data was received on.
        /// </summary>
        public Channel Channel;
        /// <summary>
        /// Index of the transport that is for.
        /// This is primarily used when supporting multiple transports.
        /// </summary>
        public int TransportIndex;

        public ClientReceivedDataArgs(ArraySegment<byte> data, Channel channel, int transportIndex)
        {
            Data = data;
            Channel = channel;
            TransportIndex = transportIndex;
        }
    }



    /// <summary>
    /// Container about a connection state change for a client.
    /// </summary>
    public struct RemoteConnectionStateArgs
    {
        /// <summary>
        /// Index of the transport that is for.
        /// This is primarily used when supporting multiple transports.
        /// </summary>
        public int TransportIndex;
        /// <summary>
        /// New connection state.
        /// </summary>
        public RemoteConnectionState ConnectionState;
        /// <summary>
        /// ConnectionId for which client the state changed. Will be -1 if ConnectionState was for the local server.
        /// </summary>
        public int ConnectionId;

        public RemoteConnectionStateArgs(RemoteConnectionState connectionState, int connectionId, int transportIndex)
        {
            ConnectionState = connectionState;
            ConnectionId = connectionId;
            TransportIndex = transportIndex;
        }
    }

    /// <summary>
    /// Container about a connection state change for the server.
    /// </summary>
    public struct ServerConnectionStateArgs
    {
        /// <summary>
        /// Index of the transport that is for.
        /// This is primarily used when supporting multiple transports.
        /// </summary>
        public int TransportIndex;
        /// <summary>
        /// New connection state.
        /// </summary>
        public LocalConnectionState ConnectionState;

        public ServerConnectionStateArgs(LocalConnectionState connectionState, int transportIndex)
        {            
            ConnectionState = connectionState;
            TransportIndex = transportIndex;
        }
    }

    /// <summary>
    /// Container about a connection state change for the local client.
    /// </summary>
    public struct ClientConnectionStateArgs
    {
        /// <summary>
        /// New connection state.
        /// </summary>
        public LocalConnectionState ConnectionState;
        /// <summary>
        /// Index of the transport that is for.
        /// This is primarily used when supporting multiple transports.
        /// </summary>
        public int TransportIndex;

        public ClientConnectionStateArgs(LocalConnectionState connectionState, int transportIndex)
        {            
            ConnectionState = connectionState;
            TransportIndex = transportIndex;
        }
    }
}

﻿namespace FishNet.Transporting
{
    /// <summary>
    /// Channel which data is sent or received.
    /// </summary>
    public enum IPAddressType : byte
    {
        /// <summary>
        /// Address is IPv4.
        /// </summary>
        IPv4 = 0,
        /// <summary>
        /// Address is IPv6.
        /// </summary>
        IPv6 = 1
    }


}﻿using FishNet.Managing.Timing;
using UnityEngine;

namespace FishNet.Transporting
{
    [DisallowMultipleComponent]
    [DefaultExecutionOrder(short.MinValue)]
    internal class NetworkReaderLoop : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// TimeManager this loop is for.
        /// </summary>
        private TimeManager _timeManager;
        #endregion

        private void Awake()
        {
            _timeManager = GetComponent<TimeManager>();
        }

        private void FixedUpdate()
        {
            _timeManager.TickFixedUpdate();
        }
        private void Update()
        {
            _timeManager.TickUpdate();
        }
    }


}﻿using FishNet.Managing.Timing;
using UnityEngine;

namespace FishNet.Transporting
{
    [DisallowMultipleComponent]
    [DefaultExecutionOrder(short.MaxValue)]
    internal class NetworkWriterLoop : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// TimeManager this loop is for.
        /// </summary>
        private TimeManager _timeManager;
        #endregion

        private void Awake()
        {
            _timeManager = GetComponent<TimeManager>();
        }

        private void LateUpdate()
        {
            Iterate();
        }

        /// <summary>
        /// Performs read on transport.
        /// </summary>
        private void Iterate()
        {
            _timeManager.TickLateUpdate();
        }

    }


}﻿using FishNet.Documenting;

namespace FishNet.Transporting
{

    /// <summary>
    /// PacketIds to indicate the type of packet which is being sent or arriving.
    /// </summary>
    [APIExclude]
    public enum PacketId : ushort
    {
        Unset = 0,
        Authenticated = 1,
        Split = 2,
        ObjectSpawn = 3,
        ObjectDespawn = 4,
        PredictedSpawnResult = 5,
        SyncType = 7,
        ServerRpc = 8,
        ObserversRpc = 9,
        TargetRpc = 10,
        OwnershipChange = 11,
        Broadcast = 12,
        UNUSED = 13,
        PingPong = 14,
        Replicate = 15,
        Reconcile = 16,
        Disconnect = 17,
        TimingUpdate = 18,
        UNUSED2 = 19,
        StateUpdate = 20,
        Version = 21,
    }

}﻿using FishNet.Managing;
using FishNet.Managing.Logging;
using System;
using UnityEngine;

namespace FishNet.Transporting
{
    /// <summary>
    /// Processes connection states, and data sent to and from a socket.
    /// </summary>
    public abstract class Transport : MonoBehaviour
    {
        #region Private.
        /// <summary>
        /// NetworkManager for this transport.
        /// </summary>
        public NetworkManager NetworkManager { get; private set; }
        /// <summary>
        /// Index this transport belongs to when using multiple transports at once.
        /// </summary>
        public int Index { get; private set; }
        #endregion

        #region Initialization and unity.
        /// <summary>
        /// Initializes the transport. Use this instead of Awake.
        /// <param name="transportIndex">Index this transport belongs to when using multiple transports at once.</param>
        /// </summary>
        public virtual void Initialize(NetworkManager networkManager, int transportIndex)
        {
            NetworkManager = networkManager;
            Index = transportIndex;
        }
        #endregion

        #region ConnectionStates.
        /// <summary>
        /// Gets the address of a remote connection Id.
        /// </summary>
        /// <param name="connectionId">Connectionid to get the address for.</param>
        /// <returns></returns>
        public abstract string GetConnectionAddress(int connectionId);

        /// <summary>
        /// Called when a connection state changes for the local client.
        /// </summary>
        public abstract event Action<ClientConnectionStateArgs> OnClientConnectionState;
        /// <summary>
        /// Called when a connection state changes for the local server.
        /// </summary>
        public abstract event Action<ServerConnectionStateArgs> OnServerConnectionState;
        /// <summary>
        /// Called when a connection state changes for a remote client.
        /// </summary>
        public abstract event Action<RemoteConnectionStateArgs> OnRemoteConnectionState;

        /// <summary>
        /// Handles a ConnectionStateArgs for the local client.
        /// </summary>
        /// <param name="connectionStateArgs">Data being handled.</param>
        public abstract void HandleClientConnectionState(ClientConnectionStateArgs connectionStateArgs);

        /// <summary>
        /// Handles a ConnectionStateArgs for the local server.
        /// </summary>
        /// <param name="connectionStateArgs">Data being handled.</param>
        public abstract void HandleServerConnectionState(ServerConnectionStateArgs connectionStateArgs);

        /// <summary>
        /// Handles a ConnectionStateArgs for a remote client.
        /// </summary>
        /// <param name="connectionStateArgs">Data being handled.</param>
        public abstract void HandleRemoteConnectionState(RemoteConnectionStateArgs connectionStateArgs);

        /// <summary>
        /// Gets the current local ConnectionState.
        /// </summary>
        /// <param name="server">True if getting ConnectionState for the server.</param>
        public abstract LocalConnectionState GetConnectionState(bool server);

        /// <summary>
        /// Gets the current ConnectionState of a client connected to the server. Can only be called on the server.
        /// </summary>
        /// <param name="connectionId">ConnectionId to get ConnectionState for.</param>
        public abstract RemoteConnectionState GetConnectionState(int connectionId);
        #endregion

        #region Sending.
        /// <summary>
        /// Sends to the server.
        /// </summary>
        /// <param name="channelId">Channel to use.</param>
        /// <param name="segment">Data to send.</param>
        public abstract void SendToServer(byte channelId, ArraySegment<byte> segment);

        /// <summary>
        /// Sends to a client.
        /// </summary>
        /// <param name="channelId">Channel to use.</param>
        /// <param name="segment">Data to send.</param>
        /// <param name="connectionId">ConnectionId to send to. When sending to clients can be used to specify which connection to send to.</param>
        public abstract void SendToClient(byte channelId, ArraySegment<byte> segment, int connectionId);
        #endregion

        #region Receiving
        /// <summary>
        /// Called when the client receives data.
        /// </summary>
        public abstract event Action<ClientReceivedDataArgs> OnClientReceivedData;

        /// <summary>
        /// Handles a ClientReceivedDataArgs.
        /// </summary>
        /// <param name="receivedDataArgs">Data being handled.</param>
        public abstract void HandleClientReceivedDataArgs(ClientReceivedDataArgs receivedDataArgs);

        /// <summary>
        /// Called when the server receives data.
        /// </summary>
        public abstract event Action<ServerReceivedDataArgs> OnServerReceivedData;

        /// <summary>
        /// Handles a ServerReceivedDataArgs.
        /// </summary>
        /// <param name="receivedDataArgs">Data being handled.</param>
        public abstract void HandleServerReceivedDataArgs(ServerReceivedDataArgs receivedDataArgs);

        /// <summary>
        /// Returns packet loss percentage. Not all transports support this feature.
        /// </summary>
        /// <param name="asServer">True to return packet loss on the server, false to return packet loss on the client.</param>
        public virtual float GetPacketLoss(bool asServer) => 0f;
        #endregion

        #region Iterating.
        /// <summary>
        /// Processes data received by the socket.
        /// </summary>
        /// <param name="asServer">True to read data from clients, false to read data from the server.
        public abstract void IterateIncoming(bool asServer);

        /// <summary>
        /// Processes data to be sent by the socket.
        /// </summary>
        /// <param name="asServer">True to send data from the local server to clients, false to send from the local client to server.
        public abstract void IterateOutgoing(bool asServer);
        #endregion

        #region Configuration.
        /// <summary>
        /// Returns if the transport is only run locally, offline.
        /// While true several security checks are disabled.
        /// </summary>
        /// <param name="connectionid">Optional connectionId to check against.</param>
        public virtual bool IsLocalTransport(int connectionid) => false;

        /// <summary>
        /// Gets how long in seconds until either the server or client socket must go without data before being timed out.
        /// </summary>
        /// <param name="asServer">True to get the timeout for the server socket, false for the client socket.</param>
        /// <returns></returns>
        public virtual float GetTimeout(bool asServer) => -1f;

        /// <summary>
        /// Sets how long in seconds until either the server or client socket must go without data before being timed out.
        /// </summary>
        /// <param name="asServer">True to set the timeout for the server socket, false for the client socket.</param>
        public virtual void SetTimeout(float value, bool asServer) { }

        /// <summary>
        /// Returns the maximum number of clients allowed to connect to the server. If the transport does not support this method the value -1 is returned.
        /// </summary>
        /// <returns>Maximum clients transport allows.</returns>
        public virtual int GetMaximumClients()
        {
            string message = $"The current transport does not support this feature.";
            NetworkManager.LogWarning(message);
            return -1;
        }

        /// <summary>
        /// Sets the maximum number of clients allowed to connect to the server. If applied at runtime and clients exceed this value existing clients will stay connected but new clients may not connect.
        /// </summary>
        /// <param name="value">Maximum clients to allow.</param>
        public virtual void SetMaximumClients(int value)
        {
            string message = $"The current transport does not support this feature.";
            NetworkManager.LogWarning(message);
        }

        /// <summary>
        /// Sets which address the client will connect to.
        /// </summary>
        /// <param name="address">Address client will connect to.</param>
        public virtual void SetClientAddress(string address) { }

        /// <summary>
        /// Returns which address the client will connect to.
        /// </summary>
        public virtual string GetClientAddress() => string.Empty;

        /// <summary>
        /// Sets which address the server will bind to.
        /// </summary>
        /// <param name="address">Address server will bind to.</param>
        /// <param name="addressType">Address type to set.</param>
        public virtual void SetServerBindAddress(string address, IPAddressType addressType) { }

        /// <summary>
        /// Gets which address the server will bind to.
        /// </summary>
        /// <param name="addressType">Address type to return.</param>
        public virtual string GetServerBindAddress(IPAddressType addressType) => string.Empty;

        /// <summary>
        /// Sets which port to use.
        /// </summary>
        /// <param name="port">Port to use.</param>
        public virtual void SetPort(ushort port) { }

        /// <summary>
        /// Gets which port to use.
        /// </summary>
        public virtual ushort GetPort() => 0;
        #endregion

        #region Start and stop.
        /// <summary>
        /// Starts the local server or client using configured settings.
        /// </summary>
        /// <param name="server">True to start server.</param>
        public abstract bool StartConnection(bool server);

        /// <summary>
        /// Stops the local server or client.
        /// </summary>
        /// <param name="server">True to stop server.</param>
        public abstract bool StopConnection(bool server);

        /// <summary>
        /// Stops a remote client from the server, disconnecting the client.
        /// </summary>
        /// <param name="connectionId">ConnectionId of the client to disconnect.</param>
        /// <param name="immediately">True to abrutly stop the client socket. The technique used to accomplish immediate disconnects may vary depending on the transport.
        /// When not using immediate disconnects it's recommended to perform disconnects using the ServerManager rather than accessing the transport directly.
        /// </param>
        public abstract bool StopConnection(int connectionId, bool immediately);

        /// <summary>
        /// Stops both client and server.
        /// </summary>
        public abstract void Shutdown();
        #endregion

        #region Channels.
        /// <summary>
        /// Gets the MTU for a channel.
        /// </summary>
        /// <param name="channel">Channel to get MTU for.</param>
        /// <returns>MTU of channel.</returns>
        public abstract int GetMTU(byte channel);
        #endregion
    }
}﻿using FishNet.Managing;
using System;
using UnityEngine;

namespace FishNet.Transporting
{
    
    public static class TransportConsts
    {
        /// <summary>
        /// Value used when a transport index is not known or set for a connection.
        /// </summary>
        public const int UNSET_TRANSPORT_INDEX = -1;

    }
}
#if UNITY_EDITOR || DEVELOPMENT_BUILD
#define DEVELOPMENT
#endif
using FishNet.Connection;
using FishNet.Managing;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Transporting.Multipass
{
    [AddComponentMenu("FishNet/Transport/Multipass")]
    public class Multipass : Transport
    {
        #region Types.
        public struct ClientTransportData : IEquatable<ClientTransportData>
        {
            /// <summary>
            /// Transport index this connection is on.
            /// </summary>
            public int TransportIndex;
            /// <summary>
            /// ConnectionId assigned by the transport.
            /// </summary>
            public int TransportId;
            /// <summary>
            /// Connection Id assigned by multipass. This Id is the one communicated to the NetworkManager.
            /// </summary>
            public int MultipassId;
            /// <summary>
            /// Cached hashcode for values.
            /// </summary>
            private int _hashCode;

            public ClientTransportData(int transportIndex, int transportId, int multipassId)
            {
                TransportIndex = transportIndex;
                TransportId = transportId;
                MultipassId = multipassId;
                _hashCode = (transportIndex, transportId, multipassId).GetHashCode();
            }

            public bool Equals(ClientTransportData other)
            {
                return (_hashCode == other._hashCode);
            }
        }
        #endregion

        #region Public.
        /// <summary>
        /// While true server actions such as starting or stopping the server will run on all transport.
        /// </summary>
        [Tooltip("While true server actions such as starting or stopping the server will run on all transport.")]
        public bool GlobalServerActions = true;
        /// <summary>
        /// 
        /// </summary>
        private Transport _clientTransport;
        /// <summary>
        /// Transport the client is using.
        /// Use SetClientTransport to assign this value.
        /// </summary>
        [HideInInspector]
        public Transport ClientTransport
        {
            get
            {
                //If not yet set.
                if (_clientTransport == null)
                {
                    //If there are transports to set from.
                    if (_transports.Count != 0)
                        _clientTransport = _transports[0];

                    /* Give feedback to developer that transport was not set
                     * before accessing this. Transport should always be set
                     * manually rather than assuming the default client
                     * transport. */
                    if (_clientTransport == null)
                        base.NetworkManager.LogError($"ClientTransport in Multipass could not be set to the first transport. This can occur if no trnasports are specified or if the first entry is null.");
                    else
                        base.NetworkManager.LogError($"ClientTransport in Multipass is being automatically set to {_clientTransport.GetType()}. For production use SetClientTransport before attempting to access the ClientTransport.");
                }

                return _clientTransport;
            }

            private set => _clientTransport = value;
        }
        #endregion

        #region Serialized.
        /// <summary>
        /// 
        /// </summary>
        [Tooltip("Transports to use.")]
        [SerializeField]
        private List<Transport> _transports = new();
        /// <summary>
        /// Transports to use.
        /// </summary>
        public IReadOnlyList<Transport> Transports => _transports;
        #endregion

        #region Private.
        /// <summary>
        /// An unset/invalid ClientTransportData.
        /// </summary>
        private readonly ClientTransportData INVALID_CLIENTTRANSPORTDATA = new(int.MinValue, int.MinValue, int.MinValue);
        /// <summary>
        /// MultipassId lookup.
        /// </summary>
        private Dictionary<int, ClientTransportData> _multpassIdLookup = new();
        /// <summary>
        /// TransportId lookup. Each index within the list is the same as the transport index.
        /// </summary>
        private List<Dictionary<int, ClientTransportData>> _transportIdLookup = new();
        /// <summary>
        /// Ids available to new connections.
        /// </summary>
        private Queue<int> _availableMultipassIds = new();
        /// <summary>
        /// Last Id added to availableMultipassIds.
        /// </summary>
        private int _lastAvailableMultipassId = 0;
        #endregion

        public override void Initialize(NetworkManager networkManager, int transportIndex)
        {
            base.Initialize(networkManager, transportIndex);

            //Remove any null transports and warn.
            for (int i = 0; i < _transports.Count; i++)
            {
                if (_transports[i] == null)
                {
                    base.NetworkManager.LogWarning($"Transports contains a null entry on index {i}.");
                    _transports.RemoveAt(i);
                    i--;
                }
            }

            //No transports to use.
            if (_transports.Count == 0)
            {
                base.NetworkManager.LogError($"No transports are set within Multipass.");
                return;
            }

            //Create transportsToMultipass.
            for (int i = 0; i < _transports.Count; i++)
            {
                Dictionary<int, ClientTransportData> dict = new();
                _transportIdLookup.Add(dict);
                //Initialize transports and callbacks.
                _transports[i].Initialize(networkManager, i);
                _transports[i].OnClientConnectionState += Multipass_OnClientConnectionState;
                _transports[i].OnServerConnectionState += Multipass_OnServerConnectionState;
                _transports[i].OnRemoteConnectionState += Multipass_OnRemoteConnectionState;
                _transports[i].OnClientReceivedData += Multipass_OnClientReceivedData;
                _transports[i].OnServerReceivedData += Multipass_OnServerReceivedData;
            }
        }

        private void OnDestroy()
        {
            //Initialize each transport.
            foreach (Transport t in _transports)
                t.Shutdown();

            ResetLookupCollections();
        }

        #region ClientIds.
        /// <summary>
        /// Resets lookup collections and caches potential garbage.
        /// </summary>
        private void ResetLookupCollections()
        {
            _multpassIdLookup.Clear();

            for (int i = 0; i < _transportIdLookup.Count; i++)
                _transportIdLookup[i].Clear();
        }

        /// <summary>
        /// Clears ClientIds when appropriate.
        /// </summary>
        private void TryResetClientIds(bool force)
        {
            //Can only clear when every transport server isnt connected.
            if (!force)
            {
                foreach (Transport t in _transports)
                {
                    //Cannot clear if a server is running still.
                    if (t.GetConnectionState(true) == LocalConnectionState.Started)
                        return;
                }
            }

            ResetLookupCollections();
            CreateAvailableIds(true);
        }

        /// <summary>
        /// Gets the Multipass connectionId using a transport connectionid.
        /// </summary>
        private ClientTransportData GetDataFromTransportId(int transportIndex, int transportId, bool log)
        {
            Dictionary<int, ClientTransportData> dict = _transportIdLookup[transportIndex];
            if (dict.TryGetValueIL2CPP(transportId, out ClientTransportData ctd))
                return ctd;

            //Fall through/fail.
            if (log)
                base.NetworkManager.LogError($"Multipass connectionId could not be found for transportIndex {transportIndex}, transportId of {transportId}.");
            return INVALID_CLIENTTRANSPORTDATA;
        }

        /// <summary>
        /// Gets the TransportIdData using a Multipass connectionId.
        /// </summary>
        private ClientTransportData GetDataFromMultipassId(int multipassId)
        {
            if (_multpassIdLookup.TryGetValueIL2CPP(multipassId, out ClientTransportData ctd))
                return ctd;

            //Fall through/fail.
            base.NetworkManager.LogError($"TransportIdData could not be found for Multipass connectionId of {multipassId}.");
            return INVALID_CLIENTTRANSPORTDATA;
        }
        #endregion

        #region ConnectionStates.
        /// <summary>
        /// Gets the IP address of a remote connectionId.
        /// </summary>
        public override string GetConnectionAddress(int multipassId)
        {
            ClientTransportData ctd = GetDataFromMultipassId(multipassId);
            if (ctd.Equals(INVALID_CLIENTTRANSPORTDATA))
                return string.Empty;

            return _transports[ctd.TransportIndex].GetConnectionAddress(ctd.TransportId);
        }

        /// <summary>
        /// Called when a connection state changes for the local client.
        /// </summary>
        public override event Action<ClientConnectionStateArgs> OnClientConnectionState;
        /// <summary>
        /// Called when a connection state changes for the local server.
        /// </summary>
        public override event Action<ServerConnectionStateArgs> OnServerConnectionState;
        /// <summary>
        /// Called when a connection state changes for a remote client.
        /// </summary>
        public override event Action<RemoteConnectionStateArgs> OnRemoteConnectionState;

        /// <summary>
        /// Gets the current local ConnectionState of the first transport.
        /// </summary>
        /// <param name="server">True if getting ConnectionState for the server.</param>
        public override LocalConnectionState GetConnectionState(bool server)
        {
            if (server)
            {
                base.NetworkManager.LogError($"This method is not supported for server. Use GetConnectionState(server, transportIndex) instead.");
                return LocalConnectionState.Stopped;
            }

            if (IsClientTransportSetWithError("GetConnectionState"))
                return GetConnectionState(server, ClientTransport.Index);
            else
                return LocalConnectionState.Stopped;
        }

        /// <summary>
        /// Gets the current local ConnectionState of the transport on index.
        /// </summary>
        /// <param name="server">True if getting ConnectionState for the server.</param>
        public LocalConnectionState GetConnectionState(bool server, int transportIndex)
        {
            if (!IndexInRange(transportIndex, true))
                return LocalConnectionState.Stopped;

            return _transports[transportIndex].GetConnectionState(server);
        }

        /// <summary>
        /// Gets the current ConnectionState of a remote client on the server.
        /// </summary>
        /// <param name="multipassId">ConnectionId to get ConnectionState for.</param>
        public override RemoteConnectionState GetConnectionState(int multipassId)
        {
            ClientTransportData ctd = GetDataFromMultipassId(multipassId);
            if (ctd.Equals(INVALID_CLIENTTRANSPORTDATA))
                return RemoteConnectionState.Stopped;

            return _transports[ctd.TransportIndex].GetConnectionState(ctd.TransportId);
        }

        /// <summary>
        /// Gets the current ConnectionState of a remote client on the server of the transport on index.
        /// </summary>
        /// <param name="connectionId">ConnectionId to get ConnectionState for.</param>
        public RemoteConnectionState GetConnectionState(int connectionId, int index)
        {
            if (!IndexInRange(index, true))
                return RemoteConnectionState.Stopped;

            return _transports[index].GetConnectionState(connectionId);
        }

        /// <summary>
        /// Handles a ConnectionStateArgs for the local client.
        /// </summary>
        /// <param name="connectionStateArgs"></param>
        private void Multipass_OnClientConnectionState(ClientConnectionStateArgs connectionStateArgs)
        {
            OnClientConnectionState?.Invoke(connectionStateArgs);
        }

        /// <summary>
        /// Handles a ConnectionStateArgs for the local server.
        /// </summary>
        /// <param name="connectionStateArgs"></param>
        private void Multipass_OnServerConnectionState(ServerConnectionStateArgs connectionStateArgs)
        {
            OnServerConnectionState?.Invoke(connectionStateArgs);
            TryResetClientIds(false);
        }

        /// <summary>
        /// Handles a ConnectionStateArgs for a remote client.
        /// </summary>
        /// <param name="connectionStateArgs"></param>
        private void Multipass_OnRemoteConnectionState(RemoteConnectionStateArgs connectionStateArgs)
        {
            /* When starting Multipass needs to get a new
             * connectionId to be used within FN. This is the 'ClientId'
             * that is passed around for ownership, rpcs, ect.
             *
             * The new connectionId will be linked with the connectionId
             * from the transport, named transportConnectionid.
             *
             * When data arrives the transportStateId is used as a key
             * in fromClientIds, where Multipass Id is returned. The argument values
             * are then overwritten with the MultipassId.
             *
             * When data is being sent the same process is performed but reversed.
             * The connectionId is looked up in toClientIds, where the transportConnectionId
             * is output. Then as before the argument values are overwritten with the
             * transportConnectionId. */

            int transportIndex = connectionStateArgs.TransportIndex;
            int transportConnectionId = connectionStateArgs.ConnectionId;
            /* MultipassId is set to a new value when connecting
             * or discovered value when disconnecting. */
            int multipassId;
            Dictionary<int, ClientTransportData> transportToMultipass = _transportIdLookup[transportIndex];

            //Started.
            if (connectionStateArgs.ConnectionState == RemoteConnectionState.Started)
            {
                if (_availableMultipassIds.Count == 0)
                {
                    bool addedIds = CreateAvailableIds(false);
                    if (!addedIds)
                    {
                        base.NetworkManager.Log($"There are no more available connectionIds to use. Connection {transportConnectionId} has been kicked.");
                        _transports[transportIndex].StopConnection(transportConnectionId, true);
                        return;
                    }
                }
                //Get a multipassId for new connections.
                multipassId = _availableMultipassIds.Dequeue();

                //Get and update a clienttransportdata.
                ClientTransportData ctd = new(transportIndex, transportConnectionId, multipassId);
                //Assign the lookup for transportId/index.
                transportToMultipass[transportConnectionId] = ctd;
                //Assign the lookup for multipassId.
                _multpassIdLookup[multipassId] = ctd;

                //Update args to use multipassId before invoking.
                connectionStateArgs.ConnectionId = multipassId;
                OnRemoteConnectionState?.Invoke(connectionStateArgs);
            }
            //Stopped.
            else
            {
                Transport transport = _transports[transportIndex];
                //Only log if the server is started for the specified transport.
                bool log = (transport.GetConnectionState(server: true) == LocalConnectionState.Started);
                
                ClientTransportData ctd = GetDataFromTransportId(transportIndex, transportConnectionId, log);
                /* If CTD could not be found then the connection
                 * is not stored/known. Nothing further can be done; the event cannot
                 * invoke either since Id is unknown. */
                if (ctd.Equals(INVALID_CLIENTTRANSPORTDATA))
                    return;

                //Add the multipassId back to the queue.
                _availableMultipassIds.Enqueue(ctd.MultipassId);
                transportToMultipass.Remove(transportConnectionId);
                _multpassIdLookup.Remove(ctd.MultipassId);
#if DEVELOPMENT
                //Remove packets held for connection from latency simulator.
                base.NetworkManager.TransportManager.LatencySimulator.RemovePendingForConnection(ctd.MultipassId);
#endif

                //Update args to use multipassId before invoking.
                connectionStateArgs.ConnectionId = ctd.MultipassId;
                OnRemoteConnectionState?.Invoke(connectionStateArgs);
            }
        }
        #endregion

        #region Iterating.
        /// <summary>
        /// Processes data received by the socket.
        /// </summary>
        /// <param name="asServer">True to process data received on the server.</param>
        public override void IterateIncoming(bool asServer)
        {
            foreach (Transport t in _transports)
                t.IterateIncoming(asServer);
        }

        /// <summary>
        /// Processes data to be sent by the socket.
        /// </summary>
        /// <param name="asServer">True to send data from the local server to clients, false to send from the local client to server.
        public override void IterateOutgoing(bool asServer)
        {
            foreach (Transport t in _transports)
                t.IterateOutgoing(asServer);
        }
        #endregion

        #region ReceivedData.
        /// <summary>
        /// Called when client receives data.
        /// </summary>
        public override event Action<ClientReceivedDataArgs> OnClientReceivedData;

        /// <summary>
        /// Handles a ClientReceivedDataArgs.
        /// </summary>
        /// <param name="receivedDataArgs"></param>
        private void Multipass_OnClientReceivedData(ClientReceivedDataArgs receivedDataArgs)
        {
            OnClientReceivedData?.Invoke(receivedDataArgs);
        }

        /// <summary>
        /// Called when server receives data.
        /// </summary>
        public override event Action<ServerReceivedDataArgs> OnServerReceivedData;

        /// <summary>
        /// Handles a ClientReceivedDataArgs.
        /// </summary>
        /// <param name="receivedDataArgs"></param>
        private void Multipass_OnServerReceivedData(ServerReceivedDataArgs receivedDataArgs)
        {
            ClientTransportData ctd = GetDataFromTransportId(receivedDataArgs.TransportIndex, receivedDataArgs.ConnectionId, log: true);
            if (ctd.Equals(INVALID_CLIENTTRANSPORTDATA))
                return;

            receivedDataArgs.ConnectionId = ctd.MultipassId;
            OnServerReceivedData?.Invoke(receivedDataArgs);
        }
        #endregion

        #region Sending.
        /// <summary>
        /// Sends to the server on ClientTransport.
        /// </summary>
        /// <param name="channelId">Channel to use.</param>
        /// /// <param name="segment">Data to send.</param>
        public override void SendToServer(byte channelId, ArraySegment<byte> segment)
        {
            if (ClientTransport != null)
                ClientTransport.SendToServer(channelId, segment);
        }

        /// <summary>
        /// Sends data to a client.
        /// </summary>
        public override void SendToClient(byte channelId, ArraySegment<byte> segment, int multipassId)
        {
            ClientTransportData ctd = GetDataFromMultipassId(multipassId);
            if (ctd.Equals(INVALID_CLIENTTRANSPORTDATA))
                return;

            _transports[ctd.TransportIndex].SendToClient(channelId, segment, ctd.TransportId);
        }

        /// <summary>
        /// Sends data to a client.
        /// </summary>
        /// <param name="transportIndex">TransportIndex the client is using.</param>
        public void SendToClient(byte channelId, ArraySegment<byte> segment, int transportId, int transportIndex)
        {
            _transports[transportIndex].SendToClient(channelId, segment, transportId);
        }
        #endregion

        #region Configuration.
        /// <summary>
        /// Returns if GlobalServerActions is true and if not logs an error.
        /// </summary>
        /// <returns></returns>
        private bool UseGlobalServerActionsWithError(string methodText)
        {
            if (!GlobalServerActions)
            {
                base.NetworkManager.LogError($"Method {methodText} is not supported while GlobalServerActions is false.");
                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Returns if ClientTransport is set and if not logs an error.
        /// </summary>
        /// <param name="methodText"></param>
        /// <returns></returns>
        private bool IsClientTransportSetWithError(string methodText)
        {
            if (ClientTransport == null)
            {
                base.NetworkManager.LogError($"ClientTransport is not set. Use SetClientTransport before calling {methodText}.");
                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Populates the availableIds collection.
        /// </summary>
        /// <returns>True if at least 1 Id was added.</returns>
        private bool CreateAvailableIds(bool reset)
        {
            if (reset)
            {
                _lastAvailableMultipassId = 0;
                _availableMultipassIds.Clear();
            }
            //Add in blocks of 1000.
            int added = 0;
            while ((_lastAvailableMultipassId <= NetworkConnection.MAXIMUM_CLIENTID_WITHOUT_SIMULATED_VALUE) && (added < 1000))
            {
                added++;
                _availableMultipassIds.Enqueue(_lastAvailableMultipassId);
                _lastAvailableMultipassId++;
            }

            return (added > 0);
        }

        /// <summary>
        /// Sets the client transport to the first of type.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        public void SetClientTransport<T>()
        {
            int index = -1;
            for (int i = 0; i < _transports.Count; i++)
            {
                if (_transports[i].GetType() == typeof(T))
                {
                    index = i;
                    break;
                }
            }

            SetClientTransport(index);
        }

        /// <summary>
        /// Sets the client transport to the first of type T.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        public void SetClientTransport(Type type)
        {
            int index = -1;
            for (int i = 0; i < _transports.Count; i++)
            {
                if (_transports[i].GetType() == type)
                {
                    index = i;
                    break;
                }
            }

            SetClientTransport(index);
        }

        /// <summary>
        /// Sets the client transport to the matching reference of transport.
        /// </summary>
        /// <param name="transport"></param>
        public void SetClientTransport(Transport transport)
        {
            int index = -1;
            for (int i = 0; i < _transports.Count; i++)
            {
                if (_transports[i] == transport)
                {
                    index = i;
                    break;
                }
            }

            SetClientTransport(index);
        }

        /// <summary>
        /// Sets the client transport to the transport on index.
        /// </summary>
        /// <param name="index"></param>
        public void SetClientTransport(int index)
        {
            if (!IndexInRange(index, true))
                return;

            ClientTransport = _transports[index];
        }

        /// <summary>
        /// Gets the Transport on index.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public Transport GetTransport(int index)
        {
            if (!IndexInRange(index, true))
                return null;

            return _transports[index];
        }

        /// <summary>
        /// Gets the Transport on of type T.
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        public T GetTransport<T>()
        {
            foreach (Transport t in _transports)
            {
                if (t.GetType() == typeof(T))
                    return (T)(object)t;
            }

            return default(T);
        }

        /// <summary>
        /// Returns if the first transport is a local transport, optionally checking against connectionId.
        /// While true several security checks are disabled.
        /// </summary>
        public override bool IsLocalTransport(int connectionId)
        {
            foreach (Transport item in _transports)
                return item.IsLocalTransport(connectionId);

            return false;
        }

        /// <summary>
        /// Returns if the transportId is a local transport, optionally checking against connectionId.
        /// While true several security checks are disabled.
        /// </summary>
        public bool IsLocalTransport(int transportId, int connectionId)
        {
            if (!IndexInRange(transportId, true))
                return false;

            return _transports[transportId].IsLocalTransport(connectionId);
        }

        /// <summary>
        /// Returns the maximum number of clients allowed to connect to the server. If the transport does not support this method the value -1 is returned.
        /// This method is not supported. Use GetMaximumClients(transportIndex) instead.
        /// </summary>
        /// <returns></returns>
        public override int GetMaximumClients()
        {
            base.NetworkManager.LogError($"This method is not supported. Use GetMaximumClients(transportIndex) instead.");
            return -1;
        }

        /// <summary>
        /// Returns the maximum number of clients allowed to connect to the server. If the transport does not support this method the value -1 is returned.
        /// The first transport is used.
        /// </summary>
        /// <returns></returns>
        public int GetMaximumClients(int transportIndex)
        {
            if (!IndexInRange(transportIndex, true))
                return -1;

            return _transports[transportIndex].GetMaximumClients();
        }

        /// <summary>
        /// Sets maximum number of clients allowed to connect to the server. If applied at runtime and clients exceed this value existing clients will stay connected but new clients may not connect.
        /// This sets the value for every transport.
        /// </summary>
        /// <param name="value"></param>
        public override void SetMaximumClients(int value)
        {
            foreach (Transport t in _transports)
                t.SetMaximumClients(value);
        }

        /// <summary>
        /// Sets maximum number of clients allowed to connect to the server. If applied at runtime and clients exceed this value existing clients will stay connected but new clients may not connect.
        /// This sets the value to the transport on index.
        /// </summary>
        /// <param name="value"></param>
        public void SetMaximumClients(int value, int transportIndex)
        {
            if (!IndexInRange(transportIndex, true))
                return;

            _transports[transportIndex].SetMaximumClients(value);
        }

        /// <summary>
        /// Sets which address the client will connect to.
        /// This will set the address for every transport.
        /// </summary>
        /// <param name="address"></param>
        public override void SetClientAddress(string address)
        {
            foreach (Transport t in _transports)
                t.SetClientAddress(address);
        }

        /// <summary>
        /// Sets which address the client will connect to.
        /// </summary>
        /// <param name="address"></param>
        /// <param name="index">Transport index to set for.</param>
        public void SetClientAddress(string address, int index)
        {
            if (!IndexInRange(index, true))
                return;

            _transports[index].SetClientAddress(address);
        }

        /// <summary>
        /// Sets which address the server will bind to.
        /// This will set the address for every transport.
        /// </summary>
        public override void SetServerBindAddress(string address, IPAddressType addressType)
        {
            foreach (Transport t in _transports)
                t.SetServerBindAddress(address, addressType);
        }

        /// Sets which address the server will bind to.
        /// This is called on the transport of index.
        /// </summary>
        /// <param name="address"></param>
        public void SetServerBindAddress(string address, IPAddressType addressType, int index)
        {
            if (!IndexInRange(index, true))
                return;

            _transports[index].SetServerBindAddress(address, addressType);
        }

        /// <summary>
        /// Sets which port to use.
        /// This will set the port for every transport.
        /// </summary>
        public override void SetPort(ushort port)
        {
            foreach (Transport t in _transports)
                t.SetPort(port);
        }

        /// <summary>
        /// Sets which port to use on transport of index.
        /// </summary>
        public void SetPort(ushort port, int index)
        {
            if (!IndexInRange(index, true))
                return;

            _transports[index].SetPort(port);
        }

        /// <summary>
        /// Gets the first transports port.
        /// </summary>
        /// <returns></returns>
        public override ushort GetPort()
        {
            foreach (Transport t in _transports)
                return t.GetPort();

            return base.GetPort();
        }
        #endregion

        #region Start and stop.
        /// <summary>
        /// Starts the local server or client using configured settings on the first transport.
        /// </summary>
        /// <param name="server">True to start server.</param>
        public override bool StartConnection(bool server)
        {
            //Server.
            if (server)
            {
                if (!UseGlobalServerActionsWithError("StartConnection"))
                    return false;

                bool success = true;
                for (int i = 0; i < _transports.Count; i++)
                {
                    if (!StartConnection(true, i))
                        success = false;
                }

                return success;
            }
            //Client.
            else
            {
                if (IsClientTransportSetWithError("StartConnection"))
                    return StartConnection(false, ClientTransport.Index);
                else
                    return false;
            }
        }

        /// <summary>
        /// Starts the local server or client using configured settings on transport of index.
        /// </summary>
        /// <param name="server">True to start server.</param>
        public bool StartConnection(bool server, int index)
        {
            if (server)
            {
                return StartServer(index);
            }
            else
            {
                if (IsClientTransportSetWithError("StartConnection"))
                    return StartClient();
                else
                    return false;
            }
        }

        /// <summary>
        /// Stops the local server or client on the first transport.
        /// </summary>
        /// <param name="server">True to stop server.</param>
        public override bool StopConnection(bool server)
        {
            //Server
            if (server)
            {
                if (!UseGlobalServerActionsWithError("StopConnection"))
                    return false;

                bool success = true;
                for (int i = 0; i < _transports.Count; i++)
                {
                    if (!StopConnection(true, i))
                        success = false;
                }

                return success;
            }
            //Client.
            else
            {
                if (IsClientTransportSetWithError("StopConnection"))
                    return StopConnection(false, ClientTransport.Index);
                else
                    return false;
            }
        }

        /// <summary>
        /// Stops the local server or client on transport of index.
        /// </summary>
        /// <param name="server">True to stop server.</param>
        public bool StopConnection(bool server, int index)
        {
            if (server)
            {
                return StopServer(index);
            }
            else
            {
                if (IsClientTransportSetWithError("StopConnection"))
                    return StopClient();
                else
                    return false;
            }
        }

        /// <summary>
        /// Stops a remote client from the server, disconnecting the client.
        /// </summary>
        /// <param name="connectionId">ConnectionId of the client to disconnect.</param>
        /// <param name="immediately">True to abrutly stp the client socket without waiting socket thread.</param>
        public override bool StopConnection(int connectionId, bool immediately)
        {
            return StopClient(connectionId, immediately);
        }

        /// <summary>
        /// Stops the server connection on transportIndex.
        /// </summary>
        /// <param name="sendDisconnectMessage">True to send a disconnect message to connections before stopping them.</param>
        /// <param name="transportIndex">Index of transport to stop on.</param>
        public bool StopServerConnection(bool sendDisconnectMessage, int transportIndex)
        {
            if (sendDisconnectMessage)
            {
                //Get dictionary for transportIndex.
                Dictionary<int, ClientTransportData> dict = _transportIdLookup[transportIndex];
                //Create an array containing all multipass Ids for transportIndex.
                int[] multipassIds = new int[dict.Count];
                int index = 0;
                foreach (ClientTransportData item in dict.Values)
                    multipassIds[index++] = item.MultipassId;
                //Tell serve manager to write disconnect for those ids.
                base.NetworkManager.ServerManager.SendDisconnectMessages(multipassIds);
                //Iterate outgoing on transport which is being stopped.
                _transports[transportIndex].IterateOutgoing(asServer: true);
            }

            return StopConnection(true, transportIndex);
        }

        /// <summary>
        /// Stops both client and server on all transports.
        /// </summary>
        public override void Shutdown()
        {
            foreach (Transport t in _transports)
            {
                //Stops client then server connections.
                t.StopConnection(false);
                t.StopConnection(true);
            }
        }

        #region Privates.
        /// <summary>
        /// Starts server of transport on index.
        /// </summary>
        /// <returns>True if there were no blocks. A true response does not promise a socket will or has connected.</returns>
        private bool StartServer(int index)
        {
            if (!IndexInRange(index, true))
                return false;

            return _transports[index].StartConnection(true);
        }

        /// <summary>
        /// Stops server of transport on index.
        /// </summary>
        private bool StopServer(int index)
        {
            if (!IndexInRange(index, true))
                return false;

            return _transports[index].StopConnection(true);
        }

        /// <summary>
        /// Starts the client on ClientTransport.
        /// </summary>
        /// <param name="address"></param>
        /// <returns>True if there were no blocks. A true response does not promise a socket will or has connected.</returns>
        private bool StartClient()
        {
            return ClientTransport.StartConnection(false);
        }

        /// <summary>
        /// Stops the client on ClientTransport.
        /// </summary>
        private bool StopClient()
        {
            return ClientTransport.StopConnection(false);
        }

        /// <summary>
        /// Stops a remote client on the server.
        /// </summary>
        /// <param name="multipassId"></param>
        /// <param name="immediately">True to abrutly stp the client socket without waiting socket thread.</param>
        private bool StopClient(int multipassId, bool immediately)
        {
            ClientTransportData ctd = GetDataFromMultipassId(multipassId);
            if (ctd.Equals(INVALID_CLIENTTRANSPORTDATA))
                return false;

            return _transports[ctd.TransportIndex].StopConnection(ctd.TransportId, immediately);
        }
        #endregion
        #endregion

        #region Channels.
        /// <summary>
        /// Gets the MTU for a channel on the first transport. This should take header size into consideration.
        /// For example, if MTU is 1200 and a packet header for this channel is 10 in size, this method should return 1190.
        /// </summary>
        /// <param name="channel"></param>
        /// <returns></returns>
        public override int GetMTU(byte channel)
        {
            return GetMTU(channel, 0);
        }

        /// <summary>
        /// Gets the MTU for a channel of transport on index. This should take header size into consideration.
        /// For example, if MTU is 1200 and a packet header for this channel is 10 in size, this method should return 1190.
        /// </summary>
        /// <param name="channel"></param>
        /// <returns></returns>
        public int GetMTU(byte channel, int index)
        {
            if (!IndexInRange(index, true))
                return -1;

            return _transports[index].GetMTU(channel);
        }
        #endregion

        #region Misc.
        /// <summary>
        /// Returns if an index is within range of the Transports collection.
        /// </summary>
        private bool IndexInRange(int index, bool error)
        {
            if (index >= _transports.Count || index < 0)
            {
                if (error)
                    base.NetworkManager.LogError($"Index of {index} is out of Transports range.");
                return false;
            }
            else
            {
                return true;
            }
        }

        //perf change events to direct calls in transports.
        public override void HandleServerConnectionState(ServerConnectionStateArgs connectionStateArgs) { }
        public override void HandleRemoteConnectionState(RemoteConnectionStateArgs connectionStateArgs) { }
        public override void HandleClientReceivedDataArgs(ClientReceivedDataArgs receivedDataArgs) { }
        public override void HandleServerReceivedDataArgs(ServerReceivedDataArgs receivedDataArgs) { }
        public override void HandleClientConnectionState(ClientConnectionStateArgs connectionStateArgs) { }
        #endregion
    }
}using FishNet.Managing;
using FishNet.Managing.Transporting;
using LiteNetLib.Layers;
using System;
using System.Runtime.CompilerServices;
using LiteNetLib;
using UnityEngine;

namespace FishNet.Transporting.Tugboat
{
    [DisallowMultipleComponent]
    [AddComponentMenu("FishNet/Transport/Tugboat")]
    public class Tugboat : Transport
    {
        ~Tugboat()
        {
            Shutdown();
        }

        #region Serialized.
        /* Settings / Misc. */
        /// <summary>
        /// True to stop local server and client sockets using a new thread.
        /// </summary>
        internal bool StopSocketsOnThread => _stopSocketsOnThread;
        [Tooltip("True to stop local server and client sockets using a new thread.")]
        [SerializeField]
        private bool _stopSocketsOnThread = false;
        /// <summary>
        /// While true, forces sockets to send data directly to interface without routing.
        /// </summary>
        internal bool DontRoute => _dontRoute;
        [Tooltip("While true, forces sockets to send data directly to interface without routing.")]
        [SerializeField]
        private bool _dontRoute;
        /// <summary>
        /// Allows the same address and port to be used multiple times by the server. This can be useful if you wish to launch multiple builds or server instances on the same machine using the same configuration.
        /// </summary>
        internal bool ReuseAddress => _reuseAddress;
        [Tooltip("Allows the same address and port to be used multiple times by the server. This can be useful if you wish to launch multiple builds or server instances on the same machine using the same configuration.")]
        [SerializeField]
        private bool _reuseAddress;
        /* Channels. */
        /// <summary>
        /// Maximum transmission unit for the unreliable channel.
        /// </summary>
        [Tooltip("Maximum transmission unit for the unreliable channel.")]
        [Range(MINIMUM_UDP_MTU, MAXIMUM_UDP_MTU)]
        [SerializeField]
        private int _unreliableMtu = 1023;

        /* Server. */
        /// <summary>
        /// IPv4 address to bind server to.
        /// </summary>
        [Tooltip("IPv4 Address to bind server to.")]
        [SerializeField]
        private string _ipv4BindAddress;
        /// <summary>
        /// Enable IPv6 only on demand to avoid problems in Linux environments where it may have been disabled on host
        /// </summary>
        [Tooltip("Enable IPv6, Server listens on IPv4 and IPv6 address")]
        [SerializeField]
        private bool _enableIpv6 = true;
        /// <summary>
        /// IPv6 address to bind server to.
        /// </summary>
        [Tooltip("IPv6 Address to bind server to.")]
        [SerializeField]
        private string _ipv6BindAddress;
        /// <summary>
        /// Port to use.
        /// </summary>
        [Tooltip("Port to use.")]
        [SerializeField]
        private ushort _port = 7770;
        /// <summary>
        /// Maximum number of players which may be connected at once.
        /// </summary>
        [Tooltip("Maximum number of players which may be connected at once.")]
        [Range(1, 9999)]
        [SerializeField]
        private int _maximumClients = 4095;

        /* Client. */
        /// <summary>
        /// Address to connect.
        /// </summary>
        [Tooltip("Address to connect.")]
        [SerializeField]
        private string _clientAddress = "localhost";
        #endregion

        #region Private.
        /// <summary>
        /// PacketLayer to use with LiteNetLib.
        /// </summary>
        private PacketLayerBase _packetLayer;
        /// <summary>
        /// Server socket and handler. This field is exposed for advanced-use. Use caution when accessing this outside of this class.
        /// </summary>
        public Server.ServerSocket ServerSocket = new();
        /// <summary>
        /// Client socket and handler. This field is exposed for advanced-use. Use caution when accessing this outside of this class.
        /// </summary>
        public Client.ClientSocket ClientSocket = new();
        /// <summary>
        /// Current timeout for the client.
        /// </summary>
        private int _clientTimeout = MAX_TIMEOUT_SECONDS;
        /// <summary>
        /// Current timeout for the server.
        /// </summary>
        private int _serverTimeout = MAX_TIMEOUT_SECONDS;
        #endregion

        #region Const.
        /// <summary>
        /// Maximum timeout value to use.
        /// </summary>
        private const ushort MAX_TIMEOUT_SECONDS = 1800;
        /// <summary>
        /// Minimum UDP packet size allowed.
        /// </summary>
        private const int MINIMUM_UDP_MTU = 576;
        /// <summary>
        /// Maximum UDP packet size allowed.
        /// </summary>
        private const int MAXIMUM_UDP_MTU = 1023;
        #endregion

        #region Initialization and unity.
        public override void Initialize(NetworkManager networkManager, int transportIndex)
        {
            base.Initialize(networkManager, transportIndex);
            networkManager.TimeManager.OnUpdate += TimeManager_OnUpdate;
        }

        protected void OnDestroy()
        {
            Shutdown();
            if (base.NetworkManager != null)
                base.NetworkManager.TimeManager.OnUpdate -= TimeManager_OnUpdate;
        }
        #endregion

        #region ConnectionStates.
        /// <summary>
        /// Gets the address of a remote connection Id.
        /// </summary>
        /// <param name="connectionId"></param>
        /// <returns></returns>
        public override string GetConnectionAddress(int connectionId)
        {
            return ServerSocket.GetConnectionAddress(connectionId);
        }

        /// <summary>
        /// Called when a connection state changes for the local client.
        /// </summary>
        public override event Action<ClientConnectionStateArgs> OnClientConnectionState;
        /// <summary>
        /// Called when a connection state changes for the local server.
        /// </summary>
        public override event Action<ServerConnectionStateArgs> OnServerConnectionState;
        /// <summary>
        /// Called when a connection state changes for a remote client.
        /// </summary>
        public override event Action<RemoteConnectionStateArgs> OnRemoteConnectionState;

        /// <summary>
        /// Gets the current local ConnectionState.
        /// </summary>
        /// <param name="server">True if getting ConnectionState for the server.</param>
        public override LocalConnectionState GetConnectionState(bool server)
        {
            if (server)
                return ServerSocket.GetConnectionState();
            else
                return ClientSocket.GetConnectionState();
        }

        /// <summary>
        /// Gets the current ConnectionState of a remote client on the server.
        /// </summary>
        /// <param name="connectionId">ConnectionId to get ConnectionState for.</param>
        public override RemoteConnectionState GetConnectionState(int connectionId)
        {
            return ServerSocket.GetConnectionState(connectionId);
        }

        /// <summary>
        /// Handles a ConnectionStateArgs for the local client.
        /// </summary>
        /// <param name="connectionStateArgs"></param>
        public override void HandleClientConnectionState(ClientConnectionStateArgs connectionStateArgs)
        {
            OnClientConnectionState?.Invoke(connectionStateArgs);
        }

        /// <summary>
        /// Handles a ConnectionStateArgs for the local server.
        /// </summary>
        /// <param name="connectionStateArgs"></param>
        public override void HandleServerConnectionState(ServerConnectionStateArgs connectionStateArgs)
        {
            OnServerConnectionState?.Invoke(connectionStateArgs);
        }

        /// <summary>
        /// Handles a ConnectionStateArgs for a remote client.
        /// </summary>
        /// <param name="connectionStateArgs"></param>
        public override void HandleRemoteConnectionState(RemoteConnectionStateArgs connectionStateArgs)
        {
            OnRemoteConnectionState?.Invoke(connectionStateArgs);
        }
        #endregion

        #region Iterating.
        /// <summary>
        /// Called every update to poll for data.
        /// </summary>
        private void TimeManager_OnUpdate()
        {
            ServerSocket?.PollSocket();
            ClientSocket?.PollSocket();
        }

        /// <summary>
        /// Processes data received by the socket.
        /// </summary>
        /// <param name="asServer">True to read data from clients, false to read data from the server.
        public override void IterateIncoming(bool asServer)
        {
            if (asServer)
                ServerSocket.IterateIncoming();
            else
                ClientSocket.IterateIncoming();
        }

        /// <summary>
        /// Processes data to be sent by the socket.
        /// </summary>
        /// <param name="asServer">True to send data from the local server to clients, false to send from the local client to server.
        public override void IterateOutgoing(bool asServer)
        {
            if (asServer)
                ServerSocket.IterateOutgoing();
            else
                ClientSocket.IterateOutgoing();
        }
        #endregion

        #region Sending.
        /// <summary>
        /// Sends to the server or all clients.
        /// </summary>
        /// <param name="channelId">Channel to use.</param>
        /// <param name="segment">Data to send.</param>
        public override void SendToServer(byte channelId, ArraySegment<byte> segment)
        {
            SanitizeChannel(ref channelId);
            ClientSocket.SendToServer(channelId, segment);
        }

        /// <summary>
        /// Sends data to a client.
        /// </summary>
        /// <param name="channelId"></param>
        /// <param name="segment"></param>
        /// <param name="connectionId"></param>
        public override void SendToClient(byte channelId, ArraySegment<byte> segment, int connectionId)
        {
            SanitizeChannel(ref channelId);
            ServerSocket.SendToClient(channelId, segment, connectionId);
        }
        #endregion

        #region Receiving.
        /// <summary>
        /// Called when client receives data.
        /// </summary>
        public override event Action<ClientReceivedDataArgs> OnClientReceivedData;

        /// <summary>
        /// Handles a ClientReceivedDataArgs.
        /// </summary>
        /// <param name="receivedDataArgs"></param>
        public override void HandleClientReceivedDataArgs(ClientReceivedDataArgs receivedDataArgs)
        {
            OnClientReceivedData?.Invoke(receivedDataArgs);
        }

        /// <summary>
        /// Called when server receives data.
        /// </summary>
        public override event Action<ServerReceivedDataArgs> OnServerReceivedData;

        /// <summary>
        /// Handles a ClientReceivedDataArgs.
        /// </summary>
        /// <param name="receivedDataArgs"></param>
        public override void HandleServerReceivedDataArgs(ServerReceivedDataArgs receivedDataArgs)
        {
            OnServerReceivedData?.Invoke(receivedDataArgs);
        }

        /// <summary>
        /// Returns packet loss percentage. This transport supports this feature.
        /// </summary>
        /// <param name="asServer">True to return packet loss on the server, false to return packet loss on the client.</param>
        public override float GetPacketLoss(bool asServer)
        {
            NetManager nm;
            if (asServer && ServerSocket != null)
                nm = ServerSocket.NetManager;
            else if (!asServer && ClientSocket != null)
                nm = ClientSocket.NetManager;
            else
                nm = null;

            if (nm == null)
                return 0f;

            return nm.Statistics.PacketLossPercent;
        }
        #endregion

        #region Configuration.
        /// <summary>
        /// Sets which PacketLayer to use with LiteNetLib.
        /// </summary>
        /// <param name="packetLayer"></param>
        public void SetPacketLayer(PacketLayerBase packetLayer)
        {
            _packetLayer = packetLayer;
            if (GetConnectionState(true) != LocalConnectionState.Stopped)
                base.NetworkManager.LogWarning("PacketLayer is set but will not be applied until the server stops.");
            if (GetConnectionState(false) != LocalConnectionState.Stopped)
                base.NetworkManager.LogWarning("PacketLayer is set but will not be applied until the client stops.");

            InitializeSocket(asServer: true);
            InitializeSocket(asServer: false);
        }

        /// <summary>
        /// How long in seconds until either the server or client socket must go without data before being timed out.
        /// </summary>
        /// <param name="asServer">True to get the timeout for the server socket, false for the client socket.</param>
        /// <returns></returns>
        public override float GetTimeout(bool asServer)
        {
            //Server and client uses the same timeout.
            return (float)MAX_TIMEOUT_SECONDS;
        }

        /// <summary>
        /// Sets how long in seconds until either the server or client socket must go without data before being timed out.
        /// </summary>
        /// <param name="asServer">True to set the timeout for the server socket, false for the client socket.</param>
        public override void SetTimeout(float value, bool asServer)
        {
            int timeoutValue = (int)Math.Ceiling(value);
            if (asServer)
                _serverTimeout = timeoutValue;
            else
                _clientTimeout = timeoutValue;

            UpdateTimeout();
        }

        /// <summary>
        /// Returns the maximum number of clients allowed to connect to the server. If the transport does not support this method the value -1 is returned.
        /// </summary>
        /// <returns></returns>
        public override int GetMaximumClients()
        {
            return ServerSocket.GetMaximumClients();
        }

        /// <summary>
        /// Sets maximum number of clients allowed to connect to the server. If applied at runtime and clients exceed this value existing clients will stay connected but new clients may not connect.
        /// </summary>
        /// <param name="value"></param>
        public override void SetMaximumClients(int value)
        {
            _maximumClients = value;
            ServerSocket.SetMaximumClients(value);
        }

        /// <summary>
        /// Sets which address the client will connect to.
        /// </summary>
        /// <param name="address"></param>
        public override void SetClientAddress(string address)
        {
            _clientAddress = address;
        }

        /// <summary>
        /// Gets which address the client will connect to.
        /// </summary>
        public override string GetClientAddress()
        {
            return _clientAddress;
        }

        /// <summary>
        /// Sets which address the server will bind to.
        /// </summary>
        /// <param name="address"></param>
        public override void SetServerBindAddress(string address, IPAddressType addressType)
        {
            if (addressType == IPAddressType.IPv4)
                _ipv4BindAddress = address;
            else
                _ipv6BindAddress = address;
        }

        /// <summary>
        /// Gets which address the server will bind to.
        /// </summary>
        /// <param name="address"></param>
        public override string GetServerBindAddress(IPAddressType addressType)
        {
            if (addressType == IPAddressType.IPv4)
                return _ipv4BindAddress;
            else
                return _ipv6BindAddress;
        }

        /// <summary>
        /// Sets which port to use.
        /// </summary>
        /// <param name="port"></param>
        public override void SetPort(ushort port)
        {
            _port = port;
        }

        /// <summary>
        /// Gets which port to use.
        /// </summary>
        /// <param name="port"></param>
        public override ushort GetPort()
        {
            //Server.
            ushort? result = ServerSocket?.GetPort();
            if (result.HasValue)
                return result.Value;
            //Client.
            result = ClientSocket?.GetPort();
            if (result.HasValue)
                return result.Value;

            return _port;
        }
        #endregion

        #region Start and stop.
        /// <summary>
        /// Starts the local server or client using configured settings.
        /// </summary>
        /// <param name="server">True to start server.</param>
        public override bool StartConnection(bool server)
        {
            if (server)
                return StartServer();
            else
                return StartClient(_clientAddress);
        }

        /// <summary>
        /// Stops the local server or client.
        /// </summary>
        /// <param name="server">True to stop server.</param>
        public override bool StopConnection(bool server)
        {
            if (server)
                return StopServer();
            else
                return StopClient();
        }

        /// <summary>
        /// Stops a remote client from the server, disconnecting the client.
        /// </summary>
        /// <param name="connectionId">ConnectionId of the client to disconnect.</param>
        /// <param name="immediately">True to abrutly stop the client socket. The technique used to accomplish immediate disconnects may vary depending on the transport.
        /// When not using immediate disconnects it's recommended to perform disconnects using the ServerManager rather than accessing the transport directly.
        /// </param>
        public override bool StopConnection(int connectionId, bool immediately)
        {
            return ServerSocket.StopConnection(connectionId);
        }

        /// <summary>
        /// Stops both client and server.
        /// </summary>
        public override void Shutdown()
        {
            //Stops client then server connections.
            StopConnection(false);
            StopConnection(true);
        }

        #region Privates.
        /// <summary>
        /// Initializes client or server socket.
        /// </summary>
        private void InitializeSocket(bool asServer)
        {
            if (asServer)
                ServerSocket.Initialize(this, _unreliableMtu, _packetLayer, _enableIpv6);
            else
                ClientSocket.Initialize(this, _unreliableMtu, _packetLayer);
        }

        /// <summary>
        /// Starts server.
        /// </summary>
        private bool StartServer()
        {
            InitializeSocket(asServer: true);
            UpdateTimeout();
            return ServerSocket.StartConnection(_port, _maximumClients, _ipv4BindAddress, _ipv6BindAddress);
        }

        /// <summary>
        /// Stops server.
        /// </summary>
        private bool StopServer()
        {
            if (ServerSocket == null)
                return false;
            else
                return ServerSocket.StopConnection();
        }

        /// <summary>
        /// Starts the client.
        /// </summary>
        /// <param name="address"></param>
        private bool StartClient(string address)
        {
            InitializeSocket(asServer: false);
            UpdateTimeout();
            return ClientSocket.StartConnection(address, _port);
        }

        /// <summary>
        /// Updates clients timeout values.
        /// </summary>
        private void UpdateTimeout()
        {
            ClientSocket.UpdateTimeout(_clientTimeout);
            ServerSocket.UpdateTimeout(_serverTimeout);
        }

        /// <summary>
        /// Stops the client.
        /// </summary>
        private bool StopClient()
        {
            if (ClientSocket == null)
                return false;
            else
                return ClientSocket.StopConnection();
        }
        #endregion
        #endregion

        #region Channels.
        /// <summary>
        /// If channelId is invalid then channelId becomes forced to reliable.
        /// </summary>
        /// <param name="channelId"></param>
        private void SanitizeChannel(ref byte channelId)
        {
            if (channelId < 0 || channelId >= TransportManager.CHANNEL_COUNT)
            {
                NetworkManager.LogWarning($"Channel of {channelId} is out of range of supported channels. Channel will be defaulted to reliable.");
                channelId = 0;
            }
        }

        /// <summary>
        /// Gets the MTU for a channel. This should take header size into consideration.
        /// For example, if MTU is 1200 and a packet header for this channel is 10 in size, this method should return 1190.
        /// </summary>
        /// <param name="channel"></param>
        /// <returns></returns>
        public override int GetMTU(byte channel)
        {
            return _unreliableMtu;
        }
        #endregion

        #region Editor.
#if UNITY_EDITOR
        private void OnValidate()
        {
            if (_unreliableMtu < 0)
                _unreliableMtu = MINIMUM_UDP_MTU;
            else if (_unreliableMtu > MAXIMUM_UDP_MTU)
                _unreliableMtu = MAXIMUM_UDP_MTU;
        }
#endif
        #endregion
    }
}using FishNet.Managing;
using FishNet.Managing.Logging;
using LiteNetLib;
using LiteNetLib.Layers;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using UnityEngine;

namespace FishNet.Transporting.Tugboat.Client
{
    public class ClientSocket : CommonSocket
    {
        ~ClientSocket()
        {
            StopConnection();
        }

        #region Private.
        #region Configuration.
        /// <summary>
        /// Address to bind server to.
        /// </summary>
        private string _address = string.Empty;
        /// <summary>
        /// Port used by server.
        /// </summary>
        private ushort _port;
        /// <summary>
        /// MTU sizes for each channel.
        /// </summary>
        private int _mtu;
        #endregion
        #region Queues.
        /// <summary>
        /// Inbound messages which need to be handled.
        /// </summary>
        private ConcurrentQueue<Packet> _incoming = new();
        /// <summary>
        /// Outbound messages which need to be handled.
        /// </summary>
        private Queue<Packet> _outgoing = new();
        #endregion
        /// <summary>
        /// How long in seconds until client times from server.
        /// </summary>
        private int _timeout;
        /// <summary>
        /// PacketLayer to use with LiteNetLib.
        /// </summary>
        private PacketLayerBase _packetLayer;
        #endregion

        /// <summary>
        /// Initializes this for use.
        /// </summary>
        internal void Initialize(Transport t, int unreliableMTU, PacketLayerBase packetLayer)
        {
            base.Transport = t;
            _mtu = unreliableMTU;
            _packetLayer = packetLayer;
        }

        /// <summary>
        /// Updates the Timeout value as seconds.
        /// </summary>
        internal void UpdateTimeout(int timeout)
        {
            _timeout = timeout;
            base.UpdateTimeout(base.NetManager, timeout);
        }

        /// <summary>
        /// Polls the socket for new data.
        /// </summary>
        
        internal void PollSocket()
        {
            base.PollSocket(base.NetManager);
        }

        /// <summary>
        /// Threaded operation to process client actions.
        /// </summary>
        private void ThreadedSocket()
        {
            EventBasedNetListener listener = new();
            listener.NetworkReceiveEvent += Listener_NetworkReceiveEvent;
            listener.PeerConnectedEvent += Listener_PeerConnectedEvent;
            listener.PeerDisconnectedEvent += Listener_PeerDisconnectedEvent;

            base.NetManager = new(listener, _packetLayer, false);
            base.NetManager.DontRoute = ((Tugboat)base.Transport).DontRoute;
            base.NetManager.MtuOverride = (_mtu + NetConstants.FragmentedHeaderTotalSize);

            UpdateTimeout(_timeout);

            base.LocalConnectionStates.Enqueue(LocalConnectionState.Starting);
            base.NetManager.Start();
            base.NetManager.Connect(_address, _port, string.Empty);
        }
        
        /// <summary>
        /// Starts the client connection.
        /// </summary>
        internal bool StartConnection(string address, ushort port)
        {
            //Force a stop just in case the socket did not clean up.
            if (base.GetConnectionState() != LocalConnectionState.Stopped)
                base.StopSocket();
            //Enqueue starting.
            base.LocalConnectionStates.Enqueue(LocalConnectionState.Starting);
            //Iterate to cause state changes to invoke.
            IterateIncoming();
            
            //Assign properties.
            _port = port;
            _address = address;

            ResetQueues();
            Task.Run(ThreadedSocket);

            return true;
        }


        /// <summary>
        /// Stops the local socket.
        /// </summary>
        internal bool StopConnection(DisconnectInfo? info = null)
        {
            if (base.GetConnectionState() == LocalConnectionState.Stopped || base.GetConnectionState() == LocalConnectionState.Stopping)
                return false;

            if (info != null)
                base.Transport.NetworkManager.Log($"Local client disconnect reason: {info.Value.Reason}.");

            base.SetConnectionState(LocalConnectionState.Stopping, false);
            base.StopSocket();
            return true;
        }

        /// <summary>
        /// Resets queues.
        /// </summary>
        
        private void ResetQueues()
        {
            base.ClearGenericQueue(ref base.LocalConnectionStates);
            base.ClearPacketQueue(ref _incoming);
            base.ClearPacketQueue(ref _outgoing);
        }


        /// <summary>
        /// Called when disconnected from the server.
        /// </summary>
        private void Listener_PeerDisconnectedEvent(NetPeer peer, DisconnectInfo disconnectInfo)
        {
            StopConnection(disconnectInfo);
        }

        /// <summary>
        /// Called when connected to the server.
        /// </summary>
        private void Listener_PeerConnectedEvent(NetPeer peer)
        {
            base.LocalConnectionStates.Enqueue(LocalConnectionState.Started);
        }

        /// <summary>
        /// Called when data is received from a peer.
        /// </summary>
        private void Listener_NetworkReceiveEvent(NetPeer fromPeer, NetPacketReader reader, byte channel, DeliveryMethod deliveryMethod)
        {
            base.Listener_NetworkReceiveEvent(_incoming, fromPeer, reader, deliveryMethod, _mtu);
        }

        /// <summary>
        /// Dequeues and processes outgoing.
        /// </summary>
        private void DequeueOutgoing()
        {
            NetPeer peer = null;
            if (base.NetManager != null)
                peer = base.NetManager.FirstPeer;
            //Server connection hasn't been made.
            if (peer == null)
            {
                /* Only dequeue outgoing because other queues might have
                * relevant information, such as the local connection queue. */
                base.ClearPacketQueue(ref _outgoing);
            }
            else
            {
                int count = _outgoing.Count;
                for (int i = 0; i < count; i++)
                {
                    Packet outgoing = _outgoing.Dequeue();

                    ArraySegment<byte> segment = outgoing.GetArraySegment();
                    DeliveryMethod dm = (outgoing.Channel == (byte)Channel.Reliable) ?
                         DeliveryMethod.ReliableOrdered : DeliveryMethod.Unreliable;

                    //If over the MTU.
                    if (outgoing.Channel == (byte)Channel.Unreliable && segment.Count > _mtu)
                    {
                        base.Transport.NetworkManager.LogWarning($"Client is sending of {segment.Count} length on the unreliable channel, while the MTU is only {_mtu}. The channel has been changed to reliable for this send.");
                        dm = DeliveryMethod.ReliableOrdered;
                    }

                    peer.Send(segment.Array, segment.Offset, segment.Count, dm);

                    outgoing.Dispose();
                }
            }
        }

        /// <summary>
        /// Allows for Outgoing queue to be iterated.
        /// </summary>
        internal void IterateOutgoing()
        {
            DequeueOutgoing();
        }

        /// <summary>
        /// Iterates the Incoming queue.
        /// </summary>
        internal void IterateIncoming()
        {
            /* Run local connection states first so we can begin
            * to read for data at the start of the frame, as that's
            * where incoming is read. */
            while (base.LocalConnectionStates.TryDequeue(out LocalConnectionState result))
                base.SetConnectionState(result, false);

            //Not yet started, cannot continue.
            LocalConnectionState localState = base.GetConnectionState();
            if (localState != LocalConnectionState.Started)
            {
                ResetQueues();
                //If stopped try to kill task.
                if (localState == LocalConnectionState.Stopped)
                {
                    base.StopSocket();
                    return;
                }
            }

            /* Incoming. */
            while (_incoming.TryDequeue(out Packet incoming))
            {
                ClientReceivedDataArgs dataArgs = new(
                    incoming.GetArraySegment(),
                    (Channel)incoming.Channel, base.Transport.Index);
                base.Transport.HandleClientReceivedDataArgs(dataArgs);
                //Dispose of packet.
                incoming.Dispose();
            }
        }

        /// <summary>
        /// Sends a packet to the server.
        /// </summary>
        internal void SendToServer(byte channelId, ArraySegment<byte> segment)
        {
            //Not started, cannot send.
            if (base.GetConnectionState() != LocalConnectionState.Started)
                return;

            base.Send(ref _outgoing, channelId, segment, -1, _mtu);
        }


    }
}
﻿using FishNet.Utility.Performance;
using LiteNetLib;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace FishNet.Transporting.Tugboat
{

    public abstract class CommonSocket
    {

        #region Internal.
        /// <summary>
        /// Current ConnectionState.
        /// </summary>
        private LocalConnectionState _connectionState = LocalConnectionState.Stopped;
        /// <summary>
        /// Returns the current ConnectionState.
        /// </summary>
        /// <returns></returns>
        internal LocalConnectionState GetConnectionState()
        {
            return _connectionState;
        }
        /// <summary>
        /// Sets a new connection state.
        /// </summary>
        /// <param name="connectionState"></param>
        protected void SetConnectionState(LocalConnectionState connectionState, bool asServer)
        {
            //If state hasn't changed.
            if (connectionState == _connectionState)
                return;

            _connectionState = connectionState;
            if (asServer)
                Transport.HandleServerConnectionState(new(connectionState, Transport.Index));
            else
                Transport.HandleClientConnectionState(new(connectionState, Transport.Index));
        }
        #endregion
        
        #region Internal.
        /// <summary>
        /// NetManager for this socket.
        /// </summary>
        internal NetManager NetManager;
        #endregion

        #region Protected.
        /// <summary>
        /// Changes to the sockets local connection state.
        /// </summary>
        protected ConcurrentQueue<LocalConnectionState> LocalConnectionStates = new();
        /// <summary>
        /// Transport controlling this socket.
        /// </summary>
        protected Transport Transport;
        #endregion
        
        #region Private.
        /// <summary>
        /// Locks the NetManager to stop it.
        /// </summary>
        private readonly object _stopLock = new();
        #endregion

        /// <summary>
        /// Sends data to connectionId.
        /// </summary>
        internal void Send(ref Queue<Packet> queue, byte channelId, ArraySegment<byte> segment, int connectionId, int mtu)
        {
            if (GetConnectionState() != LocalConnectionState.Started)
                return;

            //ConnectionId isn't used from client to server.
            Packet outgoing = new(connectionId, segment, channelId, mtu);
            queue.Enqueue(outgoing);
        }

        /// <summary>
        /// Updates the timeout for NetManager.
        /// </summary>
        protected void UpdateTimeout(NetManager netManager, int timeout)
        {
            if (netManager == null)
                return;

            timeout = (timeout == 0) ? int.MaxValue : Math.Min(int.MaxValue, (timeout * 1000));
            netManager.DisconnectTimeout = timeout;
        }

        /// <summary>
        /// Clears a ConcurrentQueue of any type.
        /// </summary>
        internal void ClearGenericQueue<T>(ref ConcurrentQueue<T> queue)
        {
            while (queue.TryDequeue(out _)) { }
        }

        /// <summary>
        /// Clears a queue using Packet type.
        /// </summary>
        /// <param name="queue"></param>
        internal void ClearPacketQueue(ref ConcurrentQueue<Packet> queue)
        {
            while (queue.TryDequeue(out Packet p))
                p.Dispose();
        }

        /// <summary>
        /// Clears a queue using Packet type.
        /// </summary>
        /// <param name="queue"></param>
        internal void ClearPacketQueue(ref Queue<Packet> queue)
        {
            int count = queue.Count;
            for (int i = 0; i < count; i++)
            {
                Packet p = queue.Dequeue();
                p.Dispose();
            }
        }

        /// <summary>
        /// Called when data is received.
        /// </summary>
        internal virtual void Listener_NetworkReceiveEvent(ConcurrentQueue<Packet> queue, NetPeer fromPeer, NetPacketReader reader, DeliveryMethod deliveryMethod, int mtu)
        {
            //Set buffer.
            int dataLen = reader.AvailableBytes;
            //Prefer to max out returned array to mtu to reduce chance of resizing.
            int arraySize = Math.Max(dataLen, mtu);
            byte[] data = ByteArrayPool.Retrieve(arraySize);
            reader.GetBytes(data, dataLen);
            //Id.
            int id = fromPeer.Id;
            //Channel.
            byte channel = (deliveryMethod == DeliveryMethod.Unreliable) ?
                (byte)Channel.Unreliable : (byte)Channel.Reliable;
            //Add to packets.
            Packet packet = new(id, data, dataLen, channel);
            queue.Enqueue(packet);
            //Recycle reader.
            reader.Recycle();
        }

        internal void PollSocket(NetManager nm)
        {
            nm?.PollEvents();
        }

        /// <summary>
        /// Stops the socket and updates local connection state.
        /// </summary>
        protected void StopSocket()
        {
            if (NetManager == null)
                return;

            bool threaded;
            if (Transport is Tugboat tb)
                threaded = tb.StopSocketsOnThread;
            else
                threaded = false;

            //If using a thread.
            if (threaded)
            {
                Task.Run(() =>
                {
                    lock (_stopLock)
                    {
                        NetManager?.Stop();
                        NetManager = null;
                    }

                    //If not stopped yet also enqueue stop.
                    if (GetConnectionState() != LocalConnectionState.Stopped)
                        LocalConnectionStates.Enqueue(LocalConnectionState.Stopped);
                });
            }
            //Not using a thread.
            else
            {
                NetManager?.Stop();
                NetManager = null;
                //If not stopped yet also enqueue stop.
                if (GetConnectionState() != LocalConnectionState.Stopped)
                    LocalConnectionStates.Enqueue(LocalConnectionState.Stopped);
            }
        }

        /// <summary>
        /// Returns the port from the socket if active, otherwise returns null.
        /// </summary>
        /// <returns></returns>
        internal ushort? GetPort()
        {
            if (NetManager == null || !NetManager.IsRunning)
                return null;

            int port = NetManager.LocalPort;
            if (port < 0)
                port = 0;
            else if (port > ushort.MaxValue)
                port = ushort.MaxValue;

            return (ushort)port;
        }

    }

}using FishNet.Connection;
using FishNet.Managing;
using FishNet.Managing.Logging;
using LiteNetLib;
using LiteNetLib.Layers;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Net;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using UnityEngine;

namespace FishNet.Transporting.Tugboat.Server
{
    public class ServerSocket : CommonSocket
    {
        #region Public.
        /// <summary>
        /// Gets the current ConnectionState of a remote client on the server.
        /// </summary>
        /// <param name="connectionId">ConnectionId to get ConnectionState for.</param>
        internal RemoteConnectionState GetConnectionState(int connectionId)
        {
            NetPeer peer = GetNetPeer(connectionId, false);
            if (peer == null || peer.ConnectionState != ConnectionState.Connected)
                return RemoteConnectionState.Stopped;
            else
                return RemoteConnectionState.Started;
        }
        #endregion

        #region Private.
        #region Configuration.
        /// <summary>
        /// Port used by server.
        /// </summary>
        private ushort _port;
        /// <summary>
        /// Maximum number of allowed clients.
        /// </summary>
        private int _maximumClients;
        /// <summary>
        /// MTU size per packet.
        /// </summary>
        private int _mtu;
        #endregion

        #region Queues.
        /// <summary>
        /// Inbound messages which need to be handled.
        /// </summary>
        private ConcurrentQueue<Packet> _incoming = new();
        /// <summary>
        /// Outbound messages which need to be handled.
        /// </summary>
        private Queue<Packet> _outgoing = new();
        /// <summary>
        /// ConnectionEvents which need to be handled.
        /// </summary>
        private ConcurrentQueue<RemoteConnectionEvent> _remoteConnectionEvents = new();
        #endregion

        /// <summary>
        /// How long in seconds until client times from server.
        /// </summary>
        private int _timeout;
        /// <summary>
        /// IPv4 address to bind server to.
        /// </summary>
        private string _ipv4BindAddress;
        /// <summary>
        /// IPv6 address to bind server to.
        /// </summary>
        private string _ipv6BindAddress;
        /// <summary>
        /// PacketLayer to use with LiteNetLib.
        /// </summary>
        private PacketLayerBase _packetLayer;
        /// <summary>
        /// IPv6 is enabled only on demand, by default LiteNetLib always listens on IPv4 AND IPv6 which causes problems
        /// if IPv6 is disabled on host. This can be the case in Linux environments
        /// </summary>
        private bool _enableIPv6;
        #endregion

        ~ServerSocket()
        {
            StopConnection();
        }

        /// <summary>
        /// Initializes this for use.
        /// </summary>
        /// <param name="t"></param>
        internal void Initialize(Transport t, int unreliableMTU, PacketLayerBase packetLayer, bool enableIPv6)
        {
            base.Transport = t;
            _mtu = unreliableMTU;
            _packetLayer = packetLayer;
            _enableIPv6 = enableIPv6;
        }

        /// <summary>
        /// Updates the Timeout value as seconds.
        /// </summary>
        internal void UpdateTimeout(int timeout)
        {
            _timeout = timeout;
            base.UpdateTimeout(base.NetManager, timeout);
        }

        /// <summary>
        /// Polls the socket for new data.
        /// </summary>
        internal void PollSocket()
        {
            base.PollSocket(base.NetManager);
        }

        /// <summary>
        /// Threaded operation to process server actions.
        /// </summary>
        private void ThreadedSocket()
        {
            EventBasedNetListener listener = new();
            listener.ConnectionRequestEvent += Listener_ConnectionRequestEvent;
            listener.PeerConnectedEvent += Listener_PeerConnectedEvent;
            listener.NetworkReceiveEvent += Listener_NetworkReceiveEvent;
            listener.PeerDisconnectedEvent += Listener_PeerDisconnectedEvent;

            base.NetManager = new(listener, _packetLayer, false);
            base.NetManager.DontRoute = ((Tugboat)base.Transport).DontRoute;
            base.NetManager.ReuseAddress = ((Tugboat)base.Transport).ReuseAddress;
            base.NetManager.MtuOverride = (_mtu + NetConstants.FragmentedHeaderTotalSize);

            UpdateTimeout(_timeout);

            //Set bind addresses.
            IPAddress ipv4 = null;
            IPAddress ipv6 = null;

            //Set ipv4
            if (!string.IsNullOrEmpty(_ipv4BindAddress))
            {
                if (!IPAddress.TryParse(_ipv4BindAddress, out ipv4))
                    ipv4 = null;

                //If unable to parse try to get address another way.
                if (ipv4 == null)
                {
                    IPHostEntry hostEntry = Dns.GetHostEntry(_ipv4BindAddress);
                    if (hostEntry.AddressList.Length > 0)
                    {
                        ipv4 = hostEntry.AddressList[0];
                        base.Transport.NetworkManager.Log($"IPv4 could not parse correctly but was resolved to {ipv4.ToString()}");
                    }
                }
            }
            else
            {
                IPAddress.TryParse("0.0.0.0", out ipv4);
            }

            if (_enableIPv6 && !string.IsNullOrEmpty(_ipv6BindAddress))
            {
                //Set ipv6 if protocol is enabled.
                if (!IPAddress.TryParse(_ipv6BindAddress, out ipv6))
                    ipv6 = null;
            }
            else
            {
                IPAddress.TryParse("0:0:0:0:0:0:0:0", out ipv6);
            }

            string ipv4FailText = (ipv4 == null) ? $"IPv4 address {_ipv4BindAddress} failed to parse. " : string.Empty;
            string ipv6FailText = (_enableIPv6 && ipv6 == null) ? $"IPv6 address {_ipv6BindAddress} failed to parse. " : string.Empty;
            if (ipv4FailText != string.Empty || ipv6FailText != string.Empty)
            {
                base.Transport.NetworkManager.Log($"{ipv4FailText}{ipv6FailText}Clear the bind address field to use any bind address.");
                StopConnection();
                return;
            }

            base.NetManager.IPv6Enabled = _enableIPv6;
            bool startResult = base.NetManager.Start(ipv4, ipv6, _port);
            //If started succcessfully.
            if (startResult)
            {
                base.LocalConnectionStates.Enqueue(LocalConnectionState.Started);
            }
            //Failed to start.
            else
            {
                base.Transport.NetworkManager.LogError($"Server failed to start. This usually occurs when the specified port is unavailable, be it closed or already in use.");
                StopConnection();
            }
        }

        /// <summary>
        /// Gets the address of a remote connection Id.
        /// </summary>
        /// <param name="connectionId"></param>
        /// <returns>Returns string.empty if Id is not found.</returns>
        internal string GetConnectionAddress(int connectionId)
        {
            if (GetConnectionState() != LocalConnectionState.Started)
            {
                NetworkManager nm = (Transport == null) ? null : Transport.NetworkManager;
                string msg = "Server socket is not started.";
                nm.LogWarning(msg);
                return string.Empty;
            }

            NetPeer peer = GetNetPeer(connectionId, false);
            if (peer == null)
            {
                Transport.NetworkManager.LogWarning($"Connection Id {connectionId} returned a null NetPeer.");
                return string.Empty;
            }

            return peer.Address.ToString();
        }

        /// <summary>
        /// Returns a NetPeer for connectionId.
        /// </summary>
        /// <param name="connectionId"></param>
        /// <returns></returns>
        private NetPeer GetNetPeer(int connectionId, bool connectedOnly)
        {
            if (base.NetManager != null)
            {
                NetPeer peer = base.NetManager.GetPeerById(connectionId);
                if (connectedOnly && peer != null && peer.ConnectionState != ConnectionState.Connected)
                    peer = null;

                return peer;
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Starts the server.
        /// </summary>
        internal bool StartConnection(ushort port, int maximumClients, string ipv4BindAddress, string ipv6BindAddress)
        {
            //Force a stop just in case the socket did not clean up.
            if (base.GetConnectionState() != LocalConnectionState.Stopped)
                base.StopSocket();
            //Enqueue starting.
            base.LocalConnectionStates.Enqueue(LocalConnectionState.Starting);
            //Iterate to cause state changes to invoke.
            IterateIncoming();

            //Assign properties.
            _port = port;
            _maximumClients = maximumClients;
            _ipv4BindAddress = ipv4BindAddress;
            _ipv6BindAddress = ipv6BindAddress;
            ResetQueues();

            Task.Run(ThreadedSocket);

            return true;
        }

        /// <summary>
        /// Stops the local socket.
        /// </summary>
        internal bool StopConnection()
        {
            if (base.NetManager == null || base.GetConnectionState() == LocalConnectionState.Stopped || base.GetConnectionState() == LocalConnectionState.Stopping)
                return false;

            base.LocalConnectionStates.Enqueue(LocalConnectionState.Stopping);
            base.StopSocket();
            return true;
        }

        /// <summary>
        /// Stops a remote client disconnecting the client from the server.
        /// </summary>
        /// <param name="connectionId">ConnectionId of the client to disconnect.</param>
        internal bool StopConnection(int connectionId)
        {
            //Server isn't running.
            if (base.NetManager == null || base.GetConnectionState() != LocalConnectionState.Started)
                return false;

            NetPeer peer = GetNetPeer(connectionId, false);
            if (peer == null)
                return false;

            try
            {
                peer.Disconnect();
                //Let LiteNetLib get the disconnect event which will enqueue a remote connection state.
                //base.Transport.HandleRemoteConnectionState(new RemoteConnectionStateArgs(RemoteConnectionState.Stopped, connectionId, base.Transport.Index));
            }
            catch
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Resets queues.
        /// </summary>
        private void ResetQueues()
        {
            base.ClearGenericQueue(ref base.LocalConnectionStates);
            base.ClearPacketQueue(ref _incoming);
            base.ClearPacketQueue(ref _outgoing);
            base.ClearGenericQueue(ref _remoteConnectionEvents);
        }

        /// <summary>
        /// Called when a peer disconnects or times out.
        /// </summary>
        private void Listener_PeerDisconnectedEvent(NetPeer peer, DisconnectInfo disconnectInfo)
        {
            _remoteConnectionEvents.Enqueue(new(false, peer.Id));
        }

        /// <summary>
        /// Called when a peer completes connection.
        /// </summary>
        private void Listener_PeerConnectedEvent(NetPeer peer)
        {
            _remoteConnectionEvents.Enqueue(new(true, peer.Id));
        }

        /// <summary>
        /// Called when data is received from a peer.
        /// </summary>
        private void Listener_NetworkReceiveEvent(NetPeer fromPeer, NetPacketReader reader, byte channel, DeliveryMethod deliveryMethod)
        {
            //If over the MTU.
            if (reader.AvailableBytes > _mtu)
            {
                _remoteConnectionEvents.Enqueue(new(false, fromPeer.Id));
                fromPeer.Disconnect();
            }
            else
            {
                base.Listener_NetworkReceiveEvent(_incoming, fromPeer, reader, deliveryMethod, _mtu);
            }
        }

        /// <summary>
        /// Called when a remote connection request is made.
        /// </summary>
        private void Listener_ConnectionRequestEvent(ConnectionRequest request)
        {
            if (base.NetManager == null)
                return;

            //At maximum peers.
            if (base.NetManager.ConnectedPeersCount >= _maximumClients)
            {
                request.Reject();
                return;
            }

            request.AcceptIfKey(key: string.Empty);
        }

        /// <summary>
        /// Dequeues and processes outgoing.
        /// </summary>
        private void DequeueOutgoing()
        {
            if (base.GetConnectionState() != LocalConnectionState.Started || base.NetManager == null)
            {
                //Not started, clear outgoing.
                base.ClearPacketQueue(ref _outgoing);
            }
            else
            {
                int count = _outgoing.Count;
                for (int i = 0; i < count; i++)
                {
                    Packet outgoing = _outgoing.Dequeue();
                    int connectionId = outgoing.ConnectionId;

                    ArraySegment<byte> segment = outgoing.GetArraySegment();
                    DeliveryMethod dm = (outgoing.Channel == (byte)Channel.Reliable) ? DeliveryMethod.ReliableOrdered : DeliveryMethod.Unreliable;

                    //If over the MTU.
                    if (outgoing.Channel == (byte)Channel.Unreliable && segment.Count > _mtu)
                    {
                        base.Transport.NetworkManager.LogWarning($"Server is sending of {segment.Count} length on the unreliable channel, while the MTU is only {_mtu}. The channel has been changed to reliable for this send.");
                        dm = DeliveryMethod.ReliableOrdered;
                    }

                    //Send to all clients.
                    if (connectionId == NetworkConnection.UNSET_CLIENTID_VALUE)
                    {
                        base.NetManager.SendToAll(segment.Array, segment.Offset, segment.Count, dm);
                    }
                    //Send to one client.
                    else
                    {
                        NetPeer peer = GetNetPeer(connectionId, true);
                        //If peer is found.
                        if (peer != null)
                            peer.Send(segment.Array, segment.Offset, segment.Count, dm);
                    }

                    outgoing.Dispose();
                }
            }
        }

        /// <summary>
        /// Allows for Outgoing queue to be iterated.
        /// </summary>
        internal void IterateOutgoing()
        {
            DequeueOutgoing();
        }

        /// <summary>
        /// Iterates the Incoming queue.
        /// </summary>
        internal void IterateIncoming()
        {
            /* Run local connection states first so we can begin
             * to read for data at the start of the frame, as that's
             * where incoming is read. */
            while (base.LocalConnectionStates.TryDequeue(out LocalConnectionState result))
                base.SetConnectionState(result, true);

            //Not yet started.
            LocalConnectionState localState = base.GetConnectionState();
            if (localState != LocalConnectionState.Started)
            {
                ResetQueues();
                //If stopped try to kill task.
                if (localState == LocalConnectionState.Stopped)
                {
                    base.StopSocket();
                    return;
                }
            }

            //Handle connection and disconnection events.
            while (_remoteConnectionEvents.TryDequeue(out RemoteConnectionEvent connectionEvent))
            {
                RemoteConnectionState state = (connectionEvent.Connected) ? RemoteConnectionState.Started : RemoteConnectionState.Stopped;
                base.Transport.HandleRemoteConnectionState(new(state, connectionEvent.ConnectionId, base.Transport.Index));
            }

            //Handle packets.
            while (_incoming.TryDequeue(out Packet incoming))
            {
                //Make sure peer is still connected.
                NetPeer peer = GetNetPeer(incoming.ConnectionId, true);
                if (peer != null)
                {
                    ServerReceivedDataArgs dataArgs = new(incoming.GetArraySegment(), (Channel)incoming.Channel, incoming.ConnectionId, base.Transport.Index);

                    base.Transport.HandleServerReceivedDataArgs(dataArgs);
                }

                incoming.Dispose();
            }
        }

        /// <summary>
        /// Sends a packet to a single, or all clients.
        /// </summary>
        internal void SendToClient(byte channelId, ArraySegment<byte> segment, int connectionId)
        {
            Send(ref _outgoing, channelId, segment, connectionId, _mtu);
        }

        /// <summary>
        /// Returns the maximum number of clients allowed to connect to the server. If the transport does not support this method the value -1 is returned.
        /// </summary>
        /// <returns></returns>
        internal int GetMaximumClients()
        {
            return Math.Min(_maximumClients, NetworkConnection.MAXIMUM_CLIENTID_WITHOUT_SIMULATED_VALUE);
        }

        /// <summary>
        /// Sets the MaximumClients value.
        /// </summary>
        /// <param name="value"></param>
        internal void SetMaximumClients(int value)
        {
            _maximumClients = value;
        }
    }
}﻿using FishNet.Utility.Performance;
using System;

namespace FishNet.Transporting.Tugboat
{


    internal struct Packet
    {
        public readonly int ConnectionId;
        public readonly byte[] Data;
        public readonly int Length;
        public readonly byte Channel;

        public Packet(int connectionId, byte[] data, int length, byte channel)
        {
            ConnectionId = connectionId;
            Data = data;
            Length = length;
            Channel = channel;
        }

        public Packet(int sender, ArraySegment<byte> segment, byte channel, int mtu)
        {
            //Prefer to max out returned array to mtu to reduce chance of resizing.
            int arraySize = Math.Max(segment.Count, mtu);
            Data = ByteArrayPool.Retrieve(arraySize);
            Buffer.BlockCopy(segment.Array, segment.Offset, Data, 0, segment.Count);
            ConnectionId = sender;
            Length = segment.Count;
            Channel = channel;
        }

        public ArraySegment<byte> GetArraySegment()
        {
            return new(Data, 0, Length);
        }

        public void Dispose()
        {
            ByteArrayPool.Store(Data);
        }

    }


}

namespace FishNet.Transporting.Tugboat.Server
{

    internal struct RemoteConnectionEvent
    {
        public readonly bool Connected;
        public readonly int ConnectionId;
        public RemoteConnectionEvent(bool connected, int connectionId)
        {
            Connected = connected;
            ConnectionId = connectionId;
        }
    }
}

﻿#if UNITY_EDITOR
using FishNet.Object;
using UnityEditor;
using UnityEngine;

namespace FishNet.Transporting.Tugboat.Editing
{

    [CustomEditor(typeof(Tugboat), true)]
    [CanEditMultipleObjects]
    public class TugboatEditor : Editor
    {
        private SerializedProperty _stopSocketsOnThread;
        private SerializedProperty _dontRoute;
        private SerializedProperty _reuseAddress;
        private SerializedProperty _unreliableMtu;

        private SerializedProperty _ipv4BindAddress;
        private SerializedProperty _enableIpv6;
        private SerializedProperty _ipv6BindAddress;
        private SerializedProperty _port;
        private SerializedProperty _maximumClients;

        private SerializedProperty _clientAddress;


        protected virtual void OnEnable()
        {
            _stopSocketsOnThread = serializedObject.FindProperty(nameof(_stopSocketsOnThread));
            _dontRoute = serializedObject.FindProperty(nameof(_dontRoute));
            _reuseAddress = serializedObject.FindProperty(nameof(_reuseAddress));
            _unreliableMtu = serializedObject.FindProperty(nameof(_unreliableMtu));
            _ipv4BindAddress = serializedObject.FindProperty(nameof(_ipv4BindAddress));
            _enableIpv6 = serializedObject.FindProperty(nameof(_enableIpv6));
            _ipv6BindAddress = serializedObject.FindProperty(nameof(_ipv6BindAddress));
            _port = serializedObject.FindProperty(nameof(_port));
            _maximumClients = serializedObject.FindProperty(nameof(_maximumClients));
            _clientAddress = serializedObject.FindProperty(nameof(_clientAddress));            
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();
            Tugboat tb = (Tugboat)target;

            GUI.enabled = false;
            EditorGUILayout.ObjectField("Script:", MonoScript.FromMonoBehaviour(tb), typeof(Tugboat), false);
            GUI.enabled = true;

            EditorGUILayout.LabelField("Settings", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_stopSocketsOnThread);
            EditorGUILayout.PropertyField(_dontRoute);
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            EditorGUILayout.LabelField("Channels", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_unreliableMtu);
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            EditorGUILayout.LabelField("Server", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_reuseAddress);
            EditorGUILayout.PropertyField(_ipv4BindAddress);
            EditorGUILayout.PropertyField(_enableIpv6);
            if (_enableIpv6.boolValue == true)
            {
                EditorGUI.indentLevel++;
                EditorGUILayout.PropertyField(_ipv6BindAddress);
                EditorGUI.indentLevel--;
            }
            EditorGUILayout.PropertyField(_port);
            EditorGUILayout.PropertyField(_maximumClients);
            EditorGUI.indentLevel--;
            EditorGUILayout.Space();

            EditorGUILayout.LabelField("Client", EditorStyles.boldLabel);
            EditorGUI.indentLevel++;
            EditorGUILayout.PropertyField(_clientAddress);
            EditorGUI.indentLevel--;

            serializedObject.ApplyModifiedProperties();
        }



    }

}


#endif﻿using System.Collections.Generic;
using System.Threading;

namespace LiteNetLib
{
    internal abstract class BaseChannel
    {
        protected readonly NetPeer Peer;
        protected readonly Queue<NetPacket> OutgoingQueue = new(NetConstants.DefaultWindowSize);
        private int _isAddedToPeerChannelSendQueue;

        public int PacketsInQueue => OutgoingQueue.Count;

        protected BaseChannel(NetPeer peer)
        {
            Peer = peer;
        }

        public void AddToQueue(NetPacket packet)
        {
            lock (OutgoingQueue)
            {
                OutgoingQueue.Enqueue(packet);
            }
            AddToPeerChannelSendQueue();
        }

        protected void AddToPeerChannelSendQueue()
        {
            if (Interlocked.CompareExchange(ref _isAddedToPeerChannelSendQueue, 1, 0) == 0)
            {
                Peer.AddToReliableChannelSendQueue(this);
            }
        }

        public bool SendAndCheckQueue()
        {
            bool hasPacketsToSend = SendNextPackets();
            if (!hasPacketsToSend)
                Interlocked.Exchange(ref _isAddedToPeerChannelSendQueue, 0);

            return hasPacketsToSend;
        }

        protected abstract bool SendNextPackets();
        public abstract bool ProcessPacket(NetPacket packet);
    }
}
﻿using System.Net;
using System.Threading;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    internal enum ConnectionRequestResult
    {
        None,
        Accept,
        Reject,
        RejectForce
    }

    public class ConnectionRequest
    {
        private readonly NetManager _listener;
        private int _used;

        public NetDataReader Data => InternalPacket.Data;

        internal ConnectionRequestResult Result { get; private set; }
        internal NetConnectRequestPacket InternalPacket;

        public readonly IPEndPoint RemoteEndPoint;

        internal void UpdateRequest(NetConnectRequestPacket connectRequest)
        {
            //old request
            if (connectRequest.ConnectionTime < InternalPacket.ConnectionTime)
                return;

            if (connectRequest.ConnectionTime == InternalPacket.ConnectionTime &&
                connectRequest.ConnectionNumber == InternalPacket.ConnectionNumber)
                return;

            InternalPacket = connectRequest;
        }

        private bool TryActivate()
        {
            return Interlocked.CompareExchange(ref _used, 1, 0) == 0;
        }

        internal ConnectionRequest(IPEndPoint remoteEndPoint, NetConnectRequestPacket requestPacket, NetManager listener)
        {
            InternalPacket = requestPacket;
            RemoteEndPoint = remoteEndPoint;
            _listener = listener;
        }

        public NetPeer AcceptIfKey(string key)
        {
            if (!TryActivate())
                return null;
            try
            {
                if (Data.GetString() == key)
                    Result = ConnectionRequestResult.Accept;
            }
            catch
            {
                NetDebug.WriteError("[AC] Invalid incoming data");
            }
            if (Result == ConnectionRequestResult.Accept)
                return _listener.OnConnectionSolved(this, null, 0, 0);

            Result = ConnectionRequestResult.Reject;
            _listener.OnConnectionSolved(this, null, 0, 0);
            return null;
        }

        /// <summary>
        /// Accept connection and get new NetPeer as result
        /// </summary>
        /// <returns>Connected NetPeer</returns>
        public NetPeer Accept()
        {
            if (!TryActivate())
                return null;
            Result = ConnectionRequestResult.Accept;
            return _listener.OnConnectionSolved(this, null, 0, 0);
        }

        public void Reject(byte[] rejectData, int start, int length, bool force)
        {
            if (!TryActivate())
                return;
            Result = force ? ConnectionRequestResult.RejectForce : ConnectionRequestResult.Reject;
            _listener.OnConnectionSolved(this, rejectData, start, length);
        }

        public void Reject(byte[] rejectData, int start, int length)
        {
            Reject(rejectData, start, length, false);
        }


        public void RejectForce(byte[] rejectData, int start, int length)
        {
            Reject(rejectData, start, length, true);
        }

        public void RejectForce()
        {
            Reject(null, 0, 0, true);
        }

        public void RejectForce(byte[] rejectData)
        {
            Reject(rejectData, 0, rejectData.Length, true);
        }

        public void RejectForce(NetDataWriter rejectData)
        {
            Reject(rejectData.Data, 0, rejectData.Length, true);
        }

        public void Reject()
        {
            Reject(null, 0, 0, false);
        }

        public void Reject(byte[] rejectData)
        {
            Reject(rejectData, 0, rejectData.Length, false);
        }

        public void Reject(NetDataWriter rejectData)
        {
            Reject(rejectData.Data, 0, rejectData.Length, false);
        }
    }
}
﻿using System.Net;
using System.Net.Sockets;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    /// <summary>
    /// Type of message that you receive in OnNetworkReceiveUnconnected event
    /// </summary>
    public enum UnconnectedMessageType
    {
        BasicMessage,
        Broadcast
    }

    /// <summary>
    /// Disconnect reason that you receive in OnPeerDisconnected event
    /// </summary>
    public enum DisconnectReason
    {
        ConnectionFailed,
        Timeout,
        HostUnreachable,
        NetworkUnreachable,
        RemoteConnectionClose,
        DisconnectPeerCalled,
        ConnectionRejected,
        InvalidProtocol,
        UnknownHost,
        Reconnect,
        PeerToPeerConnection,
        PeerNotFound
    }

    /// <summary>
    /// Additional information about disconnection
    /// </summary>
    public struct DisconnectInfo
    {
        /// <summary>
        /// Additional info why peer disconnected
        /// </summary>
        public DisconnectReason Reason;

        /// <summary>
        /// Error code (if reason is SocketSendError or SocketReceiveError)
        /// </summary>
        public SocketError SocketErrorCode;

        /// <summary>
        /// Additional data that can be accessed (only if reason is RemoteConnectionClose)
        /// </summary>
        public NetPacketReader AdditionalData;
    }

    public interface INetEventListener
    {
        /// <summary>
        /// New remote peer connected to host, or client connected to remote host
        /// </summary>
        /// <param name="peer">Connected peer object</param>
        void OnPeerConnected(NetPeer peer);

        /// <summary>
        /// Peer disconnected
        /// </summary>
        /// <param name="peer">disconnected peer</param>
        /// <param name="disconnectInfo">additional info about reason, errorCode or data received with disconnect message</param>
        void OnPeerDisconnected(NetPeer peer, DisconnectInfo disconnectInfo);

        /// <summary>
        /// Network error (on send or receive)
        /// </summary>
        /// <param name="endPoint">From endPoint (can be null)</param>
        /// <param name="socketError">Socket error</param>
        void OnNetworkError(IPEndPoint endPoint, SocketError socketError);

        /// <summary>
        /// Received some data
        /// </summary>
        /// <param name="peer">From peer</param>
        /// <param name="reader">DataReader containing all received data</param>
        /// <param name="channelNumber">Number of channel at which packet arrived</param>
        /// <param name="deliveryMethod">Type of received packet</param>
        void OnNetworkReceive(NetPeer peer, NetPacketReader reader, byte channelNumber, DeliveryMethod deliveryMethod);

        /// <summary>
        /// Received unconnected message
        /// </summary>
        /// <param name="remoteEndPoint">From address (IP and Port)</param>
        /// <param name="reader">Message data</param>
        /// <param name="messageType">Message type (simple, discovery request or response)</param>
        void OnNetworkReceiveUnconnected(IPEndPoint remoteEndPoint, NetPacketReader reader, UnconnectedMessageType messageType);

        /// <summary>
        /// Latency information updated
        /// </summary>
        /// <param name="peer">Peer with updated latency</param>
        /// <param name="latency">latency value in milliseconds</param>
        void OnNetworkLatencyUpdate(NetPeer peer, int latency);

        /// <summary>
        /// On peer connection requested
        /// </summary>
        /// <param name="request">Request information (EndPoint, internal id, additional data)</param>
        void OnConnectionRequest(ConnectionRequest request);
    }

    public interface IDeliveryEventListener
    {
        /// <summary>
        /// On reliable message delivered
        /// </summary>
        /// <param name="peer"></param>
        /// <param name="userData"></param>
        void OnMessageDelivered(NetPeer peer, object userData);
    }

    public interface INtpEventListener
    {
        /// <summary>
        /// Ntp response
        /// </summary>
        /// <param name="packet"></param>
        void OnNtpResponse(NtpPacket packet);
    }

    public interface IPeerAddressChangedListener
    {
        /// <summary>
        /// Called when peer address changed (when AllowPeerAddressChange is enabled)
        /// </summary>
        /// <param name="peer">Peer that changed address (with new address)</param>
        /// <param name="previousAddress">previous IP</param>
        void OnPeerAddressChanged(NetPeer peer, IPEndPoint previousAddress);
    }

    public class EventBasedNetListener : INetEventListener, IDeliveryEventListener, INtpEventListener, IPeerAddressChangedListener
    {
        public delegate void OnPeerConnected(NetPeer peer);
        public delegate void OnPeerDisconnected(NetPeer peer, DisconnectInfo disconnectInfo);
        public delegate void OnNetworkError(IPEndPoint endPoint, SocketError socketError);
        public delegate void OnNetworkReceive(NetPeer peer, NetPacketReader reader, byte channel, DeliveryMethod deliveryMethod);
        public delegate void OnNetworkReceiveUnconnected(IPEndPoint remoteEndPoint, NetPacketReader reader, UnconnectedMessageType messageType);
        public delegate void OnNetworkLatencyUpdate(NetPeer peer, int latency);
        public delegate void OnConnectionRequest(ConnectionRequest request);
        public delegate void OnDeliveryEvent(NetPeer peer, object userData);
        public delegate void OnNtpResponseEvent(NtpPacket packet);
        public delegate void OnPeerAddressChangedEvent(NetPeer peer, IPEndPoint previousAddress);

        public event OnPeerConnected PeerConnectedEvent;
        public event OnPeerDisconnected PeerDisconnectedEvent;
        public event OnNetworkError NetworkErrorEvent;
        public event OnNetworkReceive NetworkReceiveEvent;
        public event OnNetworkReceiveUnconnected NetworkReceiveUnconnectedEvent;
        public event OnNetworkLatencyUpdate NetworkLatencyUpdateEvent;
        public event OnConnectionRequest ConnectionRequestEvent;
        public event OnDeliveryEvent DeliveryEvent;
        public event OnNtpResponseEvent NtpResponseEvent;
        public event OnPeerAddressChangedEvent PeerAddressChangedEvent;

        public void ClearPeerConnectedEvent()
        {
            PeerConnectedEvent = null;
        }

        public void ClearPeerDisconnectedEvent()
        {
            PeerDisconnectedEvent = null;
        }

        public void ClearNetworkErrorEvent()
        {
            NetworkErrorEvent = null;
        }

        public void ClearNetworkReceiveEvent()
        {
            NetworkReceiveEvent = null;
        }

        public void ClearNetworkReceiveUnconnectedEvent()
        {
            NetworkReceiveUnconnectedEvent = null;
        }

        public void ClearNetworkLatencyUpdateEvent()
        {
            NetworkLatencyUpdateEvent = null;
        }

        public void ClearConnectionRequestEvent()
        {
            ConnectionRequestEvent = null;
        }

        public void ClearDeliveryEvent()
        {
            DeliveryEvent = null;
        }

        public void ClearNtpResponseEvent()
        {
            NtpResponseEvent = null;
        }

        public void ClearPeerAddressChangedEvent()
        {
            PeerAddressChangedEvent = null;
        }

        void INetEventListener.OnPeerConnected(NetPeer peer)
        {
            if (PeerConnectedEvent != null)
                PeerConnectedEvent(peer);
        }

        void INetEventListener.OnPeerDisconnected(NetPeer peer, DisconnectInfo disconnectInfo)
        {
            if (PeerDisconnectedEvent != null)
                PeerDisconnectedEvent(peer, disconnectInfo);
        }

        void INetEventListener.OnNetworkError(IPEndPoint endPoint, SocketError socketErrorCode)
        {
            if (NetworkErrorEvent != null)
                NetworkErrorEvent(endPoint, socketErrorCode);
        }

        void INetEventListener.OnNetworkReceive(NetPeer peer, NetPacketReader reader, byte channelNumber, DeliveryMethod deliveryMethod)
        {
            if (NetworkReceiveEvent != null)
                NetworkReceiveEvent(peer, reader, channelNumber, deliveryMethod);
        }

        void INetEventListener.OnNetworkReceiveUnconnected(IPEndPoint remoteEndPoint, NetPacketReader reader, UnconnectedMessageType messageType)
        {
            if (NetworkReceiveUnconnectedEvent != null)
                NetworkReceiveUnconnectedEvent(remoteEndPoint, reader, messageType);
        }

        void INetEventListener.OnNetworkLatencyUpdate(NetPeer peer, int latency)
        {
            if (NetworkLatencyUpdateEvent != null)
                NetworkLatencyUpdateEvent(peer, latency);
        }

        void INetEventListener.OnConnectionRequest(ConnectionRequest request)
        {
            if (ConnectionRequestEvent != null)
                ConnectionRequestEvent(request);
        }

        void IDeliveryEventListener.OnMessageDelivered(NetPeer peer, object userData)
        {
            if (DeliveryEvent != null)
                DeliveryEvent(peer, userData);
        }

        void INtpEventListener.OnNtpResponse(NtpPacket packet)
        {
            if (NtpResponseEvent != null)
                NtpResponseEvent(packet);
        }

        void IPeerAddressChangedListener.OnPeerAddressChanged(NetPeer peer, IPEndPoint previousAddress)
        {
            if (PeerAddressChangedEvent != null)
                PeerAddressChangedEvent(peer, previousAddress);
        }
    }
}
using System;
using System.Net;
using LiteNetLib.Utils;

namespace LiteNetLib
{
   internal sealed class NetConnectRequestPacket
    {
        public const int HeaderSize = 18;
        public readonly long ConnectionTime;
        public byte ConnectionNumber;
        public readonly byte[] TargetAddress;
        public readonly NetDataReader Data;
        public readonly int PeerId;

        private NetConnectRequestPacket(long connectionTime, byte connectionNumber, int localId, byte[] targetAddress, NetDataReader data)
        {
            ConnectionTime = connectionTime;
            ConnectionNumber = connectionNumber;
            TargetAddress = targetAddress;
            Data = data;
            PeerId = localId;
        }

        public static int GetProtocolId(NetPacket packet)
        {
            return BitConverter.ToInt32(packet.RawData, 1);
        }

        public static NetConnectRequestPacket FromData(NetPacket packet)
        {
            if (packet.ConnectionNumber >= NetConstants.MaxConnectionNumber)
                return null;

            //Getting connection time for peer
            long connectionTime = BitConverter.ToInt64(packet.RawData, 5);

            //Get peer id
            int peerId = BitConverter.ToInt32(packet.RawData, 13);

            //Get target address
            int addrSize = packet.RawData[HeaderSize-1];
            if (addrSize != 16 && addrSize != 28)
                return null;
            byte[] addressBytes = new byte[addrSize];
            Buffer.BlockCopy(packet.RawData, HeaderSize, addressBytes, 0, addrSize);

            // Read data and create request
            var reader = new NetDataReader(null, 0, 0);
            if (packet.Size > HeaderSize+addrSize)
                reader.SetSource(packet.RawData, HeaderSize + addrSize, packet.Size);

            return new(connectionTime, packet.ConnectionNumber, peerId, addressBytes, reader);
        }

        public static NetPacket Make(NetDataWriter connectData, SocketAddress addressBytes, long connectTime, int localId)
        {
            //Make initial packet
            var packet = new NetPacket(PacketProperty.ConnectRequest, connectData.Length+addressBytes.Size);

            //Add data
            FastBitConverter.GetBytes(packet.RawData, 1, NetConstants.ProtocolId);
            FastBitConverter.GetBytes(packet.RawData, 5, connectTime);
            FastBitConverter.GetBytes(packet.RawData, 13, localId);
            packet.RawData[HeaderSize-1] = (byte)addressBytes.Size;
            for (int i = 0; i < addressBytes.Size; i++)
                packet.RawData[HeaderSize + i] = addressBytes[i];
            Buffer.BlockCopy(connectData.Data, 0, packet.RawData, HeaderSize + addressBytes.Size, connectData.Length);
            return packet;
        }
    }

    internal sealed class NetConnectAcceptPacket
    {
        public const int Size = 15;
        public readonly long ConnectionTime;
        public readonly byte ConnectionNumber;
        public readonly int PeerId;
        public readonly bool PeerNetworkChanged;

        private NetConnectAcceptPacket(long connectionTime, byte connectionNumber, int peerId, bool peerNetworkChanged)
        {
            ConnectionTime = connectionTime;
            ConnectionNumber = connectionNumber;
            PeerId = peerId;
            PeerNetworkChanged = peerNetworkChanged;
        }

        public static NetConnectAcceptPacket FromData(NetPacket packet)
        {
            if (packet.Size != Size)
                return null;

            long connectionId = BitConverter.ToInt64(packet.RawData, 1);

            //check connect num
            byte connectionNumber = packet.RawData[9];
            if (connectionNumber >= NetConstants.MaxConnectionNumber)
                return null;

            //check reused flag
            byte isReused = packet.RawData[10];
            if (isReused > 1)
                return null;

            //get remote peer id
            int peerId = BitConverter.ToInt32(packet.RawData, 11);
            if (peerId < 0)
                return null;

            return new(connectionId, connectionNumber, peerId, isReused == 1);
        }

        public static NetPacket Make(long connectTime, byte connectNum, int localPeerId)
        {
            var packet = new NetPacket(PacketProperty.ConnectAccept, 0);
            FastBitConverter.GetBytes(packet.RawData, 1, connectTime);
            packet.RawData[9] = connectNum;
            FastBitConverter.GetBytes(packet.RawData, 11, localPeerId);
            return packet;
        }
        
        public static NetPacket MakeNetworkChanged(NetPeer peer)
        {
            var packet = new NetPacket(PacketProperty.PeerNotFound, Size-1);
            FastBitConverter.GetBytes(packet.RawData, 1, peer.ConnectTime);
            packet.RawData[9] = peer.ConnectionNum;
            packet.RawData[10] = 1;
            FastBitConverter.GetBytes(packet.RawData, 11, peer.RemoteId);
            return packet;
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace LiteNetLib
{
    internal static class NativeSocket
    {
        static unsafe class WinSock
        {
            private const string LibName = "ws2_32.dll";

            [DllImport(LibName, SetLastError = true)]
            public static extern int recvfrom(
                IntPtr socketHandle,
                [In, Out] byte[] pinnedBuffer,
                [In] int len,
                [In] SocketFlags socketFlags,
                [Out] byte[] socketAddress,
                [In, Out] ref int socketAddressSize);

            [DllImport(LibName, SetLastError = true)]
            internal static extern int sendto(
                IntPtr socketHandle,
                byte* pinnedBuffer,
                [In] int len,
                [In] SocketFlags socketFlags,
                [In] byte[] socketAddress,
                [In] int socketAddressSize);
        }

        static unsafe class UnixSock
        {
            private const string LibName = "libc";

            [DllImport(LibName, SetLastError = true)]
            public static extern int recvfrom(
                IntPtr socketHandle,
                [In, Out] byte[] pinnedBuffer,
                [In] int len,
                [In] SocketFlags socketFlags,
                [Out] byte[] socketAddress,
                [In, Out] ref int socketAddressSize);

            [DllImport(LibName, SetLastError = true)]
            internal static extern int sendto(
                IntPtr socketHandle,
                byte* pinnedBuffer,
                [In] int len,
                [In] SocketFlags socketFlags,
                [In] byte[] socketAddress,
                [In] int socketAddressSize);
        }

        public static readonly bool IsSupported = false;
        public static readonly bool UnixMode = false;

        public const int IPv4AddrSize = 16;
        public const int IPv6AddrSize = 28;
        public const int AF_INET = 2;
        public const int AF_INET6 = 10;

        private static readonly Dictionary<int, SocketError> NativeErrorToSocketError = new()
        {
            { 13, SocketError.AccessDenied },               //EACCES
            { 98, SocketError.AddressAlreadyInUse },        //EADDRINUSE
            { 99, SocketError.AddressNotAvailable },        //EADDRNOTAVAIL
            { 97, SocketError.AddressFamilyNotSupported },  //EAFNOSUPPORT
            { 11, SocketError.WouldBlock },                 //EAGAIN
            { 114, SocketError.AlreadyInProgress },         //EALREADY
            { 9, SocketError.OperationAborted },            //EBADF
            { 125, SocketError.OperationAborted },          //ECANCELED
            { 103, SocketError.ConnectionAborted },         //ECONNABORTED
            { 111, SocketError.ConnectionRefused },         //ECONNREFUSED
            { 104, SocketError.ConnectionReset },           //ECONNRESET
            { 89, SocketError.DestinationAddressRequired }, //EDESTADDRREQ
            { 14, SocketError.Fault },                      //EFAULT
            { 112, SocketError.HostDown },                  //EHOSTDOWN
            { 6, SocketError.HostNotFound },                //ENXIO
            { 113, SocketError.HostUnreachable },           //EHOSTUNREACH
            { 115, SocketError.InProgress },                //EINPROGRESS
            { 4, SocketError.Interrupted },                 //EINTR
            { 22, SocketError.InvalidArgument },            //EINVAL
            { 106, SocketError.IsConnected },               //EISCONN
            { 24, SocketError.TooManyOpenSockets },         //EMFILE
            { 90, SocketError.MessageSize },                //EMSGSIZE
            { 100, SocketError.NetworkDown },               //ENETDOWN
            { 102, SocketError.NetworkReset },              //ENETRESET
            { 101, SocketError.NetworkUnreachable },        //ENETUNREACH
            { 23, SocketError.TooManyOpenSockets },         //ENFILE
            { 105, SocketError.NoBufferSpaceAvailable },    //ENOBUFS
            { 61, SocketError.NoData },                     //ENODATA
            { 2, SocketError.AddressNotAvailable },         //ENOENT
            { 92, SocketError.ProtocolOption },             //ENOPROTOOPT
            { 107, SocketError.NotConnected },              //ENOTCONN
            { 88, SocketError.NotSocket },                  //ENOTSOCK
            { 3440, SocketError.OperationNotSupported },    //ENOTSUP
            { 1, SocketError.AccessDenied },                //EPERM
            { 32, SocketError.Shutdown },                   //EPIPE
            { 96, SocketError.ProtocolFamilyNotSupported }, //EPFNOSUPPORT
            { 93, SocketError.ProtocolNotSupported },       //EPROTONOSUPPORT
            { 91, SocketError.ProtocolType },               //EPROTOTYPE
            { 94, SocketError.SocketNotSupported },         //ESOCKTNOSUPPORT
            { 108, SocketError.Disconnecting },             //ESHUTDOWN
            { 110, SocketError.TimedOut },                  //ETIMEDOUT
            { 0, SocketError.Success }
        };

        static NativeSocket()
        {
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
            {
                IsSupported = true;
                UnixMode = true;
            }
            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                IsSupported = true;
            }
        }

        
        public static int RecvFrom(
            IntPtr socketHandle,
            byte[] pinnedBuffer,
            int len,
            byte[] socketAddress,
            ref int socketAddressSize)
        {
            return UnixMode
                ? UnixSock.recvfrom(socketHandle, pinnedBuffer, len, 0, socketAddress, ref socketAddressSize)
                : WinSock.recvfrom(socketHandle, pinnedBuffer, len, 0, socketAddress, ref socketAddressSize);
        }

        
        public static unsafe int SendTo(
            IntPtr socketHandle,
            byte* pinnedBuffer,
            int len,
            byte[] socketAddress,
            int socketAddressSize)
        {
            return UnixMode
                ? UnixSock.sendto(socketHandle, pinnedBuffer, len, 0, socketAddress, socketAddressSize)
                : WinSock.sendto(socketHandle, pinnedBuffer, len, 0, socketAddress, socketAddressSize);
        }

        public static SocketError GetSocketError()
        {
            int error = Marshal.GetLastWin32Error();
            if (UnixMode)
                return NativeErrorToSocketError.TryGetValue(error, out var err)
                    ? err
                    : SocketError.SocketError;
            return (SocketError)error;
        }

        public static SocketException GetSocketException()
        {
            int error = Marshal.GetLastWin32Error();
            if (UnixMode)
                return NativeErrorToSocketError.TryGetValue(error, out var err)
                    ? new((int)err)
                    : new SocketException((int)SocketError.SocketError);
            return new(error);
        }

        
        public static short GetNativeAddressFamily(IPEndPoint remoteEndPoint)
        {
            return UnixMode
                ? (short)(remoteEndPoint.AddressFamily == AddressFamily.InterNetwork ? AF_INET : AF_INET6)
                : (short)remoteEndPoint.AddressFamily;
        }
    }
}
﻿using System.Collections.Concurrent;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Net.Sockets;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    public enum NatAddressType
    {
        Internal,
        External
    }

    public interface INatPunchListener
    {
        void OnNatIntroductionRequest(IPEndPoint localEndPoint, IPEndPoint remoteEndPoint, string token);
        void OnNatIntroductionSuccess(IPEndPoint targetEndPoint, NatAddressType type, string token);
    }

    public class EventBasedNatPunchListener : INatPunchListener
    {
        public delegate void OnNatIntroductionRequest(IPEndPoint localEndPoint, IPEndPoint remoteEndPoint, string token);
        public delegate void OnNatIntroductionSuccess(IPEndPoint targetEndPoint, NatAddressType type, string token);

        public event OnNatIntroductionRequest NatIntroductionRequest;
        public event OnNatIntroductionSuccess NatIntroductionSuccess;

        void INatPunchListener.OnNatIntroductionRequest(IPEndPoint localEndPoint, IPEndPoint remoteEndPoint, string token)
        {
            if(NatIntroductionRequest != null)
                NatIntroductionRequest(localEndPoint, remoteEndPoint, token);
        }

        void INatPunchListener.OnNatIntroductionSuccess(IPEndPoint targetEndPoint, NatAddressType type, string token)
        {
            if (NatIntroductionSuccess != null)
                NatIntroductionSuccess(targetEndPoint, type, token);
        }
    }

    /// <summary>
    /// Module for UDP NAT Hole punching operations. Can be accessed from NetManager
    /// </summary>
    public sealed class NatPunchModule
    {
        struct RequestEventData
        {
            public IPEndPoint LocalEndPoint;
            public IPEndPoint RemoteEndPoint;
            public string Token;
        }

        struct SuccessEventData
        {
            public IPEndPoint TargetEndPoint;
            public NatAddressType Type;
            public string Token;
        }

        class NatIntroduceRequestPacket
        {
            public IPEndPoint Internal { [Preserve] get; [Preserve] set; }
            public string Token { [Preserve] get; [Preserve] set; }
        }

        class NatIntroduceResponsePacket
        {
            public IPEndPoint Internal { [Preserve] get; [Preserve] set; }
            public IPEndPoint External { [Preserve] get; [Preserve] set; }
            public string Token { [Preserve] get; [Preserve] set; }
        }

        class NatPunchPacket
        {
            public string Token { [Preserve] get; [Preserve] set; }
            public bool IsExternal { [Preserve] get; [Preserve] set; }
        }

        private readonly NetManager _socket;
        private readonly ConcurrentQueue<RequestEventData> _requestEvents = new();
        private readonly ConcurrentQueue<SuccessEventData> _successEvents = new();
        private readonly NetDataReader _cacheReader = new();
        private readonly NetDataWriter _cacheWriter = new();
        private readonly NetPacketProcessor _netPacketProcessor = new(MaxTokenLength);
        private INatPunchListener _natPunchListener;
        public const int MaxTokenLength = 256;

        /// <summary>
        /// Events automatically will be called without PollEvents method from another thread
        /// </summary>
        public bool UnsyncedEvents = false;

        internal NatPunchModule(NetManager socket)
        {
            _socket = socket;
            _netPacketProcessor.SubscribeReusable<NatIntroduceResponsePacket>(OnNatIntroductionResponse);
            _netPacketProcessor.SubscribeReusable<NatIntroduceRequestPacket, IPEndPoint>(OnNatIntroductionRequest);
            _netPacketProcessor.SubscribeReusable<NatPunchPacket, IPEndPoint>(OnNatPunch);
        }

        internal void ProcessMessage(IPEndPoint senderEndPoint, NetPacket packet)
        {
            lock (_cacheReader)
            {
                _cacheReader.SetSource(packet.RawData, NetConstants.HeaderSize, packet.Size);
                _netPacketProcessor.ReadAllPackets(_cacheReader, senderEndPoint);
            }
        }

        public void Init(INatPunchListener listener)
        {
            _natPunchListener = listener;
        }

        private void Send<
#if NET5_0_OR_GREATER
            [DynamicallyAccessedMembers(Trimming.SerializerMemberTypes)]
#endif
        T>(T packet, IPEndPoint target) where T : class, new()
        {
            _cacheWriter.Reset();
            _cacheWriter.Put((byte)PacketProperty.NatMessage);
            _netPacketProcessor.Write(_cacheWriter, packet);
            _socket.SendRaw(_cacheWriter.Data, 0, _cacheWriter.Length, target);
        }

        public void NatIntroduce(
            IPEndPoint hostInternal,
            IPEndPoint hostExternal,
            IPEndPoint clientInternal,
            IPEndPoint clientExternal,
            string additionalInfo)
        {
            var req = new NatIntroduceResponsePacket
            {
                Token = additionalInfo
            };

            //First packet (server) send to client
            req.Internal = hostInternal;
            req.External = hostExternal;
            Send(req, clientExternal);

            //Second packet (client) send to server
            req.Internal = clientInternal;
            req.External = clientExternal;
            Send(req, hostExternal);
        }

        public void PollEvents()
        {
            if (UnsyncedEvents)
                return;

            if (_natPunchListener == null || (_successEvents.IsEmpty && _requestEvents.IsEmpty))
                return;

            while (_successEvents.TryDequeue(out var evt))
            {
                _natPunchListener.OnNatIntroductionSuccess(
                    evt.TargetEndPoint,
                    evt.Type,
                    evt.Token);
            }

            while (_requestEvents.TryDequeue(out var evt))
            {
                _natPunchListener.OnNatIntroductionRequest(evt.LocalEndPoint, evt.RemoteEndPoint, evt.Token);
            }
        }

        public void SendNatIntroduceRequest(string host, int port, string additionalInfo)
        {
            SendNatIntroduceRequest(NetUtils.MakeEndPoint(host, port), additionalInfo);
        }

        public void SendNatIntroduceRequest(IPEndPoint masterServerEndPoint, string additionalInfo)
        {
            //prepare outgoing data
            string networkIp = NetUtils.GetLocalIp(LocalAddrType.IPv4);
            if (string.IsNullOrEmpty(networkIp) || masterServerEndPoint.AddressFamily == AddressFamily.InterNetworkV6)
            {
                networkIp = NetUtils.GetLocalIp(LocalAddrType.IPv6);
            }

            Send(
                new NatIntroduceRequestPacket
                {
                    Internal = NetUtils.MakeEndPoint(networkIp, _socket.LocalPort),
                    Token = additionalInfo
                },
                masterServerEndPoint);
        }

        //We got request and must introduce
        private void OnNatIntroductionRequest(NatIntroduceRequestPacket req, IPEndPoint senderEndPoint)
        {
            if (UnsyncedEvents)
            {
                _natPunchListener.OnNatIntroductionRequest(
                    req.Internal,
                    senderEndPoint,
                    req.Token);
            }
            else
            {
                _requestEvents.Enqueue(new()
                {
                    LocalEndPoint = req.Internal,
                    RemoteEndPoint = senderEndPoint,
                    Token = req.Token
                });
            }
        }

        //We got introduce and must punch
        private void OnNatIntroductionResponse(NatIntroduceResponsePacket req)
        {
            NetDebug.Write(NetLogLevel.Trace, "[NAT] introduction received");

            // send internal punch
            var punchPacket = new NatPunchPacket {Token = req.Token};
            Send(punchPacket, req.Internal);
            NetDebug.Write(NetLogLevel.Trace, $"[NAT] internal punch sent to {req.Internal}");

            // hack for some routers
            _socket.Ttl = 2;
            _socket.SendRaw(new[] { (byte)PacketProperty.Empty }, 0, 1, req.External);

            // send external punch
            _socket.Ttl = NetConstants.SocketTTL;
            punchPacket.IsExternal = true;
            Send(punchPacket, req.External);
            NetDebug.Write(NetLogLevel.Trace, $"[NAT] external punch sent to {req.External}");
        }

        //We got punch and can connect
        private void OnNatPunch(NatPunchPacket req, IPEndPoint senderEndPoint)
        {
            //Read info
            NetDebug.Write(NetLogLevel.Trace, $"[NAT] punch received from {senderEndPoint} - additional info: {req.Token}");

            //Release punch success to client; enabling him to Connect() to Sender if token is ok
            if(UnsyncedEvents)
            {
                _natPunchListener.OnNatIntroductionSuccess(
                    senderEndPoint,
                    req.IsExternal ? NatAddressType.External : NatAddressType.Internal,
                    req.Token
                    );
            }
            else
            {
                _successEvents.Enqueue(new()
                {
                    TargetEndPoint = senderEndPoint,
                    Type = req.IsExternal ? NatAddressType.External : NatAddressType.Internal,
                    Token = req.Token
                });
            }
        }
    }
}
﻿namespace LiteNetLib
{
    /// <summary>
    /// Sending method type
    /// </summary>
    public enum DeliveryMethod : byte
    {
        /// <summary>
        /// Unreliable. Packets can be dropped, can be duplicated, can arrive without order.
        /// </summary>
        Unreliable = 4,

        /// <summary>
        /// Reliable. Packets won't be dropped, won't be duplicated, can arrive without order.
        /// </summary>
        ReliableUnordered = 0,

        /// <summary>
        /// Unreliable. Packets can be dropped, won't be duplicated, will arrive in order.
        /// </summary>
        Sequenced = 1,

        /// <summary>
        /// Reliable and ordered. Packets won't be dropped, won't be duplicated, will arrive in order.
        /// </summary>
        ReliableOrdered = 2,

        /// <summary>
        /// Reliable only last packet. Packets can be dropped (except the last one), won't be duplicated, will arrive in order.
        /// Cannot be fragmented
        /// </summary>
        ReliableSequenced = 3
    }

    /// <summary>
    /// Network constants. Can be tuned from sources for your purposes.
    /// </summary>
    public static class NetConstants
    {
        //can be tuned
        public const int DefaultWindowSize = 64;
        public const int SocketBufferSize = 1024 * 1024; //1mb
        public const int SocketTTL = 255;

        public const int HeaderSize = 1;
        public const int ChanneledHeaderSize = 4;
        public const int FragmentHeaderSize = 6;
        public const int FragmentedHeaderTotalSize = ChanneledHeaderSize + FragmentHeaderSize;
        public const ushort MaxSequence = 32768;
        public const ushort HalfMaxSequence = MaxSequence / 2;

        //protocol
        internal const int ProtocolId = 13;
        internal const int MaxUdpHeaderSize = 68;
        internal const int ChannelTypeCount = 4;

        internal static readonly int[] PossibleMtu =
        {
            576  - MaxUdpHeaderSize, //minimal (RFC 1191)
            1024,                    //most games standard
            1232 - MaxUdpHeaderSize,
            1460 - MaxUdpHeaderSize, //google cloud
            1472 - MaxUdpHeaderSize, //VPN
            1492 - MaxUdpHeaderSize, //Ethernet with LLC and SNAP, PPPoE (RFC 1042)
            1500 - MaxUdpHeaderSize  //Ethernet II (RFC 1191)
        };

        //Max possible single packet size
        public static readonly int MaxPacketSize = PossibleMtu[PossibleMtu.Length - 1];
        public static readonly int MaxUnreliableDataSize = MaxPacketSize - HeaderSize;

        //peer specific
        public const byte MaxConnectionNumber = 4;
    }
}
﻿using System;
using System.Diagnostics;

namespace LiteNetLib
{
    public class InvalidPacketException : ArgumentException
    {
        public InvalidPacketException(string message) : base(message)
        {
        }
    }

    public class TooBigPacketException : InvalidPacketException
    {
        public TooBigPacketException(string message) : base(message)
        {
        }
    }

    public enum NetLogLevel
    {
        Warning,
        Error,
        Trace,
        Info
    }

    /// <summary>
    /// Interface to implement for your own logger
    /// </summary>
    public interface INetLogger
    {
        void WriteNet(NetLogLevel level, string str, params object[] args);
    }

    /// <summary>
    /// Static class for defining your own LiteNetLib logger instead of Console.WriteLine
    /// or Debug.Log if compiled with UNITY flag
    /// </summary>
    public static class NetDebug
    {
        public static INetLogger Logger = null;
        private static readonly object DebugLogLock = new();
        private static void WriteLogic(NetLogLevel logLevel, string str, params object[] args)
        {
            lock (DebugLogLock)
            {
                if (Logger == null)
                {
#if UNITY_5_3_OR_NEWER
                    UnityEngine.Debug.Log(string.Format(str, args));
#else
                    Console.WriteLine(str, args);
#endif
                }
                else
                {
                    Logger.WriteNet(logLevel, str, args);
                }
            }
        }

        [Conditional("DEBUG_MESSAGES")]
        internal static void Write(string str)
        {
            WriteLogic(NetLogLevel.Trace, str);
        }

        [Conditional("DEBUG_MESSAGES")]
        internal static void Write(NetLogLevel level, string str)
        {
            WriteLogic(level, str);
        }

        [Conditional("DEBUG_MESSAGES"), Conditional("DEBUG")]
        internal static void WriteForce(string str)
        {
            WriteLogic(NetLogLevel.Trace, str);
        }

        [Conditional("DEBUG_MESSAGES"), Conditional("DEBUG")]
        internal static void WriteForce(NetLogLevel level, string str)
        {
            WriteLogic(level, str);
        }

        internal static void WriteError(string str)
        {
            WriteLogic(NetLogLevel.Error, str);
        }
    }
}
﻿#if UNITY_2018_3_OR_NEWER
#define UNITY_SOCKET_FIX
#endif
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using LiteNetLib.Layers;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    public sealed class NetPacketReader : NetDataReader
    {
        private NetPacket _packet;
        private readonly NetManager _manager;
        private readonly NetEvent _evt;

        internal NetPacketReader(NetManager manager, NetEvent evt)
        {
            _manager = manager;
            _evt = evt;
        }

        internal void SetSource(NetPacket packet, int headerSize)
        {
            if (packet == null)
                return;
            _packet = packet;
            SetSource(packet.RawData, headerSize, packet.Size);
        }

        internal void RecycleInternal()
        {
            Clear();
            if (_packet != null)
                _manager.PoolRecycle(_packet);
            _packet = null;
            _manager.RecycleEvent(_evt);
        }

        public void Recycle()
        {
            if (_manager.AutoRecycle)
                return;
            RecycleInternal();
        }
    }

    internal sealed class NetEvent
    {
        public NetEvent Next;

        public enum EType
        {
            Connect,
            Disconnect,
            Receive,
            ReceiveUnconnected,
            Error,
            ConnectionLatencyUpdated,
            Broadcast,
            ConnectionRequest,
            MessageDelivered,
            PeerAddressChanged
        }
        public EType Type;

        public NetPeer Peer;
        public IPEndPoint RemoteEndPoint;
        public object UserData;
        public int Latency;
        public SocketError ErrorCode;
        public DisconnectReason DisconnectReason;
        public ConnectionRequest ConnectionRequest;
        public DeliveryMethod DeliveryMethod;
        public byte ChannelNumber;
        public readonly NetPacketReader DataReader;

        public NetEvent(NetManager manager)
        {
            DataReader = new(manager, this);
        }
    }

    /// <summary>
    /// Main class for all network operations. Can be used as client and/or server.
    /// </summary>
    public partial class NetManager : IEnumerable<NetPeer>
    {
        public struct NetPeerEnumerator : IEnumerator<NetPeer>
        {
            private readonly NetPeer _initialPeer;
            private NetPeer _p;

            public NetPeerEnumerator(NetPeer p)
            {
                _initialPeer = p;
                _p = null;
            }

            public void Dispose()
            {

            }

            public bool MoveNext()
            {
                _p = _p == null ? _initialPeer : _p.NextPeer;
                return _p != null;
            }

            public void Reset()
            {
                throw new NotSupportedException();
            }

            public NetPeer Current => _p;
            object IEnumerator.Current => _p;
        }

#if DEBUG
        private struct IncomingData
        {
            public NetPacket Data;
            public IPEndPoint EndPoint;
            public DateTime TimeWhenGet;
        }
        private readonly List<IncomingData> _pingSimulationList = new();
        private readonly Random _randomGenerator = new();
        private const int MinLatencyThreshold = 5;
#endif

        private Thread _logicThread;
        private bool _manualMode;
        private readonly AutoResetEvent _updateTriggerEvent = new(true);

        private NetEvent _pendingEventHead;
        private NetEvent _pendingEventTail;

        private NetEvent _netEventPoolHead;
        private readonly INetEventListener _netEventListener;
        private readonly IDeliveryEventListener _deliveryEventListener;
        private readonly INtpEventListener _ntpEventListener;
        private readonly IPeerAddressChangedListener _peerAddressChangedListener;

        private readonly Dictionary<IPEndPoint, ConnectionRequest> _requestsDict = new();
        private readonly ConcurrentDictionary<IPEndPoint, NtpRequest> _ntpRequests = new();
        private long _connectedPeersCount;
        private readonly List<NetPeer> _connectedPeerListCache = new();
        private readonly PacketLayerBase _extraPacketLayer;
        private int _nextPeerId;
        private ConcurrentQueue<int> _peerIds = new();
        private byte _channelsCount = 1;
        private readonly object _eventLock = new();

        //config section
        /// <summary>
        /// Enable messages receiving without connection. (with SendUnconnectedMessage method)
        /// </summary>
        public bool UnconnectedMessagesEnabled = false;

        /// <summary>
        /// Enable nat punch messages
        /// </summary>
        public bool NatPunchEnabled = false;

        /// <summary>
        /// Library logic update and send period in milliseconds
        /// Lowest values in Windows doesn't change much because of Thread.Sleep precision
        /// To more frequent sends (or sends tied to your game logic) use <see cref="TriggerUpdate"/>
        /// </summary>
        public int UpdateTime = 15;

        /// <summary>
        /// Interval for latency detection and checking connection (in milliseconds)
        /// </summary>
        public int PingInterval = 1000;

        /// <summary>
        /// If NetManager doesn't receive any packet from remote peer during this time (in milliseconds) then connection will be closed
        /// (including library internal keepalive packets)
        /// </summary>
        public int DisconnectTimeout = 5000;

        /// <summary>
        /// Simulate packet loss by dropping random amount of packets. (Works only in DEBUG mode)
        /// </summary>
        public bool SimulatePacketLoss = false;

        /// <summary>
        /// Simulate latency by holding packets for random time. (Works only in DEBUG mode)
        /// </summary>
        public bool SimulateLatency = false;

        /// <summary>
        /// Chance of packet loss when simulation enabled. value in percents (1 - 100).
        /// </summary>
        public int SimulationPacketLossChance = 10;

        /// <summary>
        /// Minimum simulated latency (in milliseconds)
        /// </summary>
        public int SimulationMinLatency = 30;

        /// <summary>
        /// Maximum simulated latency (in milliseconds)
        /// </summary>
        public int SimulationMaxLatency = 100;

        /// <summary>
        /// Events automatically will be called without PollEvents method from another thread
        /// </summary>
        public bool UnsyncedEvents = false;

        /// <summary>
        /// If true - receive event will be called from "receive" thread immediately otherwise on PollEvents call
        /// </summary>
        public bool UnsyncedReceiveEvent = false;

        /// <summary>
        /// If true - delivery event will be called from "receive" thread immediately otherwise on PollEvents call
        /// </summary>
        public bool UnsyncedDeliveryEvent = false;

        /// <summary>
        /// Allows receive broadcast packets
        /// </summary>
        public bool BroadcastReceiveEnabled = false;

        /// <summary>
        /// Delay between initial connection attempts (in milliseconds)
        /// </summary>
        public int ReconnectDelay = 500;

        /// <summary>
        /// Maximum connection attempts before client stops and call disconnect event.
        /// </summary>
        public int MaxConnectAttempts = 10;

        /// <summary>
        /// Enables socket option "ReuseAddress" for specific purposes
        /// </summary>
        public bool ReuseAddress = false;

        /// <summary>
        /// UDP Only Socket Option
        /// Normally IP sockets send packets of data through routers and gateways until they reach the final destination.
        /// If the DontRoute flag is set to True, then data will be delivered on the local subnet only.
        /// </summary>
        public bool DontRoute = false;

        /// <summary>
        /// Statistics of all connections
        /// </summary>
        public readonly NetStatistics Statistics = new();

        /// <summary>
        /// Toggles the collection of network statistics for the instance and all known peers
        /// </summary>
        public bool EnableStatistics = false;

        /// <summary>
        /// NatPunchModule for NAT hole punching operations
        /// </summary>
        public readonly NatPunchModule NatPunchModule;

        /// <summary>
        /// Returns true if socket listening and update thread is running
        /// </summary>
        public bool IsRunning { get; private set; }

        /// <summary>
        /// Local EndPoint (host and port)
        /// </summary>
        public int LocalPort { get; private set; }

        /// <summary>
        /// Automatically recycle NetPacketReader after OnReceive event
        /// </summary>
        public bool AutoRecycle;

        /// <summary>
        /// IPv6 support
        /// </summary>
        public bool IPv6Enabled = true;

        /// <summary>
        /// Override MTU for all new peers registered in this NetManager, will ignores MTU Discovery!
        /// </summary>
        public int MtuOverride = 0;

        /// <summary>
        /// Sets initial MTU to lowest possible value according to RFC1191 (576 bytes)
        /// </summary>
        public bool UseSafeMtu = false;

        /// <summary>
        /// First peer. Useful for Client mode
        /// </summary>
        public NetPeer FirstPeer => _headPeer;

        /// <summary>
        /// Experimental feature mostly for servers. Only for Windows/Linux
        /// use direct socket calls for send/receive to drastically increase speed and reduce GC pressure
        /// </summary>
        public bool UseNativeSockets = false;

        /// <summary>
        /// Disconnect peers if HostUnreachable or NetworkUnreachable spawned (old behaviour 0.9.x was true)
        /// </summary>
        public bool DisconnectOnUnreachable = false;

        /// <summary>
        /// Allows peer change it's ip (lte to wifi, wifi to lte, etc). Use only on server
        /// </summary>
        public bool AllowPeerAddressChange = false;

        /// <summary>
        /// QoS channel count per message type (value must be between 1 and 64 channels)
        /// </summary>
        public byte ChannelsCount
        {
            get => _channelsCount;
            set
            {
                if (value < 1 || value > 64)
                    throw new ArgumentException("Channels count must be between 1 and 64");
                _channelsCount = value;
            }
        }

        /// <summary>
        /// Returns connected peers list (with internal cached list)
        /// </summary>
        public List<NetPeer> ConnectedPeerList
        {
            get
            {
                GetPeersNonAlloc(_connectedPeerListCache, ConnectionState.Connected);
                return _connectedPeerListCache;
            }
        }

        /// <summary>
        /// Returns connected peers count
        /// </summary>
        public int ConnectedPeersCount => (int)Interlocked.Read(ref _connectedPeersCount);

        public int ExtraPacketSizeForLayer => _extraPacketLayer?.ExtraPacketSizeForLayer ?? 0;

        public NetManager(bool useSocketFix = true)
        {
            _useSocketFix = useSocketFix;
        }
        /// <summary>
        /// NetManager constructor
        /// </summary>
        /// <param name="listener">Network events listener (also can implement IDeliveryEventListener)</param>
        /// <param name="extraPacketLayer">Extra processing of packages, like CRC checksum or encryption. All connected NetManagers must have same layer.</param>
#if UNITY_SOCKET_FIX
        public NetManager(INetEventListener listener, PacketLayerBase extraPacketLayer = null, bool useSocketFix = true)
        {
            _useSocketFix = useSocketFix;
#else
        public NetManager(INetEventListener listener, PacketLayerBase extraPacketLayer = null)
        {
#endif
            _netEventListener = listener;
            _deliveryEventListener = listener as IDeliveryEventListener;
            _ntpEventListener = listener as INtpEventListener;
            _peerAddressChangedListener = listener as IPeerAddressChangedListener;
            NatPunchModule = new(this);
            _extraPacketLayer = extraPacketLayer;
        }

        internal void ConnectionLatencyUpdated(NetPeer fromPeer, int latency)
        {
            CreateEvent(NetEvent.EType.ConnectionLatencyUpdated, fromPeer, latency: latency);
        }

        internal void MessageDelivered(NetPeer fromPeer, object userData)
        {
            if (_deliveryEventListener != null)
                CreateEvent(NetEvent.EType.MessageDelivered, fromPeer, userData: userData);
        }

        internal void DisconnectPeerForce(NetPeer peer,
            DisconnectReason reason,
            SocketError socketErrorCode,
            NetPacket eventData)
        {
            DisconnectPeer(peer, reason, socketErrorCode, true, null, 0, 0, eventData);
        }

        private void DisconnectPeer(
            NetPeer peer,
            DisconnectReason reason,
            SocketError socketErrorCode,
            bool force,
            byte[] data,
            int start,
            int count,
            NetPacket eventData)
        {
            var shutdownResult = peer.Shutdown(data, start, count, force);
            if (shutdownResult == ShutdownResult.None)
                return;
            if (shutdownResult == ShutdownResult.WasConnected)
                Interlocked.Decrement(ref _connectedPeersCount);
            CreateEvent(
                NetEvent.EType.Disconnect,
                peer,
                errorCode: socketErrorCode,
                disconnectReason: reason,
                readerSource: eventData);
        }

        private void CreateEvent(
            NetEvent.EType type,
            NetPeer peer = null,
            IPEndPoint remoteEndPoint = null,
            SocketError errorCode = 0,
            int latency = 0,
            DisconnectReason disconnectReason = DisconnectReason.ConnectionFailed,
            ConnectionRequest connectionRequest = null,
            DeliveryMethod deliveryMethod = DeliveryMethod.Unreliable,
            byte channelNumber = 0,
            NetPacket readerSource = null,
            object userData = null)
        {
            NetEvent evt;
            bool unsyncEvent = UnsyncedEvents;

            if (type == NetEvent.EType.Connect)
                Interlocked.Increment(ref _connectedPeersCount);
            else if (type == NetEvent.EType.MessageDelivered)
                unsyncEvent = UnsyncedDeliveryEvent;

            lock (_eventLock)
            {
                evt = _netEventPoolHead;
                if (evt == null)
                    evt = new(this);
                else
                    _netEventPoolHead = evt.Next;
            }

            evt.Next = null;
            evt.Type = type;
            evt.DataReader.SetSource(readerSource, readerSource?.GetHeaderSize() ?? 0);
            evt.Peer = peer;
            evt.RemoteEndPoint = remoteEndPoint;
            evt.Latency = latency;
            evt.ErrorCode = errorCode;
            evt.DisconnectReason = disconnectReason;
            evt.ConnectionRequest = connectionRequest;
            evt.DeliveryMethod = deliveryMethod;
            evt.ChannelNumber = channelNumber;
            evt.UserData = userData;

            if (unsyncEvent || _manualMode)
            {
                ProcessEvent(evt);
            }
            else
            {
                lock (_eventLock)
                {
                    if (_pendingEventTail == null)
                        _pendingEventHead = evt;
                    else
                        _pendingEventTail.Next = evt;
                    _pendingEventTail = evt;
                }
            }
        }

        private void ProcessEvent(NetEvent evt)
        {
            NetDebug.Write("[NM] Processing event: " + evt.Type);
            bool emptyData = evt.DataReader.IsNull;
            switch (evt.Type)
            {
                case NetEvent.EType.Connect:
                    _netEventListener.OnPeerConnected(evt.Peer);
                    break;
                case NetEvent.EType.Disconnect:
                    var info = new DisconnectInfo
                    {
                        Reason = evt.DisconnectReason,
                        AdditionalData = evt.DataReader,
                        SocketErrorCode = evt.ErrorCode
                    };
                    _netEventListener.OnPeerDisconnected(evt.Peer, info);
                    RemovePeer(evt.Peer);
                    break;
                case NetEvent.EType.Receive:
                    _netEventListener.OnNetworkReceive(evt.Peer, evt.DataReader, evt.ChannelNumber, evt.DeliveryMethod);
                    break;
                case NetEvent.EType.ReceiveUnconnected:
                    _netEventListener.OnNetworkReceiveUnconnected(evt.RemoteEndPoint, evt.DataReader, UnconnectedMessageType.BasicMessage);
                    break;
                case NetEvent.EType.Broadcast:
                    _netEventListener.OnNetworkReceiveUnconnected(evt.RemoteEndPoint, evt.DataReader, UnconnectedMessageType.Broadcast);
                    break;
                case NetEvent.EType.Error:
                    _netEventListener.OnNetworkError(evt.RemoteEndPoint, evt.ErrorCode);
                    RemovePeer(evt.Peer);
                    break;
                case NetEvent.EType.ConnectionLatencyUpdated:
                    _netEventListener.OnNetworkLatencyUpdate(evt.Peer, evt.Latency);
                    break;
                case NetEvent.EType.ConnectionRequest:
                    _netEventListener.OnConnectionRequest(evt.ConnectionRequest);
                    break;
                case NetEvent.EType.MessageDelivered:
                    _deliveryEventListener.OnMessageDelivered(evt.Peer, evt.UserData);
                    break;
                case NetEvent.EType.PeerAddressChanged:
                    _peersLock.EnterUpgradeableReadLock();
                    IPEndPoint previousAddress = null;
                    if (ContainsPeer(evt.Peer))
                    {
                        _peersLock.EnterWriteLock();
                        RemovePeerFromSet(evt.Peer);
                        previousAddress = new(evt.Peer.Address, evt.Peer.Port);
                        evt.Peer.FinishEndPointChange(evt.RemoteEndPoint);
                        AddPeerToSet(evt.Peer);
                        _peersLock.ExitWriteLock();
                    }
                    _peersLock.ExitUpgradeableReadLock();
                    if (previousAddress != null && _peerAddressChangedListener != null)
                        _peerAddressChangedListener.OnPeerAddressChanged(evt.Peer, previousAddress);
                    break;
            }
            //Recycle if not message
            if (emptyData)
                RecycleEvent(evt);
            else if (AutoRecycle)
                evt.DataReader.RecycleInternal();
        }

        internal void RecycleEvent(NetEvent evt)
        {
            evt.Peer = null;
            evt.ErrorCode = 0;
            evt.RemoteEndPoint = null;
            evt.ConnectionRequest = null;
            lock (_eventLock)
            {
                evt.Next = _netEventPoolHead;
                _netEventPoolHead = evt;
            }
        }

        //Update function
        private void UpdateLogic()
        {
            var peersToRemove = new List<NetPeer>();
            var stopwatch = new Stopwatch();
            stopwatch.Start();

            while (IsRunning)
            {
                try
                {
                    ProcessDelayedPackets();
                    int elapsed = (int)stopwatch.ElapsedMilliseconds;
                    elapsed = elapsed <= 0 ? 1 : elapsed;
                    stopwatch.Restart();

                    for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
                    {
                        if (netPeer.ConnectionState == ConnectionState.Disconnected &&
                            netPeer.TimeSinceLastPacket > DisconnectTimeout)
                        {
                            peersToRemove.Add(netPeer);
                        }
                        else
                        {
                            netPeer.Update(elapsed);
                        }
                    }

                    if (peersToRemove.Count > 0)
                    {
                        _peersLock.EnterWriteLock();
                        for (int i = 0; i < peersToRemove.Count; i++)
                            RemovePeerInternal(peersToRemove[i]);
                        _peersLock.ExitWriteLock();
                        peersToRemove.Clear();
                    }

                    ProcessNtpRequests(elapsed);

                    int sleepTime = UpdateTime - (int)stopwatch.ElapsedMilliseconds;
                    if (sleepTime > 0)
                        _updateTriggerEvent.WaitOne(sleepTime);
                }
                catch (ThreadAbortException)
                {
                    return;
                }
                catch (Exception e)
                {
                    NetDebug.WriteError("[NM] LogicThread error: " + e);
                }
            }
            stopwatch.Stop();
        }

        [Conditional("DEBUG")]
        private void ProcessDelayedPackets()
        {
#if DEBUG
            if (!SimulateLatency)
                return;

            var time = DateTime.UtcNow;
            lock (_pingSimulationList)
            {
                for (int i = 0; i < _pingSimulationList.Count; i++)
                {
                    var incomingData = _pingSimulationList[i];
                    if (incomingData.TimeWhenGet <= time)
                    {
                        DebugMessageReceived(incomingData.Data, incomingData.EndPoint);
                        _pingSimulationList.RemoveAt(i);
                        i--;
                    }
                }
            }
#endif
        }

        private void ProcessNtpRequests(int elapsedMilliseconds)
        {
            List<IPEndPoint> requestsToRemove = null;
            foreach (var ntpRequest in _ntpRequests)
            {
                ntpRequest.Value.Send(_udpSocketv4, elapsedMilliseconds);
                if (ntpRequest.Value.NeedToKill)
                {
                    if (requestsToRemove == null)
                        requestsToRemove = new();
                    requestsToRemove.Add(ntpRequest.Key);
                }
            }

            if (requestsToRemove != null)
            {
                foreach (var ipEndPoint in requestsToRemove)
                {
                    _ntpRequests.TryRemove(ipEndPoint, out _);
                }
            }
        }

        /// <summary>
        /// Update and send logic. Use this only when NetManager started in manual mode
        /// </summary>
        /// <param name="elapsedMilliseconds">elapsed milliseconds since last update call</param>
        public void ManualUpdate(int elapsedMilliseconds)
        {
            if (!_manualMode)
                return;

            for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
            {
                if (netPeer.ConnectionState == ConnectionState.Disconnected && netPeer.TimeSinceLastPacket > DisconnectTimeout)
                {
                    RemovePeerInternal(netPeer);
                }
                else
                {
                    netPeer.Update(elapsedMilliseconds);
                }
            }
            ProcessNtpRequests(elapsedMilliseconds);
        }

        internal NetPeer OnConnectionSolved(ConnectionRequest request, byte[] rejectData, int start, int length)
        {
            NetPeer netPeer = null;

            if (request.Result == ConnectionRequestResult.RejectForce)
            {
                NetDebug.Write(NetLogLevel.Trace, "[NM] Peer connect reject force.");
                if (rejectData != null && length > 0)
                {
                    var shutdownPacket = PoolGetWithProperty(PacketProperty.Disconnect, length);
                    shutdownPacket.ConnectionNumber = request.InternalPacket.ConnectionNumber;
                    FastBitConverter.GetBytes(shutdownPacket.RawData, 1, request.InternalPacket.ConnectionTime);
                    if (shutdownPacket.Size >= NetConstants.PossibleMtu[0])
                        NetDebug.WriteError("[Peer] Disconnect additional data size more than MTU!");
                    else
                        Buffer.BlockCopy(rejectData, start, shutdownPacket.RawData, 9, length);
                    SendRawAndRecycle(shutdownPacket, request.RemoteEndPoint);
                }
                lock (_requestsDict)
                    _requestsDict.Remove(request.RemoteEndPoint);
            }
            else lock (_requestsDict)
                {
                    if (TryGetPeer(request.RemoteEndPoint, out netPeer))
                    {
                        //already have peer
                    }
                    else if (request.Result == ConnectionRequestResult.Reject)
                    {
                        netPeer = new(this, request.RemoteEndPoint, GetNextPeerId());
                        netPeer.Reject(request.InternalPacket, rejectData, start, length);
                        AddPeer(netPeer);
                        NetDebug.Write(NetLogLevel.Trace, "[NM] Peer connect reject.");
                    }
                    else //Accept
                    {
                        netPeer = new(this, request, GetNextPeerId());
                        AddPeer(netPeer);
                        CreateEvent(NetEvent.EType.Connect, netPeer);
                        NetDebug.Write(NetLogLevel.Trace, $"[NM] Received peer connection Id: {netPeer.ConnectTime}, EP: {netPeer}");
                    }
                    _requestsDict.Remove(request.RemoteEndPoint);
                }

            return netPeer;
        }

        private int GetNextPeerId()
        {
            /* Build a small queue so that when fetching
            * an id its unlikely to be one that was just returned. This adds
            * a buffer to applications which may be using the Id to identity
            * clients in their code, but may need time to dispose of objects
            * associated with the Id. */
            const int addCount = 5000;
            const int halfCount = (addCount / 2);
            if (_peerIds.Count < halfCount)
            {
                //At most how many can be added.
                const int maxIdValue = int.MaxValue;
                long addable = Math.Min(addCount, (maxIdValue - _nextPeerId));

                if (addable == 0)
                {
                    NetDebug.Write(NetLogLevel.Error, $"[NM] PeerIds have exceeded the maximum value of {maxIdValue}. A new Id cannot be returned.");
                    return 0;
                }

                for (int i = 0; i < addCount; i++)
                    _peerIds.Enqueue(_nextPeerId++);
            }

            return (_peerIds.TryDequeue(out int result)) ? result : _nextPeerId++;
        }

        private void ProcessConnectRequest(
            IPEndPoint remoteEndPoint,
            NetPeer netPeer,
            NetConnectRequestPacket connRequest)
        {
            //if we have peer
            if (netPeer != null)
            {
                var processResult = netPeer.ProcessConnectRequest(connRequest);
                NetDebug.Write($"ConnectRequest LastId: {netPeer.ConnectTime}, NewId: {connRequest.ConnectionTime}, EP: {remoteEndPoint}, Result: {processResult}");

                switch (processResult)
                {
                    case ConnectRequestResult.Reconnection:
                        DisconnectPeerForce(netPeer, DisconnectReason.Reconnect, 0, null);
                        RemovePeer(netPeer);
                        //go to new connection
                        break;
                    case ConnectRequestResult.NewConnection:
                        RemovePeer(netPeer);
                        //go to new connection
                        break;
                    case ConnectRequestResult.P2PLose:
                        DisconnectPeerForce(netPeer, DisconnectReason.PeerToPeerConnection, 0, null);
                        RemovePeer(netPeer);
                        //go to new connection
                        break;
                    default:
                        //no operations needed
                        return;
                }
                //ConnectRequestResult.NewConnection
                //Set next connection number
                if (processResult != ConnectRequestResult.P2PLose)
                    connRequest.ConnectionNumber = (byte)((netPeer.ConnectionNum + 1) % NetConstants.MaxConnectionNumber);
                //To reconnect peer
            }
            else
            {
                NetDebug.Write($"ConnectRequest Id: {connRequest.ConnectionTime}, EP: {remoteEndPoint}");
            }

            ConnectionRequest req;
            lock (_requestsDict)
            {
                if (_requestsDict.TryGetValue(remoteEndPoint, out req))
                {
                    req.UpdateRequest(connRequest);
                    return;
                }
                req = new(remoteEndPoint, connRequest, this);
                _requestsDict.Add(remoteEndPoint, req);
            }
            NetDebug.Write($"[NM] Creating request event: {connRequest.ConnectionTime}");
            CreateEvent(NetEvent.EType.ConnectionRequest, connectionRequest: req);
        }

        private void OnMessageReceived(NetPacket packet, IPEndPoint remoteEndPoint)
        {
            if (packet.Size == 0)
            {
                PoolRecycle(packet);
                return;
            }
#if DEBUG
            if (SimulatePacketLoss && _randomGenerator.NextDouble() * 100 < SimulationPacketLossChance)
            {
                //drop packet
                return;
            }
            if (SimulateLatency)
            {
                int latency = _randomGenerator.Next(SimulationMinLatency, SimulationMaxLatency);
                if (latency > MinLatencyThreshold)
                {
                    lock (_pingSimulationList)
                    {
                        _pingSimulationList.Add(new()
                        {
                            Data = packet,
                            EndPoint = remoteEndPoint,
                            TimeWhenGet = DateTime.UtcNow.AddMilliseconds(latency)
                        });
                    }
                    //hold packet
                    return;
                }
            }

            //ProcessEvents
            DebugMessageReceived(packet, remoteEndPoint);
        }

        private void DebugMessageReceived(NetPacket packet, IPEndPoint remoteEndPoint)
        {
#endif
            var originalPacketSize = packet.Size;
            if (EnableStatistics)
            {
                Statistics.IncrementPacketsReceived();
                Statistics.AddBytesReceived(originalPacketSize);
            }

            if (_ntpRequests.Count > 0 && _ntpRequests.TryGetValue(remoteEndPoint, out var request))
            {
                if (packet.Size < 48)
                {
                    NetDebug.Write(NetLogLevel.Trace, $"NTP response too short: {packet.Size}");
                    return;
                }

                byte[] copiedData = new byte[packet.Size];
                Buffer.BlockCopy(packet.RawData, 0, copiedData, 0, packet.Size);
                NtpPacket ntpPacket = NtpPacket.FromServerResponse(copiedData, DateTime.UtcNow);
                try
                {
                    ntpPacket.ValidateReply();
                }
                catch (InvalidOperationException ex)
                {
                    NetDebug.Write(NetLogLevel.Trace, $"NTP response error: {ex.Message}");
                    ntpPacket = null;
                }

                if (ntpPacket != null)
                {
                    _ntpRequests.TryRemove(remoteEndPoint, out _);
                    _ntpEventListener?.OnNtpResponse(ntpPacket);
                }
                return;
            }

            if (_extraPacketLayer != null)
            {
                _extraPacketLayer.ProcessInboundPacket(ref remoteEndPoint, ref packet.RawData, ref packet.Size);
                if (packet.Size == 0)
                    return;
            }

            if (!packet.Verify())
            {
                NetDebug.WriteError("[NM] DataReceived: bad!");
                PoolRecycle(packet);
                return;
            }

            switch (packet.Property)
            {
                //special case connect request
                case PacketProperty.ConnectRequest:
                    if (NetConnectRequestPacket.GetProtocolId(packet) != NetConstants.ProtocolId)
                    {
                        SendRawAndRecycle(PoolGetWithProperty(PacketProperty.InvalidProtocol), remoteEndPoint);
                        return;
                    }
                    break;
                //unconnected messages
                case PacketProperty.Broadcast:
                    if (!BroadcastReceiveEnabled)
                        return;
                    CreateEvent(NetEvent.EType.Broadcast, remoteEndPoint: remoteEndPoint, readerSource: packet);
                    return;
                case PacketProperty.UnconnectedMessage:
                    if (!UnconnectedMessagesEnabled)
                        return;
                    CreateEvent(NetEvent.EType.ReceiveUnconnected, remoteEndPoint: remoteEndPoint, readerSource: packet);
                    return;
                case PacketProperty.NatMessage:
                    if (NatPunchEnabled)
                        NatPunchModule.ProcessMessage(remoteEndPoint, packet);
                    return;
            }

            //Check normal packets
            bool peerFound = remoteEndPoint is NetPeer netPeer || TryGetPeer(remoteEndPoint, out netPeer);

            if (peerFound && EnableStatistics)
            {
                netPeer.Statistics.IncrementPacketsReceived();
                netPeer.Statistics.AddBytesReceived(originalPacketSize);
            }

            switch (packet.Property)
            {
                case PacketProperty.ConnectRequest:
                    var connRequest = NetConnectRequestPacket.FromData(packet);
                    if (connRequest != null)
                        ProcessConnectRequest(remoteEndPoint, netPeer, connRequest);
                    break;
                case PacketProperty.PeerNotFound:
                    if (peerFound) //local
                    {
                        if (netPeer.ConnectionState != ConnectionState.Connected)
                            return;
                        if (packet.Size == 1)
                        {
                            //first reply
                            //send NetworkChanged packet
                            netPeer.ResetMtu();
                            SendRaw(NetConnectAcceptPacket.MakeNetworkChanged(netPeer), remoteEndPoint);
                            NetDebug.Write($"PeerNotFound sending connection info: {remoteEndPoint}");
                        }
                        else if (packet.Size == 2 && packet.RawData[1] == 1)
                        {
                            //second reply
                            DisconnectPeerForce(netPeer, DisconnectReason.PeerNotFound, 0, null);
                        }
                    }
                    else if (packet.Size > 1) //remote
                    {
                        //check if this is old peer
                        bool isOldPeer = false;

                        if (AllowPeerAddressChange)
                        {
                            NetDebug.Write($"[NM] Looks like address change: {packet.Size}");
                            var remoteData = NetConnectAcceptPacket.FromData(packet);
                            if (remoteData != null &&
                                remoteData.PeerNetworkChanged &&
                                remoteData.PeerId < _peersArray.Length)
                            {
                                _peersLock.EnterUpgradeableReadLock();
                                var peer = _peersArray[remoteData.PeerId];
                                _peersLock.ExitUpgradeableReadLock();
                                if (peer != null &&
                                    peer.ConnectTime == remoteData.ConnectionTime &&
                                    peer.ConnectionNum == remoteData.ConnectionNumber)
                                {
                                    if (peer.ConnectionState == ConnectionState.Connected)
                                    {
                                        peer.InitiateEndPointChange();
                                        CreateEvent(NetEvent.EType.PeerAddressChanged, peer, remoteEndPoint);
                                        NetDebug.Write("[NM] PeerNotFound change address of remote peer");
                                    }
                                    isOldPeer = true;
                                }
                            }
                        }

                        PoolRecycle(packet);

                        //else peer really not found
                        if (!isOldPeer)
                        {
                            var secondResponse = PoolGetWithProperty(PacketProperty.PeerNotFound, 1);
                            secondResponse.RawData[1] = 1;
                            SendRawAndRecycle(secondResponse, remoteEndPoint);
                        }
                    }
                    break;
                case PacketProperty.InvalidProtocol:
                    if (peerFound && netPeer.ConnectionState == ConnectionState.Outgoing)
                        DisconnectPeerForce(netPeer, DisconnectReason.InvalidProtocol, 0, null);
                    break;
                case PacketProperty.Disconnect:
                    if (peerFound)
                    {
                        var disconnectResult = netPeer.ProcessDisconnect(packet);
                        if (disconnectResult == DisconnectResult.None)
                        {
                            PoolRecycle(packet);
                            return;
                        }
                        DisconnectPeerForce(
                            netPeer,
                            disconnectResult == DisconnectResult.Disconnect
                            ? DisconnectReason.RemoteConnectionClose
                            : DisconnectReason.ConnectionRejected,
                            0, packet);
                    }
                    else
                    {
                        PoolRecycle(packet);
                    }
                    //Send shutdown
                    SendRawAndRecycle(PoolGetWithProperty(PacketProperty.ShutdownOk), remoteEndPoint);
                    break;
                case PacketProperty.ConnectAccept:
                    if (!peerFound)
                        return;
                    var connAccept = NetConnectAcceptPacket.FromData(packet);
                    if (connAccept != null && netPeer.ProcessConnectAccept(connAccept))
                        CreateEvent(NetEvent.EType.Connect, netPeer);
                    break;
                default:
                    if (peerFound)
                        netPeer.ProcessPacket(packet);
                    else
                        SendRawAndRecycle(PoolGetWithProperty(PacketProperty.PeerNotFound), remoteEndPoint);
                    break;
            }
        }

        internal void CreateReceiveEvent(NetPacket packet, DeliveryMethod method, byte channelNumber, int headerSize, NetPeer fromPeer)
        {
            NetEvent evt;

            if (UnsyncedEvents || UnsyncedReceiveEvent || _manualMode)
            {
                lock (_eventLock)
                {
                    evt = _netEventPoolHead;
                    if (evt == null)
                        evt = new(this);
                    else
                        _netEventPoolHead = evt.Next;
                }
                evt.Next = null;
                evt.Type = NetEvent.EType.Receive;
                evt.DataReader.SetSource(packet, headerSize);
                evt.Peer = fromPeer;
                evt.DeliveryMethod = method;
                evt.ChannelNumber = channelNumber;
                ProcessEvent(evt);
            }
            else
            {
                lock (_eventLock)
                {
                    evt = _netEventPoolHead;
                    if (evt == null)
                        evt = new(this);
                    else
                        _netEventPoolHead = evt.Next;

                    evt.Next = null;
                    evt.Type = NetEvent.EType.Receive;
                    evt.DataReader.SetSource(packet, headerSize);
                    evt.Peer = fromPeer;
                    evt.DeliveryMethod = method;
                    evt.ChannelNumber = channelNumber;

                    if (_pendingEventTail == null)
                        _pendingEventHead = evt;
                    else
                        _pendingEventTail.Next = evt;
                    _pendingEventTail = evt;
                }
            }
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="writer">DataWriter with data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(NetDataWriter writer, DeliveryMethod options)
        {
            SendToAll(writer.Data, 0, writer.Length, options);
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(byte[] data, DeliveryMethod options)
        {
            SendToAll(data, 0, data.Length, options);
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(byte[] data, int start, int length, DeliveryMethod options)
        {
            SendToAll(data, start, length, 0, options);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="writer">DataWriter with data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(NetDataWriter writer, byte channelNumber, DeliveryMethod options)
        {
            SendToAll(writer.Data, 0, writer.Length, channelNumber, options);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(byte[] data, byte channelNumber, DeliveryMethod options)
        {
            SendToAll(data, 0, data.Length, channelNumber, options);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(byte[] data, int start, int length, byte channelNumber, DeliveryMethod options)
        {
            try
            {
                _peersLock.EnterReadLock();
                for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
                    netPeer.Send(data, start, length, channelNumber, options);
            }
            finally
            {
                _peersLock.ExitReadLock();
            }
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="writer">DataWriter with data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(NetDataWriter writer, DeliveryMethod options, NetPeer excludePeer)
        {
            SendToAll(writer.Data, 0, writer.Length, 0, options, excludePeer);
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(byte[] data, DeliveryMethod options, NetPeer excludePeer)
        {
            SendToAll(data, 0, data.Length, 0, options, excludePeer);
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(byte[] data, int start, int length, DeliveryMethod options, NetPeer excludePeer)
        {
            SendToAll(data, start, length, 0, options, excludePeer);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="writer">DataWriter with data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(NetDataWriter writer, byte channelNumber, DeliveryMethod options, NetPeer excludePeer)
        {
            SendToAll(writer.Data, 0, writer.Length, channelNumber, options, excludePeer);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(byte[] data, byte channelNumber, DeliveryMethod options, NetPeer excludePeer)
        {
            SendToAll(data, 0, data.Length, channelNumber, options, excludePeer);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(byte[] data, int start, int length, byte channelNumber, DeliveryMethod options, NetPeer excludePeer)
        {
            try
            {
                _peersLock.EnterReadLock();
                for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
                {
                    if (netPeer != excludePeer)
                        netPeer.Send(data, start, length, channelNumber, options);
                }
            }
            finally
            {
                _peersLock.ExitReadLock();
            }
        }

#if LITENETLIB_SPANS || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1 || NETCOREAPP3_1 || NET5_0 || NETSTANDARD2_1
        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        public void SendToAll(ReadOnlySpan<byte> data, DeliveryMethod options)
        {
            SendToAll(data, 0, options, null);
        }

        /// <summary>
        /// Send data to all connected peers (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(ReadOnlySpan<byte> data, DeliveryMethod options, NetPeer excludePeer)
        {
            SendToAll(data, 0, options, excludePeer);
        }

        /// <summary>
        /// Send data to all connected peers
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <param name="excludePeer">Excluded peer</param>
        public void SendToAll(ReadOnlySpan<byte> data, byte channelNumber, DeliveryMethod options, NetPeer excludePeer)
        {
            try
            {
                _peersLock.EnterReadLock();
                for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
                {
                    if (netPeer != excludePeer)
                        netPeer.Send(data, channelNumber, options);
                }
            }
            finally
            {
                _peersLock.ExitReadLock();
            }
        }
        
        /// <summary>
        /// Send message without connection
        /// </summary>
        /// <param name="message">Raw data</param>
        /// <param name="remoteEndPoint">Packet destination</param>
        /// <returns>Operation result</returns>
        public bool SendUnconnectedMessage(ReadOnlySpan<byte> message, IPEndPoint remoteEndPoint)
        {
            int headerSize = NetPacket.GetHeaderSize(PacketProperty.UnconnectedMessage);
            var packet = PoolGetPacket(message.Length + headerSize);
            packet.Property = PacketProperty.UnconnectedMessage;
            message.CopyTo(new Span<byte>(packet.RawData, headerSize, message.Length));
            return SendRawAndRecycle(packet, remoteEndPoint) > 0;
        }
#endif

        /// <summary>
        /// Start logic thread and listening on available port
        /// </summary>
        public bool Start()
        {
            return Start(0);
        }

        /// <summary>
        /// Start logic thread and listening on selected port
        /// </summary>
        /// <param name="addressIPv4">bind to specific ipv4 address</param>
        /// <param name="addressIPv6">bind to specific ipv6 address</param>
        /// <param name="port">port to listen</param>
        public bool Start(IPAddress addressIPv4, IPAddress addressIPv6, int port)
        {
            return Start(addressIPv4, addressIPv6, port, false);
        }

        /// <summary>
        /// Start logic thread and listening on selected port
        /// </summary>
        /// <param name="addressIPv4">bind to specific ipv4 address</param>
        /// <param name="addressIPv6">bind to specific ipv6 address</param>
        /// <param name="port">port to listen</param>
        public bool Start(string addressIPv4, string addressIPv6, int port)
        {
            IPAddress ipv4 = NetUtils.ResolveAddress(addressIPv4);
            IPAddress ipv6 = NetUtils.ResolveAddress(addressIPv6);
            return Start(ipv4, ipv6, port);
        }

        /// <summary>
        /// Start logic thread and listening on selected port
        /// </summary>
        /// <param name="port">port to listen</param>
        public bool Start(int port)
        {
            return Start(IPAddress.Any, IPAddress.IPv6Any, port);
        }

        /// <summary>
        /// Start in manual mode and listening on selected port
        /// In this mode you should use ManualReceive (without PollEvents) for receive packets
        /// and ManualUpdate(...) for update and send packets
        /// This mode useful mostly for single-threaded servers
        /// </summary>
        /// <param name="addressIPv4">bind to specific ipv4 address</param>
        /// <param name="addressIPv6">bind to specific ipv6 address</param>
        /// <param name="port">port to listen</param>
        public bool StartInManualMode(IPAddress addressIPv4, IPAddress addressIPv6, int port)
        {
            return Start(addressIPv4, addressIPv6, port, true);
        }

        /// <summary>
        /// Start in manual mode and listening on selected port
        /// In this mode you should use ManualReceive (without PollEvents) for receive packets
        /// and ManualUpdate(...) for update and send packets
        /// This mode useful mostly for single-threaded servers
        /// </summary>
        /// <param name="addressIPv4">bind to specific ipv4 address</param>
        /// <param name="addressIPv6">bind to specific ipv6 address</param>
        /// <param name="port">port to listen</param>
        public bool StartInManualMode(string addressIPv4, string addressIPv6, int port)
        {
            IPAddress ipv4 = NetUtils.ResolveAddress(addressIPv4);
            IPAddress ipv6 = NetUtils.ResolveAddress(addressIPv6);
            return StartInManualMode(ipv4, ipv6, port);
        }

        /// <summary>
        /// Start in manual mode and listening on selected port
        /// In this mode you should use ManualReceive (without PollEvents) for receive packets
        /// and ManualUpdate(...) for update and send packets
        /// This mode useful mostly for single-threaded servers
        /// </summary>
        /// <param name="port">port to listen</param>
        public bool StartInManualMode(int port)
        {
            return StartInManualMode(IPAddress.Any, IPAddress.IPv6Any, port);
        }

        /// <summary>
        /// Send message without connection
        /// </summary>
        /// <param name="message">Raw data</param>
        /// <param name="remoteEndPoint">Packet destination</param>
        /// <returns>Operation result</returns>
        public bool SendUnconnectedMessage(byte[] message, IPEndPoint remoteEndPoint)
        {
            return SendUnconnectedMessage(message, 0, message.Length, remoteEndPoint);
        }

        /// <summary>
        /// Send message without connection. WARNING This method allocates a new IPEndPoint object and
        /// synchronously makes a DNS request. If you're calling this method every frame it will be
        /// much faster to just cache the IPEndPoint.
        /// </summary>
        /// <param name="writer">Data serializer</param>
        /// <param name="address">Packet destination IP or hostname</param>
        /// <param name="port">Packet destination port</param>
        /// <returns>Operation result</returns>
        public bool SendUnconnectedMessage(NetDataWriter writer, string address, int port)
        {
            IPEndPoint remoteEndPoint = NetUtils.MakeEndPoint(address, port);

            return SendUnconnectedMessage(writer.Data, 0, writer.Length, remoteEndPoint);
        }

        /// <summary>
        /// Send message without connection
        /// </summary>
        /// <param name="writer">Data serializer</param>
        /// <param name="remoteEndPoint">Packet destination</param>
        /// <returns>Operation result</returns>
        public bool SendUnconnectedMessage(NetDataWriter writer, IPEndPoint remoteEndPoint)
        {
            return SendUnconnectedMessage(writer.Data, 0, writer.Length, remoteEndPoint);
        }

        /// <summary>
        /// Send message without connection
        /// </summary>
        /// <param name="message">Raw data</param>
        /// <param name="start">data start</param>
        /// <param name="length">data length</param>
        /// <param name="remoteEndPoint">Packet destination</param>
        /// <returns>Operation result</returns>
        public bool SendUnconnectedMessage(byte[] message, int start, int length, IPEndPoint remoteEndPoint)
        {
            //No need for CRC here, SendRaw does that
            NetPacket packet = PoolGetWithData(PacketProperty.UnconnectedMessage, message, start, length);
            return SendRawAndRecycle(packet, remoteEndPoint) > 0;
        }

        /// <summary>
        /// Triggers update and send logic immediately (works asynchronously)
        /// </summary>
        public void TriggerUpdate()
        {
            _updateTriggerEvent.Set();
        }

        /// <summary>
        /// Receive "maxProcessedEvents" pending events. Call this in game update code
        /// In Manual mode it will call also socket Receive (which can be slow)
        /// 0 - receive all events
        /// </summary>
        /// <param name="maxProcessedEvents">Max events that will be processed (called INetEventListener Connect/Receive/Etc), 0 - receive all events</param>
        public void PollEvents(int maxProcessedEvents = 0)
        {
            if (_manualMode)
            {
                if (_udpSocketv4 != null)
                    ManualReceive(_udpSocketv4, _bufferEndPointv4, maxProcessedEvents);
                if (_udpSocketv6 != null && _udpSocketv6 != _udpSocketv4)
                    ManualReceive(_udpSocketv6, _bufferEndPointv6, maxProcessedEvents);
                ProcessDelayedPackets();
                return;
            }
            if (UnsyncedEvents)
                return;
            NetEvent pendingEvent;
            lock (_eventLock)
            {
                pendingEvent = _pendingEventHead;
                _pendingEventHead = null;
                _pendingEventTail = null;
            }

            int counter = 0;
            while (pendingEvent != null)
            {
                var next = pendingEvent.Next;
                ProcessEvent(pendingEvent);
                pendingEvent = next;
                counter++;
                if (counter == maxProcessedEvents)
                    break;
            }
        }

        /// <summary>
        /// Connect to remote host
        /// </summary>
        /// <param name="address">Server IP or hostname</param>
        /// <param name="port">Server Port</param>
        /// <param name="key">Connection key</param>
        /// <returns>New NetPeer if new connection, Old NetPeer if already connected, null peer if there is ConnectionRequest awaiting</returns>
        /// <exception cref="InvalidOperationException">Manager is not running. Call <see cref="Start()"/></exception>
        public NetPeer Connect(string address, int port, string key)
        {
            return Connect(address, port, NetDataWriter.FromString(key));
        }

        /// <summary>
        /// Connect to remote host
        /// </summary>
        /// <param name="address">Server IP or hostname</param>
        /// <param name="port">Server Port</param>
        /// <param name="connectionData">Additional data for remote peer</param>
        /// <returns>New NetPeer if new connection, Old NetPeer if already connected, null peer if there is ConnectionRequest awaiting</returns>
        /// <exception cref="InvalidOperationException">Manager is not running. Call <see cref="Start()"/></exception>
        public NetPeer Connect(string address, int port, NetDataWriter connectionData)
        {
            IPEndPoint ep;
            try
            {
                ep = NetUtils.MakeEndPoint(address, port);
            }
            catch
            {
                CreateEvent(NetEvent.EType.Disconnect, disconnectReason: DisconnectReason.UnknownHost);
                return null;
            }
            return Connect(ep, connectionData);
        }

        /// <summary>
        /// Connect to remote host
        /// </summary>
        /// <param name="target">Server end point (ip and port)</param>
        /// <param name="key">Connection key</param>
        /// <returns>New NetPeer if new connection, Old NetPeer if already connected, null peer if there is ConnectionRequest awaiting</returns>
        /// <exception cref="InvalidOperationException">Manager is not running. Call <see cref="Start()"/></exception>
        public NetPeer Connect(IPEndPoint target, string key)
        {
            return Connect(target, NetDataWriter.FromString(key));
        }

        /// <summary>
        /// Connect to remote host
        /// </summary>
        /// <param name="target">Server end point (ip and port)</param>
        /// <param name="connectionData">Additional data for remote peer</param>
        /// <returns>New NetPeer if new connection, Old NetPeer if already connected, null peer if there is ConnectionRequest awaiting</returns>
        /// <exception cref="InvalidOperationException">Manager is not running. Call <see cref="Start()"/></exception>
        public NetPeer Connect(IPEndPoint target, NetDataWriter connectionData)
        {
            if (!IsRunning)
                throw new InvalidOperationException("Client is not running");

            lock (_requestsDict)
            {
                if (_requestsDict.ContainsKey(target))
                    return null;

                byte connectionNumber = 0;
                if (TryGetPeer(target, out var peer))
                {
                    switch (peer.ConnectionState)
                    {
                        //just return already connected peer
                        case ConnectionState.Connected:
                        case ConnectionState.Outgoing:
                            return peer;
                    }
                    //else reconnect
                    connectionNumber = (byte)((peer.ConnectionNum + 1) % NetConstants.MaxConnectionNumber);
                    RemovePeer(peer);
                }

                //Create reliable connection
                //And send connection request
                peer = new(this, target, GetNextPeerId(), connectionNumber, connectionData);
                AddPeer(peer);
                return peer;
            }
        }

        /// <summary>
        /// Force closes connection and stop all threads.
        /// </summary>
        public void Stop()
        {
            Stop(true);
        }

        /// <summary>
        /// Force closes connection and stop all threads.
        /// </summary>
        /// <param name="sendDisconnectMessages">Send disconnect messages</param>
        public void Stop(bool sendDisconnectMessages)
        {
            if (!IsRunning)
                return;
            NetDebug.Write("[NM] Stop");

#if UNITY_SOCKET_FIX
            if (_useSocketFix)
            {
                _pausedSocketFix.Deinitialize();
                _pausedSocketFix = null;
            }
#endif

            //Send last disconnect
            for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
                netPeer.Shutdown(null, 0, 0, !sendDisconnectMessages);

            //Stop
            CloseSocket();
            _updateTriggerEvent.Set();
            if (!_manualMode)
            {
                _logicThread.Join();
                _logicThread = null;
            }

            //clear peers
            ClearPeerSet();
            _peerIds = new();
            _nextPeerId = 0;
#if DEBUG
            lock (_pingSimulationList)
                _pingSimulationList.Clear();
#endif
            _connectedPeersCount = 0;
            _pendingEventHead = null;
            _pendingEventTail = null;
        }

        /// <summary>
        /// Return peers count with connection state
        /// </summary>
        /// <param name="peerState">peer connection state (you can use as bit flags)</param>
        /// <returns>peers count</returns>
        public int GetPeersCount(ConnectionState peerState)
        {
            int count = 0;
            _peersLock.EnterReadLock();
            for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
            {
                if ((netPeer.ConnectionState & peerState) != 0)
                    count++;
            }
            _peersLock.ExitReadLock();
            return count;
        }

        /// <summary>
        /// Get copy of peers (without allocations)
        /// </summary>
        /// <param name="peers">List that will contain result</param>
        /// <param name="peerState">State of peers</param>
        public void GetPeersNonAlloc(List<NetPeer> peers, ConnectionState peerState)
        {
            peers.Clear();
            _peersLock.EnterReadLock();
            for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
            {
                if ((netPeer.ConnectionState & peerState) != 0)
                    peers.Add(netPeer);
            }
            _peersLock.ExitReadLock();
        }

        /// <summary>
        /// Disconnect all peers without any additional data
        /// </summary>
        public void DisconnectAll()
        {
            DisconnectAll(null, 0, 0);
        }

        /// <summary>
        /// Disconnect all peers with shutdown message
        /// </summary>
        /// <param name="data">Data to send (must be less or equal MTU)</param>
        /// <param name="start">Data start</param>
        /// <param name="count">Data count</param>
        public void DisconnectAll(byte[] data, int start, int count)
        {
            //Send disconnect packets
            _peersLock.EnterReadLock();
            for (var netPeer = _headPeer; netPeer != null; netPeer = netPeer.NextPeer)
            {
                DisconnectPeer(
                    netPeer,
                    DisconnectReason.DisconnectPeerCalled,
                    0,
                    false,
                    data,
                    start,
                    count,
                    null);
            }
            _peersLock.ExitReadLock();
        }

        /// <summary>
        /// Immediately disconnect peer from server without additional data
        /// </summary>
        /// <param name="peer">peer to disconnect</param>
        public void DisconnectPeerForce(NetPeer peer)
        {
            DisconnectPeerForce(peer, DisconnectReason.DisconnectPeerCalled, 0, null);
        }

        /// <summary>
        /// Disconnect peer from server
        /// </summary>
        /// <param name="peer">peer to disconnect</param>
        public void DisconnectPeer(NetPeer peer)
        {
            DisconnectPeer(peer, null, 0, 0);
        }

        /// <summary>
        /// Disconnect peer from server and send additional data (Size must be less or equal MTU - 8)
        /// </summary>
        /// <param name="peer">peer to disconnect</param>
        /// <param name="data">additional data</param>
        public void DisconnectPeer(NetPeer peer, byte[] data)
        {
            DisconnectPeer(peer, data, 0, data.Length);
        }

        /// <summary>
        /// Disconnect peer from server and send additional data (Size must be less or equal MTU - 8)
        /// </summary>
        /// <param name="peer">peer to disconnect</param>
        /// <param name="writer">additional data</param>
        public void DisconnectPeer(NetPeer peer, NetDataWriter writer)
        {
            DisconnectPeer(peer, writer.Data, 0, writer.Length);
        }

        /// <summary>
        /// Disconnect peer from server and send additional data (Size must be less or equal MTU - 8)
        /// </summary>
        /// <param name="peer">peer to disconnect</param>
        /// <param name="data">additional data</param>
        /// <param name="start">data start</param>
        /// <param name="count">data length</param>
        public void DisconnectPeer(NetPeer peer, byte[] data, int start, int count)
        {
            DisconnectPeer(
                peer,
                DisconnectReason.DisconnectPeerCalled,
                0,
                false,
                data,
                start,
                count,
                null);
        }

        /// <summary>
        /// Create the requests for NTP server
        /// </summary>
        /// <param name="endPoint">NTP Server address.</param>
        public void CreateNtpRequest(IPEndPoint endPoint)
        {
            _ntpRequests.TryAdd(endPoint, new(endPoint));
        }

        /// <summary>
        /// Create the requests for NTP server
        /// </summary>
        /// <param name="ntpServerAddress">NTP Server address.</param>
        /// <param name="port">port</param>
        public void CreateNtpRequest(string ntpServerAddress, int port)
        {
            IPEndPoint endPoint = NetUtils.MakeEndPoint(ntpServerAddress, port);
            _ntpRequests.TryAdd(endPoint, new(endPoint));
        }

        /// <summary>
        /// Create the requests for NTP server (default port)
        /// </summary>
        /// <param name="ntpServerAddress">NTP Server address.</param>
        public void CreateNtpRequest(string ntpServerAddress)
        {
            IPEndPoint endPoint = NetUtils.MakeEndPoint(ntpServerAddress, NtpRequest.DefaultPort);
            _ntpRequests.TryAdd(endPoint, new(endPoint));
        }

        public NetPeerEnumerator GetEnumerator()
        {
            return new(_headPeer);
        }

        IEnumerator<NetPeer> IEnumerable<NetPeer>.GetEnumerator()
        {
            return new NetPeerEnumerator(_headPeer);
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return new NetPeerEnumerator(_headPeer);
        }
    }
}
﻿using System;
using System.Net;
using System.Threading;

namespace LiteNetLib
{
    //minimal hashset class from dotnet with some optimizations
    public partial class NetManager
    {
        private const int MaxPrimeArrayLength = 0x7FFFFFC3;
        private const int HashPrime = 101;
        private const int Lower31BitMask = 0x7FFFFFFF;
        private static readonly int[] Primes =
        {
            3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521, 631, 761, 919,
            1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419, 10103, 12143, 14591,
            17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431, 90523, 108631, 130363, 156437,
            187751, 225307, 270371, 324449, 389357, 467237, 560689, 672827, 807403, 968897, 1162687, 1395263,
            1674319, 2009191, 2411033, 2893249, 3471899, 4166287, 4999559, 5999471, 7199369
        };

        private static int HashSetGetPrime(int min)
        {
            foreach (int prime in Primes)
            {
                if (prime >= min)
                    return prime;
            }

            // Outside of our predefined table. Compute the hard way.
            for (int i = (min | 1); i < int.MaxValue; i += 2)
            {
                if (IsPrime(i) && ((i - 1) % HashPrime != 0))
                    return i;
            }
            return min;

            bool IsPrime(int candidate)
            {
                if ((candidate & 1) != 0)
                {
                    int limit = (int)Math.Sqrt(candidate);
                    for (int divisor = 3; divisor <= limit; divisor += 2)
                    {
                        if (candidate % divisor == 0)
                            return false;
                    }
                    return true;
                }
                return candidate == 2;
            }
        }

        private struct Slot
        {
            internal int HashCode;
            internal int Next;
            internal NetPeer Value;
        }

        private int[] _buckets;
        private Slot[] _slots;
        private int _count;
        private int _lastIndex;
        private int _freeList = -1;
        private NetPeer[] _peersArray = new NetPeer[32];
        private readonly ReaderWriterLockSlim _peersLock = new(LockRecursionPolicy.NoRecursion);
        private volatile NetPeer _headPeer;

        private void ClearPeerSet()
        {
            _peersLock.EnterWriteLock();
            _headPeer = null;
            if (_lastIndex > 0)
            {
                Array.Clear(_slots, 0, _lastIndex);
                Array.Clear(_buckets, 0, _buckets.Length);
                _lastIndex = 0;
                _count = 0;
                _freeList = -1;
            }
            _peersArray = new NetPeer[32];
            _peersLock.ExitWriteLock();
        }

        private bool ContainsPeer(NetPeer item)
        {
            if (_buckets != null)
            {
                int hashCode = item.GetHashCode() & Lower31BitMask;
                for (int i = _buckets[hashCode % _buckets.Length] - 1; i >= 0; i = _slots[i].Next)
                {
                    if (_slots[i].HashCode == hashCode && _slots[i].Value.Equals(item))
                        return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Gets peer by peer id
        /// </summary>
        /// <param name="id">id of peer</param>
        /// <returns>Peer if peer with id exist, otherwise null</returns>
        public NetPeer GetPeerById(int id)
        {
            return id >= 0 && id < _peersArray.Length ? _peersArray[id] : null;
        }

        /// <summary>
        /// Gets peer by peer id
        /// </summary>
        /// <param name="id">id of peer</param>
        /// <param name="peer">resulting peer</param>
        /// <returns>True if peer with id exist, otherwise false</returns>
        public bool TryGetPeerById(int id, out NetPeer peer)
        {
            peer = GetPeerById(id);
            return peer != null;
        }

        private void AddPeer(NetPeer peer)
        {
            _peersLock.EnterWriteLock();
            if (_headPeer != null)
            {
                peer.NextPeer = _headPeer;
                _headPeer.PrevPeer = peer;
            }
            _headPeer = peer;
            AddPeerToSet(peer);
            if (peer.Id >= _peersArray.Length)
            {
                int newSize = _peersArray.Length * 2;
                while (peer.Id >= newSize)
                    newSize *= 2;
                Array.Resize(ref _peersArray, newSize);
            }
            _peersArray[peer.Id] = peer;
            _peersLock.ExitWriteLock();
        }

        private void RemovePeer(NetPeer peer)
        {
            _peersLock.EnterWriteLock();
            RemovePeerInternal(peer);
            _peersLock.ExitWriteLock();
        }

        private void RemovePeerInternal(NetPeer peer)
        {
            if (!RemovePeerFromSet(peer))
                return;
            if (peer == _headPeer)
                _headPeer = peer.NextPeer;

            if (peer.PrevPeer != null)
                peer.PrevPeer.NextPeer = peer.NextPeer;
            if (peer.NextPeer != null)
                peer.NextPeer.PrevPeer = peer.PrevPeer;
            peer.PrevPeer = null;

            _peersArray[peer.Id] = null;
            _peerIds.Enqueue(peer.Id);
        }

        private bool RemovePeerFromSet(NetPeer peer)
        {
            if (_buckets == null)
                return false;
            if (peer == null)
                return false;
            int hashCode = peer.GetHashCode() & Lower31BitMask;
            int bucket = hashCode % _buckets.Length;
            int last = -1;
            for (int i = _buckets[bucket] - 1; i >= 0; last = i, i = _slots[i].Next)
            {
                if (_slots[i].HashCode == hashCode && _slots[i].Value.Equals(peer))
                {
                    if (last < 0)
                        _buckets[bucket] = _slots[i].Next + 1;
                    else
                        _slots[last].Next = _slots[i].Next;
                    _slots[i].HashCode = -1;
                    _slots[i].Value = null;
                    _slots[i].Next = _freeList;

                    _count--;
                    if (_count == 0)
                    {
                        _lastIndex = 0;
                        _freeList = -1;
                    }
                    else
                    {
                        _freeList = i;
                    }
                    return true;
                }
            }
            return false;
        }

        private bool TryGetPeer(IPEndPoint endPoint, out NetPeer actualValue)
        {
            if (_buckets != null)
            {
#if NET8_0_OR_GREATER
                //can be NetPeer or IPEndPoint
                int hashCode = (UseNativeSockets ? endPoint.GetHashCode() : endPoint.Serialize().GetHashCode()) & Lower31BitMask;
#else
                int hashCode = endPoint.GetHashCode() & Lower31BitMask;
#endif
                _peersLock.EnterReadLock();
                for (int i = _buckets[hashCode % _buckets.Length] - 1; i >= 0; i = _slots[i].Next)
                {
                    if (_slots[i].HashCode == hashCode && _slots[i].Value.Equals(endPoint))
                    {
                        actualValue = _slots[i].Value;
                        _peersLock.ExitReadLock();
                        return true;
                    }
                }
                _peersLock.ExitReadLock();
            }
            actualValue = null;
            return false;
        }

        //only used for NET8
        private bool TryGetPeer(SocketAddress saddr, out NetPeer actualValue)
        {
            if (_buckets != null)
            {
                int hashCode = saddr.GetHashCode() & Lower31BitMask;
                _peersLock.EnterReadLock();
                for (int i = _buckets[hashCode % _buckets.Length] - 1; i >= 0; i = _slots[i].Next)
                {
                    if (_slots[i].HashCode == hashCode && _slots[i].Value.Serialize().Equals(saddr))
                    {
                        actualValue = _slots[i].Value;
                        _peersLock.ExitReadLock();
                        return true;
                    }
                }
                _peersLock.ExitReadLock();
            }
            actualValue = null;
            return false;
        }

        private bool AddPeerToSet(NetPeer value)
        {
            if (_buckets == null)
            {
                int size = HashSetGetPrime(0);
                _buckets = new int[size];
                _slots = new Slot[size];
            }

            int hashCode = value.GetHashCode() & Lower31BitMask;
            int bucket = hashCode % _buckets.Length;
            for (int i = _buckets[hashCode % _buckets.Length] - 1; i >= 0; i = _slots[i].Next)
            {
                if (_slots[i].HashCode == hashCode && _slots[i].Value.Equals(value))
                    return false;
            }

            int index;
            if (_freeList >= 0)
            {
                index = _freeList;
                _freeList = _slots[index].Next;
            }
            else
            {
                if (_lastIndex == _slots.Length)
                {
                    //increase capacity
                    int newSize = 2 * _count;
                    newSize = (uint)newSize > MaxPrimeArrayLength && MaxPrimeArrayLength > _count
                        ? MaxPrimeArrayLength
                        : HashSetGetPrime(newSize);

                    // Able to increase capacity; copy elements to larger array and rehash
                    Slot[] newSlots = new Slot[newSize];
                    Array.Copy(_slots, 0, newSlots, 0, _lastIndex);
                    _buckets = new int[newSize];
                    for (int i = 0; i < _lastIndex; i++)
                    {
                        int b = newSlots[i].HashCode % newSize;
                        newSlots[i].Next = _buckets[b] - 1;
                        _buckets[b] = i + 1;
                    }
                    _slots = newSlots;
                    // this will change during resize
                    bucket = hashCode % _buckets.Length;
                }
                index = _lastIndex;
                _lastIndex++;
            }
            _slots[index].HashCode = hashCode;
            _slots[index].Value = value;
            _slots[index].Next = _buckets[bucket] - 1;
            _buckets[bucket] = index + 1;
            _count++;

            return true;
        }
    }

}
﻿using System;

namespace LiteNetLib
{
    public partial class NetManager
    {
        private NetPacket _poolHead;
        private int _poolCount;
        private readonly object _poolLock = new();

        /// <summary>
        /// Maximum packet pool size (increase if you have tons of packets sending)
        /// </summary>
        public int PacketPoolSize = 1000;

        public int PoolCount => _poolCount;
        
        private NetPacket PoolGetWithData(PacketProperty property, byte[] data, int start, int length)
        {
            int headerSize = NetPacket.GetHeaderSize(property);
            NetPacket packet = PoolGetPacket(length + headerSize);
            packet.Property = property;
            Buffer.BlockCopy(data, start, packet.RawData, headerSize, length);
            return packet;
        }

        //Get packet with size
        private NetPacket PoolGetWithProperty(PacketProperty property, int size)
        {
            NetPacket packet = PoolGetPacket(size + NetPacket.GetHeaderSize(property));
            packet.Property = property;
            return packet;
        }

        private NetPacket PoolGetWithProperty(PacketProperty property)
        {
            NetPacket packet = PoolGetPacket(NetPacket.GetHeaderSize(property));
            packet.Property = property;
            return packet;
        }

        internal NetPacket PoolGetPacket(int size)
        {
            if (size > NetConstants.MaxPacketSize)
                return new(size);

            NetPacket packet;
            lock (_poolLock)
            {
                packet = _poolHead;
                if (packet == null)
                    return new(size);
                
                _poolHead = _poolHead.Next;
                _poolCount--;
            }
            
            packet.Size = size;
            if (packet.RawData.Length < size)
                packet.RawData = new byte[size];
            return packet;
        }

        internal void PoolRecycle(NetPacket packet)
        {
            if (packet.RawData.Length > NetConstants.MaxPacketSize || _poolCount >= PacketPoolSize)
            {
                //Don't pool big packets. Save memory
                return;
            }
            
            //Clean fragmented flag
            packet.RawData[0] = 0;
            lock (_poolLock)
            {
                packet.Next = _poolHead;
                _poolHead = packet;
                _poolCount++;
            }
        }
    }
}
﻿#if UNITY_2018_3_OR_NEWER
#define UNITY_SOCKET_FIX
#endif
using System.Runtime.InteropServices;
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    public partial class NetManager
    {
        private const int ReceivePollingTime = 500000; //0.5 second

        private Socket _udpSocketv4;
        private Socket _udpSocketv6;
        private Thread _receiveThread;
        private IPEndPoint _bufferEndPointv4;
        private IPEndPoint _bufferEndPointv6;
#if UNITY_SOCKET_FIX
        private PausedSocketFix _pausedSocketFix;
        private bool _useSocketFix;
#endif

#if NET8_0_OR_GREATER
        private readonly SocketAddress _sockAddrCacheV4 = new SocketAddress(AddressFamily.InterNetwork);
        private readonly SocketAddress _sockAddrCacheV6 = new SocketAddress(AddressFamily.InterNetworkV6);
#endif

        private const int SioUdpConnreset = -1744830452; //SIO_UDP_CONNRESET = IOC_IN | IOC_VENDOR | 12
        private static readonly IPAddress MulticastAddressV6 = IPAddress.Parse("ff02::1");
        public static readonly bool IPv6Support;

        // special case in iOS (and possibly android that should be resolved in unity)
        internal bool NotConnected;

        public short Ttl
        {
            get
            {
#if UNITY_SWITCH
                return 0;
#else
                return _udpSocketv4.Ttl;
#endif
            }
            internal set
            {
#if !UNITY_SWITCH
                _udpSocketv4.Ttl = value;
#endif
            }
        }

        static NetManager()
        {
#if DISABLE_IPV6
            IPv6Support = false;
#elif !UNITY_2019_1_OR_NEWER && !UNITY_2018_4_OR_NEWER && (!UNITY_EDITOR && ENABLE_IL2CPP)
            string version = UnityEngine.Application.unityVersion;
            IPv6Support = Socket.OSSupportsIPv6 && int.Parse(version.Remove(version.IndexOf('f')).Split('.')[2]) >= 6;
#else
            IPv6Support = Socket.OSSupportsIPv6;
#endif
        }

        private bool ProcessError(SocketException ex)
        {
            switch (ex.SocketErrorCode)
            {
                case SocketError.NotConnected:
                    NotConnected = true;
                    return true;
                case SocketError.Interrupted:
                case SocketError.NotSocket:
                case SocketError.OperationAborted:
                    return true;
                case SocketError.ConnectionReset:
                case SocketError.MessageSize:
                case SocketError.TimedOut:
                case SocketError.NetworkReset:
                case SocketError.WouldBlock:
                    //NetDebug.Write($"[R]Ignored error: {(int)ex.SocketErrorCode} - {ex}");
                    break;
                default:
                    NetDebug.WriteError($"[R]Error code: {(int)ex.SocketErrorCode} - {ex}");
                    CreateEvent(NetEvent.EType.Error, errorCode: ex.SocketErrorCode);
                    break;
            }
            return false;
        }

        private void ManualReceive(Socket socket, EndPoint bufferEndPoint, int maxReceive)
        {
            //Reading data
            try
            {
                int packetsReceived = 0;
                while (socket.Available > 0)
                {
                    ReceiveFrom(socket, ref bufferEndPoint);
                    packetsReceived++;
                    if (packetsReceived == maxReceive)
                        break;
                }
            }
            catch (SocketException ex)
            {
                ProcessError(ex);
            }
            catch (ObjectDisposedException)
            {

            }
            catch (Exception e)
            {
                //protects socket receive thread
                NetDebug.WriteError("[NM] SocketReceiveThread error: " + e );
            }
        }

        private void NativeReceiveLogic()
        {
            IntPtr socketHandle4 = _udpSocketv4.Handle;
            IntPtr socketHandle6 = _udpSocketv6?.Handle ?? IntPtr.Zero;
            byte[] addrBuffer4 = new byte[NativeSocket.IPv4AddrSize];
            byte[] addrBuffer6 = new byte[NativeSocket.IPv6AddrSize];
            var tempEndPoint = new IPEndPoint(IPAddress.Any, 0);
            var selectReadList = new List<Socket>(2);
            var socketv4 = _udpSocketv4;
            var socketV6 = _udpSocketv6;
            var packet = PoolGetPacket(NetConstants.MaxPacketSize);

            while (IsRunning)
            {
                try
                {
                    if (socketV6 == null)
                    {
                        if (NativeReceiveFrom(socketHandle4, addrBuffer4) == false)
                            return;
                        continue;
                    }
                    bool messageReceived = false;
                    if (socketv4.Available != 0 || selectReadList.Contains(socketv4))
                    {
                        if (NativeReceiveFrom(socketHandle4, addrBuffer4) == false)
                            return;
                        messageReceived = true;
                    }
                    if (socketV6.Available != 0 || selectReadList.Contains(socketV6))
                    {
                        if (NativeReceiveFrom(socketHandle6, addrBuffer6) == false)
                            return;
                        messageReceived = true;
                    }

                    selectReadList.Clear();

                    if (messageReceived)
                        continue;

                    selectReadList.Add(socketv4);
                    selectReadList.Add(socketV6);

                    Socket.Select(selectReadList, null, null, ReceivePollingTime);
                }
                catch (SocketException ex)
                {
                    if (ProcessError(ex))
                        return;
                }
                catch (ObjectDisposedException)
                {
                    //socket closed
                    return;
                }
                catch (ThreadAbortException)
                {
                    //thread closed
                    return;
                }
                catch (Exception e)
                {
                    //protects socket receive thread
                    NetDebug.WriteError("[NM] SocketReceiveThread error: " + e );
                }
            }

            bool NativeReceiveFrom(IntPtr s, byte[] address)
            {
                int addrSize = address.Length;
                packet.Size = NativeSocket.RecvFrom(s, packet.RawData, NetConstants.MaxPacketSize, address, ref addrSize);
                if (packet.Size == 0)
                    return true; //socket closed or empty packet

                if (packet.Size == -1)
                {
                    //Linux timeout EAGAIN
                    return ProcessError(new((int)NativeSocket.GetSocketError())) == false;
                }

                //NetDebug.WriteForce($"[R]Received data from {endPoint}, result: {packet.Size}");
                //refresh temp Addr/Port
                short family      = (short)((address[1] << 8) | address[0]);
                tempEndPoint.Port =(ushort)((address[2] << 8) | address[3]);
                if ((NativeSocket.UnixMode && family == NativeSocket.AF_INET6) || (!NativeSocket.UnixMode && (AddressFamily)family == AddressFamily.InterNetworkV6))
                {
                    uint scope = unchecked((uint)(
                        (address[27] << 24) +
                        (address[26] << 16) +
                        (address[25] << 8) +
                        (address[24])));
#if NETCOREAPP || NETSTANDARD2_1 || NETSTANDARD2_1_OR_GREATER
                    tempEndPoint.Address = new IPAddress(new ReadOnlySpan<byte>(address, 8, 16), scope);
#else
                    byte[] addrBuffer = new byte[16];
                    Buffer.BlockCopy(address, 8, addrBuffer, 0, 16);
                    tempEndPoint.Address = new(addrBuffer, scope);
#endif
                }
                else //IPv4
                {
                    long ipv4Addr = unchecked((uint)((address[4] & 0x000000FF) |
                                                     (address[5] << 8 & 0x0000FF00) |
                                                     (address[6] << 16 & 0x00FF0000) |
                                                     (address[7] << 24)));
                    tempEndPoint.Address = new(ipv4Addr);
                }

                if (TryGetPeer(tempEndPoint, out var peer))
                {
                    //use cached native ep
                    OnMessageReceived(packet, peer);
                }
                else
                {
                    OnMessageReceived(packet, tempEndPoint);
                    tempEndPoint = new(IPAddress.Any, 0);
                }
                packet = PoolGetPacket(NetConstants.MaxPacketSize);
                return true;
            }
        }

        private void ReceiveFrom(Socket s, ref EndPoint bufferEndPoint)
        {
            var packet = PoolGetPacket(NetConstants.MaxPacketSize);
#if NET8_0_OR_GREATER
            var sockAddr = s.AddressFamily == AddressFamily.InterNetwork ? _sockAddrCacheV4 : _sockAddrCacheV6;
            packet.Size = s.ReceiveFrom(packet, SocketFlags.None, sockAddr);
            OnMessageReceived(packet, TryGetPeer(sockAddr, out var peer) ? peer : (IPEndPoint)bufferEndPoint.Create(sockAddr));
#else
            packet.Size = s.ReceiveFrom(packet.RawData, 0, NetConstants.MaxPacketSize, SocketFlags.None, ref bufferEndPoint);
            OnMessageReceived(packet, (IPEndPoint)bufferEndPoint);
#endif
        }

        private void ReceiveLogic()
        {
            EndPoint bufferEndPoint4 = new IPEndPoint(IPAddress.Any, 0);
            EndPoint bufferEndPoint6 = new IPEndPoint(IPAddress.IPv6Any, 0);
            var selectReadList = new List<Socket>(2);
            var socketv4 = _udpSocketv4;
            var socketV6 = _udpSocketv6;

            while (IsRunning)
            {
                //Reading data
                try
                {
                    if (socketV6 == null)
                    {
                        if (socketv4.Available == 0 && !socketv4.Poll(ReceivePollingTime, SelectMode.SelectRead))
                            continue;
                        ReceiveFrom(socketv4, ref bufferEndPoint4);
                    }
                    else
                    {
                        bool messageReceived = false;
                        if (socketv4.Available != 0 || selectReadList.Contains(socketv4))
                        {
                            ReceiveFrom(socketv4, ref bufferEndPoint4);
                            messageReceived = true;
                        }
                        if (socketV6.Available != 0 || selectReadList.Contains(socketV6))
                        {
                            ReceiveFrom(socketV6, ref bufferEndPoint6);
                            messageReceived = true;
                        }

                        selectReadList.Clear();

                        if (messageReceived)
                            continue;

                        selectReadList.Add(socketv4);
                        selectReadList.Add(socketV6);
                        Socket.Select(selectReadList, null, null, ReceivePollingTime);
                    }
                    //NetDebug.Write(NetLogLevel.Trace, $"[R]Received data from {bufferEndPoint}, result: {packet.Size}");
                }
                catch (SocketException ex)
                {
                    if (ProcessError(ex))
                        return;
                }
                catch (ObjectDisposedException)
                {
                    //socket closed
                    return;
                }
                catch (ThreadAbortException)
                {
                    //thread closed
                    return;
                }
                catch (Exception e)
                {
                    //protects socket receive thread
                    NetDebug.WriteError("[NM] SocketReceiveThread error: " + e );
                }
            }
        }

        /// <summary>
        /// Start logic thread and listening on selected port
        /// </summary>
        /// <param name="addressIPv4">bind to specific ipv4 address</param>
        /// <param name="addressIPv6">bind to specific ipv6 address</param>
        /// <param name="port">port to listen</param>
        /// <param name="manualMode">mode of library</param>
        public bool Start(IPAddress addressIPv4, IPAddress addressIPv6, int port, bool manualMode)
        {
            if (IsRunning && NotConnected == false)
                return false;

            NotConnected = false;
            _manualMode = manualMode;
            UseNativeSockets = UseNativeSockets && NativeSocket.IsSupported;
            _udpSocketv4 = new(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            if (!BindSocket(_udpSocketv4, new(addressIPv4, port)))
                return false;

            LocalPort = ((IPEndPoint) _udpSocketv4.LocalEndPoint).Port;

#if UNITY_SOCKET_FIX
            if (_useSocketFix && _pausedSocketFix == null)
                _pausedSocketFix = new(this, addressIPv4, addressIPv6, port, manualMode);
#endif

            IsRunning = true;
            if (_manualMode)
            {
                _bufferEndPointv4 = new(IPAddress.Any, 0);
            }

            //Check IPv6 support
            if (IPv6Support && IPv6Enabled)
            {
                _udpSocketv6 = new(AddressFamily.InterNetworkV6, SocketType.Dgram, ProtocolType.Udp);
                //Use one port for two sockets
                if (BindSocket(_udpSocketv6, new(addressIPv6, LocalPort)))
                {
                    if (_manualMode)
                        _bufferEndPointv6 = new(IPAddress.IPv6Any, 0);
                }
                else
                {
                    _udpSocketv6 = null;
                }
            }

            if (!manualMode)
            {
                ThreadStart ts = ReceiveLogic;
                if (UseNativeSockets)
                    ts = NativeReceiveLogic;
                _receiveThread = new(ts)
                {
                    Name = $"ReceiveThread({LocalPort})",
                    IsBackground = true
                };
                _receiveThread.Start();
                if (_logicThread == null)
                {
                    _logicThread = new(UpdateLogic) { Name = "LogicThread", IsBackground = true };
                    _logicThread.Start();
                }
            }

            return true;
        }

        private bool BindSocket(Socket socket, IPEndPoint ep)
        {
            //Setup socket
            socket.ReceiveTimeout = 500;
            socket.SendTimeout = 500;
            socket.ReceiveBufferSize = NetConstants.SocketBufferSize;
            socket.SendBufferSize = NetConstants.SocketBufferSize;
            socket.Blocking = true;

            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                try
                {
                    socket.IOControl(SioUdpConnreset, new byte[] {0}, null);
                }
                catch
                {
                    //ignored
                }
            }

            try
            {
                socket.ExclusiveAddressUse = !ReuseAddress;
                socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, ReuseAddress);
                socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.DontRoute, DontRoute);
            }
            catch
            {
                //Unity with IL2CPP throws an exception here, it doesn't matter in most cases so just ignore it
            }
            if (ep.AddressFamily == AddressFamily.InterNetwork)
            {
                Ttl = NetConstants.SocketTTL;

                try { socket.EnableBroadcast = true; }
                catch (SocketException e)
                {
                    NetDebug.WriteError($"[B]Broadcast error: {e.SocketErrorCode}");
                }

                if (!RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
                {
                    try { socket.DontFragment = true; }
                    catch (SocketException e)
                    {
                        NetDebug.WriteError($"[B]DontFragment error: {e.SocketErrorCode}");
                    }
                }
            }
            //Bind
            try
            {
                socket.Bind(ep);
                NetDebug.Write(NetLogLevel.Trace, $"[B]Successfully binded to port: {((IPEndPoint)socket.LocalEndPoint).Port}, AF: {socket.AddressFamily}");

                //join multicast
                if (ep.AddressFamily == AddressFamily.InterNetworkV6)
                {
                    try
                    {
#if !UNITY_SOCKET_FIX
                        socket.SetSocketOption(
                            SocketOptionLevel.IPv6,
                            SocketOptionName.AddMembership,
                            new IPv6MulticastOption(MulticastAddressV6));
#endif
                    }
                    catch (Exception)
                    {
                        // Unity3d throws exception - ignored
                    }
                }
            }
            catch (SocketException bindException)
            {
                switch (bindException.SocketErrorCode)
                {
                    //IPv6 bind fix
                    case SocketError.AddressAlreadyInUse:
                        if (socket.AddressFamily == AddressFamily.InterNetworkV6)
                        {
                            try
                            {
                                //Set IPv6Only
                                socket.DualMode = false;
                                socket.Bind(ep);
                            }
                            catch (SocketException ex)
                            {
                                //because its fixed in 2018_3
                                NetDebug.WriteError($"[B]Bind exception: {ex}, errorCode: {ex.SocketErrorCode}");
                                return false;
                            }
                            return true;
                        }
                        break;
                    //hack for iOS (Unity3D)
                    case SocketError.AddressFamilyNotSupported:
                        return true;
                }
                NetDebug.WriteError($"[B]Bind exception: {bindException}, errorCode: {bindException.SocketErrorCode}");
                return false;
            }
            return true;
        }

        internal int SendRawAndRecycle(NetPacket packet, IPEndPoint remoteEndPoint)
        {
            int result = SendRaw(packet.RawData, 0, packet.Size, remoteEndPoint);
            PoolRecycle(packet);
            return result;
        }

        internal int SendRaw(NetPacket packet, IPEndPoint remoteEndPoint)
        {
            return SendRaw(packet.RawData, 0, packet.Size, remoteEndPoint);
        }

        internal int SendRaw(byte[] message, int start, int length, IPEndPoint remoteEndPoint)
        {
            if (!IsRunning)
                return 0;

            NetPacket expandedPacket = null;
            if (_extraPacketLayer != null)
            {
                expandedPacket = PoolGetPacket(length + _extraPacketLayer.ExtraPacketSizeForLayer);
                Buffer.BlockCopy(message, start, expandedPacket.RawData, 0, length);
                start = 0;
                _extraPacketLayer.ProcessOutBoundPacket(ref remoteEndPoint, ref expandedPacket.RawData, ref start, ref length);
                message = expandedPacket.RawData;
            }

            var socket = _udpSocketv4;
            if (remoteEndPoint.AddressFamily == AddressFamily.InterNetworkV6 && IPv6Support)
            {
                socket = _udpSocketv6;
                if (socket == null)
                    return 0;
            }

            int result;
            try
            {
                if (UseNativeSockets && remoteEndPoint is NetPeer peer)
                {
                    unsafe
                    {
                        fixed (byte* dataWithOffset = &message[start])
                            result = NativeSocket.SendTo(socket.Handle, dataWithOffset, length, peer.NativeAddress, peer.NativeAddress.Length);
                    }
                    if (result == -1)
                        throw NativeSocket.GetSocketException();
                }
                else
                {
#if NET8_0_OR_GREATER
                    result = socket.SendTo(new ReadOnlySpan<byte>(message, start, length), SocketFlags.None, remoteEndPoint.Serialize());
#else
                    result = socket.SendTo(message, start, length, SocketFlags.None, remoteEndPoint);
#endif
                }
                //NetDebug.WriteForce("[S]Send packet to {0}, result: {1}", remoteEndPoint, result);
            }
            catch (SocketException ex)
            {
                switch (ex.SocketErrorCode)
                {
                    case SocketError.NoBufferSpaceAvailable:
                    case SocketError.Interrupted:
                        return 0;
                    case SocketError.MessageSize:
                        NetDebug.Write(NetLogLevel.Trace, $"[SRD] 10040, datalen: {length}");
                        return 0;

                    case SocketError.HostUnreachable:
                    case SocketError.NetworkUnreachable:
                        if (DisconnectOnUnreachable && remoteEndPoint is NetPeer peer)
                        {
                            DisconnectPeerForce(
                                peer,
                                ex.SocketErrorCode == SocketError.HostUnreachable
                                    ? DisconnectReason.HostUnreachable
                                    : DisconnectReason.NetworkUnreachable,
                                ex.SocketErrorCode,
                                null);
                        }

                        CreateEvent(NetEvent.EType.Error, remoteEndPoint: remoteEndPoint, errorCode: ex.SocketErrorCode);
                        return -1;

                    case SocketError.Shutdown:
                        CreateEvent(NetEvent.EType.Error, remoteEndPoint: remoteEndPoint, errorCode: ex.SocketErrorCode);
                        return -1;

                    default:
                        NetDebug.WriteError($"[S] {ex}");
                        return -1;
                }
            }
            catch (Exception ex)
            {
                NetDebug.WriteError($"[S] {ex}");
                return 0;
            }
            finally
            {
                if (expandedPacket != null)
                    PoolRecycle(expandedPacket);
            }

            if (result <= 0)
                return 0;

            if (EnableStatistics)
            {
                Statistics.IncrementPacketsSent();
                Statistics.AddBytesSent(length);
            }

            return result;
        }

        public bool SendBroadcast(NetDataWriter writer, int port)
        {
            return SendBroadcast(writer.Data, 0, writer.Length, port);
        }

        public bool SendBroadcast(byte[] data, int port)
        {
            return SendBroadcast(data, 0, data.Length, port);
        }

        public bool SendBroadcast(byte[] data, int start, int length, int port)
        {
            if (!IsRunning)
                return false;

            NetPacket packet;
            if (_extraPacketLayer != null)
            {
                var headerSize = NetPacket.GetHeaderSize(PacketProperty.Broadcast);
                packet = PoolGetPacket(headerSize + length + _extraPacketLayer.ExtraPacketSizeForLayer);
                packet.Property = PacketProperty.Broadcast;
                Buffer.BlockCopy(data, start, packet.RawData, headerSize, length);
                var checksumComputeStart = 0;
                int preCrcLength = length + headerSize;
                IPEndPoint emptyEp = null;
                _extraPacketLayer.ProcessOutBoundPacket(ref emptyEp, ref packet.RawData, ref checksumComputeStart, ref preCrcLength);
            }
            else
            {
                packet = PoolGetWithData(PacketProperty.Broadcast, data, start, length);
            }

            bool broadcastSuccess = false;
            bool multicastSuccess = false;
            try
            {
                broadcastSuccess = _udpSocketv4.SendTo(
                    packet.RawData,
                    0,
                    packet.Size,
                    SocketFlags.None,
                    new IPEndPoint(IPAddress.Broadcast, port)) > 0;

                if (_udpSocketv6 != null)
                {
                    multicastSuccess = _udpSocketv6.SendTo(
                        packet.RawData,
                        0,
                        packet.Size,
                        SocketFlags.None,
                        new IPEndPoint(MulticastAddressV6, port)) > 0;
                }
            }
            catch (SocketException ex)
            {
                if (ex.SocketErrorCode == SocketError.HostUnreachable)
                    return broadcastSuccess;
                NetDebug.WriteError($"[S][MCAST] {ex}");
                return broadcastSuccess;
            }
            catch (Exception ex)
            {
                NetDebug.WriteError($"[S][MCAST] {ex}");
                return broadcastSuccess;
            }
            finally
            {
                PoolRecycle(packet);
            }

            return broadcastSuccess || multicastSuccess;
        }

        private void CloseSocket()
        {
            IsRunning = false;
            _udpSocketv4?.Close();
            _udpSocketv6?.Close();
            _udpSocketv4 = null;
            _udpSocketv6 = null;
            if (_receiveThread != null && _receiveThread != Thread.CurrentThread)
                _receiveThread.Join();
            _receiveThread = null;
        }
    }
}
﻿using System;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    internal enum PacketProperty : byte
    {
        Unreliable,
        Channeled,
        Ack,
        Ping,
        Pong,
        ConnectRequest,
        ConnectAccept,
        Disconnect,
        UnconnectedMessage,
        MtuCheck,
        MtuOk,
        Broadcast,
        Merged,
        ShutdownOk,
        PeerNotFound,
        InvalidProtocol,
        NatMessage,
        Empty
    }

    internal sealed class NetPacket
    {
        private static readonly int PropertiesCount = Enum.GetValues(typeof(PacketProperty)).Length;
        private static readonly int[] HeaderSizes;

        static NetPacket()
        {
            HeaderSizes = NetUtils.AllocatePinnedUninitializedArray<int>(PropertiesCount);
            for (int i = 0; i < HeaderSizes.Length; i++)
            {
                switch ((PacketProperty)i)
                {
                    case PacketProperty.Channeled:
                    case PacketProperty.Ack:
                        HeaderSizes[i] = NetConstants.ChanneledHeaderSize;
                        break;
                    case PacketProperty.Ping:
                        HeaderSizes[i] = NetConstants.HeaderSize + 2;
                        break;
                    case PacketProperty.ConnectRequest:
                        HeaderSizes[i] = NetConnectRequestPacket.HeaderSize;
                        break;
                    case PacketProperty.ConnectAccept:
                        HeaderSizes[i] = NetConnectAcceptPacket.Size;
                        break;
                    case PacketProperty.Disconnect:
                        HeaderSizes[i] = NetConstants.HeaderSize + 8;
                        break;
                    case PacketProperty.Pong:
                        HeaderSizes[i] = NetConstants.HeaderSize + 10;
                        break;
                    default:
                        HeaderSizes[i] = NetConstants.HeaderSize;
                        break;
                }
            }
        }

        //Header
        public PacketProperty Property
        {
            get => (PacketProperty)(RawData[0] & 0x1F);
            set => RawData[0] = (byte)((RawData[0] & 0xE0) | (byte)value);
        }

        public byte ConnectionNumber
        {
            get => (byte)((RawData[0] & 0x60) >> 5);
            set => RawData[0] = (byte) ((RawData[0] & 0x9F) | (value << 5));
        }

        public ushort Sequence
        {
            get => BitConverter.ToUInt16(RawData, 1);
            set => FastBitConverter.GetBytes(RawData, 1, value);
        }

        public bool IsFragmented => (RawData[0] & 0x80) != 0;

        public void MarkFragmented()
        {
            RawData[0] |= 0x80; //set first bit
        }

        public byte ChannelId
        {
            get => RawData[3];
            set => RawData[3] = value;
        }

        public ushort FragmentId
        {
            get => BitConverter.ToUInt16(RawData, 4);
            set => FastBitConverter.GetBytes(RawData, 4, value);
        }

        public ushort FragmentPart
        {
            get => BitConverter.ToUInt16(RawData, 6);
            set => FastBitConverter.GetBytes(RawData, 6, value);
        }

        public ushort FragmentsTotal
        {
            get => BitConverter.ToUInt16(RawData, 8);
            set => FastBitConverter.GetBytes(RawData, 8, value);
        }

        //Data
        public byte[] RawData;
        public int Size;

        //Delivery
        public object UserData;

        //Pool node
        public NetPacket Next;

        public NetPacket(int size)
        {
            RawData = new byte[size];
            Size = size;
        }

        public NetPacket(PacketProperty property, int size)
        {
            size += GetHeaderSize(property);
            RawData = new byte[size];
            Property = property;
            Size = size;
        }

        public static int GetHeaderSize(PacketProperty property)
        {
            return HeaderSizes[(int)property];
        }

        public int GetHeaderSize()
        {
            return HeaderSizes[RawData[0] & 0x1F];
        }

        public bool Verify()
        {
            byte property = (byte)(RawData[0] & 0x1F);
            if (property >= PropertiesCount)
                return false;
            int headerSize = HeaderSizes[property];
            bool fragmented = (RawData[0] & 0x80) != 0;
            return Size >= headerSize && (!fragmented || Size >= headerSize + NetConstants.FragmentHeaderSize);
        }

        #if LITENETLIB_SPANS || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1 || NETCOREAPP3_1 || NET5_0 || NETSTANDARD2_1
        public static implicit operator Span<byte>(NetPacket p) => new Span<byte>(p.RawData, 0, p.Size);
        #endif
    }
}
﻿#if DEBUG
#define STATS_ENABLED
#endif
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Threading;
using LiteNetLib.Utils;

namespace LiteNetLib
{
    /// <summary>
    /// Peer connection state
    /// </summary>
    [Flags]
    public enum ConnectionState : byte
    {
        Outgoing         = 1 << 1,
        Connected         = 1 << 2,
        ShutdownRequested = 1 << 3,
        Disconnected      = 1 << 4,
        EndPointChange    = 1 << 5,
        Any = Outgoing | Connected | ShutdownRequested | EndPointChange
    }

    internal enum ConnectRequestResult
    {
        None,
        P2PLose, //when peer connecting
        Reconnection,  //when peer was connected
        NewConnection  //when peer was disconnected
    }

    internal enum DisconnectResult
    {
        None,
        Reject,
        Disconnect
    }

    internal enum ShutdownResult
    {
        None,
        Success,
        WasConnected
    }

    /// <summary>
    /// Network peer. Main purpose is sending messages to specific peer.
    /// </summary>
    public class NetPeer : IPEndPoint
    {
        //Ping and RTT
        private int _rtt;
        private int _avgRtt;
        private int _rttCount;
        private double _resendDelay = 27.0;
        private int _pingSendTimer;
        private int _rttResetTimer;
        private readonly Stopwatch _pingTimer = new();
        private int _timeSinceLastPacket;
        private long _remoteDelta;

        //Common
        private readonly object _shutdownLock = new();

        internal volatile NetPeer NextPeer;
        internal NetPeer PrevPeer;

        internal byte ConnectionNum
        {
            get => _connectNum;
            private set
            {
                _connectNum = value;
                _mergeData.ConnectionNumber = value;
                _pingPacket.ConnectionNumber = value;
                _pongPacket.ConnectionNumber = value;
            }
        }

        //Channels
        private readonly Queue<NetPacket> _unreliableChannel;
        private readonly ConcurrentQueue<BaseChannel> _channelSendQueue;
        private readonly BaseChannel[] _channels;

        //MTU
        private int _mtu;
        private int _mtuIdx;
        private bool _finishMtu;
        private int _mtuCheckTimer;
        private int _mtuCheckAttempts;
        private const int MtuCheckDelay = 1000;
        private const int MaxMtuCheckAttempts = 4;
        private readonly object _mtuMutex = new();

        //Fragment
        private class IncomingFragments
        {
            public NetPacket[] Fragments;
            public int ReceivedCount;
            public int TotalSize;
            public byte ChannelId;
        }
        private int _fragmentId;
        private readonly Dictionary<ushort, IncomingFragments> _holdedFragments;
        private readonly Dictionary<ushort, ushort> _deliveredFragments;

        //Merging
        private readonly NetPacket _mergeData;
        private int _mergePos;
        private int _mergeCount;

        //Connection
        private int _connectAttempts;
        private int _connectTimer;
        private long _connectTime;
        private byte _connectNum;
        private ConnectionState _connectionState;
        private NetPacket _shutdownPacket;
        private const int ShutdownDelay = 300;
        private int _shutdownTimer;
        private readonly NetPacket _pingPacket;
        private readonly NetPacket _pongPacket;
        private readonly NetPacket _connectRequestPacket;
        private readonly NetPacket _connectAcceptPacket;

        /// <summary>
        /// Peer parent NetManager
        /// </summary>
        public readonly NetManager NetManager;

        /// <summary>
        /// Current connection state
        /// </summary>
        public ConnectionState ConnectionState => _connectionState;

        /// <summary>
        /// Connection time for internal purposes
        /// </summary>
        internal long ConnectTime => _connectTime;

        /// <summary>
        /// Peer id can be used as key in your dictionary of peers
        /// </summary>
        public readonly int Id;

        /// <summary>
        /// Id assigned from server
        /// </summary>
        public int RemoteId { get; private set; }

        /// <summary>
        /// Current one-way ping (RTT/2) in milliseconds
        /// </summary>
        public int Ping => _avgRtt/2;

        /// <summary>
        /// Round trip time in milliseconds
        /// </summary>
        public int RoundTripTime => _avgRtt;

        /// <summary>
        /// Current MTU - Maximum Transfer Unit ( maximum udp packet size without fragmentation )
        /// </summary>
        public int Mtu => _mtu;

        /// <summary>
        /// Delta with remote time in ticks (not accurate)
        /// positive - remote time > our time
        /// </summary>
        public long RemoteTimeDelta => _remoteDelta;

        /// <summary>
        /// Remote UTC time (not accurate)
        /// </summary>
        public DateTime RemoteUtcTime => new(DateTime.UtcNow.Ticks + _remoteDelta);

        /// <summary>
        /// Time since last packet received (including internal library packets)
        /// </summary>
        public int TimeSinceLastPacket => _timeSinceLastPacket;

        internal double ResendDelay => _resendDelay;

        /// <summary>
        /// Application defined object containing data about the connection
        /// </summary>
        public object Tag;

        /// <summary>
        /// Statistics of peer connection
        /// </summary>
        public readonly NetStatistics Statistics;

        private SocketAddress _cachedSocketAddr;
        private int _cachedHashCode;

        internal byte[] NativeAddress;

        /// <summary>
        /// IPEndPoint serialize
        /// </summary>
        /// <returns>SocketAddress</returns>
        public override SocketAddress Serialize()
        {
            return _cachedSocketAddr;
        }

        public override int GetHashCode()
        {
            //uses SocketAddress hash in NET8 and IPEndPoint hash for NativeSockets and previous NET versions
            return _cachedHashCode;
        }

        //incoming connection constructor
        internal NetPeer(NetManager netManager, IPEndPoint remoteEndPoint, int id) : base(remoteEndPoint.Address, remoteEndPoint.Port)
        {
            Id = id;
            Statistics = new();
            NetManager = netManager;

            _cachedSocketAddr = base.Serialize();
            if (NetManager.UseNativeSockets)
            {
                NativeAddress = new byte[_cachedSocketAddr.Size];
                for (int i = 0; i < _cachedSocketAddr.Size; i++)
                    NativeAddress[i] = _cachedSocketAddr[i];
            }
#if NET8_0_OR_GREATER
            _cachedHashCode = NetManager.UseNativeSockets ? base.GetHashCode() : _cachedSocketAddr.GetHashCode();
#else
            _cachedHashCode = base.GetHashCode();
#endif

            ResetMtu();

            _connectionState = ConnectionState.Connected;
            _mergeData = new(PacketProperty.Merged, NetConstants.MaxPacketSize);
            _pongPacket = new(PacketProperty.Pong, 0);
            _pingPacket = new(PacketProperty.Ping, 0) {Sequence = 1};

            _unreliableChannel = new();
            _holdedFragments = new();
            _deliveredFragments = new();

            _channels = new BaseChannel[netManager.ChannelsCount * NetConstants.ChannelTypeCount];
            _channelSendQueue = new();
        }

        internal void InitiateEndPointChange()
        {
            ResetMtu();
            _connectionState = ConnectionState.EndPointChange;
        }

        internal void FinishEndPointChange(IPEndPoint newEndPoint)
        {
            if (_connectionState != ConnectionState.EndPointChange)
                return;
            _connectionState = ConnectionState.Connected;

            Address = newEndPoint.Address;
            Port = newEndPoint.Port;

            if (NetManager.UseNativeSockets)
            {
                NativeAddress = new byte[_cachedSocketAddr.Size];
                for (int i = 0; i < _cachedSocketAddr.Size; i++)
                    NativeAddress[i] = _cachedSocketAddr[i];
            }
            _cachedSocketAddr = base.Serialize();
#if NET8_0_OR_GREATER
            _cachedHashCode = NetManager.UseNativeSockets ? base.GetHashCode() : _cachedSocketAddr.GetHashCode();
#else
            _cachedHashCode = base.GetHashCode();
#endif
        }

        internal void ResetMtu()
        {
            _finishMtu = false;
            if (NetManager.MtuOverride > 0)
                OverrideMtu(NetManager.MtuOverride);
            else if (NetManager.UseSafeMtu)
                SetMtu(0);
            else
                SetMtu(1);
        }

        private void SetMtu(int mtuIdx)
        {
            _mtuIdx = mtuIdx;
            _mtu = NetConstants.PossibleMtu[mtuIdx] - NetManager.ExtraPacketSizeForLayer;
        }

        private void OverrideMtu(int mtuValue)
        {
            _mtu = mtuValue;
            _finishMtu = true;
        }

        /// <summary>
        /// Returns packets count in queue for reliable channel
        /// </summary>
        /// <param name="channelNumber">number of channel 0-63</param>
        /// <param name="ordered">type of channel ReliableOrdered or ReliableUnordered</param>
        /// <returns>packets count in channel queue</returns>
        public int GetPacketsCountInReliableQueue(byte channelNumber, bool ordered)
        {
            int idx = channelNumber * NetConstants.ChannelTypeCount +
                       (byte) (ordered ? DeliveryMethod.ReliableOrdered : DeliveryMethod.ReliableUnordered);
            var channel = _channels[idx];
            return channel != null ? ((ReliableChannel)channel).PacketsInQueue : 0;
        }

        /// <summary>
        /// Create temporary packet (maximum size MTU - headerSize) to send later without additional copies
        /// </summary>
        /// <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <returns>PooledPacket that you can use to write data starting from UserDataOffset</returns>
        public PooledPacket CreatePacketFromPool(DeliveryMethod deliveryMethod, byte channelNumber)
        {
            //multithreaded variable
            int mtu = _mtu;
            var packet = NetManager.PoolGetPacket(mtu);
            if (deliveryMethod == DeliveryMethod.Unreliable)
            {
                packet.Property = PacketProperty.Unreliable;
                return new(packet, mtu, 0);
            }
            else
            {
                packet.Property = PacketProperty.Channeled;
                return new(packet, mtu, (byte)(channelNumber * NetConstants.ChannelTypeCount + (byte)deliveryMethod));
            }
        }

        /// <summary>
        /// Sends pooled packet without data copy
        /// </summary>
        /// <param name="packet">packet to send</param>
        /// <param name="userDataSize">size of user data you want to send</param>
        public void SendPooledPacket(PooledPacket packet, int userDataSize)
        {
            if (_connectionState != ConnectionState.Connected)
                return;
            packet._packet.Size = packet.UserDataOffset + userDataSize;
            if (packet._packet.Property == PacketProperty.Channeled)
            {
                CreateChannel(packet._channelNumber).AddToQueue(packet._packet);
            }
            else
            {
                lock(_unreliableChannel)
                    _unreliableChannel.Enqueue(packet._packet);
            }
        }

        private BaseChannel CreateChannel(byte idx)
        {
            BaseChannel newChannel = _channels[idx];
            if (newChannel != null)
                return newChannel;
            switch ((DeliveryMethod)(idx % NetConstants.ChannelTypeCount))
            {
                case DeliveryMethod.ReliableUnordered:
                    newChannel = new ReliableChannel(this, false, idx);
                    break;
                case DeliveryMethod.Sequenced:
                    newChannel = new SequencedChannel(this, false, idx);
                    break;
                case DeliveryMethod.ReliableOrdered:
                    newChannel = new ReliableChannel(this, true, idx);
                    break;
                case DeliveryMethod.ReliableSequenced:
                    newChannel = new SequencedChannel(this, true, idx);
                    break;
            }
            BaseChannel prevChannel = Interlocked.CompareExchange(ref _channels[idx], newChannel, null);
            if (prevChannel != null)
                return prevChannel;

            return newChannel;
        }

        //"Connect to" constructor
        internal NetPeer(NetManager netManager, IPEndPoint remoteEndPoint, int id, byte connectNum, NetDataWriter connectData)
            : this(netManager, remoteEndPoint, id)
        {
            _connectTime = DateTime.UtcNow.Ticks;
            _connectionState = ConnectionState.Outgoing;
            ConnectionNum = connectNum;

            //Make initial packet
            _connectRequestPacket = NetConnectRequestPacket.Make(connectData, remoteEndPoint.Serialize(), _connectTime, id);
            _connectRequestPacket.ConnectionNumber = connectNum;

            //Send request
            NetManager.SendRaw(_connectRequestPacket, this);

            NetDebug.Write(NetLogLevel.Trace, $"[CC] ConnectId: {_connectTime}, ConnectNum: {connectNum}");
        }

        //"Accept" incoming constructor
        internal NetPeer(NetManager netManager, ConnectionRequest request, int id)
            : this(netManager, request.RemoteEndPoint, id)
        {
            _connectTime = request.InternalPacket.ConnectionTime;
            ConnectionNum = request.InternalPacket.ConnectionNumber;
            RemoteId = request.InternalPacket.PeerId;

            //Make initial packet
            _connectAcceptPacket = NetConnectAcceptPacket.Make(_connectTime, ConnectionNum, id);

            //Make Connected
            _connectionState = ConnectionState.Connected;

            //Send
            NetManager.SendRaw(_connectAcceptPacket, this);

            NetDebug.Write(NetLogLevel.Trace, $"[CC] ConnectId: {_connectTime}");
        }

        //Reject
        internal void Reject(NetConnectRequestPacket requestData, byte[] data, int start, int length)
        {
            _connectTime = requestData.ConnectionTime;
            _connectNum = requestData.ConnectionNumber;
            Shutdown(data, start, length, false);
        }

        internal bool ProcessConnectAccept(NetConnectAcceptPacket packet)
        {
            if (_connectionState != ConnectionState.Outgoing)
                return false;

            //check connection id
            if (packet.ConnectionTime != _connectTime)
            {
                NetDebug.Write(NetLogLevel.Trace, $"[NC] Invalid connectId: {packet.ConnectionTime} != our({_connectTime})");
                return false;
            }
            //check connect num
            ConnectionNum = packet.ConnectionNumber;
            RemoteId = packet.PeerId;

            NetDebug.Write(NetLogLevel.Trace, "[NC] Received connection accept");
            Interlocked.Exchange(ref _timeSinceLastPacket, 0);
            _connectionState = ConnectionState.Connected;
            return true;
        }

        /// <summary>
        /// Gets maximum size of packet that will be not fragmented.
        /// </summary>
        /// <param name="options">Type of packet that you want send</param>
        /// <returns>size in bytes</returns>
        public int GetMaxSinglePacketSize(DeliveryMethod options)
        {
            return _mtu - NetPacket.GetHeaderSize(options == DeliveryMethod.Unreliable ? PacketProperty.Unreliable : PacketProperty.Channeled);
        }

        /// <summary>
        /// Send data to peer with delivery event called
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
        /// <param name="userData">User data that will be received in DeliveryEvent</param>
        /// <exception cref="ArgumentException">
        ///     If you trying to send unreliable packet type<para/>
        /// </exception>
        public void SendWithDeliveryEvent(byte[] data, byte channelNumber, DeliveryMethod deliveryMethod, object userData)
        {
            if (deliveryMethod != DeliveryMethod.ReliableOrdered && deliveryMethod != DeliveryMethod.ReliableUnordered)
                throw new ArgumentException("Delivery event will work only for ReliableOrdered/Unordered packets");
            SendInternal(data, 0, data.Length, channelNumber, deliveryMethod, userData);
        }

        /// <summary>
        /// Send data to peer with delivery event called
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
        /// <param name="userData">User data that will be received in DeliveryEvent</param>
        /// <exception cref="ArgumentException">
        ///     If you trying to send unreliable packet type<para/>
        /// </exception>
        public void SendWithDeliveryEvent(byte[] data, int start, int length, byte channelNumber, DeliveryMethod deliveryMethod, object userData)
        {
            if (deliveryMethod != DeliveryMethod.ReliableOrdered && deliveryMethod != DeliveryMethod.ReliableUnordered)
                throw new ArgumentException("Delivery event will work only for ReliableOrdered/Unordered packets");
            SendInternal(data, start, length, channelNumber, deliveryMethod, userData);
        }

        /// <summary>
        /// Send data to peer with delivery event called
        /// </summary>
        /// <param name="dataWriter">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
        /// <param name="userData">User data that will be received in DeliveryEvent</param>
        /// <exception cref="ArgumentException">
        ///     If you trying to send unreliable packet type<para/>
        /// </exception>
        public void SendWithDeliveryEvent(NetDataWriter dataWriter, byte channelNumber, DeliveryMethod deliveryMethod, object userData)
        {
            if (deliveryMethod != DeliveryMethod.ReliableOrdered && deliveryMethod != DeliveryMethod.ReliableUnordered)
                throw new ArgumentException("Delivery event will work only for ReliableOrdered/Unordered packets");
            SendInternal(dataWriter.Data, 0, dataWriter.Length, channelNumber, deliveryMethod, userData);
        }

        /// <summary>
        /// Send data to peer (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(byte[] data, DeliveryMethod deliveryMethod)
        {
            SendInternal(data, 0, data.Length, 0, deliveryMethod, null);
        }

        /// <summary>
        /// Send data to peer (channel - 0)
        /// </summary>
        /// <param name="dataWriter">DataWriter with data</param>
        /// <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(NetDataWriter dataWriter, DeliveryMethod deliveryMethod)
        {
            SendInternal(dataWriter.Data, 0, dataWriter.Length, 0, deliveryMethod, null);
        }

        /// <summary>
        /// Send data to peer (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="options">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(byte[] data, int start, int length, DeliveryMethod options)
        {
            SendInternal(data, start, length, 0, options, null);
        }

        /// <summary>
        /// Send data to peer
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(byte[] data, byte channelNumber, DeliveryMethod deliveryMethod)
        {
            SendInternal(data, 0, data.Length, channelNumber, deliveryMethod, null);
        }

        /// <summary>
        /// Send data to peer
        /// </summary>
        /// <param name="dataWriter">DataWriter with data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(NetDataWriter dataWriter, byte channelNumber, DeliveryMethod deliveryMethod)
        {
            SendInternal(dataWriter.Data, 0, dataWriter.Length, channelNumber, deliveryMethod, null);
        }

        /// <summary>
        /// Send data to peer
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="start">Start of data</param>
        /// <param name="length">Length of data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(byte[] data, int start, int length, byte channelNumber, DeliveryMethod deliveryMethod)
        {
            SendInternal(data, start, length, channelNumber, deliveryMethod, null);
        }

        private void SendInternal(
            byte[] data,
            int start,
            int length,
            byte channelNumber,
            DeliveryMethod deliveryMethod,
            object userData)
        {
            if (_connectionState != ConnectionState.Connected || channelNumber >= _channels.Length)
                return;

            //Select channel
            PacketProperty property;
            BaseChannel channel = null;

            if (deliveryMethod == DeliveryMethod.Unreliable)
            {
                property = PacketProperty.Unreliable;
            }
            else
            {
                property = PacketProperty.Channeled;
                channel = CreateChannel((byte)(channelNumber * NetConstants.ChannelTypeCount + (byte)deliveryMethod));
            }

            //Prepare
            NetDebug.Write("[RS]Packet: " + property);

            //Check fragmentation
            int headerSize = NetPacket.GetHeaderSize(property);
            //Save mtu for multithread
            int mtu = _mtu;
            if (length + headerSize > mtu)
            {
                //if cannot be fragmented
                if (deliveryMethod != DeliveryMethod.ReliableOrdered && deliveryMethod != DeliveryMethod.ReliableUnordered)
                    throw new TooBigPacketException("Unreliable or ReliableSequenced packet size exceeded maximum of " + (mtu - headerSize) + " bytes, Check allowed size by GetMaxSinglePacketSize()");

                int packetFullSize = mtu - headerSize;
                int packetDataSize = packetFullSize - NetConstants.FragmentHeaderSize;
                int totalPackets = length / packetDataSize + (length % packetDataSize == 0 ? 0 : 1);

                NetDebug.Write($@"FragmentSend:
 MTU: {mtu}
 headerSize: {headerSize}
 packetFullSize: {packetFullSize}
 packetDataSize: {packetDataSize}
 totalPackets: {totalPackets}");

                if (totalPackets > ushort.MaxValue)
                    throw new TooBigPacketException("Data was split in " + totalPackets + " fragments, which exceeds " + ushort.MaxValue);

                ushort currentFragmentId = (ushort)Interlocked.Increment(ref _fragmentId);

                for(ushort partIdx = 0; partIdx < totalPackets; partIdx++)
                {
                    int sendLength = length > packetDataSize ? packetDataSize : length;

                    NetPacket p = NetManager.PoolGetPacket(headerSize + sendLength + NetConstants.FragmentHeaderSize);
                    p.Property = property;
                    p.UserData = userData;
                    p.FragmentId = currentFragmentId;
                    p.FragmentPart = partIdx;
                    p.FragmentsTotal = (ushort)totalPackets;
                    p.MarkFragmented();

                    Buffer.BlockCopy(data, start + partIdx * packetDataSize, p.RawData, NetConstants.FragmentedHeaderTotalSize, sendLength);
                    channel.AddToQueue(p);

                    length -= sendLength;
                }
                return;
            }

            //Else just send
            NetPacket packet = NetManager.PoolGetPacket(headerSize + length);
            packet.Property = property;
            Buffer.BlockCopy(data, start, packet.RawData, headerSize, length);
            packet.UserData = userData;

            if (channel == null) //unreliable
            {
                lock(_unreliableChannel)
                    _unreliableChannel.Enqueue(packet);
            }
            else
            {
                channel.AddToQueue(packet);
            }
        }

#if LITENETLIB_SPANS || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1 || NETCOREAPP3_1 || NET5_0 || NETSTANDARD2_1
        /// <summary>
        /// Send data to peer with delivery event called
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Delivery method (reliable, unreliable, etc.)</param>
        /// <param name="userData">User data that will be received in DeliveryEvent</param>
        /// <exception cref="ArgumentException">
        ///     If you trying to send unreliable packet type<para/>
        /// </exception>
        public void SendWithDeliveryEvent(ReadOnlySpan<byte> data, byte channelNumber, DeliveryMethod deliveryMethod, object userData)
        {
            if (deliveryMethod != DeliveryMethod.ReliableOrdered && deliveryMethod != DeliveryMethod.ReliableUnordered)
                throw new ArgumentException("Delivery event will work only for ReliableOrdered/Unordered packets");
            SendInternal(data, channelNumber, deliveryMethod, userData);
        }

        /// <summary>
        /// Send data to peer (channel - 0)
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(ReadOnlySpan<byte> data, DeliveryMethod deliveryMethod)
        {
            SendInternal(data, 0, deliveryMethod, null);
        }

        /// <summary>
        /// Send data to peer
        /// </summary>
        /// <param name="data">Data</param>
        /// <param name="channelNumber">Number of channel (from 0 to channelsCount - 1)</param>
        /// <param name="deliveryMethod">Send options (reliable, unreliable, etc.)</param>
        /// <exception cref="TooBigPacketException">
        ///     If size exceeds maximum limit:<para/>
        ///     MTU - headerSize bytes for Unreliable<para/>
        ///     Fragment count exceeded ushort.MaxValue<para/>
        /// </exception>
        public void Send(ReadOnlySpan<byte> data, byte channelNumber, DeliveryMethod deliveryMethod)
        {
            SendInternal(data, channelNumber, deliveryMethod, null);
        }

        private void SendInternal(
            ReadOnlySpan<byte> data,
            byte channelNumber,
            DeliveryMethod deliveryMethod,
            object userData)
        {
            if (_connectionState != ConnectionState.Connected || channelNumber >= _channels.Length)
                return;

            //Select channel
            PacketProperty property;
            BaseChannel channel = null;

            if (deliveryMethod == DeliveryMethod.Unreliable)
            {
                property = PacketProperty.Unreliable;
            }
            else
            {
                property = PacketProperty.Channeled;
                channel = CreateChannel((byte)(channelNumber * NetConstants.ChannelTypeCount + (byte)deliveryMethod));
            }

            //Prepare
            NetDebug.Write("[RS]Packet: " + property);

            //Check fragmentation
            int headerSize = NetPacket.GetHeaderSize(property);
            //Save mtu for multithread
            int mtu = _mtu;
            int length = data.Length;
            if (length + headerSize > mtu)
            {
                //if cannot be fragmented
                if (deliveryMethod != DeliveryMethod.ReliableOrdered && deliveryMethod != DeliveryMethod.ReliableUnordered)
                    throw new TooBigPacketException("Unreliable or ReliableSequenced packet size exceeded maximum of " + (mtu - headerSize) + " bytes, Check allowed size by GetMaxSinglePacketSize()");

                int packetFullSize = mtu - headerSize;
                int packetDataSize = packetFullSize - NetConstants.FragmentHeaderSize;
                int totalPackets = length / packetDataSize + (length % packetDataSize == 0 ? 0 : 1);

                if (totalPackets > ushort.MaxValue)
                    throw new TooBigPacketException("Data was split in " + totalPackets + " fragments, which exceeds " + ushort.MaxValue);

                ushort currentFragmentId = (ushort)Interlocked.Increment(ref _fragmentId);

                for (ushort partIdx = 0; partIdx < totalPackets; partIdx++)
                {
                    int sendLength = length > packetDataSize ? packetDataSize : length;

                    NetPacket p = NetManager.PoolGetPacket(headerSize + sendLength + NetConstants.FragmentHeaderSize);
                    p.Property = property;
                    p.UserData = userData;
                    p.FragmentId = currentFragmentId;
                    p.FragmentPart = partIdx;
                    p.FragmentsTotal = (ushort)totalPackets;
                    p.MarkFragmented();

                    data.Slice(partIdx * packetDataSize, sendLength).CopyTo(new Span<byte>(p.RawData, NetConstants.FragmentedHeaderTotalSize, sendLength));
                    channel.AddToQueue(p);

                    length -= sendLength;
                }
                return;
            }

            //Else just send
            NetPacket packet = NetManager.PoolGetPacket(headerSize + length);
            packet.Property = property;
            data.CopyTo(new Span<byte>(packet.RawData, headerSize, length));
            packet.UserData = userData;

            if (channel == null) //unreliable
            {
                lock(_unreliableChannel)
                    _unreliableChannel.Enqueue(packet);
            }
            else
            {
                channel.AddToQueue(packet);
            }
        }
#endif

        public void Disconnect(byte[] data)
        {
            NetManager.DisconnectPeer(this, data);
        }

        public void Disconnect(NetDataWriter writer)
        {
            NetManager.DisconnectPeer(this, writer);
        }

        public void Disconnect(byte[] data, int start, int count)
        {
            NetManager.DisconnectPeer(this, data, start, count);
        }

        public void Disconnect()
        {
            NetManager.DisconnectPeer(this);
        }

        internal DisconnectResult ProcessDisconnect(NetPacket packet)
        {
            if ((_connectionState == ConnectionState.Connected || _connectionState == ConnectionState.Outgoing) &&
                packet.Size >= 9 &&
                BitConverter.ToInt64(packet.RawData, 1) == _connectTime &&
                packet.ConnectionNumber == _connectNum)
            {
                return _connectionState == ConnectionState.Connected
                    ? DisconnectResult.Disconnect
                    : DisconnectResult.Reject;
            }
            return DisconnectResult.None;
        }

        internal void AddToReliableChannelSendQueue(BaseChannel channel)
        {
            _channelSendQueue.Enqueue(channel);
        }

        internal ShutdownResult Shutdown(byte[] data, int start, int length, bool force)
        {
            lock (_shutdownLock)
            {
                //trying to shutdown already disconnected
                if (_connectionState == ConnectionState.Disconnected ||
                    _connectionState == ConnectionState.ShutdownRequested)
                {
                    return ShutdownResult.None;
                }

                var result = _connectionState == ConnectionState.Connected
                    ? ShutdownResult.WasConnected
                    : ShutdownResult.Success;

                //don't send anything
                if (force)
                {
                    _connectionState = ConnectionState.Disconnected;
                    return result;
                }

                //reset time for reconnect protection
                Interlocked.Exchange(ref _timeSinceLastPacket, 0);

                //send shutdown packet
                _shutdownPacket = new(PacketProperty.Disconnect, length) {ConnectionNumber = _connectNum};
                FastBitConverter.GetBytes(_shutdownPacket.RawData, 1, _connectTime);
                if (_shutdownPacket.Size >= _mtu)
                {
                    //Drop additional data
                    NetDebug.WriteError("[Peer] Disconnect additional data size more than MTU - 8!");
                }
                else if (data != null && length > 0)
                {
                    Buffer.BlockCopy(data, start, _shutdownPacket.RawData, 9, length);
                }
                _connectionState = ConnectionState.ShutdownRequested;
                NetDebug.Write("[Peer] Send disconnect");
                NetManager.SendRaw(_shutdownPacket, this);
                return result;
            }
        }

        private void UpdateRoundTripTime(int roundTripTime)
        {
            _rtt += roundTripTime;
            _rttCount++;
            _avgRtt = _rtt/_rttCount;
            _resendDelay = 25.0 + _avgRtt * 2.1; // 25 ms + double rtt
        }

        internal void AddReliablePacket(DeliveryMethod method, NetPacket p)
        {
            if (p.IsFragmented)
            {
                NetDebug.Write($"Fragment. Id: {p.FragmentId}, Part: {p.FragmentPart}, Total: {p.FragmentsTotal}");
                //Get needed array from dictionary
                ushort packetFragId = p.FragmentId;
                byte packetChannelId = p.ChannelId;
                if (!_holdedFragments.TryGetValue(packetFragId, out var incomingFragments))
                {
                    incomingFragments = new()
                    {
                        Fragments = new NetPacket[p.FragmentsTotal],
                        ChannelId = p.ChannelId
                    };
                    _holdedFragments.Add(packetFragId, incomingFragments);
                }

                //Cache
                var fragments = incomingFragments.Fragments;

                //Error check
                if (p.FragmentPart >= fragments.Length ||
                    fragments[p.FragmentPart] != null ||
                    p.ChannelId != incomingFragments.ChannelId)
                {
                    NetManager.PoolRecycle(p);
                    NetDebug.WriteError("Invalid fragment packet");
                    return;
                }
                //Fill array
                fragments[p.FragmentPart] = p;

                //Increase received fragments count
                incomingFragments.ReceivedCount++;

                //Increase total size
                incomingFragments.TotalSize += p.Size - NetConstants.FragmentedHeaderTotalSize;

                //Check for finish
                if (incomingFragments.ReceivedCount != fragments.Length)
                    return;

                //just simple packet
                NetPacket resultingPacket = NetManager.PoolGetPacket(incomingFragments.TotalSize);

                int pos = 0;
                for (int i = 0; i < incomingFragments.ReceivedCount; i++)
                {
                    var fragment = fragments[i];
                    int writtenSize = fragment.Size - NetConstants.FragmentedHeaderTotalSize;

                    if (pos+writtenSize > resultingPacket.RawData.Length)
                    {
                        _holdedFragments.Remove(packetFragId);
                        NetDebug.WriteError($"Fragment error pos: {pos + writtenSize} >= resultPacketSize: {resultingPacket.RawData.Length} , totalSize: {incomingFragments.TotalSize}");
                        return;
                    }
                    if (fragment.Size > fragment.RawData.Length)
                    {
                        _holdedFragments.Remove(packetFragId);
                        NetDebug.WriteError($"Fragment error size: {fragment.Size} > fragment.RawData.Length: {fragment.RawData.Length}");
                        return;
                    }

                    //Create resulting big packet
                    Buffer.BlockCopy(
                        fragment.RawData,
                        NetConstants.FragmentedHeaderTotalSize,
                        resultingPacket.RawData,
                        pos,
                        writtenSize);
                    pos += writtenSize;

                    //Free memory
                    NetManager.PoolRecycle(fragment);
                    fragments[i] = null;
                }

                //Clear memory
                _holdedFragments.Remove(packetFragId);

                //Send to process
                NetManager.CreateReceiveEvent(resultingPacket, method, (byte)(packetChannelId / NetConstants.ChannelTypeCount), 0, this);
            }
            else //Just simple packet
            {
                NetManager.CreateReceiveEvent(p, method, (byte)(p.ChannelId / NetConstants.ChannelTypeCount), NetConstants.ChanneledHeaderSize, this);
            }
        }

        private void ProcessMtuPacket(NetPacket packet)
        {
            //header + int
            if (packet.Size < NetConstants.PossibleMtu[0])
                return;

            //first stage check (mtu check and mtu ok)
            int receivedMtu = BitConverter.ToInt32(packet.RawData, 1);
            int endMtuCheck = BitConverter.ToInt32(packet.RawData, packet.Size - 4);
            if (receivedMtu != packet.Size || receivedMtu != endMtuCheck || receivedMtu > NetConstants.MaxPacketSize)
            {
                NetDebug.WriteError($"[MTU] Broken packet. RMTU {receivedMtu}, EMTU {endMtuCheck}, PSIZE {packet.Size}");
                return;
            }

            if (packet.Property == PacketProperty.MtuCheck)
            {
                _mtuCheckAttempts = 0;
                NetDebug.Write("[MTU] check. send back: " + receivedMtu);
                packet.Property = PacketProperty.MtuOk;
                NetManager.SendRawAndRecycle(packet, this);
            }
            else if(receivedMtu > _mtu && !_finishMtu) //MtuOk
            {
                //invalid packet
                if (receivedMtu != NetConstants.PossibleMtu[_mtuIdx + 1] - NetManager.ExtraPacketSizeForLayer)
                    return;

                lock (_mtuMutex)
                {
                    SetMtu(_mtuIdx+1);
                }
                //if maxed - finish.
                if (_mtuIdx == NetConstants.PossibleMtu.Length - 1)
                    _finishMtu = true;
                NetManager.PoolRecycle(packet);
                NetDebug.Write("[MTU] ok. Increase to: " + _mtu);
            }
        }

        private void UpdateMtuLogic(int deltaTime)
        {
            if (_finishMtu)
                return;

            _mtuCheckTimer += deltaTime;
            if (_mtuCheckTimer < MtuCheckDelay)
                return;

            _mtuCheckTimer = 0;
            _mtuCheckAttempts++;
            if (_mtuCheckAttempts >= MaxMtuCheckAttempts)
            {
                _finishMtu = true;
                return;
            }

            lock (_mtuMutex)
            {
                if (_mtuIdx >= NetConstants.PossibleMtu.Length - 1)
                    return;

                //Send increased packet
                int newMtu = NetConstants.PossibleMtu[_mtuIdx + 1] - NetManager.ExtraPacketSizeForLayer;
                var p = NetManager.PoolGetPacket(newMtu);
                p.Property = PacketProperty.MtuCheck;
                FastBitConverter.GetBytes(p.RawData, 1, newMtu);         //place into start
                FastBitConverter.GetBytes(p.RawData, p.Size - 4, newMtu);//and end of packet

                //Must check result for MTU fix
                if (NetManager.SendRawAndRecycle(p, this) <= 0)
                    _finishMtu = true;
            }
        }

        internal ConnectRequestResult ProcessConnectRequest(NetConnectRequestPacket connRequest)
        {
            //current or new request
            switch (_connectionState)
            {
                //P2P case
                case ConnectionState.Outgoing:
                    //fast check
                    if (connRequest.ConnectionTime < _connectTime)
                    {
                        return ConnectRequestResult.P2PLose;
                    }
                    //slow rare case check
                    if (connRequest.ConnectionTime == _connectTime)
                    {
                        var localBytes = connRequest.TargetAddress;
                        for (int i = _cachedSocketAddr.Size-1; i >= 0; i--)
                        {
                            byte rb = _cachedSocketAddr[i];
                            if (rb == localBytes[i])
                                continue;
                            if (rb < localBytes[i])
                                return ConnectRequestResult.P2PLose;
                        }
                    }
                    break;

                case ConnectionState.Connected:
                    //Old connect request
                    if (connRequest.ConnectionTime == _connectTime)
                    {
                        //just reply accept
                        NetManager.SendRaw(_connectAcceptPacket, this);
                    }
                    //New connect request
                    else if (connRequest.ConnectionTime > _connectTime)
                    {
                        return ConnectRequestResult.Reconnection;
                    }
                    break;

                case ConnectionState.Disconnected:
                case ConnectionState.ShutdownRequested:
                    if (connRequest.ConnectionTime >= _connectTime)
                        return ConnectRequestResult.NewConnection;
                    break;
            }
            return ConnectRequestResult.None;
        }

        //Process incoming packet
        internal void ProcessPacket(NetPacket packet)
        {
            //not initialized
            if (_connectionState == ConnectionState.Outgoing || _connectionState == ConnectionState.Disconnected)
            {
                NetManager.PoolRecycle(packet);
                return;
            }
            if (packet.Property == PacketProperty.ShutdownOk)
            {
                if (_connectionState == ConnectionState.ShutdownRequested)
                    _connectionState = ConnectionState.Disconnected;
                NetManager.PoolRecycle(packet);
                return;
            }
            if (packet.ConnectionNumber != _connectNum)
            {
                NetDebug.Write(NetLogLevel.Trace, "[RR]Old packet");
                NetManager.PoolRecycle(packet);
                return;
            }
            Interlocked.Exchange(ref _timeSinceLastPacket, 0);

            NetDebug.Write($"[RR]PacketProperty: {packet.Property}");
            switch (packet.Property)
            {
                case PacketProperty.Merged:
                    int pos = NetConstants.HeaderSize;
                    while (pos < packet.Size)
                    {
                        ushort size = BitConverter.ToUInt16(packet.RawData, pos);
                        pos += 2;
                        if (packet.RawData.Length - pos < size)
                            break;

                        NetPacket mergedPacket = NetManager.PoolGetPacket(size);
                        Buffer.BlockCopy(packet.RawData, pos, mergedPacket.RawData, 0, size);
                        mergedPacket.Size = size;

                        if (!mergedPacket.Verify())
                            break;

                        pos += size;
                        ProcessPacket(mergedPacket);
                    }
                    NetManager.PoolRecycle(packet);
                    break;
                //If we get ping, send pong
                case PacketProperty.Ping:
                    if (NetUtils.RelativeSequenceNumber(packet.Sequence, _pongPacket.Sequence) > 0)
                    {
                        NetDebug.Write("[PP]Ping receive, send pong");
                        FastBitConverter.GetBytes(_pongPacket.RawData, 3, DateTime.UtcNow.Ticks);
                        _pongPacket.Sequence = packet.Sequence;
                        NetManager.SendRaw(_pongPacket, this);
                    }
                    NetManager.PoolRecycle(packet);
                    break;

                //If we get pong, calculate ping time and rtt
                case PacketProperty.Pong:
                    if (packet.Sequence == _pingPacket.Sequence)
                    {
                        _pingTimer.Stop();
                        int elapsedMs = (int)_pingTimer.ElapsedMilliseconds;
                        _remoteDelta = BitConverter.ToInt64(packet.RawData, 3) + (elapsedMs * TimeSpan.TicksPerMillisecond ) / 2 - DateTime.UtcNow.Ticks;
                        UpdateRoundTripTime(elapsedMs);
                        NetManager.ConnectionLatencyUpdated(this, elapsedMs / 2);
                        NetDebug.Write($"[PP]Ping: {packet.Sequence} - {elapsedMs} - {_remoteDelta}");
                    }
                    NetManager.PoolRecycle(packet);
                    break;

                case PacketProperty.Ack:
                case PacketProperty.Channeled:
                    if (packet.ChannelId >= _channels.Length)
                    {
                        NetManager.PoolRecycle(packet);
                        break;
                    }
                    var channel = _channels[packet.ChannelId] ?? (packet.Property == PacketProperty.Ack ? null : CreateChannel(packet.ChannelId));
                    if (channel != null)
                    {
                        if (!channel.ProcessPacket(packet))
                            NetManager.PoolRecycle(packet);
                    }
                    break;

                //Simple packet without acks
                case PacketProperty.Unreliable:
                    NetManager.CreateReceiveEvent(packet, DeliveryMethod.Unreliable, 0, NetConstants.HeaderSize, this);
                    return;

                case PacketProperty.MtuCheck:
                case PacketProperty.MtuOk:
                    ProcessMtuPacket(packet);
                    break;

                default:
                    NetDebug.WriteError("Error! Unexpected packet type: " + packet.Property);
                    break;
            }
        }

        private void SendMerged()
        {
            if (_mergeCount == 0)
                return;
            int bytesSent;
            if (_mergeCount > 1)
            {
                NetDebug.Write("[P]Send merged: " + _mergePos + ", count: " + _mergeCount);
                bytesSent = NetManager.SendRaw(_mergeData.RawData, 0, NetConstants.HeaderSize + _mergePos, this);
            }
            else
            {
                //Send without length information and merging
                bytesSent = NetManager.SendRaw(_mergeData.RawData, NetConstants.HeaderSize + 2, _mergePos - 2, this);
            }

            if (NetManager.EnableStatistics)
            {
                Statistics.IncrementPacketsSent();
                Statistics.AddBytesSent(bytesSent);
            }

            _mergePos = 0;
            _mergeCount = 0;
        }

        internal void SendUserData(NetPacket packet)
        {
            packet.ConnectionNumber = _connectNum;
            int mergedPacketSize = NetConstants.HeaderSize + packet.Size + 2;
            const int sizeTreshold = 20;
            if (mergedPacketSize + sizeTreshold >= _mtu)
            {
                NetDebug.Write(NetLogLevel.Trace, "[P]SendingPacket: " + packet.Property);
                int bytesSent = NetManager.SendRaw(packet, this);

                if (NetManager.EnableStatistics)
                {
                    Statistics.IncrementPacketsSent();
                    Statistics.AddBytesSent(bytesSent);
                }

                return;
            }
            if (_mergePos + mergedPacketSize > _mtu)
                SendMerged();

            FastBitConverter.GetBytes(_mergeData.RawData, _mergePos + NetConstants.HeaderSize, (ushort)packet.Size);
            Buffer.BlockCopy(packet.RawData, 0, _mergeData.RawData, _mergePos + NetConstants.HeaderSize + 2, packet.Size);
            _mergePos += packet.Size + 2;
            _mergeCount++;
            //DebugWriteForce("Merged: " + _mergePos + "/" + (_mtu - 2) + ", count: " + _mergeCount);
        }

        internal void Update(int deltaTime)
        {
            Interlocked.Add(ref _timeSinceLastPacket, deltaTime);
            switch (_connectionState)
            {
                case ConnectionState.Connected:
                    if (_timeSinceLastPacket > NetManager.DisconnectTimeout)
                    {
                        NetDebug.Write($"[UPDATE] Disconnect by timeout: {_timeSinceLastPacket} > {NetManager.DisconnectTimeout}");
                        NetManager.DisconnectPeerForce(this, DisconnectReason.Timeout, 0, null);
                        return;
                    }
                    break;

                case ConnectionState.ShutdownRequested:
                    if (_timeSinceLastPacket > NetManager.DisconnectTimeout)
                    {
                        _connectionState = ConnectionState.Disconnected;
                    }
                    else
                    {
                        _shutdownTimer += deltaTime;
                        if (_shutdownTimer >= ShutdownDelay)
                        {
                            _shutdownTimer = 0;
                            NetManager.SendRaw(_shutdownPacket, this);
                        }
                    }
                    return;

                case ConnectionState.Outgoing:
                    _connectTimer += deltaTime;
                    if (_connectTimer > NetManager.ReconnectDelay)
                    {
                        _connectTimer = 0;
                        _connectAttempts++;
                        if (_connectAttempts > NetManager.MaxConnectAttempts)
                        {
                            NetManager.DisconnectPeerForce(this, DisconnectReason.ConnectionFailed, 0, null);
                            return;
                        }

                        //else send connect again
                        NetManager.SendRaw(_connectRequestPacket, this);
                    }
                    return;

                case ConnectionState.Disconnected:
                    return;
            }

            //Send ping
            _pingSendTimer += deltaTime;
            if (_pingSendTimer >= NetManager.PingInterval)
            {
                NetDebug.Write("[PP] Send ping...");
                //reset timer
                _pingSendTimer = 0;
                //send ping
                _pingPacket.Sequence++;
                //ping timeout
                if (_pingTimer.IsRunning)
                    UpdateRoundTripTime((int)_pingTimer.ElapsedMilliseconds);
                _pingTimer.Restart();
                NetManager.SendRaw(_pingPacket, this);
            }

            //RTT - round trip time
            _rttResetTimer += deltaTime;
            if (_rttResetTimer >= NetManager.PingInterval * 3)
            {
                _rttResetTimer = 0;
                _rtt = _avgRtt;
                _rttCount = 1;
            }

            UpdateMtuLogic(deltaTime);

            //Pending send
            int count = _channelSendQueue.Count;
            while (count-- > 0)
            {
                if (!_channelSendQueue.TryDequeue(out var channel))
                    break;
                if (channel.SendAndCheckQueue())
                {
                    // still has something to send, re-add it to the send queue
                    _channelSendQueue.Enqueue(channel);
                }
            }

            lock (_unreliableChannel)
            {
                int unreliableCount = _unreliableChannel.Count;
                for (int i = 0; i < unreliableCount; i++)
                {
                    var packet = _unreliableChannel.Dequeue();
                    SendUserData(packet);
                    NetManager.PoolRecycle(packet);
                }
            }

            SendMerged();
        }

        //For reliable channel
        internal void RecycleAndDeliver(NetPacket packet)
        {
            if (packet.UserData != null)
            {
                if (packet.IsFragmented)
                {
                    _deliveredFragments.TryGetValue(packet.FragmentId, out ushort fragCount);
                    fragCount++;
                    if (fragCount == packet.FragmentsTotal)
                    {
                        NetManager.MessageDelivered(this, packet.UserData);
                        _deliveredFragments.Remove(packet.FragmentId);
                    }
                    else
                    {
                        _deliveredFragments[packet.FragmentId] = fragCount;
                    }
                }
                else
                {
                    NetManager.MessageDelivered(this, packet.UserData);
                }
                packet.UserData = null;
            }
            NetManager.PoolRecycle(packet);
        }
    }
}
﻿using System.Threading;

namespace LiteNetLib
{
    public sealed class NetStatistics
    {
        private long _packetsSent;
        private long _packetsReceived;
        private long _bytesSent;
        private long _bytesReceived;
        private long _packetLoss;

        public long PacketsSent => Interlocked.Read(ref _packetsSent);
        public long PacketsReceived => Interlocked.Read(ref _packetsReceived);
        public long BytesSent => Interlocked.Read(ref _bytesSent);
        public long BytesReceived => Interlocked.Read(ref _bytesReceived);
        public long PacketLoss => Interlocked.Read(ref _packetLoss);

        public long PacketLossPercent
        {
            get
            {
                long sent = PacketsSent, loss = PacketLoss;

                return sent == 0 ? 0 : loss * 100 / sent;
            }
        }

        public void Reset()
        {
            Interlocked.Exchange(ref _packetsSent, 0);
            Interlocked.Exchange(ref _packetsReceived, 0);
            Interlocked.Exchange(ref _bytesSent, 0);
            Interlocked.Exchange(ref _bytesReceived, 0);
            Interlocked.Exchange(ref _packetLoss, 0);
        }

        public void IncrementPacketsSent()
        {
            Interlocked.Increment(ref _packetsSent);
        }

        public void IncrementPacketsReceived()
        {
            Interlocked.Increment(ref _packetsReceived);
        }

        public void AddBytesSent(long bytesSent)
        {
            Interlocked.Add(ref _bytesSent, bytesSent);
        }

        public void AddBytesReceived(long bytesReceived)
        {
            Interlocked.Add(ref _bytesReceived, bytesReceived);
        }

        public void IncrementPacketLoss()
        {
            Interlocked.Increment(ref _packetLoss);
        }

        public void AddPacketLoss(long packetLoss)
        {
            Interlocked.Add(ref _packetLoss, packetLoss);
        }

        public override string ToString()
        {
            return
                string.Format(
                    "BytesReceived: {0}\nPacketsReceived: {1}\nBytesSent: {2}\nPacketsSent: {3}\nPacketLoss: {4}\nPacketLossPercent: {5}\n",
                    BytesReceived,
                    PacketsReceived,
                    BytesSent,
                    PacketsSent,
                    PacketLoss,
                    PacketLossPercent);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Net.Sockets;
using System.Net.NetworkInformation;

namespace LiteNetLib
{
    /// <summary>
    /// Address type that you want to receive from NetUtils.GetLocalIp method
    /// </summary>
    [Flags]
    public enum LocalAddrType
    {
        IPv4 = 1,
        IPv6 = 2,
        All = IPv4 | IPv6
    }

    /// <summary>
    /// Some specific network utilities
    /// </summary>
    public static class NetUtils
    {
        private static readonly NetworkSorter NetworkSorter = new();

        public static IPEndPoint MakeEndPoint(string hostStr, int port)
        {
            return new(ResolveAddress(hostStr), port);
        }

        public static IPAddress ResolveAddress(string hostStr)
        {
            if(hostStr == "localhost")
                return IPAddress.Loopback;

            if (!IPAddress.TryParse(hostStr, out var ipAddress))
            {
                if (NetManager.IPv6Support)
                    ipAddress = ResolveAddress(hostStr, AddressFamily.InterNetworkV6);
                if (ipAddress == null)
                    ipAddress = ResolveAddress(hostStr, AddressFamily.InterNetwork);
            }
            if (ipAddress == null)
                throw new ArgumentException("Invalid address: " + hostStr);

            return ipAddress;
        }

        public static IPAddress ResolveAddress(string hostStr, AddressFamily addressFamily)
        {
            IPAddress[] addresses = Dns.GetHostEntry(hostStr).AddressList;
            foreach (IPAddress ip in addresses)
            {
                if (ip.AddressFamily == addressFamily)
                {
                    return ip;
                }
            }
            return null;
        }

        /// <summary>
        /// Get all local ip addresses
        /// </summary>
        /// <param name="addrType">type of address (IPv4, IPv6 or both)</param>
        /// <returns>List with all local ip addresses</returns>
        public static List<string> GetLocalIpList(LocalAddrType addrType)
        {
            List<string> targetList = new();
            GetLocalIpList(targetList, addrType);
            return targetList;
        }

        /// <summary>
        /// Get all local ip addresses (non alloc version)
        /// </summary>
        /// <param name="targetList">result list</param>
        /// <param name="addrType">type of address (IPv4, IPv6 or both)</param>
        public static void GetLocalIpList(IList<string> targetList, LocalAddrType addrType)
        {
            bool ipv4 = (addrType & LocalAddrType.IPv4) == LocalAddrType.IPv4;
            bool ipv6 = (addrType & LocalAddrType.IPv6) == LocalAddrType.IPv6;
            try
            {
                // Sort networks interfaces so it prefer Wifi over Cellular networks
                // Most cellulars networks seems to be incompatible with NAT Punch
                var networks = NetworkInterface.GetAllNetworkInterfaces();
                Array.Sort(networks, NetworkSorter);

                foreach (NetworkInterface ni in networks)
                {
                    //Skip loopback and disabled network interfaces
                    if (ni.NetworkInterfaceType == NetworkInterfaceType.Loopback ||
                        ni.OperationalStatus != OperationalStatus.Up)
                        continue;

                    var ipProps = ni.GetIPProperties();

                    //Skip address without gateway
                    if (ipProps.GatewayAddresses.Count == 0)
                        continue;

                    foreach (UnicastIPAddressInformation ip in ipProps.UnicastAddresses)
                    {
                        var address = ip.Address;
                        if ((ipv4 && address.AddressFamily == AddressFamily.InterNetwork) ||
                            (ipv6 && address.AddressFamily == AddressFamily.InterNetworkV6))
                            targetList.Add(address.ToString());
                    }
                }

	            //Fallback mode (unity android)
	            if (targetList.Count == 0)
	            {
	                IPAddress[] addresses = Dns.GetHostEntry(Dns.GetHostName()).AddressList;
	                foreach (IPAddress ip in addresses)
	                {
	                    if((ipv4 && ip.AddressFamily == AddressFamily.InterNetwork) ||
	                       (ipv6 && ip.AddressFamily == AddressFamily.InterNetworkV6))
	                        targetList.Add(ip.ToString());
	                }
	            }
            }
            catch
            {
                //ignored
            }

            if (targetList.Count == 0)
            {
                if(ipv4)
                    targetList.Add("127.0.0.1");
                if(ipv6)
                    targetList.Add("::1");
            }
        }

        private static readonly List<string> IpList = new();
        /// <summary>
        /// Get first detected local ip address
        /// </summary>
        /// <param name="addrType">type of address (IPv4, IPv6 or both)</param>
        /// <returns>IP address if available. Else - string.Empty</returns>
        public static string GetLocalIp(LocalAddrType addrType)
        {
            lock (IpList)
            {
                IpList.Clear();
                GetLocalIpList(IpList, addrType);
                return IpList.Count == 0 ? string.Empty : IpList[0];
            }
        }

        // ===========================================
        // Internal and debug log related stuff
        // ===========================================
        internal static void PrintInterfaceInfos()
        {
            NetDebug.WriteForce(NetLogLevel.Info, $"IPv6Support: { NetManager.IPv6Support}");
            try
            {
                foreach (NetworkInterface ni in NetworkInterface.GetAllNetworkInterfaces())
                {
                    foreach (UnicastIPAddressInformation ip in ni.GetIPProperties().UnicastAddresses)
                    {
                        if (ip.Address.AddressFamily == AddressFamily.InterNetwork ||
                            ip.Address.AddressFamily == AddressFamily.InterNetworkV6)
                        {
                            NetDebug.WriteForce(
                                NetLogLevel.Info,
                                $"Interface: {ni.Name}, Type: {ni.NetworkInterfaceType}, Ip: {ip.Address}, OpStatus: {ni.OperationalStatus}");
                        }
                    }
                }
            }
            catch (Exception e)
            {
                NetDebug.WriteForce(NetLogLevel.Info, $"Error while getting interface infos: {e}");
            }
        }

        internal static int RelativeSequenceNumber(int number, int expected)
        {
            return (number - expected + NetConstants.MaxSequence + NetConstants.HalfMaxSequence) % NetConstants.MaxSequence - NetConstants.HalfMaxSequence;
        }

        internal static T[] AllocatePinnedUninitializedArray<T>(int count) where T : unmanaged
        {
#if NET5_0_OR_GREATER || NET5_0
            return GC.AllocateUninitializedArray<T>(count, true);
#else
            return new T[count];
#endif
        }
    }

    // Pick the most obvious choice for the local IP
    // Ethernet > Wifi > Others > Cellular
    internal class NetworkSorter : IComparer<NetworkInterface>
    {
        [SuppressMessage("ReSharper", "PossibleNullReferenceException")]
        public int Compare(NetworkInterface a, NetworkInterface b)
        {
            var isCellularA = a.NetworkInterfaceType == NetworkInterfaceType.Wman ||
                              a.NetworkInterfaceType == NetworkInterfaceType.Wwanpp ||
                              a.NetworkInterfaceType == NetworkInterfaceType.Wwanpp2;

            var isCellularB = b.NetworkInterfaceType == NetworkInterfaceType.Wman ||
                              b.NetworkInterfaceType == NetworkInterfaceType.Wwanpp ||
                              b.NetworkInterfaceType == NetworkInterfaceType.Wwanpp2;

            var isWifiA     = a.NetworkInterfaceType == NetworkInterfaceType.Wireless80211;
            var isWifiB     = b.NetworkInterfaceType == NetworkInterfaceType.Wireless80211;

            var isEthernetA = a.NetworkInterfaceType == NetworkInterfaceType.Ethernet ||
                              a.NetworkInterfaceType == NetworkInterfaceType.Ethernet3Megabit ||
                              a.NetworkInterfaceType == NetworkInterfaceType.GigabitEthernet ||
                              a.NetworkInterfaceType == NetworkInterfaceType.FastEthernetFx ||
                              a.NetworkInterfaceType == NetworkInterfaceType.FastEthernetT;

            var isEthernetB = b.NetworkInterfaceType == NetworkInterfaceType.Ethernet ||
                              b.NetworkInterfaceType == NetworkInterfaceType.Ethernet3Megabit ||
                              b.NetworkInterfaceType == NetworkInterfaceType.GigabitEthernet ||
                              b.NetworkInterfaceType == NetworkInterfaceType.FastEthernetFx ||
                              b.NetworkInterfaceType == NetworkInterfaceType.FastEthernetT;

            var isOtherA    = !isCellularA && !isWifiA && !isEthernetA;
            var isOtherB    = !isCellularB && !isWifiB && !isEthernetB;

            var priorityA = isEthernetA ? 3 : isWifiA ? 2 : isOtherA ? 1 : 0;
            var priorityB = isEthernetB ? 3 : isWifiB ? 2 : isOtherB ? 1 : 0;

            return priorityA > priorityB ? -1 : priorityA < priorityB ? 1 : 0;
        }
    }
}
﻿#if UNITY_2018_3_OR_NEWER
using System.Net;

namespace LiteNetLib
{
    public class PausedSocketFix
    {
        private readonly NetManager _netManager;
        private readonly IPAddress _ipv4;
        private readonly IPAddress _ipv6;
        private readonly int _port;
        private readonly bool _manualMode;
        private bool _initialized;

        public PausedSocketFix(NetManager netManager, IPAddress ipv4, IPAddress ipv6, int port, bool manualMode)
        {
            _netManager = netManager;
            _ipv4 = ipv4;
            _ipv6 = ipv6;
            _port = port;
            _manualMode = manualMode;
            UnityEngine.Application.focusChanged += Application_focusChanged;
            _initialized = true;
        }

        public void Deinitialize()
        {
            if (_initialized)
                UnityEngine.Application.focusChanged -= Application_focusChanged;
            _initialized = false;
        }

        private void Application_focusChanged(bool focused)
        {
            //If coming back into focus see if a reconnect is needed.
            if (focused)
            {
                //try reconnect
                if (!_initialized)
                    return;
                //Was intentionally disconnected at some point.
                if (!_netManager.IsRunning)
                    return;
                //Socket is in working state.
                if (_netManager.NotConnected == false)
                    return;

                //Socket isn't running but should be. Try to start again.
                if (!_netManager.Start(_ipv4, _ipv6, _port, _manualMode))
                {
                    NetDebug.WriteError($"[S] Cannot restore connection. Ipv4 {_ipv4}, Ipv6 {_ipv6}, Port {_port}, ManualMode {_manualMode}");
                }
            }
        }
    }
}
#endif
﻿namespace LiteNetLib
{
    public readonly ref struct PooledPacket
    {
        internal readonly NetPacket _packet;
        internal readonly byte _channelNumber;

        /// <summary>
        /// Maximum data size that you can put into such packet
        /// </summary>
        public readonly int MaxUserDataSize;

        /// <summary>
        /// Offset for user data when writing to Data array
        /// </summary>
        public readonly int UserDataOffset;

        /// <summary>
        /// Raw packet data. Do not modify header! Use UserDataOffset as start point for your data
        /// </summary>
        public byte[] Data => _packet.RawData;

        internal PooledPacket(NetPacket packet, int maxDataSize, byte channelNumber)
        {
            _packet = packet;
            UserDataOffset = _packet.GetHeaderSize();
            _packet.Size = UserDataOffset;
            MaxUserDataSize = maxDataSize - UserDataOffset;
            _channelNumber = channelNumber;
        }
    }
}
﻿using System;

namespace LiteNetLib
{
    internal sealed class ReliableChannel : BaseChannel
    {
        private struct PendingPacket
        {
            private NetPacket _packet;
            private long _timeStamp;
            private bool _isSent;

            public override string ToString()
            {
                return _packet == null ? "Empty" : _packet.Sequence.ToString();
            }

            public void Init(NetPacket packet)
            {
                _packet = packet;
                _isSent = false;
            }

            //Returns true if there is a pending packet inside
            public bool TrySend(long currentTime, NetPeer peer)
            {
                if (_packet == null)
                    return false;

                if (_isSent) //check send time
                {
                    double resendDelay = peer.ResendDelay * TimeSpan.TicksPerMillisecond;
                    double packetHoldTime = currentTime - _timeStamp;
                    if (packetHoldTime < resendDelay)
                        return true;
                    NetDebug.Write($"[RC]Resend: {packetHoldTime} > {resendDelay}");
                }
                _timeStamp = currentTime;
                _isSent = true;
                peer.SendUserData(_packet);
                return true;
            }

            public bool Clear(NetPeer peer)
            {
                if (_packet != null)
                {
                    peer.RecycleAndDeliver(_packet);
                    _packet = null;
                    return true;
                }
                return false;
            }
        }

        private readonly NetPacket _outgoingAcks;            //for send acks
        private readonly PendingPacket[] _pendingPackets;    //for unacked packets and duplicates
        private readonly NetPacket[] _receivedPackets;       //for order
        private readonly bool[] _earlyReceived;              //for unordered

        private int _localSeqence;
        private int _remoteSequence;
        private int _localWindowStart;
        private int _remoteWindowStart;

        private bool _mustSendAcks;

        private readonly DeliveryMethod _deliveryMethod;
        private readonly bool _ordered;
        private readonly int _windowSize;
        private const int BitsInByte = 8;
        private readonly byte _id;

        public ReliableChannel(NetPeer peer, bool ordered, byte id) : base(peer)
        {
            _id = id;
            _windowSize = NetConstants.DefaultWindowSize;
            _ordered = ordered;
            _pendingPackets = new PendingPacket[_windowSize];
            for (int i = 0; i < _pendingPackets.Length; i++)
                _pendingPackets[i] = new();

            if (_ordered)
            {
                _deliveryMethod = DeliveryMethod.ReliableOrdered;
                _receivedPackets = new NetPacket[_windowSize];
            }
            else
            {
                _deliveryMethod = DeliveryMethod.ReliableUnordered;
                _earlyReceived = new bool[_windowSize];
            }

            _localWindowStart = 0;
            _localSeqence = 0;
            _remoteSequence = 0;
            _remoteWindowStart = 0;
            _outgoingAcks = new(PacketProperty.Ack, (_windowSize - 1) / BitsInByte + 2) {ChannelId = id};
        }

        //ProcessAck in packet
        private void ProcessAck(NetPacket packet)
        {
            if (packet.Size != _outgoingAcks.Size)
            {
                NetDebug.Write("[PA]Invalid acks packet size");
                return;
            }

            ushort ackWindowStart = packet.Sequence;
            int windowRel = NetUtils.RelativeSequenceNumber(_localWindowStart, ackWindowStart);
            if (ackWindowStart >= NetConstants.MaxSequence || windowRel < 0)
            {
                NetDebug.Write("[PA]Bad window start");
                return;
            }

            //check relevance
            if (windowRel >= _windowSize)
            {
                NetDebug.Write("[PA]Old acks");
                return;
            }

            byte[] acksData = packet.RawData;
            lock (_pendingPackets)
            {
                for (int pendingSeq = _localWindowStart;
                    pendingSeq != _localSeqence;
                    pendingSeq = (pendingSeq + 1) % NetConstants.MaxSequence)
                {
                    int rel = NetUtils.RelativeSequenceNumber(pendingSeq, ackWindowStart);
                    if (rel >= _windowSize)
                    {
                        NetDebug.Write("[PA]REL: " + rel);
                        break;
                    }

                    int pendingIdx = pendingSeq % _windowSize;
                    int currentByte = NetConstants.ChanneledHeaderSize + pendingIdx / BitsInByte;
                    int currentBit = pendingIdx % BitsInByte;
                    if ((acksData[currentByte] & (1 << currentBit)) == 0)
                    {
                        if (Peer.NetManager.EnableStatistics)
                        {
                            Peer.Statistics.IncrementPacketLoss();
                            Peer.NetManager.Statistics.IncrementPacketLoss();
                        }

                        //Skip false ack
                        NetDebug.Write($"[PA]False ack: {pendingSeq}");
                        continue;
                    }

                    if (pendingSeq == _localWindowStart)
                    {
                        //Move window
                        _localWindowStart = (_localWindowStart + 1) % NetConstants.MaxSequence;
                    }

                    //clear packet
                    if (_pendingPackets[pendingIdx].Clear(Peer))
                        NetDebug.Write($"[PA]Removing reliableInOrder ack: {pendingSeq} - true");
                }
            }
        }

        protected override bool SendNextPackets()
        {
            if (_mustSendAcks)
            {
                _mustSendAcks = false;
                NetDebug.Write("[RR]SendAcks");
                lock(_outgoingAcks)
                    Peer.SendUserData(_outgoingAcks);
            }

            long currentTime = DateTime.UtcNow.Ticks;
            bool hasPendingPackets = false;

            lock (_pendingPackets)
            {
                //get packets from queue
                lock (OutgoingQueue)
                {
                    while (OutgoingQueue.Count > 0)
                    {
                        int relate = NetUtils.RelativeSequenceNumber(_localSeqence, _localWindowStart);
                        if (relate >= _windowSize)
                            break;

                        var netPacket = OutgoingQueue.Dequeue();
                        netPacket.Sequence = (ushort) _localSeqence;
                        netPacket.ChannelId = _id;
                        _pendingPackets[_localSeqence % _windowSize].Init(netPacket);
                        _localSeqence = (_localSeqence + 1) % NetConstants.MaxSequence;
                    }
                }

                //send
                for (int pendingSeq = _localWindowStart; pendingSeq != _localSeqence; pendingSeq = (pendingSeq + 1) % NetConstants.MaxSequence)
                {
                    // Please note: TrySend is invoked on a mutable struct, it's important to not extract it into a variable here
                    if (_pendingPackets[pendingSeq % _windowSize].TrySend(currentTime, Peer))
                        hasPendingPackets = true;
                }
            }

            return hasPendingPackets || _mustSendAcks || OutgoingQueue.Count > 0;
        }

        //Process incoming packet
        public override bool ProcessPacket(NetPacket packet)
        {
            if (packet.Property == PacketProperty.Ack)
            {
                ProcessAck(packet);
                return false;
            }
            int seq = packet.Sequence;
            if (seq >= NetConstants.MaxSequence)
            {
                NetDebug.Write("[RR]Bad sequence");
                return false;
            }

            int relate = NetUtils.RelativeSequenceNumber(seq, _remoteWindowStart);
            int relateSeq = NetUtils.RelativeSequenceNumber(seq, _remoteSequence);

            if (relateSeq > _windowSize)
            {
                NetDebug.Write("[RR]Bad sequence");
                return false;
            }

            //Drop bad packets
            if (relate < 0)
            {
                //Too old packet doesn't ack
                NetDebug.Write("[RR]ReliableInOrder too old");
                return false;
            }
            if (relate >= _windowSize * 2)
            {
                //Some very new packet
                NetDebug.Write("[RR]ReliableInOrder too new");
                return false;
            }

            //If very new - move window
            int ackIdx;
            int ackByte;
            int ackBit;
            lock (_outgoingAcks)
            {
                if (relate >= _windowSize)
                {
                    //New window position
                    int newWindowStart = (_remoteWindowStart + relate - _windowSize + 1) % NetConstants.MaxSequence;
                    _outgoingAcks.Sequence = (ushort) newWindowStart;

                    //Clean old data
                    while (_remoteWindowStart != newWindowStart)
                    {
                        ackIdx = _remoteWindowStart % _windowSize;
                        ackByte = NetConstants.ChanneledHeaderSize + ackIdx / BitsInByte;
                        ackBit = ackIdx % BitsInByte;
                        _outgoingAcks.RawData[ackByte] &= (byte) ~(1 << ackBit);
                        _remoteWindowStart = (_remoteWindowStart + 1) % NetConstants.MaxSequence;
                    }
                }

                //Final stage - process valid packet
                //trigger acks send
                _mustSendAcks = true;

                ackIdx = seq % _windowSize;
                ackByte = NetConstants.ChanneledHeaderSize + ackIdx / BitsInByte;
                ackBit = ackIdx % BitsInByte;
                if ((_outgoingAcks.RawData[ackByte] & (1 << ackBit)) != 0)
                {
                    NetDebug.Write("[RR]ReliableInOrder duplicate");
                    //because _mustSendAcks == true
                    AddToPeerChannelSendQueue();
                    return false;
                }

                //save ack
                _outgoingAcks.RawData[ackByte] |= (byte) (1 << ackBit);
            }

            AddToPeerChannelSendQueue();

            //detailed check
            if (seq == _remoteSequence)
            {
                NetDebug.Write("[RR]ReliableInOrder packet succes");
                Peer.AddReliablePacket(_deliveryMethod, packet);
                _remoteSequence = (_remoteSequence + 1) % NetConstants.MaxSequence;

                if (_ordered)
                {
                    NetPacket p;
                    while ((p = _receivedPackets[_remoteSequence % _windowSize]) != null)
                    {
                        //process holden packet
                        _receivedPackets[_remoteSequence % _windowSize] = null;
                        Peer.AddReliablePacket(_deliveryMethod, p);
                        _remoteSequence = (_remoteSequence + 1) % NetConstants.MaxSequence;
                    }
                }
                else
                {
                    while (_earlyReceived[_remoteSequence % _windowSize])
                    {
                        //process early packet
                        _earlyReceived[_remoteSequence % _windowSize] = false;
                        _remoteSequence = (_remoteSequence + 1) % NetConstants.MaxSequence;
                    }
                }
                return true;
            }

            //holden packet
            if (_ordered)
            {
                _receivedPackets[ackIdx] = packet;
            }
            else
            {
                _earlyReceived[ackIdx] = true;
                Peer.AddReliablePacket(_deliveryMethod, packet);
            }
            return true;
        }
    }
}
using System;

namespace LiteNetLib
{
    internal sealed class SequencedChannel : BaseChannel
    {
        private int _localSequence;
        private ushort _remoteSequence;
        private readonly bool _reliable;
        private NetPacket _lastPacket;
        private readonly NetPacket _ackPacket;
        private bool _mustSendAck;
        private readonly byte _id;
        private long _lastPacketSendTime;

        public SequencedChannel(NetPeer peer, bool reliable, byte id) : base(peer)
        {
            _id = id;
            _reliable = reliable;
            if (_reliable)
                _ackPacket = new(PacketProperty.Ack, 0) {ChannelId = id};
        }

        protected override bool SendNextPackets()
        {
            if (_reliable && OutgoingQueue.Count == 0)
            {
                long currentTime = DateTime.UtcNow.Ticks;
                long packetHoldTime = currentTime - _lastPacketSendTime;
                if (packetHoldTime >= Peer.ResendDelay * TimeSpan.TicksPerMillisecond)
                {
                    var packet = _lastPacket;
                    if (packet != null)
                    {
                        _lastPacketSendTime = currentTime;
                        Peer.SendUserData(packet);
                    }
                }
            }
            else
            {
                lock (OutgoingQueue)
                {
                    while (OutgoingQueue.Count > 0)
                    {
                        NetPacket packet = OutgoingQueue.Dequeue();
                        _localSequence = (_localSequence + 1) % NetConstants.MaxSequence;
                        packet.Sequence = (ushort)_localSequence;
                        packet.ChannelId = _id;
                        Peer.SendUserData(packet);

                        if (_reliable && OutgoingQueue.Count == 0)
                        {
                            _lastPacketSendTime = DateTime.UtcNow.Ticks;
                            _lastPacket = packet;
                        }
                        else
                        {
                            Peer.NetManager.PoolRecycle(packet);
                        }
                    }
                }
            }

            if (_reliable && _mustSendAck)
            {
                _mustSendAck = false;
                _ackPacket.Sequence = _remoteSequence;
                Peer.SendUserData(_ackPacket);
            }

            return _lastPacket != null;
        }

        public override bool ProcessPacket(NetPacket packet)
        {
            if (packet.IsFragmented)
                return false;
            if (packet.Property == PacketProperty.Ack)
            {
                if (_reliable && _lastPacket != null && packet.Sequence == _lastPacket.Sequence)
                    _lastPacket = null;
                return false;
            }
            int relative = NetUtils.RelativeSequenceNumber(packet.Sequence, _remoteSequence);
            bool packetProcessed = false;
            if (packet.Sequence < NetConstants.MaxSequence && relative > 0)
            {
                if (Peer.NetManager.EnableStatistics)
                {
                    Peer.Statistics.AddPacketLoss(relative - 1);
                    Peer.NetManager.Statistics.AddPacketLoss(relative - 1);
                }

                _remoteSequence = packet.Sequence;
                Peer.NetManager.CreateReceiveEvent(
                    packet,
                    _reliable ? DeliveryMethod.ReliableSequenced : DeliveryMethod.Sequenced,
                    (byte)(packet.ChannelId / NetConstants.ChannelTypeCount),
                    NetConstants.ChanneledHeaderSize,
                    Peer);
                packetProcessed = true;
            }

            if (_reliable)
            {
                _mustSendAck = true;
                AddToPeerChannelSendQueue();
            }

            return packetProcessed;
        }
    }
}
﻿#if NET5_0_OR_GREATER
using System.Diagnostics.CodeAnalysis;
using static System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes;

namespace LiteNetLib
{
    internal static class Trimming
    {
        internal const DynamicallyAccessedMemberTypes SerializerMemberTypes = PublicProperties | NonPublicProperties;
    }
}
#endif
﻿using LiteNetLib.Utils;
using System;
using System.Net;

namespace LiteNetLib.Layers
{
    public sealed class Crc32cLayer : PacketLayerBase
    {
        public Crc32cLayer() : base(CRC32C.ChecksumSize)
        {

        }

        public override void ProcessInboundPacket(ref IPEndPoint endPoint, ref byte[] data, ref int length)
        {
            if (length < NetConstants.HeaderSize + CRC32C.ChecksumSize)
            {
                NetDebug.WriteError("[NM] DataReceived size: bad!");
                //Set length to 0 to have netManager drop the packet.
                length = 0;
                return;
            }

            int checksumPoint = length - CRC32C.ChecksumSize;
            if (CRC32C.Compute(data, 0, checksumPoint) != BitConverter.ToUInt32(data, checksumPoint))
            {
                NetDebug.Write("[NM] DataReceived checksum: bad!");
                //Set length to 0 to have netManager drop the packet.
                length = 0;
                return;
            }
            length -= CRC32C.ChecksumSize;
        }

        public override void ProcessOutBoundPacket(ref IPEndPoint endPoint, ref byte[] data, ref int offset, ref int length)
        {
            FastBitConverter.GetBytes(data, length, CRC32C.Compute(data, offset, length));
            length += CRC32C.ChecksumSize;
        }
    }
}
﻿using System.Net;

namespace LiteNetLib.Layers
{
    public abstract class PacketLayerBase
    {
        public readonly int ExtraPacketSizeForLayer;

        protected PacketLayerBase(int extraPacketSizeForLayer)
        {
            ExtraPacketSizeForLayer = extraPacketSizeForLayer;
        }

        public abstract void ProcessInboundPacket(ref IPEndPoint endPoint, ref byte[] data, ref int length);
        public abstract void ProcessOutBoundPacket(ref IPEndPoint endPoint, ref byte[] data, ref int offset, ref int length);
    }
}
﻿using System;
using System.Net;
using System.Text;

namespace LiteNetLib.Layers
{
    public class XorEncryptLayer : PacketLayerBase
    {
        private byte[] _byteKey;

        public XorEncryptLayer() : base(0)
        {

        }

        public XorEncryptLayer(byte[] key) : this()
        {
            SetKey(key);
        }

        public XorEncryptLayer(string key) : this()
        {
            SetKey(key);
        }

        public void SetKey(string key)
        {
            _byteKey = Encoding.UTF8.GetBytes(key);
        }

        public void SetKey(byte[] key)
        {
            if (_byteKey == null || _byteKey.Length != key.Length)
                _byteKey = new byte[key.Length];
            Buffer.BlockCopy(key, 0, _byteKey, 0, key.Length);
        }

        public override void ProcessInboundPacket(ref IPEndPoint endPoint, ref byte[] data, ref int length)
        {
            if (_byteKey == null)
                return;
            for (int i = 0; i < length; i++)
            {
                data[i] = (byte)(data[i] ^ _byteKey[i % _byteKey.Length]);
            }
        }

        public override void ProcessOutBoundPacket(ref IPEndPoint endPoint, ref byte[] data, ref int offset, ref int length)
        {
            if (_byteKey == null)
                return;
            int cur = offset;
            for (int i = 0; i < length; i++, cur++)
            {
                data[cur] = (byte)(data[cur] ^ _byteKey[i % _byteKey.Length]);
            }
        }
    }
}
﻿#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP3_1 || NET5_0
using System;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics.X86;
#endif
#if NET5_0_OR_GREATER || NET5_0
using System.Runtime.Intrinsics.Arm;
#endif

namespace LiteNetLib.Utils
{
    //Implementation from Crc32.NET
    public static class CRC32C
    {
        public const int ChecksumSize = 4;
        private const uint Poly = 0x82F63B78u;
        private static readonly uint[] Table;

        static CRC32C()
        {
#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP3_1 || NET5_0
            if (Sse42.IsSupported)
                return;
#endif
#if NET5_0_OR_GREATER || NET5_0
            if (Crc32.IsSupported)
                return;
#endif
            Table = NetUtils.AllocatePinnedUninitializedArray<uint>(16 * 256);
            for (uint i = 0; i < 256; i++)
            {
                uint res = i;
                for (int t = 0; t < 16; t++)
                {
                    for (int k = 0; k < 8; k++)
                        res = (res & 1) == 1 ? Poly ^ (res >> 1) : (res >> 1);
                    Table[t * 256 + i] = res;
                }
            }
        }

        /// <summary>
        /// Compute CRC32C for data
        /// </summary>
        /// <param name="input">input data</param>
        /// <param name="offset">offset</param>
        /// <param name="length">length</param>
        /// <returns>CRC32C checksum</returns>
        public static uint Compute(byte[] input, int offset, int length)
        {
            uint crcLocal = uint.MaxValue;
#if NETCOREAPP3_0_OR_GREATER || NETCOREAPP3_1 || NET5_0
            if (Sse42.IsSupported)
            {
                var data = new ReadOnlySpan<byte>(input, offset, length);
                int processed = 0;
                if (Sse42.X64.IsSupported && data.Length > sizeof(ulong))
                {
                    processed = data.Length / sizeof(ulong) * sizeof(ulong);
                    var ulongs = MemoryMarshal.Cast<byte, ulong>(data.Slice(0, processed));
                    ulong crclong = crcLocal;
                    for (int i = 0; i < ulongs.Length; i++)
                    {
                        crclong = Sse42.X64.Crc32(crclong, ulongs[i]);
                    }

                    crcLocal = (uint)crclong;
                }
                else if (data.Length > sizeof(uint))
                {
                    processed = data.Length / sizeof(uint) * sizeof(uint);
                    var uints = MemoryMarshal.Cast<byte, uint>(data.Slice(0, processed));
                    for (int i = 0; i < uints.Length; i++)
                    {
                        crcLocal = Sse42.Crc32(crcLocal, uints[i]);
                    }
                }

                for (int i = processed; i < data.Length; i++)
                {
                    crcLocal = Sse42.Crc32(crcLocal, data[i]);
                }

                return crcLocal ^ uint.MaxValue;
            }
#endif
#if NET5_0_OR_GREATER || NET5_0
            if (Crc32.IsSupported)
            {
                var data = new ReadOnlySpan<byte>(input, offset, length);
                int processed = 0;
                if (Crc32.Arm64.IsSupported && data.Length > sizeof(ulong))
                {
                    processed = data.Length / sizeof(ulong) * sizeof(ulong);
                    var ulongs = MemoryMarshal.Cast<byte, ulong>(data.Slice(0, processed));
                    for (int i = 0; i < ulongs.Length; i++)
                    {
                        crcLocal = Crc32.Arm64.ComputeCrc32C(crcLocal, ulongs[i]);
                    }
                }
                else if (data.Length > sizeof(uint))
                {
                    processed = data.Length / sizeof(uint) * sizeof(uint);
                    var uints = MemoryMarshal.Cast<byte, uint>(data.Slice(0, processed));
                    for (int i = 0; i < uints.Length; i++)
                    {
                        crcLocal = Crc32.ComputeCrc32C(crcLocal, uints[i]);
                    }
                }

                for (int i = processed; i < data.Length; i++)
                {
                    crcLocal = Crc32.ComputeCrc32C(crcLocal, data[i]);
                }

                return crcLocal ^ uint.MaxValue;
            }
#endif
            while (length >= 16)
            {
                var a = Table[(3 * 256) + input[offset + 12]]
                        ^ Table[(2 * 256) + input[offset + 13]]
                        ^ Table[(1 * 256) + input[offset + 14]]
                        ^ Table[(0 * 256) + input[offset + 15]];

                var b = Table[(7 * 256) + input[offset + 8]]
                        ^ Table[(6 * 256) + input[offset + 9]]
                        ^ Table[(5 * 256) + input[offset + 10]]
                        ^ Table[(4 * 256) + input[offset + 11]];

                var c = Table[(11 * 256) + input[offset + 4]]
                        ^ Table[(10 * 256) + input[offset + 5]]
                        ^ Table[(9 * 256) + input[offset + 6]]
                        ^ Table[(8 * 256) + input[offset + 7]];

                var d = Table[(15 * 256) + ((byte)crcLocal ^ input[offset])]
                        ^ Table[(14 * 256) + ((byte)(crcLocal >> 8) ^ input[offset + 1])]
                        ^ Table[(13 * 256) + ((byte)(crcLocal >> 16) ^ input[offset + 2])]
                        ^ Table[(12 * 256) + ((crcLocal >> 24) ^ input[offset + 3])];

                crcLocal = d ^ c ^ b ^ a;
                offset += 16;
                length -= 16;
            }
            while (--length >= 0)
                crcLocal = Table[(byte)(crcLocal ^ input[offset++])] ^ crcLocal >> 8;
            return crcLocal ^ uint.MaxValue;
        }
    }
}
﻿using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace LiteNetLib.Utils
{
    public static class FastBitConverter
    {
#if (LITENETLIB_UNSAFE || NETCOREAPP3_1 || NET5_0 || NETCOREAPP3_0_OR_GREATER) && !BIGENDIAN
#if LITENETLIB_UNSAFE
        
        public static unsafe void GetBytes<T>(byte[] bytes, int startIndex, T value) where T : unmanaged
        {
            int size = sizeof(T);
            if (bytes.Length < startIndex + size)
                ThrowIndexOutOfRangeException();
#if NETCOREAPP3_1 || NET5_0 || NETCOREAPP3_0_OR_GREATER
            Unsafe.As<byte, T>(ref bytes[startIndex]) = value;
#else
            fixed (byte* ptr = &bytes[startIndex])
            {
#if UNITY_ANDROID
                // On some android systems, assigning *(T*)ptr throws a NRE if
                // the ptr isn't aligned (i.e. if Position is 1,2,3,5, etc.).
                // Here we have to use memcpy.
                //
                // => we can't get a pointer of a struct in C# without
                //    marshalling allocations
                // => instead, we stack allocate an array of type T and use that
                // => stackalloc avoids GC and is very fast. it only works for
                //    value types, but all blittable types are anyway.
                T* valueBuffer = stackalloc T[1] { value };
                UnsafeUtility.MemCpy(ptr, valueBuffer, size);
#else
                *(T*)ptr = value;
#endif
            }
#endif
        }
#else
        
        public static void GetBytes<T>(byte[] bytes, int startIndex, T value) where T : unmanaged
        {
            if (bytes.Length < startIndex + Unsafe.SizeOf<T>())
                ThrowIndexOutOfRangeException();
            Unsafe.As<byte, T>(ref bytes[startIndex]) = value;
        }
#endif

        private static void ThrowIndexOutOfRangeException() => throw new IndexOutOfRangeException();
#else
        [StructLayout(LayoutKind.Explicit)]
        private struct ConverterHelperDouble
        {
            [FieldOffset(0)]
            public ulong Along;

            [FieldOffset(0)]
            public double Adouble;
        }

        [StructLayout(LayoutKind.Explicit)]
        private struct ConverterHelperFloat
        {
            [FieldOffset(0)]
            public int Aint;

            [FieldOffset(0)]
            public float Afloat;
        }

        
        private static void WriteLittleEndian(byte[] buffer, int offset, ulong data)
        {
#if BIGENDIAN
            buffer[offset + 7] = (byte)(data);
            buffer[offset + 6] = (byte)(data >> 8);
            buffer[offset + 5] = (byte)(data >> 16);
            buffer[offset + 4] = (byte)(data >> 24);
            buffer[offset + 3] = (byte)(data >> 32);
            buffer[offset + 2] = (byte)(data >> 40);
            buffer[offset + 1] = (byte)(data >> 48);
            buffer[offset    ] = (byte)(data >> 56);
#else
            buffer[offset] = (byte)(data);
            buffer[offset + 1] = (byte)(data >> 8);
            buffer[offset + 2] = (byte)(data >> 16);
            buffer[offset + 3] = (byte)(data >> 24);
            buffer[offset + 4] = (byte)(data >> 32);
            buffer[offset + 5] = (byte)(data >> 40);
            buffer[offset + 6] = (byte)(data >> 48);
            buffer[offset + 7] = (byte)(data >> 56);
#endif
        }

        
        private static void WriteLittleEndian(byte[] buffer, int offset, int data)
        {
#if BIGENDIAN
            buffer[offset + 3] = (byte)(data);
            buffer[offset + 2] = (byte)(data >> 8);
            buffer[offset + 1] = (byte)(data >> 16);
            buffer[offset    ] = (byte)(data >> 24);
#else
            buffer[offset] = (byte)(data);
            buffer[offset + 1] = (byte)(data >> 8);
            buffer[offset + 2] = (byte)(data >> 16);
            buffer[offset + 3] = (byte)(data >> 24);
#endif
        }

        
        public static void WriteLittleEndian(byte[] buffer, int offset, short data)
        {
#if BIGENDIAN
            buffer[offset + 1] = (byte)(data);
            buffer[offset    ] = (byte)(data >> 8);
#else
            buffer[offset] = (byte)(data);
            buffer[offset + 1] = (byte)(data >> 8);
#endif
        }

        
        public static void GetBytes(byte[] bytes, int startIndex, double value)
        {
            ConverterHelperDouble ch = new() { Adouble = value };
            WriteLittleEndian(bytes, startIndex, ch.Along);
        }

        
        public static void GetBytes(byte[] bytes, int startIndex, float value)
        {
            ConverterHelperFloat ch = new() { Afloat = value };
            WriteLittleEndian(bytes, startIndex, ch.Aint);
        }

        
        public static void GetBytes(byte[] bytes, int startIndex, short value)
        {
            WriteLittleEndian(bytes, startIndex, value);
        }

        
        public static void GetBytes(byte[] bytes, int startIndex, ushort value)
        {
            WriteLittleEndian(bytes, startIndex, (short)value);
        }

        
        public static void GetBytes(byte[] bytes, int startIndex, int value)
        {
            WriteLittleEndian(bytes, startIndex, value);
        }

        
        public static void GetBytes(byte[] bytes, int startIndex, uint value)
        {
            WriteLittleEndian(bytes, startIndex, (int)value);
        }

        
        public static void GetBytes(byte[] bytes, int startIndex, long value)
        {
            WriteLittleEndian(bytes, startIndex, (ulong)value);
        }

        
        public static void GetBytes(byte[] bytes, int startIndex, ulong value)
        {
            WriteLittleEndian(bytes, startIndex, value);
        }
#endif
    }
}
﻿namespace LiteNetLib.Utils
{
    public interface INetSerializable
    {
        void Serialize(NetDataWriter writer);
        void Deserialize(NetDataReader reader);
    }
}
﻿using System;
using System.Net;
using System.Runtime.CompilerServices;

namespace LiteNetLib.Utils
{
    public class NetDataReader
    {
        protected byte[] _data;
        protected int _position;
        protected int _dataSize;
        private int _offset;

        public byte[] RawData
        {
            
            get => _data;
        }
        public int RawDataSize
        {
            
            get => _dataSize;
        }
        public int UserDataOffset
        {
            
            get => _offset;
        }
        public int UserDataSize
        {
            
            get => _dataSize - _offset;
        }
        public bool IsNull
        {
            
            get => _data == null;
        }
        public int Position
        {
            
            get => _position;
        }
        public bool EndOfData
        {
            
            get => _position == _dataSize;
        }
        public int AvailableBytes
        {
            
            get => _dataSize - _position;
        }

        public void SkipBytes(int count)
        {
            _position += count;
        }

        public void SetPosition(int position)
        {
            _position = position;
        }

        public void SetSource(NetDataWriter dataWriter)
        {
            _data = dataWriter.Data;
            _position = 0;
            _offset = 0;
            _dataSize = dataWriter.Length;
        }

        public void SetSource(byte[] source)
        {
            _data = source;
            _position = 0;
            _offset = 0;
            _dataSize = source.Length;
        }

        public void SetSource(byte[] source, int offset, int maxSize)
        {
            _data = source;
            _position = offset;
            _offset = offset;
            _dataSize = maxSize;
        }

        public NetDataReader()
        {

        }

        public NetDataReader(NetDataWriter writer)
        {
            SetSource(writer);
        }

        public NetDataReader(byte[] source)
        {
            SetSource(source);
        }

        public NetDataReader(byte[] source, int offset, int maxSize)
        {
            SetSource(source, offset, maxSize);
        }

        #region GetMethods

        public void Get<T>(out T result) where T : struct, INetSerializable
        {
            result = default(T);
            result.Deserialize(this);
        }

        public void Get<T>(out T result, Func<T> constructor) where T : class, INetSerializable
        {
            result = constructor();
            result.Deserialize(this);
        }

        public void Get(out IPEndPoint result)
        {
            result = GetNetEndPoint();
        }

        public void Get(out byte result)
        {
            result = GetByte();
        }

        public void Get(out sbyte result)
        {
            result = (sbyte)GetByte();
        }

        public void Get(out bool result)
        {
            result = GetBool();
        }

        public void Get(out char result)
        {
            result = GetChar();
        }

        public void Get(out ushort result)
        {
            result = GetUShort();
        }

        public void Get(out short result)
        {
            result = GetShort();
        }

        public void Get(out ulong result)
        {
            result = GetULong();
        }

        public void Get(out long result)
        {
            result = GetLong();
        }

        public void Get(out uint result)
        {
            result = GetUInt();
        }

        public void Get(out int result)
        {
            result = GetInt();
        }

        public void Get(out double result)
        {
            result = GetDouble();
        }

        public void Get(out float result)
        {
            result = GetFloat();
        }

        public void Get(out string result)
        {
            result = GetString();
        }

        public void Get(out string result, int maxLength)
        {
            result = GetString(maxLength);
        }

        public IPEndPoint GetNetEndPoint()
        {
            string host = GetString(1000);
            int port = GetInt();
            return NetUtils.MakeEndPoint(host, port);
        }

        public byte GetByte()
        {
            byte res = _data[_position];
            _position++;
            return res;
        }

        public sbyte GetSByte()
        {
            return (sbyte)GetByte();
        }

        public T[] GetArray<T>(ushort size)
        {
            ushort length = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            T[] result = new T[length];
            length *= size;
            Buffer.BlockCopy(_data, _position, result, 0, length);
            _position += length;
            return result;
        }

        public T[] GetArray<T>() where T : INetSerializable, new()
        {
            ushort length = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            T[] result = new T[length];
            for (int i = 0; i < length; i++)
            {
                var item = new T();
                item.Deserialize(this);
                result[i] = item;
            }
            return result;
        }
        
        public bool[] GetBoolArray()
        {
            return GetArray<bool>(1);
        }

        public ushort[] GetUShortArray()
        {
            return GetArray<ushort>(2);
        }

        public short[] GetShortArray()
        {
            return GetArray<short>(2);
        }

        public int[] GetIntArray()
        {
            return GetArray<int>(4);
        }

        public uint[] GetUIntArray()
        {
            return GetArray<uint>(4);
        }

        public float[] GetFloatArray()
        {
            return GetArray<float>(4);
        }

        public double[] GetDoubleArray()
        {
            return GetArray<double>(8);
        }

        public long[] GetLongArray()
        {
            return GetArray<long>(8);
        }

        public ulong[] GetULongArray()
        {
            return GetArray<ulong>(8);
        }

        public string[] GetStringArray()
        {
            ushort length = GetUShort();
            string[] arr = new string[length];
            for (int i = 0; i < length; i++)
            {
                arr[i] = GetString();
            }
            return arr;
        }

        /// <summary>
        /// Note that "maxStringLength" only limits the number of characters in a string, not its size in bytes.
        /// Strings that exceed this parameter are returned as empty
        /// </summary>
        public string[] GetStringArray(int maxStringLength)
        {
            ushort length = GetUShort();
            string[] arr = new string[length];
            for (int i = 0; i < length; i++)
            {
                arr[i] = GetString(maxStringLength);
            }
            return arr;
        }

        public bool GetBool()
        {
            return GetByte() == 1;
        }

        public char GetChar()
        {
            return (char)GetUShort();
        }

        public ushort GetUShort()
        {
            ushort result = BitConverter.ToUInt16(_data, _position);
            _position += 2;
            return result;
        }

        public short GetShort()
        {
            short result = BitConverter.ToInt16(_data, _position);
            _position += 2;
            return result;
        }

        public long GetLong()
        {
            long result = BitConverter.ToInt64(_data, _position);
            _position += 8;
            return result;
        }

        public ulong GetULong()
        {
            ulong result = BitConverter.ToUInt64(_data, _position);
            _position += 8;
            return result;
        }

        public int GetInt()
        {
            int result = BitConverter.ToInt32(_data, _position);
            _position += 4;
            return result;
        }

        public uint GetUInt()
        {
            uint result = BitConverter.ToUInt32(_data, _position);
            _position += 4;
            return result;
        }

        public float GetFloat()
        {
            float result = BitConverter.ToSingle(_data, _position);
            _position += 4;
            return result;
        }

        public double GetDouble()
        {
            double result = BitConverter.ToDouble(_data, _position);
            _position += 8;
            return result;
        }

        /// <summary>
        /// Note that "maxLength" only limits the number of characters in a string, not its size in bytes.
        /// </summary>
        /// <returns>"string.Empty" if value > "maxLength"</returns>
        public string GetString(int maxLength)
        {
            ushort size = GetUShort();
            if (size == 0)
            {
                return string.Empty;
            }

            int actualSize = size - 1;
            if (actualSize >= NetDataWriter.StringBufferMaxLength)
            {
                return null;
            }

            ArraySegment<byte> data = GetBytesSegment(actualSize);

            return (maxLength > 0 && NetDataWriter.uTF8Encoding.Value.GetCharCount(data.Array, data.Offset, data.Count) > maxLength) ?
                string.Empty :
                NetDataWriter.uTF8Encoding.Value.GetString(data.Array, data.Offset, data.Count);
        }

        public string GetString()
        {
            ushort size = GetUShort();
            if (size == 0)
            {
                return string.Empty;
            }

            int actualSize = size - 1;
            if (actualSize >= NetDataWriter.StringBufferMaxLength)
            {
                return null;
            }

            ArraySegment<byte> data = GetBytesSegment(actualSize);

            return NetDataWriter.uTF8Encoding.Value.GetString(data.Array, data.Offset, data.Count);
        }

        public ArraySegment<byte> GetBytesSegment(int count)
        {
            ArraySegment<byte> segment = new(_data, _position, count);
            _position += count;
            return segment;
        }

        public ArraySegment<byte> GetRemainingBytesSegment()
        {
            ArraySegment<byte> segment = new(_data, _position, AvailableBytes);
            _position = _data.Length;
            return segment;
        }

        public T Get<T>() where T : struct, INetSerializable
        {
            var obj = default(T);
            obj.Deserialize(this);
            return obj;
        }

        public T Get<T>(Func<T> constructor) where T : class, INetSerializable
        {
            var obj = constructor();
            obj.Deserialize(this);
            return obj;
        }

#if LITENETLIB_SPANS || NETCOREAPP2_1_OR_GREATER || NETSTANDARD2_1_OR_GREATER || NETCOREAPP2_1 || NETCOREAPP3_1 || NET5_0 || NETSTANDARD2_1
        
        public ReadOnlySpan<byte> GetRemainingBytesSpan()
        {
            return new ReadOnlySpan<byte>(_data, _position, _dataSize - _position);
        }
#endif

        public byte[] GetRemainingBytes()
        {
            byte[] outgoingData = new byte[AvailableBytes];
            Buffer.BlockCopy(_data, _position, outgoingData, 0, AvailableBytes);
            _position = _data.Length;
            return outgoingData;
        }

        public void GetBytes(byte[] destination, int start, int count)
        {
            Buffer.BlockCopy(_data, _position, destination, start, count);
            _position += count;
        }

        public void GetBytes(byte[] destination, int count)
        {
            Buffer.BlockCopy(_data, _position, destination, 0, count);
            _position += count;
        }

        public sbyte[] GetSBytesWithLength()
        {
            return GetArray<sbyte>(1);
        }

        public byte[] GetBytesWithLength()
        {
            return GetArray<byte>(1);
        }
        #endregion

        #region PeekMethods

        public byte PeekByte()
        {
            return _data[_position];
        }

        public sbyte PeekSByte()
        {
            return (sbyte)_data[_position];
        }

        public bool PeekBool()
        {
            return _data[_position] == 1;
        }

        public char PeekChar()
        {
            return (char)PeekUShort();
        }

        public ushort PeekUShort()
        {
            return BitConverter.ToUInt16(_data, _position);
        }

        public short PeekShort()
        {
            return BitConverter.ToInt16(_data, _position);
        }

        public long PeekLong()
        {
            return BitConverter.ToInt64(_data, _position);
        }

        public ulong PeekULong()
        {
            return BitConverter.ToUInt64(_data, _position);
        }

        public int PeekInt()
        {
            return BitConverter.ToInt32(_data, _position);
        }

        public uint PeekUInt()
        {
            return BitConverter.ToUInt32(_data, _position);
        }

        public float PeekFloat()
        {
            return BitConverter.ToSingle(_data, _position);
        }

        public double PeekDouble()
        {
            return BitConverter.ToDouble(_data, _position);
        }

        /// <summary>
        /// Note that "maxLength" only limits the number of characters in a string, not its size in bytes.
        /// </summary>
        public string PeekString(int maxLength)
        {
            ushort size = PeekUShort();
            if (size == 0)
            {
                return string.Empty;
            }

            int actualSize = size - 1;
            if (actualSize >= NetDataWriter.StringBufferMaxLength)
            {
                return null;
            }

            return (maxLength > 0 && NetDataWriter.uTF8Encoding.Value.GetCharCount(_data, _position + 2, actualSize) > maxLength) ?
                string.Empty :
                NetDataWriter.uTF8Encoding.Value.GetString(_data, _position + 2, actualSize);
        }

        public string PeekString()
        {
            ushort size = PeekUShort();
            if (size == 0)
            {
                return string.Empty;
            }

            int actualSize = size - 1;
            if (actualSize >= NetDataWriter.StringBufferMaxLength)
            {
                return null;
            }

            return NetDataWriter.uTF8Encoding.Value.GetString(_data, _position + 2, actualSize);
        }
        #endregion

        #region TryGetMethods
        public bool TryGetByte(out byte result)
        {
            if (AvailableBytes >= 1)
            {
                result = GetByte();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetSByte(out sbyte result)
        {
            if (AvailableBytes >= 1)
            {
                result = GetSByte();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetBool(out bool result)
        {
            if (AvailableBytes >= 1)
            {
                result = GetBool();
                return true;
            }
            result = false;
            return false;
        }

        public bool TryGetChar(out char result)
        {
            if (!TryGetUShort(out ushort uShortValue))
            {
                result = '\0';
                return false;
            }
            result = (char)uShortValue;
            return true;
        }

        public bool TryGetShort(out short result)
        {
            if (AvailableBytes >= 2)
            {
                result = GetShort();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetUShort(out ushort result)
        {
            if (AvailableBytes >= 2)
            {
                result = GetUShort();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetInt(out int result)
        {
            if (AvailableBytes >= 4)
            {
                result = GetInt();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetUInt(out uint result)
        {
            if (AvailableBytes >= 4)
            {
                result = GetUInt();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetLong(out long result)
        {
            if (AvailableBytes >= 8)
            {
                result = GetLong();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetULong(out ulong result)
        {
            if (AvailableBytes >= 8)
            {
                result = GetULong();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetFloat(out float result)
        {
            if (AvailableBytes >= 4)
            {
                result = GetFloat();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetDouble(out double result)
        {
            if (AvailableBytes >= 8)
            {
                result = GetDouble();
                return true;
            }
            result = 0;
            return false;
        }

        public bool TryGetString(out string result)
        {
            if (AvailableBytes >= 2)
            {
                ushort strSize = PeekUShort();
                if (AvailableBytes >= strSize + 1)
                {
                    result = GetString();
                    return true;
                }
            }
            result = null;
            return false;
        }

        public bool TryGetStringArray(out string[] result)
        {
            if (!TryGetUShort(out ushort strArrayLength)) {
                result = null;
                return false;
            }

            result = new string[strArrayLength];
            for (int i = 0; i < strArrayLength; i++)
            {
                if (!TryGetString(out result[i]))
                {
                    result = null;
                    return false;
                }
            }

            return true;
        }

        public bool TryGetBytesWithLength(out byte[] result)
        {
            if (AvailableBytes >= 2)
            {
                ushort length = PeekUShort();
                if (length >= 0 && AvailableBytes >= 2 + length)
                {
                    result = GetBytesWithLength();
                    return true;
                }
            }
            result = null;
            return false;
        }
        #endregion

        public void Clear()
        {
            _position = 0;
            _dataSize = 0;
            _data = null;
        }
    }
}
﻿using System;
using System.Net;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;

namespace LiteNetLib.Utils
{
    public class NetDataWriter
    {
        protected byte[] _data;
        protected int _position;
        private const int InitialSize = 64;
        private readonly bool _autoResize;

        public int Capacity
        {
            
            get => _data.Length;
        }
        public byte[] Data
        {
            
            get => _data;
        }
        public int Length
        {
            
            get => _position;
        }

        public static readonly ThreadLocal<UTF8Encoding> uTF8Encoding = new(() => new(false, true));
        public const int StringBufferMaxLength = 65535;
        private readonly byte[] _stringBuffer = new byte[StringBufferMaxLength];

        public NetDataWriter() : this(true, InitialSize)
        {
        }

        public NetDataWriter(bool autoResize) : this(autoResize, InitialSize)
        {
        }

        public NetDataWriter(bool autoResize, int initialSize)
        {
            _data = new byte[initialSize];
            _autoResize = autoResize;
        }

        /// <summary>
        /// Creates NetDataWriter from existing ByteArray
        /// </summary>
        /// <param name="bytes">Source byte array</param>
        /// <param name="copy">Copy array to new location or use existing</param>
        public static NetDataWriter FromBytes(byte[] bytes, bool copy)
        {
            if (copy)
            {
                var netDataWriter = new NetDataWriter(true, bytes.Length);
                netDataWriter.Put(bytes);
                return netDataWriter;
            }
            return new(true, 0) {_data = bytes, _position = bytes.Length};
        }

        /// <summary>
        /// Creates NetDataWriter from existing ByteArray (always copied data)
        /// </summary>
        /// <param name="bytes">Source byte array</param>
        /// <param name="offset">Offset of array</param>
        /// <param name="length">Length of array</param>
        public static NetDataWriter FromBytes(byte[] bytes, int offset, int length)
        {
            var netDataWriter = new NetDataWriter(true, bytes.Length);
            netDataWriter.Put(bytes, offset, length);
            return netDataWriter;
        }

        public static NetDataWriter FromString(string value)
        {
            var netDataWriter = new NetDataWriter();
            netDataWriter.Put(value);
            return netDataWriter;
        }

        
        public void ResizeIfNeed(int newSize)
        {
            if (_data.Length < newSize)
            {
                Array.Resize(ref _data, Math.Max(newSize, _data.Length * 2));
            }
        }

        
        public void EnsureFit(int additionalSize)
        {
            if (_data.Length < _position + additionalSize)
            {
                Array.Resize(ref _data, Math.Max(_position + additionalSize, _data.Length * 2));
            }
        }

        public void Reset(int size)
        {
            ResizeIfNeed(size);
            _position = 0;
        }

        public void Reset()
        {
            _position = 0;
        }

        public byte[] CopyData()
        {
            byte[] resultData = new byte[_position];
            Buffer.BlockCopy(_data, 0, resultData, 0, _position);
            return resultData;
        }

        /// <summary>
        /// Sets position of NetDataWriter to rewrite previous values
        /// </summary>
        /// <param name="position">new byte position</param>
        /// <returns>previous position of data writer</returns>
        public int SetPosition(int position)
        {
            int prevPosition = _position;
            _position = position;
            return prevPosition;
        }

        public void Put(float value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 4);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 4;
        }

        public void Put(double value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 8);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 8;
        }

        public void Put(long value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 8);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 8;
        }

        public void Put(ulong value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 8);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 8;
        }

        public void Put(int value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 4);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 4;
        }

        public void Put(uint value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 4);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 4;
        }

        public void Put(char value)
        {
            Put((ushort)value);
        }

        public void Put(ushort value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 2);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 2;
        }

        public void Put(short value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 2);
            FastBitConverter.GetBytes(_data, _position, value);
            _position += 2;
        }

        public void Put(sbyte value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 1);
            _data[_position] = (byte)value;
            _position++;
        }

        public void Put(byte value)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 1);
            _data[_position] = value;
            _position++;
        }

        public void Put(byte[] data, int offset, int length)
        {
            if (_autoResize)
                ResizeIfNeed(_position + length);
            Buffer.BlockCopy(data, offset, _data, _position, length);
            _position += length;
        }

        public void Put(byte[] data)
        {
            if (_autoResize)
                ResizeIfNeed(_position + data.Length);
            Buffer.BlockCopy(data, 0, _data, _position, data.Length);
            _position += data.Length;
        }

        public void PutSBytesWithLength(sbyte[] data, int offset, ushort length)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 2 + length);
            FastBitConverter.GetBytes(_data, _position, length);
            Buffer.BlockCopy(data, offset, _data, _position + 2, length);
            _position += 2 + length;
        }

        public void PutSBytesWithLength(sbyte[] data)
        {
            PutArray(data, 1);
        }

        public void PutBytesWithLength(byte[] data, int offset, ushort length)
        {
            if (_autoResize)
                ResizeIfNeed(_position + 2 + length);
            FastBitConverter.GetBytes(_data, _position, length);
            Buffer.BlockCopy(data, offset, _data, _position + 2, length);
            _position += 2 + length;
        }

        public void PutBytesWithLength(byte[] data)
        {
            PutArray(data, 1);
        }

        public void Put(bool value)
        {
            Put((byte)(value ? 1 : 0));
        }

        public void PutArray(Array arr, int sz)
        {
            ushort length = arr == null ? (ushort) 0 : (ushort)arr.Length;
            sz *= length;
            if (_autoResize)
                ResizeIfNeed(_position + sz + 2);
            FastBitConverter.GetBytes(_data, _position, length);
            if (arr != null)
                Buffer.BlockCopy(arr, 0, _data, _position + 2, sz);
            _position += sz + 2;
        }

        public void PutArray(float[] value)
        {
            PutArray(value, 4);
        }

        public void PutArray(double[] value)
        {
            PutArray(value, 8);
        }

        public void PutArray(long[] value)
        {
            PutArray(value, 8);
        }

        public void PutArray(ulong[] value)
        {
            PutArray(value, 8);
        }

        public void PutArray(int[] value)
        {
            PutArray(value, 4);
        }

        public void PutArray(uint[] value)
        {
            PutArray(value, 4);
        }

        public void PutArray(ushort[] value)
        {
            PutArray(value, 2);
        }

        public void PutArray(short[] value)
        {
            PutArray(value, 2);
        }

        public void PutArray(bool[] value)
        {
            PutArray(value, 1);
        }

        public void PutArray(string[] value)
        {
            ushort strArrayLength = value == null ? (ushort)0 : (ushort)value.Length;
            Put(strArrayLength);
            for (int i = 0; i < strArrayLength; i++)
                Put(value[i]);
        }

        public void PutArray(string[] value, int strMaxLength)
        {
            ushort strArrayLength = value == null ? (ushort)0 : (ushort)value.Length;
            Put(strArrayLength);
            for (int i = 0; i < strArrayLength; i++)
                Put(value[i], strMaxLength);
        }
        
        public void PutArray<T>(T[] value) where T : INetSerializable, new()
        {
            ushort strArrayLength = (ushort)(value?.Length ?? 0);
            Put(strArrayLength);
            for (int i = 0; i < strArrayLength; i++)
                value[i].Serialize(this);
        }

        public void Put(IPEndPoint endPoint)
        {
            Put(endPoint.Address.ToString());
            Put(endPoint.Port);
        }

        public void Put(string value)
        {
            Put(value, 0);
        }

        /// <summary>
        /// Note that "maxLength" only limits the number of characters in a string, not its size in bytes.
        /// </summary>
        public void Put(string value, int maxLength)
        {
            if (string.IsNullOrEmpty(value))
            {
                Put((ushort)0);
                return;
            }

            int length = maxLength > 0 && value.Length > maxLength ? maxLength : value.Length;
            int size = uTF8Encoding.Value.GetBytes(value, 0, length, _stringBuffer, 0);

            if (size == 0 || size >= StringBufferMaxLength)
            {
                Put((ushort)0);
                return;
            }

            Put(checked((ushort)(size + 1)));
            Put(_stringBuffer, 0, size);
        }

        public void Put<T>(T obj) where T : INetSerializable
        {
            obj.Serialize(this);
        }
    }
}
﻿using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace LiteNetLib.Utils
{
    public class NetPacketProcessor
    {
        private static class HashCache<T>
        {
            public static readonly ulong Id;

            //FNV-1 64 bit hash
            static HashCache()
            {
                ulong hash = 14695981039346656037UL; //offset
                string typeName = typeof(T).ToString();
                for (var i = 0; i < typeName.Length; i++)
                {
                    hash ^= typeName[i];
                    hash *= 1099511628211UL; //prime
                }
                Id = hash;
            }
        }

        protected delegate void SubscribeDelegate(NetDataReader reader, object userData);
        private readonly NetSerializer _netSerializer;
        private readonly Dictionary<ulong, SubscribeDelegate> _callbacks = new();

        public NetPacketProcessor()
        {
            _netSerializer = new();
        }

        public NetPacketProcessor(int maxStringLength)
        {
            _netSerializer = new(maxStringLength);
        }

        protected virtual ulong GetHash<T>()
        {
            return HashCache<T>.Id;
        }

        protected virtual SubscribeDelegate GetCallbackFromData(NetDataReader reader)
        {
            ulong hash = reader.GetULong();
            if (!_callbacks.TryGetValue(hash, out var action))
            {
                throw new ParseException("Undefined packet in NetDataReader");
            }
            return action;
        }

        protected virtual void WriteHash<T>(NetDataWriter writer)
        {
            writer.Put(GetHash<T>());
        }

        /// <summary>
        /// Register nested property type
        /// </summary>
        /// <typeparam name="T">INetSerializable structure</typeparam>
        public void RegisterNestedType<T>() where T : struct, INetSerializable
        {
            _netSerializer.RegisterNestedType<T>();
        }

        /// <summary>
        /// Register nested property type
        /// </summary>
        /// <param name="writeDelegate"></param>
        /// <param name="readDelegate"></param>
        public void RegisterNestedType<T>(Action<NetDataWriter, T> writeDelegate, Func<NetDataReader, T> readDelegate)
        {
            _netSerializer.RegisterNestedType(writeDelegate, readDelegate);
        }

        /// <summary>
        /// Register nested property type
        /// </summary>
        /// <typeparam name="T">INetSerializable class</typeparam>
        public void RegisterNestedType<T>(Func<T> constructor) where T : class, INetSerializable
        {
            _netSerializer.RegisterNestedType(constructor);
        }

        /// <summary>
        /// Reads all available data from NetDataReader and calls OnReceive delegates
        /// </summary>
        /// <param name="reader">NetDataReader with packets data</param>
        public void ReadAllPackets(NetDataReader reader)
        {
            while (reader.AvailableBytes > 0)
                ReadPacket(reader);
        }

        /// <summary>
        /// Reads all available data from NetDataReader and calls OnReceive delegates
        /// </summary>
        /// <param name="reader">NetDataReader with packets data</param>
        /// <param name="userData">Argument that passed to OnReceivedEvent</param>
        /// <exception cref="ParseException">Malformed packet</exception>
        public void ReadAllPackets(NetDataReader reader, object userData)
        {
            while (reader.AvailableBytes > 0)
                ReadPacket(reader, userData);
        }

        /// <summary>
        /// Reads one packet from NetDataReader and calls OnReceive delegate
        /// </summary>
        /// <param name="reader">NetDataReader with packet</param>
        /// <exception cref="ParseException">Malformed packet</exception>
        public void ReadPacket(NetDataReader reader)
        {
            ReadPacket(reader, null);
        }

        public void Write<
#if NET5_0_OR_GREATER
            [DynamicallyAccessedMembers(Trimming.SerializerMemberTypes)]
#endif
        T>(NetDataWriter writer, T packet) where T : class, new()
        {
            WriteHash<T>(writer);
            _netSerializer.Serialize(writer, packet);
        }

        public void WriteNetSerializable<T>(NetDataWriter writer, ref T packet) where T : INetSerializable
        {
            WriteHash<T>(writer);
            packet.Serialize(writer);
        }

        /// <summary>
        /// Reads one packet from NetDataReader and calls OnReceive delegate
        /// </summary>
        /// <param name="reader">NetDataReader with packet</param>
        /// <param name="userData">Argument that passed to OnReceivedEvent</param>
        /// <exception cref="ParseException">Malformed packet</exception>
        public void ReadPacket(NetDataReader reader, object userData)
        {
            GetCallbackFromData(reader)(reader, userData);
        }

        /// <summary>
        /// Register and subscribe to packet receive event
        /// </summary>
        /// <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
        /// <param name="packetConstructor">Method that constructs packet instead of slow Activator.CreateInstance</param>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public void Subscribe<
#if NET5_0_OR_GREATER
            [DynamicallyAccessedMembers(Trimming.SerializerMemberTypes)]
#endif
        T>(Action<T> onReceive, Func<T> packetConstructor) where T : class, new()
        {
            _netSerializer.Register<T>();
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                var reference = packetConstructor();
                _netSerializer.Deserialize(reader, reference);
                onReceive(reference);
            };
        }

        /// <summary>
        /// Register and subscribe to packet receive event (with userData)
        /// </summary>
        /// <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
        /// <param name="packetConstructor">Method that constructs packet instead of slow Activator.CreateInstance</param>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public void Subscribe<
#if NET5_0_OR_GREATER
            [DynamicallyAccessedMembers(Trimming.SerializerMemberTypes)]
#endif
        T, TUserData>(Action<T, TUserData> onReceive, Func<T> packetConstructor) where T : class, new()
        {
            _netSerializer.Register<T>();
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                var reference = packetConstructor();
                _netSerializer.Deserialize(reader, reference);
                onReceive(reference, (TUserData)userData);
            };
        }

        /// <summary>
        /// Register and subscribe to packet receive event
        /// This method will overwrite last received packet class on receive (less garbage)
        /// </summary>
        /// <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public void SubscribeReusable<
#if NET5_0_OR_GREATER
            [DynamicallyAccessedMembers(Trimming.SerializerMemberTypes)]
#endif
        T>(Action<T> onReceive) where T : class, new()
        {
            _netSerializer.Register<T>();
            var reference = new T();
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                _netSerializer.Deserialize(reader, reference);
                onReceive(reference);
            };
        }

        /// <summary>
        /// Register and subscribe to packet receive event
        /// This method will overwrite last received packet class on receive (less garbage)
        /// </summary>
        /// <param name="onReceive">event that will be called when packet deserialized with ReadPacket method</param>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public void SubscribeReusable<
#if NET5_0_OR_GREATER
            [DynamicallyAccessedMembers(Trimming.SerializerMemberTypes)]
#endif
        T, TUserData>(Action<T, TUserData> onReceive) where T : class, new()
        {
            _netSerializer.Register<T>();
            var reference = new T();
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                _netSerializer.Deserialize(reader, reference);
                onReceive(reference, (TUserData)userData);
            };
        }

        public void SubscribeNetSerializable<T, TUserData>(
            Action<T, TUserData> onReceive,
            Func<T> packetConstructor) where T : INetSerializable
        {
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                var pkt = packetConstructor();
                pkt.Deserialize(reader);
                onReceive(pkt, (TUserData)userData);
            };
        }

        public void SubscribeNetSerializable<T>(
            Action<T> onReceive,
            Func<T> packetConstructor) where T : INetSerializable
        {
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                var pkt = packetConstructor();
                pkt.Deserialize(reader);
                onReceive(pkt);
            };
        }

        public void SubscribeNetSerializable<T, TUserData>(
            Action<T, TUserData> onReceive) where T : INetSerializable, new()
        {
            var reference = new T();
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                reference.Deserialize(reader);
                onReceive(reference, (TUserData)userData);
            };
        }

        public void SubscribeNetSerializable<T>(
            Action<T> onReceive) where T : INetSerializable, new()
        {
            var reference = new T();
            _callbacks[GetHash<T>()] = (reader, userData) =>
            {
                reference.Deserialize(reader);
                onReceive(reference);
            };
        }

        /// <summary>
        /// Remove any subscriptions by type
        /// </summary>
        /// <typeparam name="T">Packet type</typeparam>
        /// <returns>true if remove is success</returns>
        public bool RemoveSubscription<T>()
        {
            return _callbacks.Remove(GetHash<T>());
        }
    }
}
﻿using System;
using System.Reflection;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Runtime.Serialization;

namespace LiteNetLib.Utils
{
    public class InvalidTypeException : ArgumentException
    {
        public InvalidTypeException(string message) : base(message) { }
    }

    public class ParseException : Exception
    {
        public ParseException(string message) : base(message) { }
    }

    public class NetSerializer
    {
        private enum CallType
        {
            Basic,
            Array,
            List
        }

        private abstract class FastCall<T>
        {
            public CallType Type;
            public virtual void Init(MethodInfo getMethod, MethodInfo setMethod, CallType type) { Type = type; }
            public abstract void Read(T inf, NetDataReader r);
            public abstract void Write(T inf, NetDataWriter w);
            public abstract void ReadArray(T inf, NetDataReader r);
            public abstract void WriteArray(T inf, NetDataWriter w);
            public abstract void ReadList(T inf, NetDataReader r);
            public abstract void WriteList(T inf, NetDataWriter w);
        }

        private abstract class FastCallSpecific<TClass, TProperty> : FastCall<TClass>
        {
            protected Func<TClass, TProperty> Getter;
            protected Action<TClass, TProperty> Setter;
            protected Func<TClass, TProperty[]> GetterArr;
            protected Action<TClass, TProperty[]> SetterArr;
            protected Func<TClass, List<TProperty>> GetterList;
            protected Action<TClass, List<TProperty>> SetterList;

            public override void ReadArray(TClass inf, NetDataReader r) { throw new InvalidTypeException("Unsupported type: " + typeof(TProperty) + "[]"); }
            public override void WriteArray(TClass inf, NetDataWriter w) { throw new InvalidTypeException("Unsupported type: " + typeof(TProperty) + "[]"); }
            public override void ReadList(TClass inf, NetDataReader r) { throw new InvalidTypeException("Unsupported type: List<" + typeof(TProperty) + ">"); }
            public override void WriteList(TClass inf, NetDataWriter w) { throw new InvalidTypeException("Unsupported type: List<" + typeof(TProperty) + ">"); }

            protected TProperty[] ReadArrayHelper(TClass inf, NetDataReader r)
            {
                ushort count = r.GetUShort();
                var arr = GetterArr(inf);
                arr = arr == null || arr.Length != count ? new TProperty[count] : arr;
                SetterArr(inf, arr);
                return arr;
            }

            protected TProperty[] WriteArrayHelper(TClass inf, NetDataWriter w)
            {
                var arr = GetterArr(inf);
                w.Put((ushort)arr.Length);
                return arr;
            }

            protected List<TProperty> ReadListHelper(TClass inf, NetDataReader r, out int len)
            {
                len = r.GetUShort();
                var list = GetterList(inf);
                if (list == null)
                {
                    list = new(len);
                    SetterList(inf, list);
                }
                return list;
            }

            protected List<TProperty> WriteListHelper(TClass inf, NetDataWriter w, out int len)
            {
                var list = GetterList(inf);
                if (list == null)
                {
                    len = 0;
                    w.Put(0);
                    return null;
                }
                len = list.Count;
                w.Put((ushort)len);
                return list;
            }

            public override void Init(MethodInfo getMethod, MethodInfo setMethod, CallType type)
            {
                base.Init(getMethod, setMethod, type);
                switch (type)
                {
                    case CallType.Array:
                        GetterArr = (Func<TClass, TProperty[]>)Delegate.CreateDelegate(typeof(Func<TClass, TProperty[]>), getMethod);
                        SetterArr = (Action<TClass, TProperty[]>)Delegate.CreateDelegate(typeof(Action<TClass, TProperty[]>), setMethod);
                        break;
                    case CallType.List:
                        GetterList = (Func<TClass, List<TProperty>>)Delegate.CreateDelegate(typeof(Func<TClass, List<TProperty>>), getMethod);
                        SetterList = (Action<TClass, List<TProperty>>)Delegate.CreateDelegate(typeof(Action<TClass, List<TProperty>>), setMethod);
                        break;
                    default:
                        Getter = (Func<TClass, TProperty>)Delegate.CreateDelegate(typeof(Func<TClass, TProperty>), getMethod);
                        Setter = (Action<TClass, TProperty>)Delegate.CreateDelegate(typeof(Action<TClass, TProperty>), setMethod);
                        break;
                }
            }
        }

        private abstract class FastCallSpecificAuto<TClass, TProperty> : FastCallSpecific<TClass, TProperty>
        {
            protected abstract void ElementRead(NetDataReader r, out TProperty prop);
            protected abstract void ElementWrite(NetDataWriter w, ref TProperty prop);

            public override void Read(TClass inf, NetDataReader r)
            {
                ElementRead(r, out var elem);
                Setter(inf, elem);
            }

            public override void Write(TClass inf, NetDataWriter w)
            {
                var elem = Getter(inf);
                ElementWrite(w, ref elem);
            }

            public override void ReadArray(TClass inf, NetDataReader r)
            {
                var arr = ReadArrayHelper(inf, r);
                for (int i = 0; i < arr.Length; i++)
                    ElementRead(r, out arr[i]);
            }

            public override void WriteArray(TClass inf, NetDataWriter w)
            {
                var arr = WriteArrayHelper(inf, w);
                for (int i = 0; i < arr.Length; i++)
                    ElementWrite(w, ref arr[i]);
            }
        }

        private sealed class FastCallStatic<TClass, TProperty> : FastCallSpecific<TClass, TProperty>
        {
            private readonly Action<NetDataWriter, TProperty> _writer;
            private readonly Func<NetDataReader, TProperty> _reader;

            public FastCallStatic(Action<NetDataWriter, TProperty> write, Func<NetDataReader, TProperty> read)
            {
                _writer = write;
                _reader = read;
            }

            public override void Read(TClass inf, NetDataReader r) { Setter(inf, _reader(r)); }
            public override void Write(TClass inf, NetDataWriter w) { _writer(w, Getter(inf)); }

            public override void ReadList(TClass inf, NetDataReader r)
            {
                var list = ReadListHelper(inf, r, out int len);
                int listCount = list.Count;
                for (int i = 0; i < len; i++)
                {
                    if (i < listCount)
                        list[i] = _reader(r);
                    else
                        list.Add(_reader(r));
                }
                if (len < listCount)
                    list.RemoveRange(len, listCount - len);
            }

            public override void WriteList(TClass inf, NetDataWriter w)
            {
                var list = WriteListHelper(inf, w, out int len);
                for (int i = 0; i < len; i++)
                    _writer(w, list[i]);
            }

            public override void ReadArray(TClass inf, NetDataReader r)
            {
                var arr = ReadArrayHelper(inf, r);
                int len = arr.Length;
                for (int i = 0; i < len; i++)
                    arr[i] = _reader(r);
            }

            public override void WriteArray(TClass inf, NetDataWriter w)
            {
                var arr = WriteArrayHelper(inf, w);
                int len = arr.Length;
                for (int i = 0; i < len; i++)
                    _writer(w, arr[i]);
            }
        }

        private sealed class FastCallStruct<TClass, TProperty> : FastCallSpecific<TClass, TProperty> where TProperty : struct, INetSerializable
        {
            private TProperty _p;

            public override void Read(TClass inf, NetDataReader r)
            {
                _p.Deserialize(r);
                Setter(inf, _p);
            }

            public override void Write(TClass inf, NetDataWriter w)
            {
                _p = Getter(inf);
                _p.Serialize(w);
            }

            public override void ReadList(TClass inf, NetDataReader r)
            {
                var list = ReadListHelper(inf, r, out int len);
                int listCount = list.Count;
                for (int i = 0; i < len; i++)
                {
                    var itm = default(TProperty);
                    itm.Deserialize(r);
                    if(i < listCount)
                        list[i] = itm;
                    else
                        list.Add(itm);
                }
                if (len < listCount)
                    list.RemoveRange(len, listCount - len);
            }

            public override void WriteList(TClass inf, NetDataWriter w)
            {
                var list = WriteListHelper(inf, w, out int len);
                for (int i = 0; i < len; i++)
                    list[i].Serialize(w);
            }

            public override void ReadArray(TClass inf, NetDataReader r)
            {
                var arr = ReadArrayHelper(inf, r);
                int len = arr.Length;
                for (int i = 0; i < len; i++)
                    arr[i].Deserialize(r);
            }

            public override void WriteArray(TClass inf, NetDataWriter w)
            {
                var arr = WriteArrayHelper(inf, w);
                int len = arr.Length;
                for (int i = 0; i < len; i++)
                    arr[i].Serialize(w);
            }
        }

        private sealed class FastCallClass<TClass, TProperty> : FastCallSpecific<TClass, TProperty> where TProperty : class, INetSerializable
        {
            private readonly Func<TProperty> _constructor;
            public FastCallClass(Func<TProperty> constructor) { _constructor = constructor; }

            public override void Read(TClass inf, NetDataReader r)
            {
                var p = _constructor();
                p.Deserialize(r);
                Setter(inf, p);
            }

            public override void Write(TClass inf, NetDataWriter w)
            {
                var p = Getter(inf);
                p?.Serialize(w);
            }

            public override void ReadList(TClass inf, NetDataReader r)
            {
                var list = ReadListHelper(inf, r, out int len);
                int listCount = list.Count;
                for (int i = 0; i < len; i++)
                {
                    if (i < listCount)
                    {
                        list[i].Deserialize(r);
                    }
                    else
                    {
                        var itm = _constructor();
                        itm.Deserialize(r);
                        list.Add(itm);
                    }
                }
                if (len < listCount)
                    list.RemoveRange(len, listCount - len);
            }

            public override void WriteList(TClass inf, NetDataWriter w)
            {
                var list = WriteListHelper(inf, w, out int len);
                for (int i = 0; i < len; i++)
                    list[i].Serialize(w);
            }

            public override void ReadArray(TClass inf, NetDataReader r)
            {
                var arr = ReadArrayHelper(inf, r);
                int len = arr.Length;
                for (int i = 0; i < len; i++)
                {
                    arr[i] = _constructor();
                    arr[i].Deserialize(r);
                }
            }

            public override void WriteArray(TClass inf, NetDataWriter w)
            {
                var arr = WriteArrayHelper(inf, w);
                int len = arr.Length;
                for (int i = 0; i < len; i++)
                    arr[i].Serialize(w);
            }
        }

        private class IntSerializer<T> : FastCallSpecific<T, int>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetInt()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetIntArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class UIntSerializer<T> : FastCallSpecific<T, uint>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetUInt()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetUIntArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class ShortSerializer<T> : FastCallSpecific<T, short>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetShort()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetShortArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class UShortSerializer<T> : FastCallSpecific<T, ushort>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetUShort()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetUShortArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class LongSerializer<T> : FastCallSpecific<T, long>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetLong()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetLongArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class ULongSerializer<T> : FastCallSpecific<T, ulong>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetULong()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetULongArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class ByteSerializer<T> : FastCallSpecific<T, byte>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetByte()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetBytesWithLength()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutBytesWithLength(GetterArr(inf)); }
        }

        private class SByteSerializer<T> : FastCallSpecific<T, sbyte>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetSByte()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetSBytesWithLength()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutSBytesWithLength(GetterArr(inf)); }
        }

        private class FloatSerializer<T> : FastCallSpecific<T, float>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetFloat()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetFloatArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class DoubleSerializer<T> : FastCallSpecific<T, double>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetDouble()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetDoubleArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class BoolSerializer<T> : FastCallSpecific<T, bool>
        {
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetBool()); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf)); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetBoolArray()); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf)); }
        }

        private class CharSerializer<T> : FastCallSpecificAuto<T, char>
        {
            protected override void ElementWrite(NetDataWriter w, ref char prop) { w.Put(prop); }
            protected override void ElementRead(NetDataReader r, out char prop) { prop = r.GetChar(); }
        }

        private class IPEndPointSerializer<T> : FastCallSpecificAuto<T, IPEndPoint>
        {
            protected override void ElementWrite(NetDataWriter w, ref IPEndPoint prop) { w.Put(prop); }
            protected override void ElementRead(NetDataReader r, out IPEndPoint prop) { prop = r.GetNetEndPoint(); }
        }

        private class StringSerializer<T> : FastCallSpecific<T, string>
        {
            private readonly int _maxLength;
            public StringSerializer(int maxLength) { _maxLength = maxLength > 0 ? maxLength : short.MaxValue; }
            public override void Read(T inf, NetDataReader r) { Setter(inf, r.GetString(_maxLength)); }
            public override void Write(T inf, NetDataWriter w) { w.Put(Getter(inf), _maxLength); }
            public override void ReadArray(T inf, NetDataReader r) { SetterArr(inf, r.GetStringArray(_maxLength)); }
            public override void WriteArray(T inf, NetDataWriter w) { w.PutArray(GetterArr(inf), _maxLength); }
        }

        private class EnumByteSerializer<T> : FastCall<T>
        {
            protected readonly PropertyInfo Property;
            protected readonly Type PropertyType;
            public EnumByteSerializer(PropertyInfo property, Type propertyType)
            {
                Property = property;
                PropertyType = propertyType;
            }
            public override void Read(T inf, NetDataReader r) { Property.SetValue(inf, Enum.ToObject(PropertyType, r.GetByte()), null); }
            public override void Write(T inf, NetDataWriter w) { w.Put((byte)Property.GetValue(inf, null)); }
            public override void ReadArray(T inf, NetDataReader r) { throw new InvalidTypeException("Unsupported type: Enum[]"); }
            public override void WriteArray(T inf, NetDataWriter w) { throw new InvalidTypeException("Unsupported type: Enum[]"); }
            public override void ReadList(T inf, NetDataReader r) { throw new InvalidTypeException("Unsupported type: List<Enum>"); }
            public override void WriteList(T inf, NetDataWriter w) { throw new InvalidTypeException("Unsupported type: List<Enum>"); }
        }

        private class EnumIntSerializer<T> : EnumByteSerializer<T>
        {
            public EnumIntSerializer(PropertyInfo property, Type propertyType) : base(property, propertyType) { }
            public override void Read(T inf, NetDataReader r) { Property.SetValue(inf, Enum.ToObject(PropertyType, r.GetInt()), null); }
            public override void Write(T inf, NetDataWriter w) { w.Put((int)Property.GetValue(inf, null)); }
        }

        private sealed class ClassInfo<T>
        {
            public static ClassInfo<T> Instance;
            private readonly FastCall<T>[] _serializers;
            private readonly int _membersCount;

            public ClassInfo(List<FastCall<T>> serializers)
            {
                _membersCount = serializers.Count;
                _serializers = serializers.ToArray();
            }

            public void Write(T obj, NetDataWriter writer)
            {
                for (int i = 0; i < _membersCount; i++)
                {
                    var s = _serializers[i];
                    if (s.Type == CallType.Basic)
                        s.Write(obj, writer);
                    else if (s.Type == CallType.Array)
                        s.WriteArray(obj, writer);
                    else
                        s.WriteList(obj, writer);
                }
            }

            public void Read(T obj, NetDataReader reader)
            {
                for (int i = 0; i < _membersCount; i++)
                {
                    var s = _serializers[i];
                    if (s.Type == CallType.Basic)
                        s.Read(obj, reader);
                    else if(s.Type == CallType.Array)
                        s.ReadArray(obj, reader);
                    else
                        s.ReadList(obj, reader);
                }
            }
        }

        private abstract class CustomType
        {
            public abstract FastCall<T> Get<T>();
        }

        private sealed class CustomTypeStruct<TProperty> : CustomType where TProperty : struct, INetSerializable
        {
            public override FastCall<T> Get<T>() { return new FastCallStruct<T, TProperty>(); }
        }

        private sealed class CustomTypeClass<TProperty> : CustomType where TProperty : class, INetSerializable
        {
            private readonly Func<TProperty> _constructor;
            public CustomTypeClass(Func<TProperty> constructor) { _constructor = constructor; }
            public override FastCall<T> Get<T>() { return new FastCallClass<T, TProperty>(_constructor); }
        }

        private sealed class CustomTypeStatic<TProperty> : CustomType
        {
            private readonly Action<NetDataWriter, TProperty> _writer;
            private readonly Func<NetDataReader, TProperty> _reader;
            public CustomTypeStatic(Action<NetDataWriter, TProperty> writer, Func<NetDataReader, TProperty> reader)
            {
                _writer = writer;
                _reader = reader;
            }
            public override FastCall<T> Get<T>() { return new FastCallStatic<T, TProperty>(_writer, _reader); }
        }

        /// <summary>
        /// Register custom property type
        /// </summary>
        /// <typeparam name="T">INetSerializable structure</typeparam>
        public void RegisterNestedType<T>() where T : struct, INetSerializable
        {
            _registeredTypes.Add(typeof(T), new CustomTypeStruct<T>());
        }

        /// <summary>
        /// Register custom property type
        /// </summary>
        /// <typeparam name="T">INetSerializable class</typeparam>
        public void RegisterNestedType<T>(Func<T> constructor) where T : class, INetSerializable
        {
            _registeredTypes.Add(typeof(T), new CustomTypeClass<T>(constructor));
        }

        /// <summary>
        /// Register custom property type
        /// </summary>
        /// <typeparam name="T">Any packet</typeparam>
        /// <param name="writer">custom type writer</param>
        /// <param name="reader">custom type reader</param>
        public void RegisterNestedType<T>(Action<NetDataWriter, T> writer, Func<NetDataReader, T> reader)
        {
            _registeredTypes.Add(typeof(T), new CustomTypeStatic<T>(writer, reader));
        }

        private NetDataWriter _writer;
        private readonly int _maxStringLength;
        private readonly Dictionary<Type, CustomType> _registeredTypes = new();

        public NetSerializer() : this(0)
        {
        }

        public NetSerializer(int maxStringLength)
        {
            _maxStringLength = maxStringLength;
        }

        private ClassInfo<T> RegisterInternal<
#if NET5_0_OR_GREATER
        [DynamicallyAccessedMembers(Trimming.SerializerMemberTypes)]
#endif
            T>()
        {
            if (ClassInfo<T>.Instance != null)
                return ClassInfo<T>.Instance;

            var props = typeof(T).GetProperties(
                BindingFlags.Instance |
                BindingFlags.Public |
                BindingFlags.GetProperty |
                BindingFlags.SetProperty);
            var serializers = new List<FastCall<T>>();
            for (int i = 0; i < props.Length; i++)
            {
                var property = props[i];
                var propertyType = property.PropertyType;

                var elementType = propertyType.IsArray ? propertyType.GetElementType() : propertyType;
                var callType = propertyType.IsArray ? CallType.Array : CallType.Basic;

                if (propertyType.IsGenericType && propertyType.GetGenericTypeDefinition() == typeof(List<>))
                {
                    elementType = propertyType.GetGenericArguments()[0];
                    callType = CallType.List;
                }

                if (Attribute.IsDefined(property, typeof(IgnoreDataMemberAttribute)))
                    continue;

                var getMethod = property.GetGetMethod();
                var setMethod = property.GetSetMethod();
                if (getMethod == null || setMethod == null)
                    continue;

                FastCall<T> serialzer = null;
                if (propertyType.IsEnum)
                {
                    var underlyingType = Enum.GetUnderlyingType(propertyType);
                    if (underlyingType == typeof(byte))
                        serialzer = new EnumByteSerializer<T>(property, propertyType);
                    else if (underlyingType == typeof(int))
                        serialzer = new EnumIntSerializer<T>(property, propertyType);
                    else
                        throw new InvalidTypeException("Not supported enum underlying type: " + underlyingType.Name);
                }
                else if (elementType == typeof(string))
                    serialzer = new StringSerializer<T>(_maxStringLength);
                else if (elementType == typeof(bool))
                    serialzer = new BoolSerializer<T>();
                else if (elementType == typeof(byte))
                    serialzer = new ByteSerializer<T>();
                else if (elementType == typeof(sbyte))
                    serialzer = new SByteSerializer<T>();
                else if (elementType == typeof(short))
                    serialzer = new ShortSerializer<T>();
                else if (elementType == typeof(ushort))
                    serialzer = new UShortSerializer<T>();
                else if (elementType == typeof(int))
                    serialzer = new IntSerializer<T>();
                else if (elementType == typeof(uint))
                    serialzer = new UIntSerializer<T>();
                else if (elementType == typeof(long))
                    serialzer = new LongSerializer<T>();
                else if (elementType == typeof(ulong))
                    serialzer = new ULongSerializer<T>();
                else if (elementType == typeof(float))
                    serialzer = new FloatSerializer<T>();
                else if (elementType == typeof(double))
                    serialzer = new DoubleSerializer<T>();
                else if (elementType == typeof(char))
                    serialzer = new CharSerializer<T>();
                else if (elementType == typeof(IPEndPoint))
                    serialzer = new IPEndPointSerializer<T>();
                else
                {
                    _registeredTypes.TryGetValue(elementType, out var customType);
                    if (customType != null)
                        serialzer = customType.Get<T>();
                }

                if (serialzer != null)
                {
                    serialzer.Init(getMethod, setMethod, callType);
                    serializers.Add(serialzer);
                }
                else
                {
                    throw new InvalidTypeException("Unknown property type: " + propertyType.FullName);
                }
            }
            ClassInfo<T>.Instance = new(serializers);
            return ClassInfo<T>.Instance;
        }

        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public void Register<
#if NET5_0_OR_GREATER
            [DynamicallyAccessedMembers(Trimming.SerializerMemberTypes)]
#endif
        T>()
        {
            RegisterInternal<T>();
        }

        /// <summary>
        /// Reads packet with known type
        /// </summary>
        /// <param name="reader">NetDataReader with packet</param>
        /// <returns>Returns packet if packet in reader is matched type</returns>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public T Deserialize<
#if NET5_0_OR_GREATER
            [DynamicallyAccessedMembers(Trimming.SerializerMemberTypes)]
#endif
        T>(NetDataReader reader) where T : class, new()
        {
            var info = RegisterInternal<T>();
            var result = new T();
            try
            {
                info.Read(result, reader);
            }
            catch
            {
                return null;
            }
            return result;
        }

        /// <summary>
        /// Reads packet with known type (non alloc variant)
        /// </summary>
        /// <param name="reader">NetDataReader with packet</param>
        /// <param name="target">Deserialization target</param>
        /// <returns>Returns true if packet in reader is matched type</returns>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public bool Deserialize<
#if NET5_0_OR_GREATER
            [DynamicallyAccessedMembers(Trimming.SerializerMemberTypes)]
#endif
        T>(NetDataReader reader, T target) where T : class, new()
        {
            var info = RegisterInternal<T>();
            try
            {
                info.Read(target, reader);
            }
            catch
            {
                return false;
            }
            return true;
        }

        /// <summary>
        /// Serialize object to NetDataWriter (fast)
        /// </summary>
        /// <param name="writer">Serialization target NetDataWriter</param>
        /// <param name="obj">Object to serialize</param>
        /// <exception cref="InvalidTypeException"><typeparamref name="T"/>'s fields are not supported, or it has no fields</exception>
        public void Serialize<
#if NET5_0_OR_GREATER
            [DynamicallyAccessedMembers(Trimming.SerializerMemberTypes)]
#endif
        T>(NetDataWriter writer, T obj) where T : class, new()
        {
            RegisterInternal<T>().Write(obj, writer);
        }

        /// <summary>
        /// Serialize object to byte array
        /// </summary>
        /// <param name="obj">Object to serialize</param>
        /// <returns>byte array with serialized data</returns>
        public byte[] Serialize<
#if NET5_0_OR_GREATER
            [DynamicallyAccessedMembers(Trimming.SerializerMemberTypes)]
#endif
        T>(T obj) where T : class, new()
        {
            if (_writer == null)
                _writer = new();
            _writer.Reset();
            Serialize(_writer, obj);
            return _writer.CopyData();
        }
    }
}
﻿using System;

namespace LiteNetLib.Utils
{
    /// <summary>
    /// Represents RFC4330 SNTP packet used for communication to and from a network time server.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Most applications should just use the <see cref="NtpPacket.CorrectionOffset" /> property.
    /// </para>
    /// <para>
    /// The same data structure represents both request and reply packets.
    /// Request and reply differ in which properties are set and to what values.
    /// </para>
    /// <para>
    /// The only real property is <see cref="NtpPacket.Bytes" />.
    /// All other properties read from and write to the underlying byte array
    /// with the exception of <see cref="NtpPacket.DestinationTimestamp" />,
    /// which is not part of the packet on network and it is instead set locally after receiving the packet.
    /// </para>
    /// <para>
    /// Copied from <a href="https://guerrillantp.machinezoo.com/">GuerrillaNtp project</a>
    /// with permission from Robert Vazan (@robertvazan) under MIT license, see https://github.com/RevenantX/LiteNetLib/pull/236
    /// </para>
    /// </remarks>
    public class NtpPacket
    {
        private static readonly DateTime Epoch = new(1900, 1, 1);

        /// <summary>
        /// Gets RFC4330-encoded SNTP packet.
        /// </summary>
        /// <value>
        /// Byte array containing RFC4330-encoded SNTP packet. It is at least 48 bytes long.
        /// </value>
        /// <remarks>
        /// This is the only real property. All other properties except
        /// <see cref="NtpPacket.DestinationTimestamp" /> read from or write to this byte array.
        /// </remarks>
        public byte[] Bytes { get; }

        /// <summary>
        /// Gets the leap second indicator.
        /// </summary>
        /// <value>
        /// Leap second warning, if any. Special value
        /// <see cref="NtpLeapIndicator.AlarmCondition" /> indicates unsynchronized server clock.
        /// Default is <see cref="NtpLeapIndicator.NoWarning" />.
        /// </value>
        /// <remarks>
        /// Only servers fill in this property. Clients can consult this property for possible leap second warning.
        /// </remarks>
        public NtpLeapIndicator LeapIndicator => (NtpLeapIndicator)((Bytes[0] & 0xC0) >> 6);

        /// <summary>
        /// Gets or sets protocol version number.
        /// </summary>
        /// <value>
        /// SNTP protocol version. Default is 4, which is the latest version at the time of this writing.
        /// </value>
        /// <remarks>
        /// In request packets, clients should leave this property at default value 4.
        /// Servers usually reply with the same protocol version.
        /// </remarks>
        public int VersionNumber
        {
            get => (Bytes[0] & 0x38) >> 3;
            private set => Bytes[0] = (byte)((Bytes[0] & ~0x38) | value << 3);
        }

        /// <summary>
        /// Gets or sets SNTP packet mode, i.e. whether this is client or server packet.
        /// </summary>
        /// <value>
        /// SNTP packet mode. Default is <see cref="NtpMode.Client" /> in newly created packets.
        /// Server reply should have this property set to <see cref="NtpMode.Server" />.
        /// </value>
        public NtpMode Mode
        {
            get => (NtpMode)(Bytes[0] & 0x07);
            private set => Bytes[0] = (byte)((Bytes[0] & ~0x07) | (int)value);
        }

        /// <summary>
        /// Gets server's distance from the reference clock.
        /// </summary>
        /// <value>
        /// <para>
        /// Distance from the reference clock. This property is set only in server reply packets.
        /// Servers connected directly to reference clock hardware set this property to 1.
        /// Statum number is incremented by 1 on every hop down the NTP server hierarchy.
        /// </para>
        /// <para>
        /// Special value 0 indicates that this packet is a Kiss-o'-Death message
        /// with kiss code stored in <see cref="NtpPacket.ReferenceId" />.
        /// </para>
        /// </value>
        public int Stratum => Bytes[1];

        /// <summary>
        /// Gets server's preferred polling interval.
        /// </summary>
        /// <value>
        /// Polling interval in log2 seconds, e.g. 4 stands for 16s and 17 means 131,072s.
        /// </value>
        public int Poll => Bytes[2];

        /// <summary>
        /// Gets the precision of server clock.
        /// </summary>
        /// <value>
        /// Clock precision in log2 seconds, e.g. -20 for microsecond precision.
        /// </value>
        public int Precision => (sbyte)Bytes[3];

        /// <summary>
        /// Gets the total round-trip delay from the server to the reference clock.
        /// </summary>
        /// <value>
        /// Round-trip delay to the reference clock. Normally a positive value smaller than one second.
        /// </value>
        public TimeSpan RootDelay => GetTimeSpan32(4);

        /// <summary>
        /// Gets the estimated error in time reported by the server.
        /// </summary>
        /// <value>
        /// Estimated error in time reported by the server. Normally a positive value smaller than one second.
        /// </value>
        public TimeSpan RootDispersion => GetTimeSpan32(8);

        /// <summary>
        /// Gets the ID of the time source used by the server or Kiss-o'-Death code sent by the server.
        /// </summary>
        /// <value>
        /// <para>
        /// ID of server's time source or Kiss-o'-Death code.
        /// Purpose of this property depends on value of <see cref="NtpPacket.Stratum" /> property.
        /// </para>
        /// <para>
        /// Stratum 1 servers write here one of several special values that describe the kind of hardware clock they use.
        /// </para>
        /// <para>
        /// Stratum 2 and lower servers set this property to IPv4 address of their upstream server.
        /// If upstream server has IPv6 address, the address is hashed, because it doesn't fit in this property.
        /// </para>
        /// <para>
        /// When server sets <see cref="NtpPacket.Stratum" /> to special value 0,
        /// this property contains so called kiss code that instructs the client to stop querying the server.
        /// </para>
        /// </value>
        public uint ReferenceId => GetUInt32BE(12);

        /// <summary>
        /// Gets or sets the time when the server clock was last set or corrected.
        /// </summary>
        /// <value>
        /// Time when the server clock was last set or corrected or <c>null</c> when not specified.
        /// </value>
        /// <remarks>
        /// This Property is usually set only by servers. It usually lags server's current time by several minutes,
        /// so don't use this property for time synchronization.
        /// </remarks>
        public DateTime? ReferenceTimestamp => GetDateTime64(16);

        /// <summary>
        /// Gets or sets the time when the client sent its request.
        /// </summary>
        /// <value>
        /// This property is <c>null</c> in request packets.
        /// In reply packets, it is the time when the client sent its request.
        /// Servers copy this value from <see cref="NtpPacket.TransmitTimestamp" />
        /// that they find in received request packet.
        /// </value>
        /// <seealso cref="NtpPacket.CorrectionOffset" />
        /// <seealso cref="NtpPacket.RoundTripTime" />
        public DateTime? OriginTimestamp => GetDateTime64(24);

        /// <summary>
        /// Gets or sets the time when the request was received by the server.
        /// </summary>
        /// <value>
        /// This property is <c>null</c> in request packets.
        /// In reply packets, it is the time when the server received client request.
        /// </value>
        /// <seealso cref="NtpPacket.CorrectionOffset" />
        /// <seealso cref="NtpPacket.RoundTripTime" />
        public DateTime? ReceiveTimestamp => GetDateTime64(32);

        /// <summary>
        /// Gets or sets the time when the packet was sent.
        /// </summary>
        /// <value>
        /// Time when the packet was sent. It should never be <c>null</c>.
        /// Default value is <see cref="System.DateTime.UtcNow" />.
        /// </value>
        /// <remarks>
        /// This property must be set by both clients and servers.
        /// </remarks>
        /// <seealso cref="NtpPacket.CorrectionOffset" />
        /// <seealso cref="NtpPacket.RoundTripTime" />
        public DateTime? TransmitTimestamp { get { return GetDateTime64(40); } private set { SetDateTime64(40, value); } }

        /// <summary>
        /// Gets or sets the time of reception of response SNTP packet on the client.
        /// </summary>
        /// <value>
        /// Time of reception of response SNTP packet on the client. It is <c>null</c> in request packets.
        /// </value>
        /// <remarks>
        /// This property is not part of the protocol and has to be set when reply packet is received.
        /// </remarks>
        /// <seealso cref="NtpPacket.CorrectionOffset" />
        /// <seealso cref="NtpPacket.RoundTripTime" />
        public DateTime? DestinationTimestamp { get; private set; }

        /// <summary>
        /// Gets the round-trip time to the server.
        /// </summary>
        /// <value>
        /// Time the request spent traveling to the server plus the time the reply spent traveling back.
        /// This is calculated from timestamps in the packet as <c>(t1 - t0) + (t3 - t2)</c>
        /// where t0 is <see cref="NtpPacket.OriginTimestamp" />,
        /// t1 is <see cref="NtpPacket.ReceiveTimestamp" />,
        /// t2 is <see cref="NtpPacket.TransmitTimestamp" />,
        /// and t3 is <see cref="NtpPacket.DestinationTimestamp" />.
        /// This property throws an exception in request packets.
        /// </value>
        public TimeSpan RoundTripTime
        {
            get
            {
                CheckTimestamps();
                return (ReceiveTimestamp.Value - OriginTimestamp.Value) + (DestinationTimestamp.Value - TransmitTimestamp.Value);
            }
        }

        /// <summary>
        /// Gets the offset that should be added to local time to synchronize it with server time.
        /// </summary>
        /// <value>
        /// Time difference between server and client. It should be added to local time to get server time.
        /// It is calculated from timestamps in the packet as <c>0.5 * ((t1 - t0) - (t3 - t2))</c>
        /// where t0 is <see cref="NtpPacket.OriginTimestamp" />,
        /// t1 is <see cref="NtpPacket.ReceiveTimestamp" />,
        /// t2 is <see cref="NtpPacket.TransmitTimestamp" />,
        /// and t3 is <see cref="NtpPacket.DestinationTimestamp" />.
        /// This property throws an exception in request packets.
        /// </value>
        public TimeSpan CorrectionOffset
        {
            get
            {
                CheckTimestamps();
                return TimeSpan.FromTicks(((ReceiveTimestamp.Value - OriginTimestamp.Value) - (DestinationTimestamp.Value - TransmitTimestamp.Value)).Ticks / 2);
            }
        }

        /// <summary>
        /// Initializes default request packet.
        /// </summary>
        /// <remarks>
        /// Properties <see cref="NtpPacket.Mode" /> and <see cref="NtpPacket.VersionNumber" />
        /// are set appropriately for request packet. Property <see cref="NtpPacket.TransmitTimestamp" />
        /// is set to <see cref="System.DateTime.UtcNow" />.
        /// </remarks>
        public NtpPacket() : this(new byte[48])
        {
            Mode = NtpMode.Client;
            VersionNumber = 4;
            TransmitTimestamp = DateTime.UtcNow;
        }

        /// <summary>
        /// Initializes packet from received data.
        /// </summary>
        internal NtpPacket(byte[] bytes)
        {
            if (bytes.Length < 48)
                throw new ArgumentException("SNTP reply packet must be at least 48 bytes long.", "bytes");
            Bytes = bytes;
        }

        /// <summary>
        /// Initializes packet from data received from a server.
        /// </summary>
        /// <param name="bytes">Data received from the server.</param>
        /// <param name="destinationTimestamp">Utc time of reception of response SNTP packet on the client.</param>
        /// <returns></returns>
        public static NtpPacket FromServerResponse(byte[] bytes, DateTime destinationTimestamp)
        {
            return new(bytes) { DestinationTimestamp = destinationTimestamp };
        }

        internal void ValidateRequest()
        {
            if (Mode != NtpMode.Client)
                throw new InvalidOperationException("This is not a request SNTP packet.");
            if (VersionNumber == 0)
                throw new InvalidOperationException("Protocol version of the request is not specified.");
            if (TransmitTimestamp == null)
                throw new InvalidOperationException("TransmitTimestamp must be set in request packet.");
        }

        internal void ValidateReply()
        {
            if (Mode != NtpMode.Server)
                throw new InvalidOperationException("This is not a reply SNTP packet.");
            if (VersionNumber == 0)
                throw new InvalidOperationException("Protocol version of the reply is not specified.");
            if (Stratum == 0)
                throw new InvalidOperationException(string.Format("Received Kiss-o'-Death SNTP packet with code 0x{0:x}.", ReferenceId));
            if (LeapIndicator == NtpLeapIndicator.AlarmCondition)
                throw new InvalidOperationException("SNTP server has unsynchronized clock.");
            CheckTimestamps();
        }

        private void CheckTimestamps()
        {
            if (OriginTimestamp == null)
                throw new InvalidOperationException("Origin timestamp is missing.");
            if (ReceiveTimestamp == null)
                throw new InvalidOperationException("Receive timestamp is missing.");
            if (TransmitTimestamp == null)
                throw new InvalidOperationException("Transmit timestamp is missing.");
            if (DestinationTimestamp == null)
                throw new InvalidOperationException("Destination timestamp is missing.");
        }

        private DateTime? GetDateTime64(int offset)
        {
            var field = GetUInt64BE(offset);
            if (field == 0)
                return null;
            return new DateTime(Epoch.Ticks + Convert.ToInt64(field * (1.0 / (1L << 32) * 10000000.0)));
        }

        private void SetDateTime64(int offset, DateTime? value)
        {
            SetUInt64BE(offset, value == null ? 0 : Convert.ToUInt64((value.Value.Ticks - Epoch.Ticks) * (0.0000001 * (1L << 32))));
        }

        private TimeSpan GetTimeSpan32(int offset)
        {
            return TimeSpan.FromSeconds(GetInt32BE(offset) / (double)(1 << 16));
        }

        private ulong GetUInt64BE(int offset)
        {
            return SwapEndianness(BitConverter.ToUInt64(Bytes, offset));
        }

        private void SetUInt64BE(int offset, ulong value)
        {
            FastBitConverter.GetBytes(Bytes, offset, SwapEndianness(value));
        }

        private int GetInt32BE(int offset)
        {
            return (int)GetUInt32BE(offset);
        }

        private uint GetUInt32BE(int offset)
        {
            return SwapEndianness(BitConverter.ToUInt32(Bytes, offset));
        }

        private static uint SwapEndianness(uint x)
        {
            return ((x & 0xff) << 24) | ((x & 0xff00) << 8) | ((x & 0xff0000) >> 8) | ((x & 0xff000000) >> 24);
        }

        private static ulong SwapEndianness(ulong x)
        {
            return ((ulong)SwapEndianness((uint)x) << 32) | SwapEndianness((uint)(x >> 32));
        }
    }

    /// <summary>
    /// Represents leap second warning from the server that instructs the client to add or remove leap second.
    /// </summary>
    /// <seealso cref="NtpPacket.LeapIndicator" />
    public enum NtpLeapIndicator
    {
        /// <summary>
        /// No leap second warning. No action required.
        /// </summary>
        NoWarning,

        /// <summary>
        /// Warns the client that the last minute of the current day has 61 seconds.
        /// </summary>
        LastMinuteHas61Seconds,

        /// <summary>
        /// Warns the client that the last minute of the current day has 59 seconds.
        /// </summary>
        LastMinuteHas59Seconds,

        /// <summary>
        /// Special value indicating that the server clock is unsynchronized and the returned time is unreliable.
        /// </summary>
        AlarmCondition
    }

    /// <summary>
    /// Describes SNTP packet mode, i.e. client or server.
    /// </summary>
    /// <seealso cref="NtpPacket.Mode" />
    public enum NtpMode
    {
        /// <summary>
        /// Identifies client-to-server SNTP packet.
        /// </summary>
        Client = 3,

        /// <summary>
        /// Identifies server-to-client SNTP packet.
        /// </summary>
        Server = 4,
    }
}
﻿using System.Net;
using System.Net.Sockets;

namespace LiteNetLib.Utils
{
    internal sealed class NtpRequest
    {
        private const int ResendTimer = 1000;
        private const int KillTimer = 10000;
        public const int DefaultPort = 123;
        private readonly IPEndPoint _ntpEndPoint;
        private int _resendTime = ResendTimer;
        private int _killTime = 0;

        public NtpRequest(IPEndPoint endPoint)
        {
            _ntpEndPoint = endPoint;
        }

        public bool NeedToKill => _killTime >= KillTimer;

        public bool Send(Socket socket, int time)
        {
            _resendTime += time;
            _killTime += time;
            if (_resendTime < ResendTimer)
            {
                return false;
            }
            var packet = new NtpPacket();
            try
            {
                int sendCount = socket.SendTo(packet.Bytes, 0, packet.Bytes.Length, SocketFlags.None, _ntpEndPoint);
                return sendCount == packet.Bytes.Length;
            }
            catch
            {
                return false;
            }
        }
    }
}
﻿using System;

namespace LiteNetLib.Utils
{
    /// <summary>
    ///   <para>PreserveAttribute prevents byte code stripping from removing a class, method, field, or property.</para>
    /// </summary>
    [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface | AttributeTargets.Delegate, Inherited = false)]
    public class PreserveAttribute : Attribute
    {
    }
}
﻿// namespace FishNet.Component.Transforming
// {
//     public enum AdaptiveInterpolationType
//     {
//         /// <summary>
//         /// Adaptive interpolation is disabled. An exact interpolation value is used.
//         /// </summary>
//         Off = 0,
//         /// <summary>
//         /// Visual disturbances caused by desynchronization are definite without predicting future states.
//         /// </summary>
//         ExtremelyLow = 1,
//         /// <summary>
//         /// Visual disturbances caused by desynchronization are likely without predicting future states.
//         /// </summary>
//         VeryLow = 2,
//         /// <summary>
//         /// Visual disturbances caused by desynchronization are still possible but less likely.
//         /// </summary>
//         Low = 3,
//         /// <summary>
//         /// Visual disturbances caused by desynchronization are likely without predicting a small amount of future states.
//         /// </summary>
//         Moderate = 4,
//         /// <summary>
//         /// Visual disturbances caused by desynchronization are very unlikely. Graphics are using a generous amount interpolation.
//         /// </summary>
//         High = 5,
//         /// <summary>
//         /// Visual disturbances caused by desynchronization are extremely unlikely. Graphics are using a generous amount interpolation.
//         /// </summary>
//         VeryHigh = 6,
//     }
//
//
// }
﻿// Remove on V5
// using FishNet.Managing;
// using FishNet.Managing.Timing;
// using FishNet.Utility.Extension;
// using GameKit.Dependencies.Utilities;
// using System.Runtime.CompilerServices;
// using UnityEngine;
// using UnityEngine.Scripting;
//
// namespace FishNet.Object.Prediction
// {
//     /// <summary>
//     /// This class is under regular development and it's API may change at any time.
//     /// </summary>
//     public sealed class ChildTransformTickSmoother : IResettable
//     {
//         #region Types.
//         [Preserve]
//         private struct TickTransformProperties
//         {
//             public uint Tick;
//             public TransformProperties Properties;
//
//             public TickTransformProperties(uint tick, Transform t)
//             {
//                 Tick = tick;
//                 Properties = new TransformProperties(t.localPosition, t.localRotation, t.localScale);
//             }
//             public TickTransformProperties(uint tick, Transform t, Vector3 localScale)
//             {
//                 Tick = tick;
//                 Properties = new TransformProperties(t.localPosition, t.localRotation, localScale);
//             }
//             public TickTransformProperties(uint tick, TransformProperties tp)
//             {
//                 Tick = tick;
//                 Properties = tp;
//             }
//         }
//         #endregion
//
//         #region Private.
//         /// <summary>
//         /// Object to smooth.
//         /// </summary>
//         private Transform _graphicalObject;
//         /// <summary>
//         /// When not MoveRates.UNSET_VALUE the graphical object will teleport into it's next position if the move distance exceeds this value.
//         /// </summary>
//         private float _teleportThreshold;
//         /// <summary>
//         /// How quickly to move towards goal values.
//         /// </summary>
//         private MoveRates _moveRates = new MoveRates(MoveRates.UNSET_VALUE);
//         /// <summary>
//         /// True if a pretick occurred since last postTick.
//         /// </summary>
//         private bool _preTicked;
//         /// <summary>
//         /// World offset values of the graphical from the NetworkObject during initialization.
//         /// </summary>
//         private TransformProperties _gfxInitializedOffsetValues;
//         /// <summary>
//         /// World values of the graphical after it's been aligned to initialized values in PreTick.
//         /// </summary>
//         private TransformProperties _gfxPreSimulateWorldValues;
//         /// <summary>
//         /// TickDelta on the TimeManager.
//         /// </summary>
//         private float _tickDelta;
//         /// <summary>
//         /// How many ticks to interpolate over when not using adaptive.
//         /// </summary>
//         private byte _ownerInterpolation;
//         /// <summary>
//         /// Current interpolation, regardless of if using adaptive or not.
//         /// </summary>
//         private byte _interpolation;
//         /// <summary>
//         /// NetworkObject this is for.
//         /// </summary>
//         private NetworkObject _networkObject;
//         /// <summary>
//         /// Value to multiply movement by. This is used to reduce or increase the rate the movement buffer is consumed.
//         /// </summary>
//         private float _movementMultiplier = 1f;
//         /// <summary>
//         /// TransformProperties to move towards.
//         /// </summary>
//         private BasicQueue<TickTransformProperties> _transformProperties;
//         /// <summary>
//         /// Which properties to smooth.
//         /// </summary>
//         private TransformPropertiesFlag _ownerSmoothedProperties;
//         /// <summary>
//         /// Which properties to smooth.
//         /// </summary>
//         private TransformPropertiesFlag _spectatorSmoothedProperties;
//         /// <summary>
//         /// Updates the smoothedProperties value.
//         /// </summary>
//         /// <param name="value">New value.</param>
//         /// <param name="forSpectator">True if updating values for the spectator, false if updating for owner.</param>
//         public void SetSmoothedProperties(TransformPropertiesFlag value, bool forSpectator)
//         {
//             if (forSpectator)
//                 _spectatorSmoothedProperties = value;
//             else
//                 _ownerSmoothedProperties = value;
//         }
//         /// <summary>
//         /// Amount of adaptive interpolation to use.
//         /// </summary>
//         private AdaptiveInterpolationType _adaptiveInterpolation = AdaptiveInterpolationType.Low;
//         /// <summary>
//         /// Updates the adaptiveInterpolation value.
//         /// </summary>
//         /// <param name="adaptiveInterpolation">New value.</param>
//         public void SetAdaptiveInterpolation(AdaptiveInterpolationType adaptiveInterpolation)
//         {
//             if (adaptiveInterpolation != AdaptiveInterpolationType.Off)
//             {
//                 adaptiveInterpolation = AdaptiveInterpolationType.Off;
//                 Debug.Log($"AdaptiveInterpolation has been changed to off at runtime while it's under development. This message may be ignored.");
//             }
//             _adaptiveInterpolation = adaptiveInterpolation;
//         }
//         /// <summary>
//         /// Set interpolation to use for spectated objects if adaptiveInterpolation is off.
//         /// </summary>
//         private byte _spectatorInterpolation;
//         /// <summary>
//         /// Sets the spectator interpolation value.
//         /// </summary>
//         /// <param name="value">New value.</param>
//         /// <param name="disableAdaptiveInterpolation">True to also disable adaptive interpolation to use this new value.</param>
//         public void SetSpectatorInterpolation(byte value, bool disableAdaptiveInterpolation = true)
//         {
//             _spectatorInterpolation = value;
//             if (disableAdaptiveInterpolation)
//                 _adaptiveInterpolation = AdaptiveInterpolationType.Off;
//         }
//         /// <summary>
//         /// Previous parent the graphical was attached to.
//         /// </summary>
//         private Transform _previousParent;
//         /// <summary>
//         /// True if to detach at runtime.
//         /// </summary>
//         private bool _detach;
//         /// <summary>
//         /// True if were an owner of the NetworkObject during PreTick.
//         /// This is only used for performance gains.
//         /// </summary>
//         private bool _ownerOnPretick;
//         /// <summary>
//         /// True if adaptive interpolation should be used.
//         /// </summary>
//         private bool _useAdaptiveInterpolation => (!_ownerOnPretick && _adaptiveInterpolation != AdaptiveInterpolationType.Off);
//         /// <summary>
//         /// True if Initialized has been called and settings have not been reset.
//         /// </summary>
//         private bool _initialized;
//         #endregion
//
//         #region Const.
//         /// <summary>
//         /// Maximum allowed entries to be queued over the interpolation amount.
//         /// </summary>
//         private int MAXIMUM_QUEUED_OVER_INTERPOLATION = 3;
//         #endregion
//         
//         ~ChildTransformTickSmoother()
//         {
//             //This is a last resort for if something didnt deinitialize right.
//             ResetState();
//         }
//
//         /// <summary>
//         /// Initializes this smoother; should only be completed once.
//         /// </summary>
//         public void Initialize(NetworkObject nob, Transform graphicalObject, bool detach, float teleportDistance, float tickDelta, byte ownerInterpolation, TransformPropertiesFlag ownerSmoothedProperties, byte spectatorInterpolation, TransformPropertiesFlag specatorSmoothedProperties, AdaptiveInterpolationType adaptiveInterpolation)
//         {
//             ResetState();
//             _detach = detach;
//             _networkObject = nob;
//             _transformProperties = CollectionCaches<TickTransformProperties>.RetrieveBasicQueue();
//             _gfxInitializedOffsetValues = nob.transform.GetTransformOffsets(graphicalObject);
//             _tickDelta = tickDelta;
//             _graphicalObject = graphicalObject;
//             _teleportThreshold = teleportDistance;
//             _ownerInterpolation = ownerInterpolation;
//             _spectatorInterpolation = spectatorInterpolation;
//             _ownerSmoothedProperties = ownerSmoothedProperties;
//             _spectatorSmoothedProperties = specatorSmoothedProperties;
//             SetAdaptiveInterpolation(adaptiveInterpolation);
//             UpdateInterpolation(0);
//             _initialized = true;
//         }
//
//         /// <summary>
//         /// Deinitializes this smoother resetting values.
//         /// </summary>
//         public void Deinitialize()
//         {
//             ResetState();
//         }
//
//         /// <summary>
//         /// Updates interpolation based on localClient latency.
//         /// </summary>
//         private void UpdateInterpolation(uint clientStateTick)
//         {
//             if (_networkObject.IsServerStarted || _networkObject.IsOwner)
//             {
//                 _interpolation = _ownerInterpolation;
//             }
//             else
//             {
//                 if (_adaptiveInterpolation == AdaptiveInterpolationType.Off)
//                 {
//                     _interpolation = _spectatorInterpolation;
//                 }
//                 else
//                 {
//                     float interpolation;
//                     TimeManager tm = _networkObject.TimeManager;
//                     if (clientStateTick == 0)
//                     {
//                         //Not enough data to calculate; guestimate. This should only happen once.
//                         float fRtt = (float)tm.RoundTripTime;
//                         interpolation = (fRtt / 10f);
//
//                     }
//                     else
//                     {
//                         interpolation = (tm.LocalTick - clientStateTick) + _networkObject.PredictionManager.StateInterpolation;
//                     }
//
//                     switch (_adaptiveInterpolation)
//                     {
//                         case AdaptiveInterpolationType.VeryLow:
//                             interpolation *= 0.25f;
//                             break;
//                         case AdaptiveInterpolationType.Low:
//                             interpolation *= 0.375f;
//                             break;
//                         case AdaptiveInterpolationType.Medium:
//                             interpolation *= 0.5f;
//                             break;
//                         case AdaptiveInterpolationType.High:
//                             interpolation *= 0.75f;
//                             break;
//                             //Make no changes for maximum.
//                     }
//
//                     interpolation = Mathf.Clamp(interpolation, 1f, (float)byte.MaxValue);
//                     _interpolation = (byte)Mathf.RoundToInt(interpolation);
//                 }
//             }
//         }
//
//         internal void OnStartClient()
//         {
//             if (!_detach)
//                 return;
//
//             _previousParent = _graphicalObject.parent;
//             TransformProperties gfxWorldProperties = _graphicalObject.GetWorldProperties();
//             _graphicalObject.SetParent(null);
//             _graphicalObject.SetWorldProperties(gfxWorldProperties);
//         }
//
//         internal void OnStopClient()
//         {
//             if (!_detach || _previousParent == null || _graphicalObject == null)
//                 return;
//
//             _graphicalObject.SetParent(_previousParent);
//             _graphicalObject.SetWorldProperties(GetNetworkObjectWorldPropertiesWithOffset());
//         }
//
//         /// <summary>
//         /// Called every frame.
//         /// </summary>
//         internal void Update()
//         {
//             if (!CanSmooth())
//                 return;
//
//             if (_useAdaptiveInterpolation)
//                 AdaptiveMoveToTarget(Time.deltaTime);
//             else
//                 BasicMoveToTarget(Time.deltaTime);
//         }
//
//         /// <summary>
//         /// Called when the TimeManager invokes OnPreTick.
//         /// </summary>
//         public void OnPreTick()
//         {
//             if (!CanSmooth())
//                 return;
//
//             _preTicked = true;
//
//             _ownerOnPretick = _networkObject.IsOwner;
//             if (_useAdaptiveInterpolation)
//                 DiscardExcessiveTransformPropertiesQueue();
//             else
//                 ClearTransformPropertiesQueue();
//             //These only need to be set if still attached.
//             if (!_detach)
//                 _gfxPreSimulateWorldValues = _graphicalObject.GetWorldProperties();
//         }
//
//         /// <summary>
//         /// Called when the PredictionManager invokes OnPreReconcile.
//         /// </summary>
//         public void OnPreReconcile()
//         {
//             UpdateInterpolation(_networkObject.PredictionManager.ClientStateTick);
//         }
//
//         /// <summary>
//         /// Called when the TimeManager invokes OnPostReplay.
//         /// </summary>
//         /// <param name="clientTick">Replay tick for the local client.</param>
//         public void OnPostReplay(uint clientTick)
//         {
//             if (_transformProperties.Count == 0)
//                 return;
//             if (!_useAdaptiveInterpolation)
//                 return;
//
//             uint firstTick = _transformProperties.Peek().Tick;
//             //Already in motion to first entry, or first entry passed tick.
//             if (clientTick <= firstTick)
//                 return;
//
//             ModifyTransformProperties(clientTick, firstTick);
//         }
//
//         /// <summary>
//         /// Called when TimeManager invokes OnPostTick.
//         /// </summary>
//         /// <param name="clientTick">Local tick of the client.</param>
//         public void OnPostTick(uint clientTick)
//         {
//             if (!CanSmooth())
//                 return;
//
//             //If preticked then previous transform values are known.
//             if (_preTicked)
//             {
//                 if (_useAdaptiveInterpolation)
//                     DiscardExcessiveTransformPropertiesQueue();
//                 else
//                     ClearTransformPropertiesQueue();
//                 //Only needs to be put to pretick position if not detached.
//                 if (!_detach)
//                     _graphicalObject.SetWorldProperties(_gfxPreSimulateWorldValues);
//                 AddTransformProperties(clientTick);
//             }
//             //If did not pretick then the only thing we can do is snap to instantiated values.
//             else
//             {
//                 //Only set to position if not to detach.
//                 if (!_detach)
//                     _graphicalObject.SetWorldProperties(GetNetworkObjectWorldPropertiesWithOffset());
//             }
//         }
//
//         /// <summary>
//         /// Teleports the graphical to it's starting position and clears the internal movement queue.
//         /// </summary>
//         public void Teleport()
//         {
//             ClearTransformPropertiesQueue();
//             TransformProperties startProperties = _networkObject.transform.GetWorldProperties();
//             startProperties.Add(_gfxInitializedOffsetValues);
//             _graphicalObject.SetWorldProperties(startProperties);
//         }
//
//         /// <summary>
//         /// Clears the pending movement queue.
//         /// </summary>
//         private void ClearTransformPropertiesQueue()
//         {
//             _transformProperties.Clear();
//             //Also unset move rates since there is no more queue.
//             _moveRates = new MoveRates(MoveRates.UNSET_VALUE);
//         }
//
//         /// <summary>
//         /// Discards datas over interpolation limit from movement queue.
//         /// </summary>
//         private void DiscardExcessiveTransformPropertiesQueue()
//         {
//             if (!_useAdaptiveInterpolation)
//             {
//                 _networkObject.NetworkManager.LogError($"This method should only be called when using adaptive interpolation.");
//                 return;
//             }
//
//             int dequeueCount = (_transformProperties.Count - (_interpolation + MAXIMUM_QUEUED_OVER_INTERPOLATION));
//             //If there are entries to dequeue.
//             if (dequeueCount > 0)
//             {
//                 TickTransformProperties tpp = default;
//                 for (int i = 0; i < dequeueCount; i++)
//                     tpp = _transformProperties.Dequeue();
//
//                 SetAdaptiveMoveRates(tpp.Properties, _transformProperties[0].Properties);
//             }
//         }
//
//         /// <summary>
//         /// Adds a new transform properties and sets move rates if needed.
//         /// </summary>
//         private void AddTransformProperties(uint tick)
//         {
//             TickTransformProperties tpp = new TickTransformProperties(tick, GetNetworkObjectWorldPropertiesWithOffset());
//
//             _transformProperties.Enqueue(tpp);
//             //If first entry then set move rates.
//             if (_transformProperties.Count == 1)
//             {
//                 TransformProperties gfxWorldProperties = _graphicalObject.GetWorldProperties();
//                 if (_useAdaptiveInterpolation)
//                     SetAdaptiveMoveRates(gfxWorldProperties, tpp.Properties);
//                 else
//                     SetBasicMoveRates(gfxWorldProperties, tpp.Properties);
//             }
//         }
//
//         /// <summary>
//         /// Modifies a transform property for a tick. This does not error check for empty collections.
//         /// </summary>
//         /// <param name="firstTick">First tick in the queue. If 0 this will be looked up.</param>
//         private void ModifyTransformProperties(uint clientTick, uint firstTick)
//         {
//             uint tick = clientTick;
//             /*Ticks will always be added incremental by 1 so it's safe to jump ahead the difference
//             * of tick and firstTick. */
//             int index = (int)(tick - firstTick);
//             //Replace with new data.
//             if (index < _transformProperties.Count)
//             {
//                 _transformProperties[index] = new TickTransformProperties(tick, _networkObject.transform, _graphicalObject.localScale);
//             }
//             else
//             {
//                 //This should never happen.
//             }
//         }
//
//         /// <summary>
//         /// Returns TransformProperties of the NetworkObject with the graphicals world offset.
//         /// </summary>
//         /// <returns></returns>
//         private TransformProperties GetNetworkObjectWorldPropertiesWithOffset() => _networkObject.transform.GetWorldProperties(_gfxInitializedOffsetValues);
//
//         /// <summary>
//         /// Returns if prediction can be used on this rigidbody.
//         /// </summary>
//         /// <returns></returns>
//         private bool CanSmooth()
//         {
//             if (_graphicalObject == null)
//                 return false;
//
//             return true;
//         }
//
//         /// <summary>
//         /// Sets Position and Rotation move rates to reach Target datas.
//         /// </summary>
//         private void SetBasicMoveRates(TransformProperties prevValues, TransformProperties nextValues)
//         {
//             byte interpolation = _interpolation;
//             float duration = (_tickDelta * interpolation);
//             /* If interpolation is 1 then add on a tiny amount
//              * of more time to compensate for frame time, so that
//              * the smoothing does not complete before the next tick,
//              * as this would result in jitter. */
//             if (interpolation == 1)
//                 duration += (1 / 55f);
//             float teleportT = (_teleportThreshold * (float)interpolation);
//
//             _moveRates = MoveRates.GetMoveRates(prevValues, nextValues, duration, teleportT);
//             _moveRates.TimeRemaining = duration;
//         }
//
//
//         /// <summary>
//         /// Sets Position and Rotation move rates to reach Target datas.
//         /// </summary>
//         private void SetAdaptiveMoveRates(TransformProperties prevValues, TransformProperties nextValues)
//         {
//             float duration = _tickDelta;
//             /* If interpolation is 1 then add on a tiny amount
//              * of more time to compensate for frame time, so that
//              * the smoothing does not complete before the next tick,
//              * as this would result in jitter. */
//             float teleportT = _teleportThreshold;
//             _moveRates = MoveRates.GetMoveRates(prevValues, nextValues, duration, teleportT);
//             _moveRates.TimeRemaining = duration;
//
//             SetMovementMultiplier();
//         }
//
//         private void SetMovementMultiplier()
//         {
//             /* If there's more in queue than interpolation then begin to move faster based on overage.
//             * Move 5% faster for every overage. */
//             int overInterpolation = (_transformProperties.Count - _interpolation);
//             //If needs to be adjusted.
//             if (overInterpolation != 0f)
//             {
//                 _movementMultiplier += (0.015f * overInterpolation);
//             }
//             //If does not need to be adjusted.
//             else
//             {
//                 //If interpolation is 1 then slow down just barely to accomodate for frame delta variance.
//                 if (_interpolation == 1)
//                     _movementMultiplier = 0.99f;
//             }
//
//             _movementMultiplier = Mathf.Clamp(_movementMultiplier, 0.95f, 1.05f);
//         }
//
//
//         /// <summary>
//         /// Moves transform to target values.
//         /// </summary>
//         
//         private void BasicMoveToTarget(float delta)
//         {
//             int tpCount = _transformProperties.Count;
//             //No data.
//             if (tpCount == 0)
//                 return;
//
//             TickTransformProperties ttp = _transformProperties.Peek();
//             _moveRates.MoveWorldToTarget(_graphicalObject, ttp.Properties, delta);
//
//             //if TimeLeft is <= 0f then transform should be at goal.
//             if (_moveRates.TimeRemaining <= 0f)
//                 ClearTransformPropertiesQueue();
//         }
//
//         /// <summary>
//         /// Moves transform to target values.
//         /// </summary>
//         
//         private void AdaptiveMoveToTarget(float delta)
//         {
//             int tpCount = _transformProperties.Count;
//             //No data.
//             if (tpCount == 0)
//                 return;
//             /* If buffer is considerably under goal then halt
//              * movement. This will allow the buffer to grow. */
//             if ((tpCount - _interpolation) < -4)
//                 return;
//
//             TickTransformProperties ttp = _transformProperties.Peek();
//             TransformPropertiesFlag smoothedProperties = (_ownerOnPretick) ? _ownerSmoothedProperties : _spectatorSmoothedProperties;
//             _moveRates.MoveWorldToTarget(_graphicalObject, ttp.Properties, smoothedProperties, (delta * _movementMultiplier));
//             float tRemaining = _moveRates.TimeRemaining;
//             //if TimeLeft is <= 0f then transform is at goal. Grab a new goal if possible.
//             if (tRemaining <= 0f)
//             {
//                 //Dequeue current entry and if there's another call a move on it.
//                 _transformProperties.Dequeue();
//
//                 //If there are entries left then setup for the next.
//                 if (_transformProperties.Count > 0)
//                 {
//                     SetAdaptiveMoveRates(ttp.Properties, _transformProperties.Peek().Properties);
//                     //If delta is negative then call move again with abs.
//                     if (tRemaining < 0f)
//                         AdaptiveMoveToTarget(Mathf.Abs(tRemaining));
//                 }
//                 //No remaining, set to snap.
//                 else
//                 {
//                     ClearTransformPropertiesQueue();
//                 }
//             }
//         }
//
//         public void ResetState()
//         {
//             if (!_initialized)
//                 return;
//
//             _networkObject = null;
//             if (_graphicalObject != null)
//             {
//                 if (_networkObject != null)
//                 {
//                     if (_detach)
//                         _graphicalObject.SetParent(_networkObject.transform);
//                     _graphicalObject.SetWorldProperties(GetNetworkObjectWorldPropertiesWithOffset());
//                     _graphicalObject = null;
//                 }
//                 else if (_detach)
//                 {
//                     UnityEngine.Object.Destroy(_graphicalObject.gameObject);
//                 }
//             }
//             _movementMultiplier = 1f;
//             CollectionCaches<TickTransformProperties>.StoreAndDefault(ref _transformProperties);
//             _teleportThreshold = default;
//             _moveRates = default;
//             _preTicked = default;
//             _gfxInitializedOffsetValues = default;
//             _gfxPreSimulateWorldValues = default;
//             _tickDelta = default;
//             _interpolation = default;
//         }
//
//         public void InitializeState() { }
//     }
//
// }﻿namespace FishNet.Utility
{
    internal static class UtilityConstants
    {
        public const string CODEGEN_ASSEMBLY_NAME = "Unity.FishNet.CodeGen";
        public const string GENERATED_ASSEMBLY_NAME = "FishNet.Generated";
        public const string DEMOS_ASSEMBLY_NAME = "FishNet.Demos";
        public const string TEST_ASSEMBLY_NAME = "FishNet.Test";
        public const string RUNTIME_ASSEMBLY_NAME = "FishNet.Runtime";

        public const string GeneratedWriterPrefix = "GWrite___";
        public const string GeneratedReaderPrefix = "GRead___";
    }

}﻿using System;
using FishNet.Utility.Extension;
using GameKit.Dependencies.Utilities;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Object.Prediction
{
    [Obsolete("This class will be removed in version 5.")]
    internal class LocalTransformTickSmoother : IResettable
    {
        #region Private.
        /// <summary>
        /// Object to smooth.
        /// </summary>
        private Transform _graphicalObject;
        /// <summary>
        /// When not MoveRates.UNSET_VALUE the graphical object will teleport into it's next position if the move distance exceeds this value.
        /// </summary>
        private float _teleportThreshold;
        /// <summary>
        /// How quickly to move towards goal values.
        /// </summary>
        private MoveRates _moveRates;
        /// <summary>
        /// True if a pretick occurred since last postTick.
        /// </summary>
        private bool _preTicked;
        /// <summary>
        /// Local values of the graphical during pretick.
        /// </summary>
        private TransformProperties _gfxInitializedLocalValues;
        /// <summary>
        /// World values of the graphical after it's been aligned to initialized values in PreTick.
        /// </summary>
        private TransformProperties _gfxPreSimulateWorldValues;
        /// <summary>
        /// TickDelta on the TimeManager.
        /// </summary>
        private float _tickDelta;
        /// <summary>
        /// How many ticks to interpolate over.
        /// </summary>
        private byte _interpolation;
        #endregion

        /// <summary>
        /// Initializes this smoother; should only be completed once.
        /// </summary>
        internal void InitializeOnce(Transform graphicalObject, float teleportDistance, float tickDelta, byte interpolation)
        {
            _gfxInitializedLocalValues = graphicalObject.GetLocalProperties();
            _tickDelta = tickDelta;
            _graphicalObject = graphicalObject;
            _teleportThreshold = (teleportDistance * (float)interpolation);
            _interpolation = interpolation;
        }

        /// <summary>
        /// Called every frame.
        /// </summary>
        internal void Update()
        {
            if (!CanSmooth())
                return;

            MoveToTarget();
        }


        /// <summary>
        /// Called when the TimeManager invokes OnPreTick.
        /// </summary>
        internal void OnPreTick()
        {
            if (!CanSmooth())
                return;

            _preTicked = true;
            _gfxPreSimulateWorldValues = _graphicalObject.GetWorldProperties();
        }

        /// <summary>
        /// Called when TimeManager invokes OnPostTick.
        /// </summary>
        internal void OnPostTick()
        {
            if (!CanSmooth())
                return;

            //If preticked then previous transform values are known.
            if (_preTicked)
            {
                _graphicalObject.SetWorldProperties(_gfxPreSimulateWorldValues);
                SetMoveRates(_gfxInitializedLocalValues, _graphicalObject);
            }
            //If did not pretick then the only thing we can do is snap to instantiated values.
            else
            {
                _graphicalObject.SetLocalProperties(_gfxInitializedLocalValues);
            }
        }

        /// <summary>
        /// Returns if prediction can be used on this rigidbody.
        /// </summary>
        /// <returns></returns>
        private bool CanSmooth()
        {
            if (_graphicalObject == null)
                return false;

            return true;
        }

        /// <summary>
        /// Sets Position and Rotation move rates to reach Target datas.
        /// </summary>
        private void SetMoveRates(TransformProperties prevValues, Transform t)
        {
            float duration = (_tickDelta * (float)_interpolation);
            /* If interpolation is 1 then add on a tiny amount
             * of more time to compensate for frame time, so that
             * the smoothing does not complete before the next tick,
             * as this would result in jitter. */
            if (_interpolation == 1)
                duration += Mathf.Max(Time.deltaTime, (1f / 50f));
            float teleportT = _teleportThreshold;
            _moveRates = MoveRates.GetLocalMoveRates(prevValues, t, duration, teleportT);
        }


        /// <summary>
        /// Moves transform to target values.
        /// </summary>
        
        private void MoveToTarget()
        {
            _moveRates.Move(_graphicalObject, _gfxInitializedLocalValues, Time.deltaTime, useWorldSpace: false);
        }

        public void ResetState()
        {
            if (_graphicalObject != null)
            {
                _graphicalObject.SetLocalProperties(_gfxInitializedLocalValues);
                _graphicalObject = null;
            }
            _teleportThreshold = default;
            _moveRates = default;
            _preTicked = default;
            _gfxInitializedLocalValues = default;
            _gfxPreSimulateWorldValues = default;
            _tickDelta = default;
            _interpolation = default;
        }

        public void InitializeState() { }
    }


}﻿using System;
using GameKit.Dependencies.Utilities;

namespace FishNet.Component.Transforming
{
    /// <summary>
    /// Axes to snap of properties.
    /// </summary>
    [Flags]
    public enum SnappedAxes : uint
    {
        Unset = 0,
        X = (1 << 0),
        Y = (1 << 1),
        Z = (1 << 2),
        Everything = Enums.SHIFT_EVERYTHING_UINT,
    }


    public static class SnappedAxesExtensions 
    {
        public static bool FastContains(this SnappedAxes whole, SnappedAxes part) => (whole & part) == part;
    }

}
﻿using System;
using FishNet.Managing;
using FishNet.Managing.Timing;
using FishNet.Object;
using FishNet.Object.Prediction;
using FishNet.Utility.Extension;
using GameKit.Dependencies.Utilities;
using UnityEngine;
using UnityEngine.Scripting;

namespace FishNet.Component.Transforming
{
    /// <summary>
    /// This class is under regular development and it's API may change at any time.
    /// </summary>
    [Obsolete("This class will be removed in version 5.")]
    public sealed class TransformTickSmoother : IResettable
    {
        #region Types.
        private enum InitializeType
        {
            /// <summary>
            /// Not initialized.
            /// </summary>
            Unset,
            /// <summary>
            /// Initialized for network use.
            /// </summary>
            Networked,
            /// <summary>
            /// Initialized for non-network use.
            /// </summary>
            NonNetworked,
        }

        [Preserve]
        private struct TickTransformProperties
        {
            public uint Tick;
            public TransformProperties Properties;

            public TickTransformProperties(uint tick, Transform t)
            {
                Tick = tick;
                Properties = new(t.localPosition, t.localRotation, t.localScale);
            }

            public TickTransformProperties(uint tick, Transform t, Vector3 localScale)
            {
                Tick = tick;
                Properties = new(t.localPosition, t.localRotation, localScale);
            }

            public TickTransformProperties(uint tick, TransformProperties tp)
            {
                Tick = tick;
                Properties = tp;
            }

            public TickTransformProperties(uint tick, TransformProperties tp, Vector3 localScale)
            {
                Tick = tick;
                tp.Scale = localScale;
                Properties = tp;
            }
        }
        #endregion

        #region Private.
        /// <summary>
        /// Object to smooth.
        /// </summary>
        private Transform _graphicalObject;
        /// <summary>
        /// When not MoveRates.UNSET_VALUE the graphical object will teleport into it's next position if the move distance exceeds this value.
        /// </summary>
        private float _teleportThreshold;
        /// <summary>
        /// How quickly to move towards goal values.
        /// </summary>
        private MoveRates _moveRates = new(MoveRates.UNSET_VALUE);
        /// <summary>
        /// True if a pretick occurred since last postTick.
        /// </summary>
        private bool _preTicked;
        /// <summary>
        /// World offset values of the graphical from the NetworkObject during initialization.
        /// </summary>
        private TransformProperties _gfxInitializedOffsetValues;
        /// <summary>
        /// World values of the graphical after it's been aligned to initialized values in PreTick.
        /// </summary>
        private TransformProperties _gfxPreSimulateWorldValues;
        /// <summary>
        /// TickDelta on the TimeManager.
        /// </summary>
        private float _tickDelta;
        /// <summary>
        /// How many ticks to interpolate over when not using adaptive.
        /// </summary>
        private byte _ownerInterpolation;
        /// <summary>
        /// Current interpolation, regardless of if using adaptive or not.
        /// </summary>
        private byte _interpolation;
        /// <summary>
        /// NetworkObject this is for.
        /// </summary>
        private NetworkObject _networkObject;
        /// <summary>
        /// Value to multiply movement by. This is used to reduce or increase the rate the movement buffer is consumed.
        /// </summary>
        private float _movementMultiplier = 1f;
        /// <summary>
        /// TransformProperties to move towards.
        /// </summary>
        private BasicQueue<TickTransformProperties> _transformProperties;
        /// <summary>
        /// Which properties to smooth.
        /// </summary>
        private TransformPropertiesFlag _ownerSmoothedProperties;
        /// <summary>
        /// Which properties to smooth.
        /// </summary>
        private TransformPropertiesFlag _spectatorSmoothedProperties;

        /// <summary>
        /// Updates the smoothedProperties value.
        /// </summary>
        /// <param name="value">New value.</param>
        /// <param name="forSpectator">True if updating values for the spectator, false if updating for owner.</param>
        public void SetSmoothedProperties(TransformPropertiesFlag value, bool forSpectator)
        {
            if (forSpectator)
                _spectatorSmoothedProperties = value;
            else
                _ownerSmoothedProperties = value;
        }

        /// <summary>
        /// Amount of adaptive interpolation to use.
        /// </summary>
        private AdaptiveInterpolationType _adaptiveInterpolation = AdaptiveInterpolationType.VeryLow;

        /// <summary>
        /// Updates the adaptiveInterpolation value.
        /// </summary>
        /// <param name="adaptiveInterpolation">New value.</param>
        public void SetAdaptiveInterpolation(AdaptiveInterpolationType adaptiveInterpolation)
        {
            _adaptiveInterpolation = adaptiveInterpolation;
        }

        /// <summary>
        /// Set interpolation to use for spectated objects if adaptiveInterpolation is off.
        /// </summary>
        private byte _spectatorInterpolation;

        /// <summary>
        /// Sets the spectator interpolation value.
        /// </summary>
        /// <param name="value">New value.</param>
        /// <param name="disableAdaptiveInterpolation">True to also disable adaptive interpolation to use this new value.</param>
        public void SetSpectatorInterpolation(byte value, bool disableAdaptiveInterpolation = true)
        {
            _spectatorInterpolation = value;
            if (disableAdaptiveInterpolation)
                _adaptiveInterpolation = AdaptiveInterpolationType.Off;
        }

        /// <summary>
        /// Previous parent the graphical was attached to.
        /// </summary>
        private Transform _previousParent;
        /// <summary>
        /// True if to detach at runtime.
        /// </summary>
        private bool _detach;
        /// <summary>
        /// True if were an owner of the NetworkObject during PreTick.
        /// This is only used for performance gains.
        /// </summary>
        private bool _useOwnerSmoothing;
        /// <summary>
        /// True if Initialized has been called and settings have not been reset.
        /// </summary>
        private InitializeType _initializeType = InitializeType.Unset;
        /// <summary>
        /// Last tick this was teleported on.
        /// </summary>
        private uint _teleportedTick = TimeManager.UNSET_TICK;
        /// <summary>
        /// Last local tick a reconcile callback was received.
        /// </summary>
        private uint _lastReconcileTick = TimeManager.UNSET_TICK;
        /// <summary>
        /// Transform to track movement on.
        /// </summary>
        private Transform _rootTransform;
        /// <summary>
        /// Frame which smoothing can start.
        /// </summary>
        private int _startFrame;
        #endregion

        #region Const.
        /// <summary>
        /// Default expected interval for reconciles.
        /// </summary>
        private const int RECONCILE_INTERVAL_DEFAULT = int.MaxValue;
        /// <summary>
        /// Maximum allowed entries to be queued over the interpolation amount.
        /// </summary>
        private const int MAXIMUM_QUEUED_OVER_INTERPOLATION = 3;
        #endregion

        [Preserve]
        public TransformTickSmoother() { }

        ~TransformTickSmoother()
        {
            //This is a last resort for if something didnt deinitialize right.
            ResetState();
        }

        /// <summary>
        /// Initializes this smoother for owner and spectator. This should only occur once.
        /// </summary>
        public void InitializeNetworked(NetworkObject nob, Transform graphicalObject, bool detach, float teleportDistance, float tickDelta, byte ownerInterpolation, TransformPropertiesFlag ownerSmoothedProperties, byte spectatorInterpolation, TransformPropertiesFlag specatorSmoothedProperties, AdaptiveInterpolationType adaptiveInterpolation)
        {
            ResetState();

            _networkObject = nob;
            _spectatorInterpolation = spectatorInterpolation;
            _spectatorSmoothedProperties = specatorSmoothedProperties;

            Initialize_Internal(nob.transform, graphicalObject, detach, teleportDistance, tickDelta, ownerInterpolation, ownerSmoothedProperties, forNetworked: true);

            SetAdaptiveInterpolation(adaptiveInterpolation);
            UpdateInterpolation(0);
        }

        private void Initialize_Internal(Transform rootTransform, Transform graphicalObject, bool detach, float teleportDistance, float tickDelta, byte ownerInterpolation, TransformPropertiesFlag ownerSmoothedProperties, bool forNetworked)
        {
            _rootTransform = rootTransform;
            _detach = detach;
            _transformProperties = CollectionCaches<TickTransformProperties>.RetrieveBasicQueue();
            _gfxInitializedOffsetValues = rootTransform.GetTransformOffsets(graphicalObject);
            _tickDelta = tickDelta;
            _graphicalObject = graphicalObject;
            _teleportThreshold = teleportDistance;
            _ownerInterpolation = ownerInterpolation;

            _ownerSmoothedProperties = ownerSmoothedProperties;
            _initializeType = (forNetworked) ? InitializeType.Networked : InitializeType.NonNetworked;
        }

        /// <summary>
        /// Initializes this smoother non-networked use.
        /// </summary>
        public void Initialize(Transform rootTransform, Transform graphicalObject, bool detach, float teleportDistance, float tickDelta, byte ownerInterpolation, TransformPropertiesFlag ownerSmoothedProperties)
        {
            ResetState();

            Initialize_Internal(rootTransform, graphicalObject, detach, teleportDistance, tickDelta, ownerInterpolation, ownerSmoothedProperties, false);

            SetAdaptiveInterpolation(AdaptiveInterpolationType.Off);
        }

        /// <summary>
        /// Deinitializes this smoother resetting values.
        /// </summary>
        public void Deinitialize()
        {
            ResetState();
        }

        /// <summary>
        /// Updates interpolation based on localClient latency.
        /// </summary>
        private void UpdateInterpolation(uint clientStateTick)
        {
            /* Use owner interpolation if:
             * - Owner.
             * - Server, since server always interpolates over 1 tick; this only applies as clientHost.
             * - Not networked, use specified 'owner' interpolation.
             */
            if (_initializeType == InitializeType.NonNetworked || _networkObject.IsServerInitialized || _networkObject.Owner.IsLocalClient)
            {
                _interpolation = _ownerInterpolation;
            }
            //Not using owner interpolation.
            else
            {
                if (_adaptiveInterpolation == AdaptiveInterpolationType.Off)
                {
                    _interpolation = _spectatorInterpolation;
                }
                else
                {
                    float interpolation;
                    TimeManager tm = _networkObject.TimeManager;
                    if (clientStateTick == 0)
                    {
                        //Not enough data to calculate; guestimate. This should only happen once.
                        float fRtt = (float)tm.RoundTripTime;
                        interpolation = (fRtt / 10f);
                    }
                    else
                    {
                        interpolation = (tm.LocalTick - clientStateTick);
                    }

                    interpolation *= GetInterpolationMultiplier();
                    interpolation = Mathf.Clamp(interpolation, 2f, (float)byte.MaxValue);
                    _interpolation = (byte)Mathf.CeilToInt(interpolation);

                    float GetInterpolationMultiplier()
                    {
                        switch (_adaptiveInterpolation)
                        {
                            case AdaptiveInterpolationType.ExtremelyLow:
                                return 0.2f;
                            case AdaptiveInterpolationType.VeryLow:
                                return 0.45f;
                            case AdaptiveInterpolationType.Low:
                                return 0.8f;
                            case AdaptiveInterpolationType.Moderate:
                                return 1.05f;
                            case AdaptiveInterpolationType.High:
                                return 1.25f;
                            case AdaptiveInterpolationType.VeryHigh:
                                return 1.5f;
                            //Make no changes for maximum.
                            default:
                                _networkObject.NetworkManager.LogError($"AdaptiveInterpolationType {_adaptiveInterpolation} is unhandled.");
                                return 1f;
                        }
                    }
                }
            }
        }

        internal void OnStartClient()
        {
            if (!_detach)
                return;

            _previousParent = _graphicalObject.parent;
            TransformProperties gfxWorldProperties = _graphicalObject.GetWorldProperties();
            _graphicalObject.SetParent(null);
            _graphicalObject.SetWorldProperties(gfxWorldProperties);
        }

        internal void OnStopClient()
        {
            if (!_detach || _previousParent == null || _graphicalObject == null)
                return;

            _graphicalObject.SetParent(_previousParent);
            _graphicalObject.SetWorldProperties(GetNetworkObjectWorldPropertiesWithOffset());
        }

        /// <summary>
        /// Called every frame.
        /// </summary>
        internal void OnUpdate()
        {
            if (!CanSmooth())
                return;

            MoveToTarget(Time.deltaTime);
        }

        /// <summary>
        /// Called when the TimeManager invokes OnPreTick.
        /// </summary>
        public void OnPreTick()
        {
            if (!CanSmooth())
                return;

            _preTicked = true;
            _useOwnerSmoothing = (_networkObject == null || _networkObject.IsOwner);

            DiscardExcessiveTransformPropertiesQueue();

            //These only need to be set if still attached.
            if (!_detach)
                _gfxPreSimulateWorldValues = _graphicalObject.GetWorldProperties();
        }

        /// <summary>
        /// Called when the PredictionManager invokes OnPreReconcile.
        /// </summary>
        public void OnPreReconcile()
        {
            if (!_networkObject.IsObjectReconciling)
                return;
            if (_networkObject.IsOwner || _adaptiveInterpolation == AdaptiveInterpolationType.Off)
                return;

            uint clientStateTick = _networkObject.PredictionManager.ClientStateTick;
            _lastReconcileTick = clientStateTick;

            UpdateInterpolation(clientStateTick);
        }

        /// <summary>
        /// Called when the TimeManager invokes OnPostReplay.
        /// </summary>
        /// <param name="clientTick">Replay tick for the local client.</param>
        public void OnPostReplicateReplay(uint clientTick)
        {
            if (_networkObject.IsOwner || _adaptiveInterpolation == AdaptiveInterpolationType.Off)
                return;
            if (_transformProperties.Count == 0)
                return;
            if (clientTick <= _teleportedTick)
                return;
            uint firstTick = _transformProperties.Peek().Tick;
            //Already in motion to first entry, or first entry passed tick.
            if (clientTick <= firstTick)
                return;

            ModifyTransformProperties(clientTick, firstTick);
        }

        /// <summary>
        /// Called when TimeManager invokes OnPostTick.
        /// </summary>
        /// <param name="clientTick">Local tick of the client.</param>
        public void OnPostTick(uint clientTick)
        {
            if (!CanSmooth())
                return;
            if (clientTick <= _teleportedTick)
                return;

            //If preticked then previous transform values are known.
            if (_preTicked)
            {
                DiscardExcessiveTransformPropertiesQueue();

                //Only needs to be put to pretick position if not detached.
                if (!_detach)
                    _graphicalObject.SetWorldProperties(_gfxPreSimulateWorldValues);

                AddTransformProperties(clientTick);
            }
            //If did not pretick then the only thing we can do is snap to instantiated values.
            else
            {
                //Only set to position if not to detach.
                if (!_detach)
                    _graphicalObject.SetWorldProperties(GetNetworkObjectWorldPropertiesWithOffset());
            }
        }

        /// <summary>
        /// Teleports the graphical to it's starting position and clears the internal movement queue.
        /// </summary>
        public void Teleport()
        {
            if (_networkObject == null)
                return;
            _teleportedTick = _networkObject.TimeManager.LocalTick;
            ClearTransformPropertiesQueue();
            TransformProperties startProperties = _networkObject.transform.GetWorldProperties();
            startProperties.Add(_gfxInitializedOffsetValues);
            _graphicalObject.SetWorldProperties(startProperties);
        }

        /// <summary>
        /// Clears the pending movement queue.
        /// </summary>
        private void ClearTransformPropertiesQueue()
        {
            _transformProperties.Clear();
            //Also unset move rates since there is no more queue.
            _moveRates = new(MoveRates.UNSET_VALUE);
        }

        /// <summary>
        /// Discards datas over interpolation limit from movement queue.
        /// </summary>
        private void DiscardExcessiveTransformPropertiesQueue()
        {
            int propertiesCount = _transformProperties.Count;
            int dequeueCount = (propertiesCount - (_interpolation + MAXIMUM_QUEUED_OVER_INTERPOLATION));
            //If there are entries to dequeue.
            if (dequeueCount > 0)
            {
                TickTransformProperties tpp = default;
                for (int i = 0; i < dequeueCount; i++)
                    tpp = _transformProperties.Dequeue();

                SetMoveRates(tpp.Properties);
            }
        }

        /// <summary>
        /// Adds a new transform properties and sets move rates if needed.
        /// </summary>
        private void AddTransformProperties(uint tick)
        {
            TickTransformProperties tpp = new(tick, GetNetworkObjectWorldPropertiesWithOffset());
            _transformProperties.Enqueue(tpp);

            //If first entry then set move rates.
            if (_transformProperties.Count == 1)
            {
                TransformProperties gfxWorldProperties = _graphicalObject.GetWorldProperties();
                SetMoveRates(gfxWorldProperties);
                _startFrame = Time.frameCount + 1;
            }
        }

        /// <summary>
        /// Modifies a transform property for a tick. This does not error check for empty collections.
        /// </summary>
        /// <param name="firstTick">First tick in the queue. If 0 this will be looked up.</param>
        private void ModifyTransformProperties(uint clientTick, uint firstTick)
        {
            uint tick = clientTick;
            /*Ticks will always be added incremental by 1 so it's safe to jump ahead the difference
             * of tick and firstTick. */
            int index = (int)(tick - firstTick);
            //Replace with new data.
            if (index < _transformProperties.Count)
            {
                if (tick != _transformProperties[index].Tick)
                {
                    //Should not be possible.
                }
                else
                {
                    _transformProperties[index] = new(tick, GetNetworkObjectWorldPropertiesWithOffset(), _graphicalObject.localScale);
                }
            }
            else
            {
                //This should never happen.
            }
        }

        /// <summary>
        /// Returns TransformProperties of the NetworkObject with the graphicals world offset.
        /// </summary>
        /// <returns></returns>
        private TransformProperties GetNetworkObjectWorldPropertiesWithOffset() => _networkObject.transform.GetWorldProperties(_gfxInitializedOffsetValues);

        /// <summary>
        /// Returns if prediction can be used on this rigidbody.
        /// </summary>
        /// <returns></returns>
        private bool CanSmooth()
        {
            if (_graphicalObject == null)
                return false;
            if (_networkObject != null && _networkObject.EnablePrediction && !_networkObject.EnableStateForwarding && !_networkObject.IsController)
                return false;
            if (_networkObject.IsServerOnlyStarted)
                return false;

            return true;
        }

        /// <summary>
        /// Sets new rates based on next entries in transformProperties queue, against a supplied TransformProperties.
        /// </summary>
        private void SetMoveRates(in TransformProperties prevValues)
        {
            if (_transformProperties.Count == 0)
            {
                _moveRates = new(MoveRates.UNSET_VALUE);
                return;
            }

            TransformProperties nextValues = _transformProperties.Peek().Properties;
            float duration = _tickDelta;
            float teleportT = _teleportThreshold;

            _moveRates = MoveRates.GetMoveRates(prevValues, nextValues, duration, teleportT);
            _moveRates.TimeRemaining = duration;

            SetMovementMultiplier();
        }

        private void SetMovementMultiplier()
        {
            /* If there's more in queue than interpolation then begin to move faster based on overage.
             * Move 5% faster for every overage. */
            int overInterpolation = (_transformProperties.Count - _interpolation);
            //If needs to be adjusted.
            if (overInterpolation != 0)
            {
                _movementMultiplier += (0.015f * overInterpolation);
            }
            //If does not need to be adjusted.
            else
            {
                //If interpolation is 1 then slow down just barely to accomodate for frame delta variance.
                if (_interpolation == 1)
                    _movementMultiplier = 1f;
            }

            _movementMultiplier = Mathf.Clamp(_movementMultiplier, 0.95f, 1.05f);
        }

        /// <summary>
        /// Moves transform to target values.
        /// </summary>
        private void MoveToTarget(float delta)
        {
            if (Time.frameCount < _startFrame)
                return;
            int tpCount = _transformProperties.Count;
            //No data.
            if (tpCount == 0)
                return;
            /* If buffer is considerably under goal then halt
             * movement. This will allow the buffer to grow. */
            if ((tpCount - _interpolation) < -4)
                return;

            TickTransformProperties ttp = _transformProperties.Peek();
            TransformPropertiesFlag smoothedProperties = (_useOwnerSmoothing) ? _ownerSmoothedProperties : _spectatorSmoothedProperties;
            _moveRates.Move(_graphicalObject, ttp.Properties, smoothedProperties, (delta * _movementMultiplier), useWorldSpace: true);

            float tRemaining = _moveRates.TimeRemaining;
            //if TimeLeft is <= 0f then transform is at goal. Grab a new goal if possible.
            if (tRemaining <= 0f)
            {
                //Dequeue current entry and if there's another call a move on it.
                _transformProperties.Dequeue();

                //If there are entries left then setup for the next.
                if (_transformProperties.Count > 0)
                {
                    SetMoveRates(ttp.Properties);
                    //If delta is negative then call move again with abs.
                    if (tRemaining < 0f)
                        MoveToTarget(Mathf.Abs(tRemaining));
                }
                //No remaining, set to snap.
                else
                {
                    ClearTransformPropertiesQueue();
                }
            }
        }

        public void ResetState()
        {
            if (_initializeType == InitializeType.Unset)
                return;

            if (_graphicalObject != null)
            {
                if (_rootTransform != null)
                {
                    //Check isQuitting for UnityEditor fix //https://github.com/FirstGearGames/FishNet/issues/818
                    if (_detach && !ApplicationState.IsQuitting())
                        _graphicalObject.SetParent(_rootTransform);
                    _graphicalObject.SetWorldProperties(GetNetworkObjectWorldPropertiesWithOffset());
                    _graphicalObject = null;
                }
                else if (_detach)
                {
                    UnityEngine.Object.Destroy(_graphicalObject.gameObject);
                }
            }

            _networkObject = null;
            _teleportedTick = TimeManager.UNSET_TICK;
            _lastReconcileTick = TimeManager.UNSET_TICK;
            _movementMultiplier = 1f;
            CollectionCaches<TickTransformProperties>.StoreAndDefault(ref _transformProperties);
            _teleportThreshold = default;
            _moveRates = default;
            _preTicked = default;
            _gfxInitializedOffsetValues = default;
            _gfxPreSimulateWorldValues = default;
            _tickDelta = default;
            _interpolation = default;
        }

        public void InitializeState() { }
    }
}﻿using FishNet.Documenting;
using FishNet.Managing;
using FishNet.Object;

namespace FishNet.Utility.Extension
{
    [APIExclude]
    public static class NetworksFN
    {
        /// <summary>
        /// Returns if logic could have potentially called already on server side, and is calling a second time for clientHost side.
        /// </summary>
        public static bool DoubleLogic(this NetworkObject nob, bool asServer) => (!asServer && nob.NetworkManager.IsServerStarted);
        /// <summary>
        /// Returns if logic could have potentially called already on server side, and is calling a second time for clientHost side.
        /// </summary>
        public static bool DoubleLogic(this NetworkManager manager, bool asServer) => (!asServer && manager.IsServerStarted);
        /// <summary>
        /// Returns if logic could have potentially called already on server side, and is calling a second time for clientHost side.
        /// </summary>
        public static bool DoubleLogic(this NetworkBehaviour nb, bool asServer) => (!asServer && nb.NetworkManager.IsServerStarted);

    }

}﻿using FishNet.Managing;
using FishNet.Object;
using GameKit.Dependencies.Utilities;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace FishNet.Utility.Extension
{

    public static class Scenes
    {
        /// <summary>
        /// Gets all NetworkObjects in a scene.
        /// </summary>
        /// <param name="s">Scene to get objects in.</param>
        /// <param name="firstOnly">True to only return the first NetworkObject within an object chain. False will return nested NetworkObjects.</param>
        /// <returns></returns>
        public static void GetSceneNetworkObjects(Scene s, bool firstOnly, bool errorOnDuplicates, bool ignoreUnsetSceneIds, ref List<NetworkObject> result)
        {
            List<NetworkObject> nobCacheA = CollectionCaches<NetworkObject>.RetrieveList();
            List<NetworkObject> nobCacheB = CollectionCaches<NetworkObject>.RetrieveList();
            List<GameObject> gameObjectCache = CollectionCaches<GameObject>.RetrieveList();
            Dictionary<ulong, NetworkObject> sceneIds = CollectionCaches<ulong, NetworkObject>.RetrieveDictionary();

            //Iterate all root objects for the scene.
            s.GetRootGameObjects(gameObjectCache);
            foreach (GameObject go in gameObjectCache)
            {
                //Get NetworkObjects within children of each root.
                go.GetComponentsInChildren(true, nobCacheA);
                //If network objects are found.
                if (nobCacheA.Count > 0)
                {
                    //Add only the first networkobject 
                    if (firstOnly)
                    {
                        /* The easiest way to see if a nob is nested is to
                         * get nobs in parent and if the count is greater than 1, then
                         * it is nested. The technique used here isn't exactly fast but
                         * it will only occur during scene loads, so I'm trading off speed
                         * for effort and readability. */
                        foreach (NetworkObject nob in nobCacheA)
                        {
                            if (ignoreUnsetSceneIds && !nob.IsSceneObject)
                                continue;

                            nob.GetComponentsInParent(true, nobCacheB);
                            //No extra nobs, only this one.
                            if (nobCacheB.Count == 1 && !TryDisplayDuplicateError(nob))
                                result.Add(nob);
                        }
                    }
                    //Not first only, add them all.
                    else
                    {
                        foreach (NetworkObject item in nobCacheA)
                        {
                            if (ignoreUnsetSceneIds && !item.IsSceneObject)
                                continue;
                            if (!TryDisplayDuplicateError(item))
                                result.Add(item);
                        }
                    }

                }
            }

            CollectionCaches<ulong, NetworkObject>.Store(sceneIds);

            bool TryDisplayDuplicateError(NetworkObject nob)
            {
                if (!errorOnDuplicates)
                    return false;

                ulong id = nob.SceneId;
                //There is a duplicate.
                if (sceneIds.TryGetValue(id, out NetworkObject originalNob))
                {
                    string err = $"Object {nob.name} and {originalNob.name} in scene {nob.gameObject.scene.name} have the same sceneId of {id}. This will result in spawning errors. Exit play mode and use the Fish-Networking menu to reserialize sceneIds for scene {nob.gameObject.scene.name}.";
                    NetworkManagerExtensions.LogError(err);
                    return true;
                }
                else
                {
                    sceneIds[id] = nob;
                    return false;
                }
            }

        }

    }

}﻿using System;
using FishNet.Documenting;
using FishNet.Object;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Utility.Extension
{
    [APIExclude]
    public static class TransformFN
    {
        /// <summary>
        /// Sets values of TransformProperties to a transforms world properties.
        /// </summary>
        public static TransformProperties GetWorldProperties(this Transform t)
        {
            TransformProperties tp = new(t.position, t.rotation, t.localScale);
            return tp;
        }

        /// <summary>
        /// Sets values of TransformProperties to a transforms world properties.
        /// </summary>
        
        public static TransformProperties GetWorldProperties(this Transform t, TransformProperties offset)
        {
            TransformProperties tp = new(t.position, t.rotation, t.localScale);
            tp.Add(offset);
            return tp;
        }

        /// <summary>
        /// Sets values of TransformProperties to a transforms world properties.
        /// </summary>
        public static TransformPropertiesCls GetWorldPropertiesCls(this Transform t)
        {
            TransformPropertiesCls tp = new(t.position, t.rotation, t.localScale);
            return tp;
        }


        /// <summary>
        /// Sets values of TransformProperties to a transforms world properties.
        /// </summary>
        public static TransformProperties GetLocalProperties(this Transform t)
        {
            TransformProperties tp = new(t.localPosition, t.localRotation, t.localScale);
            return tp;
        }

        /// <summary>
        /// Sets values of TransformProperties to a transforms world properties.
        /// </summary>
        public static TransformPropertiesCls GetLocalPropertiesCls(this Transform t)
        {
            TransformPropertiesCls tp = new(t.localPosition, t.localRotation, t.localScale);
            return tp;
        }


        /// <summary>
        /// Sets values of TransformPropertiesCls to a transforms world properties.
        /// </summary>
        [Obsolete("Use TransformPropertiesExtensions.SetWorldProperties.")]
        public static void SetWorldProperties(this TransformPropertiesCls tp, Transform t) => TransformPropertiesExtensions.SetWorldProperties(tp, t);

        /// <summary>
        /// Gets the offset values by subtracting this from target.
        /// </summary>
        /// <param name="pos">Position offset result.</param>
        /// <param name="rot">Rotation offset result.</param>
        public static void SetTransformOffsets(this Transform t, Transform target, ref Vector3 pos, ref Quaternion rot)
        {
            if (target == null)
                return;
            pos = (target.position - t.position);
            rot = (target.rotation * Quaternion.Inverse(t.rotation));
        }

        /// <summary>
        /// Gets the offset values by subtracting this from target.
        /// </summary>
        /// <param name="zeroScale">True to set scale to Vector3.zero.</param>
        public static TransformProperties GetTransformOffsets(this Transform t, Transform target)
        {
            if (target == null)
                return default;
            
            return new(
                (target.position - t.position),
                (target.rotation * Quaternion.Inverse(t.rotation)),
                (target.localScale - t.localScale)
                );
        }

        /// <summary>
        /// Sets a transform to local properties.
        /// </summary>
        public static void SetLocalProperties(this Transform t, TransformPropertiesCls tp)
        {
            t.localPosition = tp.Position;
            t.localRotation = tp.Rotation;
            t.localScale = tp.LocalScale;
        }

        /// <summary>
        /// Sets a transform to local properties.
        /// </summary>
        public static void SetLocalProperties(this Transform t, TransformProperties tp)
        {
            t.localPosition = tp.Position;
            t.localRotation = tp.Rotation;
            t.localScale = tp.Scale;
        }

        /// <summary>
        /// Sets a transform to world properties.
        /// </summary>
        public static void SetWorldProperties(this Transform t, TransformPropertiesCls tp)
        {
            t.position = tp.Position;
            t.rotation = tp.Rotation;
            t.localScale = tp.LocalScale;
        }
        /// <summary>
        /// Sets a transform to world properties.
        /// </summary>
        public static void SetWorldProperties(this Transform t, TransformProperties tp)
        {
            t.position = tp.Position;
            t.rotation = tp.Rotation;
            t.localScale = tp.Scale;
        }

        /// <summary>
        /// Sets local position and rotation for a transform.
        /// </summary>
        public static void SetLocalPositionAndRotation(this Transform t, Vector3 pos, Quaternion rot)
        {
            t.localPosition = pos;
            t.localRotation = rot;
        }
        /// <summary>
        /// Sets local position, rotation, and scale for a transform.
        /// </summary>
        public static void SetLocalPositionRotationAndScale(this Transform t, Vector3 pos, Quaternion rot, Vector3 scale)
        {
            t.localPosition = pos;
            t.localRotation = rot;
            t.localScale = scale;
        }
        /// <summary>
        /// Sets local position, rotation, and scale using nullables for a transform. If a value is null then that property is skipped.
        /// </summary>
        public static void SetLocalPositionRotationAndScale(this Transform t, Vector3? nullablePos, Quaternion? nullableRot, Vector3? nullableScale)
        {
            if (nullablePos.HasValue)
                t.localPosition = nullablePos.Value;
            if (nullableRot.HasValue)
                t.localRotation = nullableRot.Value;
            if (nullableScale.HasValue)
                t.localScale = nullableScale.Value;
        }

        /// <summary>
        /// Sets world position, rotation, and scale using nullables for a transform. If a value is null then that property is skipped.
        /// </summary>
        public static void SetWorldPositionRotationAndScale(this Transform t, Vector3? nullablePos, Quaternion? nullableRot, Vector3? nullableScale)
        {
            if (nullablePos.HasValue)
                t.position = nullablePos.Value;
            if (nullableRot.HasValue)
                t.rotation = nullableRot.Value;
            if (nullableScale.HasValue)
                t.localScale = nullableScale.Value;
        }

        /// <summary>
        /// Oututs properties to use for a transform. When a nullable property has value that value is used, otherwise the transforms current property is used.
        /// </summary>
        public static void OutLocalPropertyValues(this Transform t, Vector3? nullablePos, Quaternion? nullableRot, Vector3? nullableScale, out Vector3 pos, out Quaternion rot, out Vector3 scale)
        {
            pos = (nullablePos == null) ? t.localPosition : nullablePos.Value;
            rot = (nullableRot == null) ? t.localRotation : nullableRot.Value;
            scale = (nullableScale == null) ? t.localScale : nullableScale.Value;
        }

        /// <summary>
        /// Oututs properties to use for a transform. When a nullable property has value that value is used, otherwise the transforms current property is used.
        /// </summary>
        public static void OutWorldPropertyValues(this Transform t, Vector3? nullablePos, Quaternion? nullableRot, Vector3? nullableScale, out Vector3 pos, out Quaternion rot, out Vector3 scale)
        {
            pos = (nullablePos == null) ? t.position : nullablePos.Value;
            rot = (nullableRot == null) ? t.rotation : nullableRot.Value;
            scale = (nullableScale == null) ? t.localScale : nullableScale.Value;
        }
    }

}﻿//using System; //Remove on V5

//namespace FishNet.Utility.Performance
//{

//    /// <summary>
//    /// Unity 2022 has a bug where codegen will not compile when referencing a Queue type,
//    /// while also targeting .Net as the framework API.
//    /// As a work around this class is used for queues instead.
//    /// </summary>
//    public class BasicQueue<T>
//    {
//        /// <summary>
//        /// Maximum size of the collection.
//        /// </summary>
//        public int Capacity => Collection.Length;
//        /// <summary>
//        /// Number of elements in the queue.
//        /// </summary>
//        public int Count => _written;
//        /// <summary>
//        /// Collection containing data.
//        /// </summary>
//        private T[] Collection = new T[4];
//        /// <summary>
//        /// Current write index of the collection.
//        /// </summary>
//        public int WriteIndex { get; private set; }
//        /// <summary>
//        /// Buffer for resizing.
//        /// </summary>
//        private T[] _resizeBuffer = new T[0];
//        /// <summary>
//        /// Read position of the next Dequeue.
//        /// </summary>
//        private int _read;

//        /// <summary>
//        /// Length of the queue.
//        /// </summary>
//        private int _written;

//        /// <summary>
//        /// Enqueues an entry.
//        /// </summary>
//        /// <param name="data"></param>
//        public void Enqueue(T data)
//        {
//            if (_written == Collection.Length)
//                Resize();

//            if (WriteIndex >= Collection.Length)
//                WriteIndex = 0;
//            Collection[WriteIndex] = data;

//            WriteIndex++;
//            _written++;
//        }

//        /// <summary>
//        /// Tries to dequeue the next entry.
//        /// </summary>
//        /// <param name="result">Dequeued entry.</param>
//        /// <returns>True if an entry existed to dequeue.</returns>
//        public bool TryDequeue(out T result)
//        {
//            if (_written == 0)
//            {
//                result = default;
//                return false;
//            }

//            result = Dequeue();
//            return true;
//        }

//        /// <summary>
//        /// Dequeues the next entry.
//        /// </summary>
//        /// <returns></returns>
//        public T Dequeue()
//        {
//            if (_written == 0)
//                throw new Exception($"Queue of type {typeof(T).Name} is empty.");

//            T result = Collection[_read];

//            _written--;
//            _read++;
//            if (_read >= Collection.Length)
//                _read = 0;

//            return result;
//        }

//        /// <summary>
//        /// Tries to peek the next entry.
//        /// </summary>
//        /// <param name="result">Peeked entry.</param>
//        /// <returns>True if an entry existed to peek.</returns>
//        public bool TryPeek(out T result)
//        {
//            if (_written == 0)
//            {
//                result = default;
//                return false;
//            }

//            result = Peek();
//            return true;
//        }

//        /// <summary>
//        /// Peeks the next queue entry.
//        /// </summary>
//        /// <returns></returns>
//        public T Peek()
//        {
//            if (_written == 0)
//                throw new Exception($"Queue of type {typeof(T).Name} is empty.");

//            return Collection[_read];
//        }

//        /// <summary>
//        /// Clears the queue.
//        /// </summary>
//        public void Clear()
//        {
//            _read = 0;
//            WriteIndex = 0;
//            _written = 0;

//            DefaultCollection(Collection);
//            DefaultCollection(_resizeBuffer);

//            void DefaultCollection(T[] array)
//            {
//                int count = array.Length;
//                for (int i = 0; i < count; i++)
//                    array[i] = default;
//            }
//        }

//        /// <summary>
//        /// Doubles the queue size.
//        /// </summary>
//        private void Resize()
//        {
//            int length = _written;
//            int doubleLength = (length * 2);
//            int read = _read;

//            /* Make sure copy array is the same size as current
//             * and copy contents into it. */
//            //Ensure large enough to fit contents.
//            T[] resizeBuffer = _resizeBuffer;
//            if (resizeBuffer.Length < doubleLength)
//                Array.Resize(ref resizeBuffer, doubleLength);
//            //Copy from the read of queue first.
//            int copyLength = (length - read);
//            Array.Copy(Collection, read, resizeBuffer, 0, copyLength);
//            /* If read index was higher than 0
//             * then copy remaining data as well from 0. */
//            if (read > 0)
//                Array.Copy(Collection, 0, resizeBuffer, copyLength, read);

//            //Set _array to resize.
//            Collection = resizeBuffer;
//            //Reset positions.
//            _read = 0;
//            WriteIndex = length;
//        }

//        /// <summary>
//        /// Returns value in actual index as it relates to simulated index.
//        /// </summary>
//        /// <param name="simulatedIndex">Simulated index to return. A value of 0 would return the first simulated index in the collection.</param>
//        /// <returns></returns>
//        public T this[int simulatedIndex]
//        {
//            get
//            {
//                int offset = GetRealIndex(simulatedIndex);
//                return Collection[offset];
//            }
//            set
//            {
//                int offset = GetRealIndex(simulatedIndex);
//                Collection[offset] = value;
//            }
//        }



//        /// <summary>
//        /// Returns the real index of the collection using a simulated index.
//        /// </summary>
//        /// <param name="allowUnusedBuffer">True to allow an index be returned from an unused portion of the buffer so long as it is within bounds.</param>
//        private int GetRealIndex(int simulatedIndex, bool allowUnusedBuffer = false)
//        {
//            if (simulatedIndex >= Capacity)
//            {
//                return ReturnError();
//            }
//            else
//            {
//                int written = _written;
//                //May be out of bounds if allowUnusedBuffer is false.
//                if (simulatedIndex >= written)
//                {
//                    if (!allowUnusedBuffer)
//                        return ReturnError();
//                }
//                int offset = (Capacity - written) + simulatedIndex + WriteIndex;
//                if (offset >= Capacity)
//                    offset -= Capacity;

//                return offset;
//            }

//            int ReturnError()
//            {
//                UnityEngine.Debug.LogError($"Index {simulatedIndex} is out of range. Collection count is {_written}, Capacity is {Capacity}");
//                return -1;
//            }
//        }

//    }

//}﻿using System;
using System.Collections.Generic;

namespace FishNet.Utility.Performance
{

    /// <summary>
    /// Retrieves and stores byte arrays using a pooling system.
    /// </summary>
    public static class ByteArrayPool
    {
        /// <summary>
        /// Stored byte arrays.
        /// </summary>
        private static Queue<byte[]> _byteArrays = new();

        /// <summary>
        /// Returns a byte array which will be of at lesat minimum length. The returned array must manually be stored.
        /// </summary>
        public static byte[] Retrieve(int minimumLength)
        {
            byte[] result = null;

            if (_byteArrays.Count > 0)
                result = _byteArrays.Dequeue();

            int doubleMinimumLength = (minimumLength * 2);
            if (result == null)
                result = new byte[doubleMinimumLength];
            else if (result.Length < minimumLength)
                Array.Resize(ref result, doubleMinimumLength);

            return result;
        }

        /// <summary>
        /// Stores a byte array for re-use.
        /// </summary>
        public static void Store(byte[] buffer)
        {
            /* Holy cow that's a lot of buffered
             * buffers. This wouldn't happen under normal
             * circumstances but if the user is stress
             * testing connections in one executable perhaps. */
            if (_byteArrays.Count > 300)
                return;
            _byteArrays.Enqueue(buffer);
        }

    }


}using FishNet.Managing;
using FishNet.Managing.Object;
using FishNet.Object;
using FishNet.Utility.Extension;
using GameKit.Dependencies.Utilities;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace FishNet.Utility.Performance
{
    public class DefaultObjectPool : ObjectPool
    {
        #region Public.
        /// <summary>
        /// Cache for pooled NetworkObjects.
        /// Key: CollectionId.
        /// </summary>
        public IReadOnlyList<Dictionary<int, Stack<NetworkObject>>> Cache => _cache;
        private List<Dictionary<int, Stack<NetworkObject>>> _cache = new();
        #endregion

        #region Serialized.
        /// <summary>
        /// True if to use object pooling.
        /// </summary>
        [Tooltip("True if to use object pooling.")]
        [SerializeField]
        private bool _enabled = true;
        #endregion

        #region Private.
        /// <summary>
        /// Current count of the cache collection.
        /// </summary>
        private int _cacheCount = 0;
        #endregion

#pragma warning disable CS0672 // Member overrides obsolete member
        public override NetworkObject RetrieveObject(int prefabId, ushort collectionId, Transform parent = null, Vector3? nullablePosition = null, Quaternion? nullableRotation = null, Vector3? nullableScale = null, bool makeActive = true, bool asServer = true)
#pragma warning restore CS0672 // Member overrides obsolete member
        {
            ObjectPoolRetrieveOption options = ObjectPoolRetrieveOption.Unset;
            if (makeActive)
                options |= ObjectPoolRetrieveOption.MakeActive;

            return RetrieveObject(prefabId, collectionId, options, parent, nullablePosition, nullableRotation, nullableScale, asServer);
        }

        /// <summary>
        /// Returns an object that has been stored. A new object will be created if no stored objects are available.
        /// </summary>
        /// <param name="prefabId">PrefabId of the object to return.</param>
        /// <param name="collectionId">CollectionId of the object to return.</param>
        /// <param name="asServer">True if being called on the server side.</param>
        /// <returns></returns>
        public override NetworkObject RetrieveObject(int prefabId, ushort collectionId, ObjectPoolRetrieveOption options, Transform parent = null, Vector3? nullablePosition = null, Quaternion? nullableRotation = null, Vector3? nullableScale = null, bool asServer = true)
        {
            bool makeActive = options.FastContains(ObjectPoolRetrieveOption.MakeActive);
            bool localSpace = options.FastContains(ObjectPoolRetrieveOption.LocalSpace);

            if (!_enabled)
                return GetFromInstantiate();

            Stack<NetworkObject> cache = GetCache(collectionId, prefabId, createIfMissing: true);
            NetworkObject nob = null;

            //Iterate until nob is populated just in case cache entries have been destroyed.
            while (nob == null)
            {
                if (cache.TryPop(out nob))
                {
                    if (nob != null)
                    {
                        nob.transform.SetParent(parent);
                        if (localSpace)
                            nob.transform.SetLocalPositionRotationAndScale(nullablePosition, nullableRotation, nullableScale);
                        else
                            nob.transform.SetWorldPositionRotationAndScale(nullablePosition, nullableRotation, nullableScale);

                        if (makeActive)
                            nob.gameObject.SetActive(true);

                        return nob;
                    }
                }
                //Nothing left in cache.
                else
                {
                    break;
                }
            }

            //Fall through, nothing in cache.
            return GetFromInstantiate();

            //Returns a network object via instantation.
            NetworkObject GetFromInstantiate()
            {
                NetworkObject prefab = GetPrefab(prefabId, collectionId, asServer);
                if (prefab == null)
                {
                    return null;
                }
                else
                {
                    NetworkObject result;
                    Vector3 scale;

                    if (localSpace)
                    {
                        prefab.transform.OutLocalPropertyValues(nullablePosition, nullableRotation, nullableScale, out Vector3 pos, out Quaternion rot, out scale);
                        if (parent != null)
                        {
                            //Convert pos and rot to world values for the instantiate.
                            pos = parent.TransformPoint(pos);
                            rot = (parent.rotation * rot);
                        }
                        result = Instantiate(prefab, pos, rot, parent);
                    }
                    else
                    {
                        prefab.transform.OutWorldPropertyValues(nullablePosition, nullableRotation, nullableScale, out Vector3 pos, out Quaternion rot, out scale);
                        result = Instantiate(prefab, pos, rot, parent);
                    }

                    result.transform.localScale = scale;

                    if (makeActive)
                        result.gameObject.SetActive(true);
                    return result;
                }
            }
        }

        /// <summary>
        /// Returns a prefab for prefab and collectionId.
        /// </summary>
        public override NetworkObject GetPrefab(int prefabId, ushort collectionId, bool asServer)
        {
            PrefabObjects po = base.NetworkManager.GetPrefabObjects<PrefabObjects>(collectionId, false);
            return po.GetObject(asServer, prefabId);
        }

        /// <summary>
        /// Stores an object into the pool.
        /// </summary>
        /// <param name="instantiated">Object to store.</param>
        /// <param name="asServer">True if being called on the server side.</param>
        /// <returns></returns>
        public override void StoreObject(NetworkObject instantiated, bool asServer)
        {
            //Pooling is not enabled.
            if (!_enabled)
            {
                Destroy(instantiated.gameObject);
                return;
            }

            //Get all children as well and reset state on them.
            List<NetworkObject> nestedNobs = instantiated.GetNetworkObjects(GetNetworkObjectOption.All);

            foreach (NetworkObject nob in nestedNobs)
                nob.ResetState(asServer);

            CollectionCaches<NetworkObject>.Store(nestedNobs);

            //Set root inactive.
            instantiated.gameObject.SetActive(false);

            Stack<NetworkObject> cache = GetCache(instantiated.SpawnableCollectionId, instantiated.PrefabId, createIfMissing: true);
            cache.Push(instantiated);
        }

        /// <summary>
        /// Instantiates a number of objects and adds them to the pool.
        /// </summary>
        /// <param name="prefab">Prefab to cache.</param>
        /// <param name="count">Quantity to spawn.</param>
        /// <param name="asServer">True if storing prefabs for the server collection. This is only applicable when using DualPrefabObjects.</param>
#pragma warning disable CS0672 // Member overrides obsolete member
        public override void CacheObjects(NetworkObject prefab, int count, bool asServer) => StorePrefabObjects(prefab, count, asServer);
#pragma warning restore CS0672 // Member overrides obsolete member

        /// <summary>
        /// Instantiates a number of objects and adds them to the pool.
        /// </summary>
        /// <param name="prefab">Prefab to cache.</param>
        /// <param name="count">Quantity to spawn.</param>
        /// <param name="asServer">True if storing prefabs for the server collection. This is only applicable when using DualPrefabObjects.</param>
        /// <returns>Prefabs instantiated and added to cache.</returns>
        public override List<NetworkObject> StorePrefabObjects(NetworkObject prefab, int count, bool asServer)
        {
            if (!_enabled)
                return null;
            if (count <= 0)
                return null;
            if (prefab == null)
                return null;
            if (prefab.PrefabId == NetworkObject.UNSET_PREFABID_VALUE)
            {
                NetworkManagerExtensions.LogError($"Pefab {prefab.name} has an invalid prefabId and cannot be cached.");
                return null;
            }

            List<NetworkObject> added = new();
            Stack<NetworkObject> cache = GetCache(prefab.SpawnableCollectionId, prefab.PrefabId, createIfMissing: true);

            for (int i = 0; i < count; i++)
            {
                NetworkObject nob = Instantiate(prefab);
                nob.gameObject.SetActive(false);
                cache.Push(nob);
                added.Add(nob);
            }

            return added;
        }

        /// <summary>
        /// Clears pooled objects for a specific NetworkObject.
        /// </summary>
        /// <param name="nob">Prefab or Instantiated NetworkObject to clear pool for.</param>
        /// <remarks>This will clear the entire pool for the specified object.</remarks>
        public void ClearPool(NetworkObject nob)
        {
            if (!_enabled)
                return;
            if (nob == null)
                return;

            int spawnableCollectionId = nob.SpawnableCollectionId;
            Stack<NetworkObject> stack = GetCache(spawnableCollectionId, nob.PrefabId, createIfMissing: false);
            if (stack == null)
                return;
            
            DestroyStackNetworkObjectsAndClear(stack);
            _cache[spawnableCollectionId].Clear();
        }

        /// <summary>
        /// Clears all pooled objects.
        /// </summary>
        public void ClearPool()
        {
            int count = _cache.Count;
            for (int i = 0; i < count; i++)
                ClearPool(i);
        }

        /// <summary>
        /// Clears a pool destroying objects for a SpawnableCollectionId.
        /// </summary>
        /// <param name="spawnableCollectionId">CollectionId to clear for.</param>
        public void ClearPool(int spawnableCollectionId)
        {
            if (spawnableCollectionId >= _cacheCount)
                return;

            Dictionary<int, Stack<NetworkObject>> dict = _cache[spawnableCollectionId];

            foreach (Stack<NetworkObject> item in dict.Values)
                DestroyStackNetworkObjectsAndClear(item);

            dict.Clear();
        }

        /// <summary>
        /// Gets a cache for an id or creates one if does not exist.
        /// </summary>
        /// <returns></returns>
        public Stack<NetworkObject> GetCache(int collectionId, int prefabId, bool createIfMissing)
        {
            if (collectionId >= _cacheCount)
            {
                //Do not create if missing.
                if (!createIfMissing)
                    return null;

                //Add more to the cache.
                while (_cache.Count <= collectionId)
                {
                    Dictionary<int, Stack<NetworkObject>> dict = new();
                    _cache.Add(dict);
                }
                _cacheCount = _cache.Count;
            }

            Dictionary<int, Stack<NetworkObject>> dictionary = _cache[collectionId];
            //No cache for prefabId yet, make one.
            if (!dictionary.TryGetValueIL2CPP(prefabId, out Stack<NetworkObject> cache))
            {
                if (createIfMissing)
                {
                    cache = new();
                    dictionary[prefabId] = cache;
                }
            }

            return cache;
        }

        [Obsolete("Use GetCache(int, int, bool)")]
        public Stack<NetworkObject> GetOrCreateCache(int collectionId, int prefabId) => GetCache(collectionId, prefabId, createIfMissing: true);

        /// <summary>
        /// Destroys all NetworkObjects within a stack and clears the stack.
        /// </summary>
        private void DestroyStackNetworkObjectsAndClear(Stack<NetworkObject> stack)
        {
            foreach (NetworkObject networkObject in stack)
            {
                if (networkObject != null)
                    Destroy(networkObject.gameObject);
            }

            stack.Clear();
        }
    }
}﻿using FishNet.Managing;
using FishNet.Managing.Object;
using FishNet.Object;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Utility.Performance
{
    public abstract class ObjectPool : MonoBehaviour
    {
        /// <summary>
        /// NetworkManager this ObjectPool belongs to.
        /// </summary>
        protected NetworkManager NetworkManager { get; private set; }

        /// <summary>
        /// Called at the end of every frame. This can be used to perform routine tasks.
        /// </summary>
        public virtual void LateUpdate() { }
        /// <summary>
        /// Initializes this script for use.
        /// </summary>
        public virtual void InitializeOnce(NetworkManager nm)
        {
            NetworkManager = nm;
        }
        /// <summary>
        /// Returns an object that has been stored. A new object will be created if no stored objects are available.
        /// </summary>
        /// <param name="prefabId">PrefabId of the object to return.</param>
        /// <param name="collectionId">CollectionId of the object to return.</param>
        /// <param name="asServer">True if being called on the server side.</param>
        /// <returns></returns>
        [Obsolete("Use RetrieveObject(int, ushort, RetrieveOption, parent, Vector3?, Quaternion? Vector3?, bool) instead.")] //Remove in V5
        public virtual NetworkObject RetrieveObject(int prefabId, ushort collectionId, Transform parent = null, Vector3? position = null, Quaternion? rotation = null, Vector3? scale = null, bool makeActive = true, bool asServer = true) => null;
        /// <summary>
        /// Returns an object that has been stored. A new object will be created if no stored objects are available.
        /// </summary>
        /// <param name="prefabId">PrefabId of the object to return.</param>
        /// <param name="collectionId">CollectionId of the object to return.</param>
        /// <param name="asServer">True if being called on the server side.</param>
        /// <returns></returns>
        public virtual NetworkObject RetrieveObject(int prefabId, ushort collectionId, ObjectPoolRetrieveOption options, Transform parent = null, Vector3? position = null, Quaternion? rotation = null, Vector3? scale = null, bool asServer = true) => null;
        /// <summary>
        /// Returns a prefab using specified values.
        /// </summary>
        /// <param name="prefabId">PrefabId of the object to return.</param>
        /// <param name="collectionId">CollectionId of the object to return.</param>
        /// <param name="asServer">True if being called on the server side.</param>
        /// <returns></returns>
        public virtual NetworkObject GetPrefab(int prefabId, ushort collectionId, bool asServer)
        {
            PrefabObjects po = NetworkManager.GetPrefabObjects<PrefabObjects>(collectionId, false);
            return po.GetObject(asServer, prefabId);
        }
        /// <summary>
        /// Stores an object into the pool.
        /// </summary>
        /// <param name="instantiated">Object to store.</param>
        /// <param name="asServer">True if being called on the server side.</param>
        /// <returns></returns>
        public abstract void StoreObject(NetworkObject instantiated, bool asServer);
        /// <summary>
        /// Instantiates a number of objects and adds them to the pool.
        /// </summary>
        /// <param name="prefab">Prefab to cache.</param>
        /// <param name="count">Quantity to spawn.</param>
        /// <param name="asServer">True if storing prefabs for the server collection. This is only applicable when using DualPrefabObjects.</param>
        [Obsolete("Use AddPrefabObjects.")]
        public virtual void CacheObjects(NetworkObject prefab, int count, bool asServer) { }

        /// <summary>
        /// Instantiates a number of objects and adds them to the pool.
        /// </summary>
        /// <param name="prefab">Prefab to cache.</param>
        /// <param name="count">Quantity to spawn.</param>
        /// <param name="asServer">True if storing prefabs for the server collection. This is only applicable when using DualPrefabObjects.</param>
        /// <returns>Prefabs instantiated and added to cache.</returns>
        public virtual List<NetworkObject> StorePrefabObjects(NetworkObject prefab, int count, bool asServer) => default;


    }

}﻿
namespace FishNet.Utility.Performance
{

    public static class RetrieveOptionExtensions
    {
        public static bool FastContains(this ObjectPoolRetrieveOption whole, ObjectPoolRetrieveOption part) => (whole & part) == part;
    }

    [System.Flags]
    public enum ObjectPoolRetrieveOption
    {
        Unset = 0,
        /// <summary>
        /// True to make the object active before returning.
        /// </summary>
        MakeActive = 1,
        /// <summary>
        /// True to treat supplied transform properties as local space.
        /// False will treat the properties as world space.
        /// </summary>
        LocalSpace = 2,
    }
}

﻿using FishNet.Object;
using System.Collections.Generic;
using UnityEngine;

namespace FishNet.Utility.Performance
{

    public static class GetNonAlloc
    {
        /// <summary>
        /// Gets all NetworkBehaviours on a transform.
        /// </summary>
        public static void GetNetworkBehavioursNonAlloc(this Transform t, ref List<NetworkBehaviour> results)
        {
            t.GetComponents(results);
        }

        /// <summary>
        /// Gets all transforms on transform and it's children.
        /// </summary>
        public static void GetTransformsInChildrenNonAlloc(this Transform t, ref List<Transform> results, bool includeInactive = false)
        {
            t.GetComponentsInChildren(includeInactive, results);
        }

    }

}using FishNet.Managing.Timing;
using FishNet.Object;
using GameKit.Dependencies.Utilities;
using UnityEngine;

namespace FishNet.Utility.Template
{
    /// <summary>
    /// Subscribes to tick events making them available as virtual methods.
    /// </summary>
    public abstract class TickNetworkBehaviour : NetworkBehaviour
    {
        #region Types.
        [System.Flags]
        [System.Serializable]
        public enum TickCallback : uint
        {
            None = 0,
            PreTick = (1 << 0),
            Tick = (1 << 1),
            PostTick = (1 << 2),
            Update = (1 << 3),
            LateUpdate = (1 << 4),
            Everything = Enums.SHIFT_EVERYTHING_UINT,
        }
        #endregion

        /// <summary>
        /// Tick callbacks to use.
        /// </summary>
        [Tooltip("Tick callbacks to use.")]
        [SerializeField]
        private TickCallback _tickCallbacks = (TickCallback.Tick | TickCallback.PostTick);

        /// <summary>
        /// Last subscription state.
        /// </summary>
        private bool _subscribed;
        /// <summary>
        /// TimeManager subscribed to.
        /// </summary>
        private TimeManager _timeManager;

        internal override void OnStartNetwork_Internal()
        {
            _timeManager = base.TimeManager;
            ChangeSubscriptions(subscribe: true);
            
            base.OnStartNetwork_Internal();
        }

        internal override void OnStopNetwork_Internal()
        {
            ChangeSubscriptions(subscribe: false);
            
            base.OnStopNetwork_Internal();
        }

        /// <summary>
        /// Updates callbacks to use and changes subscriptions accordingly.
        /// </summary>
        /// <param name="value">Next value.</param>
        public void SetTickCallbacks(TickCallback value)
        {
            ChangeSubscriptions(subscribe: false);
            _tickCallbacks = value;
            if (value != TickCallback.None)
                ChangeSubscriptions(subscribe: true);
        }

        private void ChangeSubscriptions(bool subscribe)
        {
            TimeManager tm = _timeManager;
            
            if (tm == null)
                return;
            if (subscribe == _subscribed)
                return;
            _subscribed = subscribe;

            if (subscribe)
            {
                if (TickCallbackFastContains(_tickCallbacks, TickCallback.PreTick))
                    tm.OnPreTick += TimeManager_OnPreTick;
                if (TickCallbackFastContains(_tickCallbacks, TickCallback.Tick))
                    tm.OnTick += TimeManager_OnTick;
                if (TickCallbackFastContains(_tickCallbacks, TickCallback.PostTick))
                    tm.OnPostTick += TimeManager_OnPostTick;
                if (TickCallbackFastContains(_tickCallbacks, TickCallback.Update))
                    tm.OnUpdate += TimeManager_OnUpdate;
                if (TickCallbackFastContains(_tickCallbacks, TickCallback.LateUpdate))
                    tm.OnLateUpdate += TimeManager_OnLateUpdate;
            }
            else
            {
                if (TickCallbackFastContains(_tickCallbacks, TickCallback.PreTick))
                    tm.OnPreTick -= TimeManager_OnPreTick;
                if (TickCallbackFastContains(_tickCallbacks, TickCallback.Tick))
                    tm.OnTick -= TimeManager_OnTick;
                if (TickCallbackFastContains(_tickCallbacks, TickCallback.PostTick))
                    tm.OnPostTick -= TimeManager_OnPostTick;
                if (TickCallbackFastContains(_tickCallbacks, TickCallback.Update))
                    tm.OnUpdate -= TimeManager_OnUpdate;
                if (TickCallbackFastContains(_tickCallbacks, TickCallback.LateUpdate))
                    tm.OnLateUpdate -= TimeManager_OnLateUpdate;
            }
        }

        protected virtual void TimeManager_OnPreTick() { }
        protected virtual void TimeManager_OnTick() { }
        protected virtual void TimeManager_OnPostTick() { }
        protected virtual void TimeManager_OnUpdate() { }
        protected virtual void TimeManager_OnLateUpdate() { }

        private bool TickCallbackFastContains(TickCallback whole, TickCallback part) => ((whole & part) == part);
    }
}